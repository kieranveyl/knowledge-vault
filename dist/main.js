// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);

// node_modules/strtok3/lib/stream/Errors.js
var defaultMessages = "End-Of-Stream", EndOfStreamError, AbortError;
var init_Errors = __esm(() => {
  EndOfStreamError = class EndOfStreamError extends Error {
    constructor() {
      super(defaultMessages);
      this.name = "EndOfStreamError";
    }
  };
  AbortError = class AbortError extends Error {
    constructor(message = "The operation was aborted") {
      super(message);
      this.name = "AbortError";
    }
  };
});

// node_modules/strtok3/lib/stream/Deferred.js
class Deferred {
  constructor() {
    this.resolve = () => null;
    this.reject = () => null;
    this.promise = new Promise((resolve, reject2) => {
      this.reject = reject2;
      this.resolve = resolve;
    });
  }
}

// node_modules/strtok3/lib/stream/AbstractStreamReader.js
class AbstractStreamReader {
  constructor() {
    this.endOfStream = false;
    this.interrupted = false;
    this.peekQueue = [];
  }
  async peek(uint8Array, mayBeLess = false) {
    const bytesRead = await this.read(uint8Array, mayBeLess);
    this.peekQueue.push(uint8Array.subarray(0, bytesRead));
    return bytesRead;
  }
  async read(buffer3, mayBeLess = false) {
    if (buffer3.length === 0) {
      return 0;
    }
    let bytesRead = this.readFromPeekBuffer(buffer3);
    if (!this.endOfStream) {
      bytesRead += await this.readRemainderFromStream(buffer3.subarray(bytesRead), mayBeLess);
    }
    if (bytesRead === 0 && !mayBeLess) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
  readFromPeekBuffer(buffer3) {
    let remaining = buffer3.length;
    let bytesRead = 0;
    while (this.peekQueue.length > 0 && remaining > 0) {
      const peekData = this.peekQueue.pop();
      if (!peekData)
        throw new Error("peekData should be defined");
      const lenCopy = Math.min(peekData.length, remaining);
      buffer3.set(peekData.subarray(0, lenCopy), bytesRead);
      bytesRead += lenCopy;
      remaining -= lenCopy;
      if (lenCopy < peekData.length) {
        this.peekQueue.push(peekData.subarray(lenCopy));
      }
    }
    return bytesRead;
  }
  async readRemainderFromStream(buffer3, mayBeLess) {
    let bytesRead = 0;
    while (bytesRead < buffer3.length && !this.endOfStream) {
      if (this.interrupted) {
        throw new AbortError;
      }
      const chunkLen = await this.readFromStream(buffer3.subarray(bytesRead), mayBeLess);
      if (chunkLen === 0)
        break;
      bytesRead += chunkLen;
    }
    if (!mayBeLess && bytesRead < buffer3.length) {
      throw new EndOfStreamError;
    }
    return bytesRead;
  }
}
var init_AbstractStreamReader = __esm(() => {
  init_Errors();
});

// node_modules/strtok3/lib/stream/StreamReader.js
var StreamReader;
var init_StreamReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  StreamReader = class StreamReader extends AbstractStreamReader {
    constructor(s) {
      super();
      this.s = s;
      this.deferred = null;
      if (!s.read || !s.once) {
        throw new Error("Expected an instance of stream.Readable");
      }
      this.s.once("end", () => {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.resolve(0);
        }
      });
      this.s.once("error", (err) => this.reject(err));
      this.s.once("close", () => this.abort());
    }
    async readFromStream(buffer3, mayBeLess) {
      if (buffer3.length === 0)
        return 0;
      const readBuffer = this.s.read(buffer3.length);
      if (readBuffer) {
        buffer3.set(readBuffer);
        return readBuffer.length;
      }
      const request2 = {
        buffer: buffer3,
        mayBeLess,
        deferred: new Deferred
      };
      this.deferred = request2.deferred;
      this.s.once("readable", () => {
        this.readDeferred(request2);
      });
      return request2.deferred.promise;
    }
    readDeferred(request2) {
      const readBuffer = this.s.read(request2.buffer.length);
      if (readBuffer) {
        request2.buffer.set(readBuffer);
        request2.deferred.resolve(readBuffer.length);
        this.deferred = null;
      } else {
        this.s.once("readable", () => {
          this.readDeferred(request2);
        });
      }
    }
    reject(err) {
      this.interrupted = true;
      if (this.deferred) {
        this.deferred.reject(err);
        this.deferred = null;
      }
    }
    async abort() {
      this.reject(new AbortError);
    }
    async close() {
      return this.abort();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReader.js
var WebStreamReader;
var init_WebStreamReader = __esm(() => {
  init_AbstractStreamReader();
  WebStreamReader = class WebStreamReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
    }
    async abort() {
      return this.close();
    }
    async close() {
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamByobReader.js
var WebStreamByobReader;
var init_WebStreamByobReader = __esm(() => {
  init_WebStreamReader();
  WebStreamByobReader = class WebStreamByobReader extends WebStreamReader {
    async readFromStream(buffer3, mayBeLess) {
      if (buffer3.length === 0)
        return 0;
      const result = await this.reader.read(new Uint8Array(buffer3.length), { min: mayBeLess ? undefined : buffer3.length });
      if (result.done) {
        this.endOfStream = result.done;
      }
      if (result.value) {
        buffer3.set(result.value);
        return result.value.length;
      }
      return 0;
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamDefaultReader.js
var WebStreamDefaultReader;
var init_WebStreamDefaultReader = __esm(() => {
  init_Errors();
  init_AbstractStreamReader();
  WebStreamDefaultReader = class WebStreamDefaultReader extends AbstractStreamReader {
    constructor(reader) {
      super();
      this.reader = reader;
      this.buffer = null;
    }
    writeChunk(target, chunk4) {
      const written = Math.min(chunk4.length, target.length);
      target.set(chunk4.subarray(0, written));
      if (written < chunk4.length) {
        this.buffer = chunk4.subarray(written);
      } else {
        this.buffer = null;
      }
      return written;
    }
    async readFromStream(buffer3, mayBeLess) {
      if (buffer3.length === 0)
        return 0;
      let totalBytesRead = 0;
      if (this.buffer) {
        totalBytesRead += this.writeChunk(buffer3, this.buffer);
      }
      while (totalBytesRead < buffer3.length && !this.endOfStream) {
        const result = await this.reader.read();
        if (result.done) {
          this.endOfStream = true;
          break;
        }
        if (result.value) {
          totalBytesRead += this.writeChunk(buffer3.subarray(totalBytesRead), result.value);
        }
      }
      if (!mayBeLess && totalBytesRead === 0 && this.endOfStream) {
        throw new EndOfStreamError;
      }
      return totalBytesRead;
    }
    abort() {
      this.interrupted = true;
      return this.reader.cancel();
    }
    async close() {
      await this.abort();
      this.reader.releaseLock();
    }
  };
});

// node_modules/strtok3/lib/stream/WebStreamReaderFactory.js
function makeWebStreamReader(stream2) {
  try {
    const reader = stream2.getReader({ mode: "byob" });
    if (reader instanceof ReadableStreamDefaultReader) {
      return new WebStreamDefaultReader(reader);
    }
    return new WebStreamByobReader(reader);
  } catch (error2) {
    if (error2 instanceof TypeError) {
      return new WebStreamDefaultReader(stream2.getReader());
    }
    throw error2;
  }
}
var init_WebStreamReaderFactory = __esm(() => {
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
});

// node_modules/strtok3/lib/stream/index.js
var init_stream = __esm(() => {
  init_Errors();
  init_StreamReader();
  init_WebStreamByobReader();
  init_WebStreamDefaultReader();
  init_WebStreamReaderFactory();
});

// node_modules/strtok3/lib/AbstractTokenizer.js
class AbstractTokenizer {
  constructor(options) {
    this.numBuffer = new Uint8Array(8);
    this.position = 0;
    this.onClose = options?.onClose;
    if (options?.abortSignal) {
      options.abortSignal.addEventListener("abort", () => {
        this.abort();
      });
    }
  }
  async readToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.readBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async peekToken(token, position = this.position) {
    const uint8Array = new Uint8Array(token.len);
    const len = await this.peekBuffer(uint8Array, { position });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(uint8Array, 0);
  }
  async readNumber(token) {
    const len = await this.readBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async peekNumber(token) {
    const len = await this.peekBuffer(this.numBuffer, { length: token.len });
    if (len < token.len)
      throw new EndOfStreamError;
    return token.get(this.numBuffer, 0);
  }
  async ignore(length3) {
    if (this.fileInfo.size !== undefined) {
      const bytesLeft = this.fileInfo.size - this.position;
      if (length3 > bytesLeft) {
        this.position += bytesLeft;
        return bytesLeft;
      }
    }
    this.position += length3;
    return length3;
  }
  async close() {
    await this.abort();
    await this.onClose?.();
  }
  normalizeOptions(uint8Array, options) {
    if (!this.supportsRandomAccess() && options && options.position !== undefined && options.position < this.position) {
      throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    }
    return {
      ...{
        mayBeLess: false,
        offset: 0,
        length: uint8Array.length,
        position: this.position
      },
      ...options
    };
  }
  abort() {
    return Promise.resolve();
  }
}
var init_AbstractTokenizer = __esm(() => {
  init_stream();
});

// node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize = 256000, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
    constructor(streamReader, options) {
      super(options);
      this.streamReader = streamReader;
      this.fileInfo = options?.fileInfo ?? {};
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const skipBytes = normOptions.position - this.position;
      if (skipBytes > 0) {
        await this.ignore(skipBytes);
        return this.readBuffer(uint8Array, options);
      }
      if (skipBytes < 0) {
        throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
      }
      if (normOptions.length === 0) {
        return 0;
      }
      const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
      this.position += bytesRead;
      if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      let bytesRead = 0;
      if (normOptions.position) {
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
          bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
          uint8Array.set(skipBuffer.subarray(skipBytes));
          return bytesRead - skipBytes;
        }
        if (skipBytes < 0) {
          throw new Error("Cannot peek from a negative offset in a stream");
        }
      }
      if (normOptions.length > 0) {
        try {
          bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);
        } catch (err) {
          if (options?.mayBeLess && err instanceof EndOfStreamError) {
            return 0;
          }
          throw err;
        }
        if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
          throw new EndOfStreamError;
        }
      }
      return bytesRead;
    }
    async ignore(length3) {
      const bufSize = Math.min(maxBufferSize, length3);
      const buf = new Uint8Array(bufSize);
      let totBytesRead = 0;
      while (totBytesRead < length3) {
        const remaining = length3 - totBytesRead;
        const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
        if (bytesRead < 0) {
          return bytesRead;
        }
        totBytesRead += bytesRead;
      }
      return totBytesRead;
    }
    abort() {
      return this.streamReader.abort();
    }
    async close() {
      return this.streamReader.close();
    }
    supportsRandomAccess() {
      return false;
    }
  };
});

// node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
  BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
    constructor(uint8Array, options) {
      super(options);
      this.uint8Array = uint8Array;
      this.fileInfo = { ...options?.fileInfo ?? {}, ...{ size: uint8Array.length } };
    }
    async readBuffer(uint8Array, options) {
      if (options?.position) {
        this.position = options.position;
      }
      const bytesRead = await this.peekBuffer(uint8Array, options);
      this.position += bytesRead;
      return bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
      if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
        throw new EndOfStreamError;
      }
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read));
      return bytes2read;
    }
    close() {
      return super.close();
    }
    supportsRandomAccess() {
      return true;
    }
    setPosition(position) {
      this.position = position;
    }
  };
});

// node_modules/strtok3/lib/BlobTokenizer.js
var init_BlobTokenizer = __esm(() => {
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/core.js
function fromStream2(stream2, options) {
  const streamReader = new StreamReader(stream2);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await streamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(streamReader, _options);
}
function fromWebStream(webStream, options) {
  const webStreamReader = makeWebStreamReader(webStream);
  const _options = options ?? {};
  const chainedClose = _options.onClose;
  _options.onClose = async () => {
    await webStreamReader.close();
    if (chainedClose) {
      return chainedClose();
    }
  };
  return new ReadStreamTokenizer(webStreamReader, _options);
}
function fromBuffer(uint8Array, options) {
  return new BufferTokenizer(uint8Array, options);
}
var init_core = __esm(() => {
  init_stream();
  init_ReadStreamTokenizer();
  init_BufferTokenizer();
  init_BlobTokenizer();
  init_stream();
  init_AbstractTokenizer();
});

// node_modules/strtok3/lib/FileTokenizer.js
import { open as fsOpen } from "fs/promises";
var FileTokenizer;
var init_FileTokenizer = __esm(() => {
  init_AbstractTokenizer();
  init_stream();
  FileTokenizer = class FileTokenizer extends AbstractTokenizer {
    static async fromFile(sourceFilePath) {
      const fileHandle = await fsOpen(sourceFilePath, "r");
      const stat = await fileHandle.stat();
      return new FileTokenizer(fileHandle, { fileInfo: { path: sourceFilePath, size: stat.size } });
    }
    constructor(fileHandle, options) {
      super(options);
      this.fileHandle = fileHandle;
      this.fileInfo = options.fileInfo;
    }
    async readBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      this.position = normOptions.position;
      if (normOptions.length === 0)
        return 0;
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      this.position += res.bytesRead;
      if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async peekBuffer(uint8Array, options) {
      const normOptions = this.normalizeOptions(uint8Array, options);
      const res = await this.fileHandle.read(uint8Array, 0, normOptions.length, normOptions.position);
      if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
        throw new EndOfStreamError;
      }
      return res.bytesRead;
    }
    async close() {
      await this.fileHandle.close();
      return super.close();
    }
    setPosition(position) {
      this.position = position;
    }
    supportsRandomAccess() {
      return true;
    }
  };
});

// node_modules/strtok3/lib/index.js
import { stat as fsStat } from "fs/promises";
async function fromStream3(stream2, options) {
  const rst = fromStream2(stream2, options);
  if (stream2.path) {
    const stat = await fsStat(stream2.path);
    rst.fileInfo.path = stream2.path;
    rst.fileInfo.size = stat.size;
  }
  return rst;
}
var fromFile;
var init_lib = __esm(() => {
  init_core();
  init_FileTokenizer();
  init_FileTokenizer();
  init_core();
  fromFile = FileTokenizer.fromFile;
});

// node_modules/ieee754/index.js
var init_ieee754 = __esm(() => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
});

// node_modules/@borewit/text-codec/lib/index.js
function textDecode(bytes, encoding = "utf-8") {
  switch (encoding.toLowerCase()) {
    case "utf-8":
    case "utf8":
      if (typeof globalThis.TextDecoder !== "undefined") {
        return new globalThis.TextDecoder("utf-8").decode(bytes);
      }
      return decodeUTF8(bytes);
    case "utf-16le":
      return decodeUTF16LE(bytes);
    case "ascii":
      return decodeASCII(bytes);
    case "latin1":
    case "iso-8859-1":
      return decodeLatin1(bytes);
    case "windows-1252":
      return decodeWindows1252(bytes);
    default:
      throw new RangeError(`Encoding '${encoding}' not supported`);
  }
}
function decodeUTF8(bytes) {
  let out = "";
  let i = 0;
  while (i < bytes.length) {
    const b1 = bytes[i++];
    if (b1 < 128) {
      out += String.fromCharCode(b1);
    } else if (b1 < 224) {
      const b2 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 31) << 6 | b2);
    } else if (b1 < 240) {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      out += String.fromCharCode((b1 & 15) << 12 | b2 << 6 | b3);
    } else {
      const b2 = bytes[i++] & 63;
      const b3 = bytes[i++] & 63;
      const b4 = bytes[i++] & 63;
      let cp = (b1 & 7) << 18 | b2 << 12 | b3 << 6 | b4;
      cp -= 65536;
      out += String.fromCharCode(55296 + (cp >> 10 & 1023), 56320 + (cp & 1023));
    }
  }
  return out;
}
function decodeUTF16LE(bytes) {
  let out = "";
  for (let i = 0;i < bytes.length; i += 2) {
    out += String.fromCharCode(bytes[i] | bytes[i + 1] << 8);
  }
  return out;
}
function decodeASCII(bytes) {
  return String.fromCharCode(...bytes.map((b) => b & 127));
}
function decodeLatin1(bytes) {
  return String.fromCharCode(...bytes);
}
function decodeWindows1252(bytes) {
  let out = "";
  for (const b of bytes) {
    if (b >= 128 && b <= 159 && WINDOWS_1252_EXTRA[b]) {
      out += WINDOWS_1252_EXTRA[b];
    } else {
      out += String.fromCharCode(b);
    }
  }
  return out;
}
var WINDOWS_1252_EXTRA, WINDOWS_1252_REVERSE;
var init_lib2 = __esm(() => {
  WINDOWS_1252_EXTRA = {
    128: "\u20AC",
    130: "\u201A",
    131: "\u0192",
    132: "\u201E",
    133: "\u2026",
    134: "\u2020",
    135: "\u2021",
    136: "\u02C6",
    137: "\u2030",
    138: "\u0160",
    139: "\u2039",
    140: "\u0152",
    142: "\u017D",
    145: "\u2018",
    146: "\u2019",
    147: "\u201C",
    148: "\u201D",
    149: "\u2022",
    150: "\u2013",
    151: "\u2014",
    152: "\u02DC",
    153: "\u2122",
    154: "\u0161",
    155: "\u203A",
    156: "\u0153",
    158: "\u017E",
    159: "\u0178"
  };
  WINDOWS_1252_REVERSE = {};
  for (const [code, char] of Object.entries(WINDOWS_1252_EXTRA)) {
    WINDOWS_1252_REVERSE[char] = Number.parseInt(code);
  }
});

// node_modules/token-types/lib/index.js
function dv(array7) {
  return new DataView(array7.buffer, array7.byteOffset);
}

class StringType2 {
  constructor(len, encoding) {
    this.len = len;
    this.encoding = encoding;
  }
  get(data, offset = 0) {
    const bytes = data.subarray(offset, offset + this.len);
    return textDecode(bytes, this.encoding);
  }
}
var UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE;
var init_lib3 = __esm(() => {
  init_ieee754();
  init_lib2();
  UINT8 = {
    len: 1,
    get(array7, offset) {
      return dv(array7).getUint8(offset);
    },
    put(array7, offset, value6) {
      dv(array7).setUint8(offset, value6);
      return offset + 1;
    }
  };
  UINT16_LE = {
    len: 2,
    get(array7, offset) {
      return dv(array7).getUint16(offset, true);
    },
    put(array7, offset, value6) {
      dv(array7).setUint16(offset, value6, true);
      return offset + 2;
    }
  };
  UINT16_BE = {
    len: 2,
    get(array7, offset) {
      return dv(array7).getUint16(offset);
    },
    put(array7, offset, value6) {
      dv(array7).setUint16(offset, value6);
      return offset + 2;
    }
  };
  UINT32_LE = {
    len: 4,
    get(array7, offset) {
      return dv(array7).getUint32(offset, true);
    },
    put(array7, offset, value6) {
      dv(array7).setUint32(offset, value6, true);
      return offset + 4;
    }
  };
  UINT32_BE = {
    len: 4,
    get(array7, offset) {
      return dv(array7).getUint32(offset);
    },
    put(array7, offset, value6) {
      dv(array7).setUint32(offset, value6);
      return offset + 4;
    }
  };
  INT32_BE = {
    len: 4,
    get(array7, offset) {
      return dv(array7).getInt32(offset);
    },
    put(array7, offset, value6) {
      dv(array7).setInt32(offset, value6);
      return offset + 4;
    }
  };
  UINT64_LE = {
    len: 8,
    get(array7, offset) {
      return dv(array7).getBigUint64(offset, true);
    },
    put(array7, offset, value6) {
      dv(array7).setBigUint64(offset, value6, true);
      return offset + 8;
    }
  };
});

// node_modules/fflate/esm/index.mjs
import { createRequire } from "module";
function inflateSync(data, opts) {
  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function gunzipSync(data, opts) {
  var st = gzs(data);
  if (st + 8 > data.length)
    err(6, "invalid gzip data");
  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);
}
function unzlibSync(data, opts) {
  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);
}
function decompressSync(data, opts) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);
}
var require2, Worker, u8, u16, i32, fleb, fdeb, clim, freb = function(eb, start5) {
  var b = new u16(31);
  for (var i = 0;i < 31; ++i) {
    b[i] = start5 += 1 << eb[i - 1];
  }
  var r = new i32(b[30]);
  for (var i = 1;i < 30; ++i) {
    for (var j = b[i];j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }
  return { b, r };
}, _a, fl, revfl, _b, fd, revfd, rev, x, i, hMap = function(cd, mb, r) {
  var s = cd.length;
  var i = 0;
  var l = new u16(mb);
  for (;i < s; ++i) {
    if (cd[i])
      ++l[cd[i] - 1];
  }
  var le = new u16(mb);
  for (i = 1;i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        var sv = i << 4 | cd[i];
        var r_1 = mb - cd[i];
        var v = le[cd[i] - 1]++ << r_1;
        for (var m = v | (1 << r_1) - 1;v <= m; ++v) {
          co[rev[v] >> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);
    for (i = 0;i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
      }
    }
  }
  return co;
}, flt, i, i, i, i, fdt, i, flrm, fdrm, max6 = function(a) {
  var m = a[0];
  for (var i = 1;i < a.length; ++i) {
    if (a[i] > m)
      m = a[i];
  }
  return m;
}, bits = function(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}, bits16 = function(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}, shft = function(p) {
  return (p + 7) / 8 | 0;
}, slc = function(v, s, e) {
  if (s == null || s < 0)
    s = 0;
  if (e == null || e > v.length)
    e = v.length;
  return new u8(v.subarray(s, e));
}, ec, err = function(ind, msg, nt) {
  var e = new Error(msg || ec[ind]);
  e.code = ind;
  if (Error.captureStackTrace)
    Error.captureStackTrace(e, err);
  if (!nt)
    throw e;
  return e;
}, inflt = function(dat, st, buf, dict) {
  var sl = dat.length, dl = dict ? dict.length : 0;
  if (!sl || st.f && !st.l)
    return buf || new u8(0);
  var noBuf = !buf;
  var resize = noBuf || st.i != 2;
  var noSt = st.i;
  if (noBuf)
    buf = new u8(sl * 3);
  var cbuf = function(l2) {
    var bl = buf.length;
    if (l2 > bl) {
      var nbuf = new u8(Math.max(bl * 2, l2));
      nbuf.set(buf);
      buf = nbuf;
    }
  };
  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
  var tbts = sl * 8;
  do {
    if (!lm) {
      final = bits(dat, pos, 1);
      var type2 = bits(dat, pos + 1, 3);
      pos += 3;
      if (!type2) {
        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
        if (t > sl) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + l);
        buf.set(dat.subarray(s, t), bt);
        st.b = bt += l, st.p = pos = t * 8, st.f = final;
        continue;
      } else if (type2 == 1)
        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
      else if (type2 == 2) {
        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14;
        var ldt = new u8(tl);
        var clt = new u8(19);
        for (var i = 0;i < hcLen; ++i) {
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }
        pos += hcLen * 3;
        var clb = max6(clt), clbmsk = (1 << clb) - 1;
        var clm = hMap(clt, clb, 1);
        for (var i = 0;i < tl; ) {
          var r = clm[bits(dat, pos, clbmsk)];
          pos += r & 15;
          var s = r >> 4;
          if (s < 16) {
            ldt[i++] = s;
          } else {
            var c = 0, n = 0;
            if (s == 16)
              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
            else if (s == 17)
              n = 3 + bits(dat, pos, 7), pos += 3;
            else if (s == 18)
              n = 11 + bits(dat, pos, 127), pos += 7;
            while (n--)
              ldt[i++] = c;
          }
        }
        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
        lbt = max6(lt);
        dbt = max6(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else
        err(1);
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
    }
    if (resize)
      cbuf(bt + 131072);
    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
    var lpos = pos;
    for (;; lpos = pos) {
      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
      pos += c & 15;
      if (pos > tbts) {
        if (noSt)
          err(0);
        break;
      }
      if (!c)
        err(2);
      if (sym < 256)
        buf[bt++] = sym;
      else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add8 = sym - 254;
        if (sym > 264) {
          var i = sym - 257, b = fleb[i];
          add8 = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        }
        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
        if (!d)
          err(3);
        pos += d & 15;
        var dt = fd[dsym];
        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (resize)
          cbuf(bt + 131072);
        var end6 = bt + add8;
        if (bt < dt) {
          var shift2 = dl - dt, dend = Math.min(dt, end6);
          if (shift2 + bt < 0)
            err(3);
          for (;bt < dend; ++bt)
            buf[bt] = dict[shift2 + bt];
        }
        for (;bt < end6; ++bt)
          buf[bt] = buf[bt - dt];
      }
    }
    st.l = lm, st.p = lpos, st.b = bt, st.f = final;
    if (lm)
      final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);
  return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);
}, et, gzs = function(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8)
    err(6, "invalid gzip data");
  var flg = d[3];
  var st = 10;
  if (flg & 4)
    st += (d[10] | d[11] << 8) + 2;
  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1);zs > 0; zs -= !d[st++])
    ;
  return st + (flg & 2);
}, gzl = function(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}, zls = function(d, dict) {
  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)
    err(6, "invalid zlib data");
  if ((d[1] >> 5 & 1) == +!dict)
    err(6, "invalid zlib data: " + (d[1] & 32 ? "need" : "unexpected") + " dictionary");
  return (d[1] >> 3 & 4) + 2;
}, td, tds = 0;
var init_esm = __esm(() => {
  require2 = createRequire("/");
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  u8 = Uint8Array;
  u16 = Uint16Array;
  i32 = Int32Array;
  fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]);
  fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]);
  clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  _a = freb(fleb, 2);
  fl = _a.b;
  revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  _b = freb(fdeb, 0);
  fd = _b.b;
  revfd = _b.r;
  rev = new u16(32768);
  for (i = 0;i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  flt = new u8(288);
  for (i = 0;i < 144; ++i)
    flt[i] = 8;
  for (i = 144;i < 256; ++i)
    flt[i] = 9;
  for (i = 256;i < 280; ++i)
    flt[i] = 7;
  for (i = 280;i < 288; ++i)
    flt[i] = 8;
  fdt = new u8(32);
  for (i = 0;i < 32; ++i)
    fdt[i] = 5;
  flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
  ];
  et = /* @__PURE__ */ new u8(0);
  td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
});

// node_modules/@tokenizer/inflate/node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  function parse4(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match25 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match25) {
      return;
    }
    var n = parseFloat(match25[1]);
    var type2 = (match25[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse4(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/@tokenizer/inflate/node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable4;
    createDebug.enable = enable4;
    createDebug.enabled = enabled2;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash3 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i);
        hash3 |= 0;
      }
      return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args2) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args2[0] = createDebug.coerce(args2[0]);
        if (typeof args2[0] !== "string") {
          args2.unshift("%O");
        }
        let index = 0;
        args2[0] = args2[0].replace(/%([a-zA-Z%])/g, (match25, format6) => {
          if (match25 === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format6];
          if (typeof formatter === "function") {
            const val = args2[index];
            match25 = formatter.call(self2, val);
            args2.splice(index, 1);
            index--;
          }
          return match25;
        });
        createDebug.formatArgs.call(self2, args2);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args2);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend3;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend3(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable4(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split3 = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (const ns of split3) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable4() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled2(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module.exports = setup;
});

// node_modules/@tokenizer/inflate/node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    let m;
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args2) {
    args2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args2[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args2.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args2[0].replace(/%[a-zA-Z%]/g, (match25) => {
      if (match25 === "%%") {
        return;
      }
      index++;
      if (match25 === "%c") {
        lastC = index;
      }
    });
    args2.splice(lastC, 0, c);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error2) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
    } catch (error2) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error2) {
    }
  }
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error2) {
      return "[UnexpectedJSONParseError]: " + error2.message;
    }
  };
});

// node_modules/@tokenizer/inflate/node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  function useColors() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args2) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args2[0] = prefix + args2[0].split("\n").join("\n" + prefix);
      args2.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args2[0] = getDate() + name + " " + args2[0];
    }
  }
  function getDate() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log4(...args2) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args2) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug2) {
    debug2.inspectOpts = {};
    const keys9 = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys9.length; i++) {
      debug2.inspectOpts[keys9[i]] = exports.inspectOpts[keys9[i]];
    }
  }
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log4;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = (()=>{throw new Error(`Cannot require module "supports-color"`);})();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error2) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/@tokenizer/inflate/node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/@tokenizer/inflate/lib/ZipToken.js
var Signature, DataDescriptor, LocalFileHeaderToken, EndOfCentralDirectoryRecordToken, FileHeader;
var init_ZipToken = __esm(() => {
  init_lib3();
  Signature = {
    LocalFileHeader: 67324752,
    DataDescriptor: 134695760,
    CentralFileHeader: 33639248,
    EndOfCentralDirectory: 101010256
  };
  DataDescriptor = {
    get(array7) {
      const flags = UINT16_LE.get(array7, 6);
      return {
        signature: UINT32_LE.get(array7, 0),
        compressedSize: UINT32_LE.get(array7, 8),
        uncompressedSize: UINT32_LE.get(array7, 12)
      };
    },
    len: 16
  };
  LocalFileHeaderToken = {
    get(array7) {
      const flags = UINT16_LE.get(array7, 6);
      return {
        signature: UINT32_LE.get(array7, 0),
        minVersion: UINT16_LE.get(array7, 4),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array7, 8),
        compressedSize: UINT32_LE.get(array7, 18),
        uncompressedSize: UINT32_LE.get(array7, 22),
        filenameLength: UINT16_LE.get(array7, 26),
        extraFieldLength: UINT16_LE.get(array7, 28),
        filename: null
      };
    },
    len: 30
  };
  EndOfCentralDirectoryRecordToken = {
    get(array7) {
      return {
        signature: UINT32_LE.get(array7, 0),
        nrOfThisDisk: UINT16_LE.get(array7, 4),
        nrOfThisDiskWithTheStart: UINT16_LE.get(array7, 6),
        nrOfEntriesOnThisDisk: UINT16_LE.get(array7, 8),
        nrOfEntriesOfSize: UINT16_LE.get(array7, 10),
        sizeOfCd: UINT32_LE.get(array7, 12),
        offsetOfStartOfCd: UINT32_LE.get(array7, 16),
        zipFileCommentLength: UINT16_LE.get(array7, 20)
      };
    },
    len: 22
  };
  FileHeader = {
    get(array7) {
      const flags = UINT16_LE.get(array7, 8);
      return {
        signature: UINT32_LE.get(array7, 0),
        minVersion: UINT16_LE.get(array7, 6),
        dataDescriptor: !!(flags & 8),
        compressedMethod: UINT16_LE.get(array7, 10),
        compressedSize: UINT32_LE.get(array7, 20),
        uncompressedSize: UINT32_LE.get(array7, 24),
        filenameLength: UINT16_LE.get(array7, 28),
        extraFieldLength: UINT16_LE.get(array7, 30),
        fileCommentLength: UINT16_LE.get(array7, 32),
        relativeOffsetOfLocalHeader: UINT32_LE.get(array7, 42),
        filename: null
      };
    },
    len: 46
  };
});

// node_modules/@tokenizer/inflate/lib/index.js
function signatureToArray(signature) {
  const signatureBytes = new Uint8Array(UINT32_LE.len);
  UINT32_LE.put(signatureBytes, 0, signature);
  return signatureBytes;
}
function indexOf(buffer3, portion) {
  const bufferLength = buffer3.length;
  const portionLength = portion.length;
  if (portionLength > bufferLength)
    return -1;
  for (let i = 0;i <= bufferLength - portionLength; i++) {
    let found = true;
    for (let j = 0;j < portionLength; j++) {
      if (buffer3[i + j] !== portion[j]) {
        found = false;
        break;
      }
    }
    if (found) {
      return i;
    }
  }
  return -1;
}
function mergeArrays(chunks2) {
  const totalLength = chunks2.reduce((acc, curr) => acc + curr.length, 0);
  const mergedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk4 of chunks2) {
    mergedArray.set(chunk4, offset);
    offset += chunk4.length;
  }
  return mergedArray;
}

class ZipHandler {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    this.syncBuffer = new Uint8Array(syncBufferSize);
  }
  async isZip() {
    return await this.peekSignature() === Signature.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(UINT32_LE);
  }
  async findEndOfCentralDirectoryLocator() {
    const randomReadTokenizer = this.tokenizer;
    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);
    const buffer3 = this.syncBuffer.subarray(0, chunkLength);
    await this.tokenizer.readBuffer(buffer3, { position: randomReadTokenizer.fileInfo.size - chunkLength });
    for (let i = buffer3.length - 4;i >= 0; i--) {
      if (buffer3[i] === eocdSignatureBytes[0] && buffer3[i + 1] === eocdSignatureBytes[1] && buffer3[i + 2] === eocdSignatureBytes[2] && buffer3[i + 3] === eocdSignatureBytes[3]) {
        return randomReadTokenizer.fileInfo.size - chunkLength + i;
      }
    }
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      debug2("Cannot reading central-directory without random-read support");
      return;
    }
    debug2("Reading central-directory...");
    const pos = this.tokenizer.position;
    const offset = await this.findEndOfCentralDirectoryLocator();
    if (offset > 0) {
      debug2("Central-directory 32-bit signature found");
      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);
      const files = [];
      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);
      for (let n = 0;n < eocdHeader.nrOfEntriesOfSize; ++n) {
        const entry = await this.tokenizer.readToken(FileHeader);
        if (entry.signature !== Signature.CentralFileHeader) {
          throw new Error("Expected Central-File-Header signature");
        }
        entry.filename = await this.tokenizer.readToken(new StringType2(entry.filenameLength, "utf-8"));
        await this.tokenizer.ignore(entry.extraFieldLength);
        await this.tokenizer.ignore(entry.fileCommentLength);
        files.push(entry);
        debug2(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);
      }
      this.tokenizer.setPosition(pos);
      return files;
    }
    this.tokenizer.setPosition(pos);
  }
  async unzip(fileCb) {
    const entries3 = await this.readCentralDirectory();
    if (entries3) {
      return this.iterateOverCentralDirectory(entries3, fileCb);
    }
    let stop2 = false;
    do {
      const zipHeader = await this.readLocalFileHeader();
      if (!zipHeader)
        break;
      const next5 = fileCb(zipHeader);
      stop2 = !!next5.stop;
      let fileData = undefined;
      await this.tokenizer.ignore(zipHeader.extraFieldLength);
      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {
        const chunks2 = [];
        let len = syncBufferSize;
        debug2("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let nextHeaderIndex = -1;
        while (nextHeaderIndex < 0 && len === syncBufferSize) {
          len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });
          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);
          const size21 = nextHeaderIndex >= 0 ? nextHeaderIndex : len;
          if (next5.handler) {
            const data = new Uint8Array(size21);
            await this.tokenizer.readBuffer(data);
            chunks2.push(data);
          } else {
            await this.tokenizer.ignore(size21);
          }
        }
        debug2(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);
        if (next5.handler) {
          await this.inflate(zipHeader, mergeArrays(chunks2), next5.handler);
        }
      } else {
        if (next5.handler) {
          debug2(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);
          fileData = new Uint8Array(zipHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next5.handler);
        } else {
          debug2(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);
          await this.tokenizer.ignore(zipHeader.compressedSize);
        }
      }
      debug2(`Reading data-descriptor at pos=${this.tokenizer.position}`);
      if (zipHeader.dataDescriptor) {
        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);
        if (dataDescriptor.signature !== 134695760) {
          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);
        }
      }
    } while (!stop2);
  }
  async iterateOverCentralDirectory(entries3, fileCb) {
    for (const fileHeader of entries3) {
      const next5 = fileCb(fileHeader);
      if (next5.handler) {
        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);
        const zipHeader = await this.readLocalFileHeader();
        if (zipHeader) {
          await this.tokenizer.ignore(zipHeader.extraFieldLength);
          const fileData = new Uint8Array(fileHeader.compressedSize);
          await this.tokenizer.readBuffer(fileData);
          await this.inflate(zipHeader, fileData, next5.handler);
        }
      }
      if (next5.stop)
        break;
    }
  }
  inflate(zipHeader, fileData, cb) {
    if (zipHeader.compressedMethod === 0) {
      return cb(fileData);
    }
    debug2(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);
    const uncompressedData = decompressSync(fileData);
    return cb(uncompressedData);
  }
  async readLocalFileHeader() {
    const signature = await this.tokenizer.peekToken(UINT32_LE);
    if (signature === Signature.LocalFileHeader) {
      const header = await this.tokenizer.readToken(LocalFileHeaderToken);
      header.filename = await this.tokenizer.readToken(new StringType2(header.filenameLength, "utf-8"));
      return header;
    }
    if (signature === Signature.CentralFileHeader) {
      return false;
    }
    if (signature === 3759263696) {
      throw new Error("Encrypted ZIP");
    }
    throw new Error("Unexpected signature");
  }
}
var import_debug, debug2, syncBufferSize, ddSignatureArray, eocdSignatureBytes;
var init_lib4 = __esm(() => {
  init_lib3();
  init_esm();
  import_debug = __toESM(require_src(), 1);
  init_ZipToken();
  debug2 = import_debug.default("tokenizer:inflate");
  syncBufferSize = 256 * 1024;
  ddSignatureArray = signatureToArray(Signature.DataDescriptor);
  eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);
});

// node_modules/uint8array-extras/index.js
function getUintBE(view) {
  const { byteLength } = view;
  if (byteLength === 6) {
    return view.getUint16(0) * 2 ** 32 + view.getUint32(2);
  }
  if (byteLength === 5) {
    return view.getUint8(0) * 2 ** 32 + view.getUint32(1);
  }
  if (byteLength === 4) {
    return view.getUint32(0);
  }
  if (byteLength === 3) {
    return view.getUint8(0) * 2 ** 16 + view.getUint16(1);
  }
  if (byteLength === 2) {
    return view.getUint16(0);
  }
  if (byteLength === 1) {
    return view.getUint8(0);
  }
}
var cachedDecoders, cachedEncoder, byteToHexLookupTable;
var init_uint8array_extras = __esm(() => {
  cachedDecoders = {
    utf8: new globalThis.TextDecoder("utf8")
  };
  cachedEncoder = new globalThis.TextEncoder;
  byteToHexLookupTable = Array.from({ length: 256 }, (_, index) => index.toString(16).padStart(2, "0"));
});

// node_modules/file-type/util.js
function stringToBytes(string6) {
  return [...string6].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {
  const readSum = Number.parseInt(new StringType2(6).get(arrayBuffer, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum3 = 8 * 32;
  for (let index = offset;index < offset + 148; index++) {
    sum3 += arrayBuffer[index];
  }
  for (let index = offset + 156;index < offset + 512; index++) {
    sum3 += arrayBuffer[index];
  }
  return readSum === sum3;
}
var uint32SyncSafeToken;
var init_util = __esm(() => {
  init_lib3();
  uint32SyncSafeToken = {
    get: (buffer3, offset) => buffer3[offset + 3] & 127 | buffer3[offset + 2] << 7 | buffer3[offset + 1] << 14 | buffer3[offset] << 21,
    len: 4
  };
});

// node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm(() => {
  extensions = [
    "jpg",
    "png",
    "apng",
    "gif",
    "webp",
    "flif",
    "xcf",
    "cr2",
    "cr3",
    "orf",
    "arw",
    "dng",
    "nef",
    "rw2",
    "raf",
    "tif",
    "bmp",
    "icns",
    "jxr",
    "psd",
    "indd",
    "zip",
    "tar",
    "rar",
    "gz",
    "bz2",
    "7z",
    "dmg",
    "mp4",
    "mid",
    "mkv",
    "webm",
    "mov",
    "avi",
    "mpg",
    "mp2",
    "mp3",
    "m4a",
    "oga",
    "ogg",
    "ogv",
    "opus",
    "flac",
    "wav",
    "spx",
    "amr",
    "pdf",
    "epub",
    "elf",
    "macho",
    "exe",
    "swf",
    "rtf",
    "wasm",
    "woff",
    "woff2",
    "eot",
    "ttf",
    "otf",
    "ttc",
    "ico",
    "flv",
    "ps",
    "xz",
    "sqlite",
    "nes",
    "crx",
    "xpi",
    "cab",
    "deb",
    "ar",
    "rpm",
    "Z",
    "lz",
    "cfb",
    "mxf",
    "mts",
    "blend",
    "bpg",
    "docx",
    "pptx",
    "xlsx",
    "3gp",
    "3g2",
    "j2c",
    "jp2",
    "jpm",
    "jpx",
    "mj2",
    "aif",
    "qcp",
    "odt",
    "ods",
    "odp",
    "xml",
    "mobi",
    "heic",
    "cur",
    "ktx",
    "ape",
    "wv",
    "dcm",
    "ics",
    "glb",
    "pcap",
    "dsf",
    "lnk",
    "alias",
    "voc",
    "ac3",
    "m4v",
    "m4p",
    "m4b",
    "f4v",
    "f4p",
    "f4b",
    "f4a",
    "mie",
    "asf",
    "ogm",
    "ogx",
    "mpc",
    "arrow",
    "shp",
    "aac",
    "mp1",
    "it",
    "s3m",
    "xm",
    "skp",
    "avif",
    "eps",
    "lzh",
    "pgp",
    "asar",
    "stl",
    "chm",
    "3mf",
    "zst",
    "jxl",
    "vcf",
    "jls",
    "pst",
    "dwg",
    "parquet",
    "class",
    "arj",
    "cpio",
    "ace",
    "avro",
    "icc",
    "fbx",
    "vsdx",
    "vtt",
    "apk",
    "drc",
    "lz4",
    "potx",
    "xltx",
    "dotx",
    "xltm",
    "ott",
    "ots",
    "otp",
    "odg",
    "otg",
    "xlsm",
    "docm",
    "dotm",
    "potm",
    "pptm",
    "jar",
    "rm",
    "ppsm",
    "ppsx"
  ];
  mimeTypes = [
    "image/jpeg",
    "image/png",
    "image/gif",
    "image/webp",
    "image/flif",
    "image/x-xcf",
    "image/x-canon-cr2",
    "image/x-canon-cr3",
    "image/tiff",
    "image/bmp",
    "image/vnd.ms-photo",
    "image/vnd.adobe.photoshop",
    "application/x-indesign",
    "application/epub+zip",
    "application/x-xpinstall",
    "application/vnd.ms-powerpoint.slideshow.macroenabled.12",
    "application/vnd.oasis.opendocument.text",
    "application/vnd.oasis.opendocument.spreadsheet",
    "application/vnd.oasis.opendocument.presentation",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "application/zip",
    "application/x-tar",
    "application/x-rar-compressed",
    "application/gzip",
    "application/x-bzip2",
    "application/x-7z-compressed",
    "application/x-apple-diskimage",
    "application/vnd.apache.arrow.file",
    "video/mp4",
    "audio/midi",
    "video/matroska",
    "video/webm",
    "video/quicktime",
    "video/vnd.avi",
    "audio/wav",
    "audio/qcelp",
    "audio/x-ms-asf",
    "video/x-ms-asf",
    "application/vnd.ms-asf",
    "video/mpeg",
    "video/3gpp",
    "audio/mpeg",
    "audio/mp4",
    "video/ogg",
    "audio/ogg",
    "audio/ogg; codecs=opus",
    "application/ogg",
    "audio/flac",
    "audio/ape",
    "audio/wavpack",
    "audio/amr",
    "application/pdf",
    "application/x-elf",
    "application/x-mach-binary",
    "application/x-msdownload",
    "application/x-shockwave-flash",
    "application/rtf",
    "application/wasm",
    "font/woff",
    "font/woff2",
    "application/vnd.ms-fontobject",
    "font/ttf",
    "font/otf",
    "font/collection",
    "image/x-icon",
    "video/x-flv",
    "application/postscript",
    "application/eps",
    "application/x-xz",
    "application/x-sqlite3",
    "application/x-nintendo-nes-rom",
    "application/x-google-chrome-extension",
    "application/vnd.ms-cab-compressed",
    "application/x-deb",
    "application/x-unix-archive",
    "application/x-rpm",
    "application/x-compress",
    "application/x-lzip",
    "application/x-cfb",
    "application/x-mie",
    "application/mxf",
    "video/mp2t",
    "application/x-blender",
    "image/bpg",
    "image/j2c",
    "image/jp2",
    "image/jpx",
    "image/jpm",
    "image/mj2",
    "audio/aiff",
    "application/xml",
    "application/x-mobipocket-ebook",
    "image/heif",
    "image/heif-sequence",
    "image/heic",
    "image/heic-sequence",
    "image/icns",
    "image/ktx",
    "application/dicom",
    "audio/x-musepack",
    "text/calendar",
    "text/vcard",
    "text/vtt",
    "model/gltf-binary",
    "application/vnd.tcpdump.pcap",
    "audio/x-dsf",
    "application/x.ms.shortcut",
    "application/x.apple.alias",
    "audio/x-voc",
    "audio/vnd.dolby.dd-raw",
    "audio/x-m4a",
    "image/apng",
    "image/x-olympus-orf",
    "image/x-sony-arw",
    "image/x-adobe-dng",
    "image/x-nikon-nef",
    "image/x-panasonic-rw2",
    "image/x-fujifilm-raf",
    "video/x-m4v",
    "video/3gpp2",
    "application/x-esri-shape",
    "audio/aac",
    "audio/x-it",
    "audio/x-s3m",
    "audio/x-xm",
    "video/MP1S",
    "video/MP2P",
    "application/vnd.sketchup.skp",
    "image/avif",
    "application/x-lzh-compressed",
    "application/pgp-encrypted",
    "application/x-asar",
    "model/stl",
    "application/vnd.ms-htmlhelp",
    "model/3mf",
    "image/jxl",
    "application/zstd",
    "image/jls",
    "application/vnd.ms-outlook",
    "image/vnd.dwg",
    "application/vnd.apache.parquet",
    "application/java-vm",
    "application/x-arj",
    "application/x-cpio",
    "application/x-ace-compressed",
    "application/avro",
    "application/vnd.iccprofile",
    "application/x.autodesk.fbx",
    "application/vnd.visio",
    "application/vnd.android.package-archive",
    "application/vnd.google.draco",
    "application/x-lz4",
    "application/vnd.openxmlformats-officedocument.presentationml.template",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "application/vnd.ms-excel.template.macroenabled.12",
    "application/vnd.oasis.opendocument.text-template",
    "application/vnd.oasis.opendocument.spreadsheet-template",
    "application/vnd.oasis.opendocument.presentation-template",
    "application/vnd.oasis.opendocument.graphics",
    "application/vnd.oasis.opendocument.graphics-template",
    "application/vnd.ms-excel.sheet.macroenabled.12",
    "application/vnd.ms-word.document.macroenabled.12",
    "application/vnd.ms-word.template.macroenabled.12",
    "application/vnd.ms-powerpoint.template.macroenabled.12",
    "application/vnd.ms-powerpoint.presentation.macroenabled.12",
    "application/java-archive",
    "application/vnd.rn-realmedia"
  ];
});

// node_modules/file-type/core.js
async function fileTypeFromBuffer(input, options) {
  return new FileTypeParser(options).fromBuffer(input);
}
async function fileTypeFromBlob(blob, options) {
  return new FileTypeParser(options).fromBlob(blob);
}
function getFileTypeFromMimeType(mimeType) {
  mimeType = mimeType.toLowerCase();
  switch (mimeType) {
    case "application/epub+zip":
      return {
        ext: "epub",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text":
      return {
        ext: "odt",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.text-template":
      return {
        ext: "ott",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return {
        ext: "ods",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return {
        ext: "ots",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation":
      return {
        ext: "odp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.presentation-template":
      return {
        ext: "otp",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics":
      return {
        ext: "odg",
        mime: mimeType
      };
    case "application/vnd.oasis.opendocument.graphics-template":
      return {
        ext: "otg",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return {
        ext: "ppsx",
        mime: mimeType
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return {
        ext: "xlsx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return {
        ext: "xlsm",
        mime: "application/vnd.ms-excel.sheet.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return {
        ext: "xltx",
        mime: mimeType
      };
    case "application/vnd.ms-excel.template.macroenabled":
      return {
        ext: "xltm",
        mime: "application/vnd.ms-excel.template.macroenabled.12"
      };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return {
        ext: "ppsm",
        mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return {
        ext: "docx",
        mime: mimeType
      };
    case "application/vnd.ms-word.document.macroenabled":
      return {
        ext: "docm",
        mime: "application/vnd.ms-word.document.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return {
        ext: "dotx",
        mime: mimeType
      };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return {
        ext: "dotm",
        mime: "application/vnd.ms-word.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return {
        ext: "potx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return {
        ext: "potm",
        mime: "application/vnd.ms-powerpoint.template.macroenabled.12"
      };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return {
        ext: "pptx",
        mime: mimeType
      };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return {
        ext: "pptm",
        mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12"
      };
    case "application/vnd.ms-visio.drawing":
      return {
        ext: "vsdx",
        mime: "application/vnd.visio"
      };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return {
        ext: "3mf",
        mime: "model/3mf"
      };
    default:
  }
}
function _check(buffer3, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer3[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer3[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer, options) {
  return new FileTypeParser(options).fromTokenizer(tokenizer);
}

class FileTypeParser {
  constructor(options) {
    this.options = {
      mpegOffsetTolerance: 0,
      ...options
    };
    this.detectors = [
      ...options?.customDetectors ?? [],
      { id: "core", detect: this.detectConfident },
      { id: "core.imprecise", detect: this.detectImprecise }
    ];
    this.tokenizerOptions = {
      abortSignal: options?.signal
    };
  }
  async fromTokenizer(tokenizer) {
    const initialPosition = tokenizer.position;
    for (const detector of this.detectors) {
      const fileType = await detector.detect(tokenizer);
      if (fileType) {
        return fileType;
      }
      if (initialPosition !== tokenizer.position) {
        return;
      }
    }
  }
  async fromBuffer(input) {
    if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
      throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof input}\``);
    }
    const buffer3 = input instanceof Uint8Array ? input : new Uint8Array(input);
    if (!(buffer3?.length > 1)) {
      return;
    }
    return this.fromTokenizer(fromBuffer(buffer3, this.tokenizerOptions));
  }
  async fromBlob(blob) {
    return this.fromStream(blob.stream());
  }
  async fromStream(stream2) {
    const tokenizer = await fromWebStream(stream2, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(tokenizer);
    } finally {
      await tokenizer.close();
    }
  }
  async toDetectionStream(stream2, options) {
    const { sampleSize = reasonableDetectionSizeInBytes } = options;
    let detectedFileType;
    let firstChunk;
    const reader = stream2.getReader({ mode: "byob" });
    try {
      const { value: chunk4, done: done14 } = await reader.read(new Uint8Array(sampleSize));
      firstChunk = chunk4;
      if (!done14 && chunk4) {
        try {
          detectedFileType = await this.fromBuffer(chunk4.subarray(0, sampleSize));
        } catch (error2) {
          if (!(error2 instanceof EndOfStreamError)) {
            throw error2;
          }
          detectedFileType = undefined;
        }
      }
      firstChunk = chunk4;
    } finally {
      reader.releaseLock();
    }
    const transformStream = new TransformStream({
      async start(controller) {
        controller.enqueue(firstChunk);
      },
      transform(chunk4, controller) {
        controller.enqueue(chunk4);
      }
    });
    const newStream = stream2.pipeThrough(transformStream);
    newStream.fileType = detectedFileType;
    return newStream;
  }
  check(header, options) {
    return _check(this.buffer, header, options);
  }
  checkString(header, options) {
    return this.check(stringToBytes(header), options);
  }
  detectConfident = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    if (tokenizer.fileInfo.size === undefined) {
      tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
    }
    this.tokenizer = tokenizer;
    await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
    if (this.check([66, 77])) {
      return {
        ext: "bmp",
        mime: "image/bmp"
      };
    }
    if (this.check([11, 119])) {
      return {
        ext: "ac3",
        mime: "audio/vnd.dolby.dd-raw"
      };
    }
    if (this.check([120, 1])) {
      return {
        ext: "dmg",
        mime: "application/x-apple-diskimage"
      };
    }
    if (this.check([77, 90])) {
      return {
        ext: "exe",
        mime: "application/x-msdownload"
      };
    }
    if (this.check([37, 33])) {
      await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
      if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
        return {
          ext: "eps",
          mime: "application/eps"
        };
      }
      return {
        ext: "ps",
        mime: "application/postscript"
      };
    }
    if (this.check([31, 160]) || this.check([31, 157])) {
      return {
        ext: "Z",
        mime: "application/x-compress"
      };
    }
    if (this.check([199, 113])) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.check([96, 234])) {
      return {
        ext: "arj",
        mime: "application/x-arj"
      };
    }
    if (this.check([239, 187, 191])) {
      this.tokenizer.ignore(3);
      return this.detectConfident(tokenizer);
    }
    if (this.check([71, 73, 70])) {
      return {
        ext: "gif",
        mime: "image/gif"
      };
    }
    if (this.check([73, 73, 188])) {
      return {
        ext: "jxr",
        mime: "image/vnd.ms-photo"
      };
    }
    if (this.check([31, 139, 8])) {
      return {
        ext: "gz",
        mime: "application/gzip"
      };
    }
    if (this.check([66, 90, 104])) {
      return {
        ext: "bz2",
        mime: "application/x-bzip2"
      };
    }
    if (this.checkString("ID3")) {
      await tokenizer.ignore(6);
      const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
      if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      await tokenizer.ignore(id3HeaderLength);
      return this.fromTokenizer(tokenizer);
    }
    if (this.checkString("MP+")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
      return {
        ext: "swf",
        mime: "application/x-shockwave-flash"
      };
    }
    if (this.check([255, 216, 255])) {
      if (this.check([247], { offset: 3 })) {
        return {
          ext: "jls",
          mime: "image/jls"
        };
      }
      return {
        ext: "jpg",
        mime: "image/jpeg"
      };
    }
    if (this.check([79, 98, 106, 1])) {
      return {
        ext: "avro",
        mime: "application/avro"
      };
    }
    if (this.checkString("FLIF")) {
      return {
        ext: "flif",
        mime: "image/flif"
      };
    }
    if (this.checkString("8BPS")) {
      return {
        ext: "psd",
        mime: "image/vnd.adobe.photoshop"
      };
    }
    if (this.checkString("MPCK")) {
      return {
        ext: "mpc",
        mime: "audio/x-musepack"
      };
    }
    if (this.checkString("FORM")) {
      return {
        ext: "aif",
        mime: "audio/aiff"
      };
    }
    if (this.checkString("icns", { offset: 0 })) {
      return {
        ext: "icns",
        mime: "image/icns"
      };
    }
    if (this.check([80, 75, 3, 4])) {
      let fileType;
      await new ZipHandler(tokenizer).unzip((zipHeader) => {
        switch (zipHeader.filename) {
          case "META-INF/mozilla.rsa":
            fileType = {
              ext: "xpi",
              mime: "application/x-xpinstall"
            };
            return {
              stop: true
            };
          case "META-INF/MANIFEST.MF":
            fileType = {
              ext: "jar",
              mime: "application/java-archive"
            };
            return {
              stop: true
            };
          case "mimetype":
            return {
              async handler(fileData) {
                const mimeType = new TextDecoder("utf-8").decode(fileData).trim();
                fileType = getFileTypeFromMimeType(mimeType);
              },
              stop: true
            };
          case "[Content_Types].xml":
            return {
              async handler(fileData) {
                let xmlContent = new TextDecoder("utf-8").decode(fileData);
                const endPos = xmlContent.indexOf('.main+xml"');
                if (endPos === -1) {
                  const mimeType = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                  if (xmlContent.includes(`ContentType="${mimeType}"`)) {
                    fileType = getFileTypeFromMimeType(mimeType);
                  }
                } else {
                  xmlContent = xmlContent.slice(0, Math.max(0, endPos));
                  const firstPos = xmlContent.lastIndexOf('"');
                  const mimeType = xmlContent.slice(Math.max(0, firstPos + 1));
                  fileType = getFileTypeFromMimeType(mimeType);
                }
              },
              stop: true
            };
          default:
            if (/classes\d*\.dex/.test(zipHeader.filename)) {
              fileType = {
                ext: "apk",
                mime: "application/vnd.android.package-archive"
              };
              return { stop: true };
            }
            return {};
        }
      });
      return fileType ?? {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("OggS")) {
      await tokenizer.ignore(28);
      const type2 = new Uint8Array(8);
      await tokenizer.readBuffer(type2);
      if (_check(type2, [79, 112, 117, 115, 72, 101, 97, 100])) {
        return {
          ext: "opus",
          mime: "audio/ogg; codecs=opus"
        };
      }
      if (_check(type2, [128, 116, 104, 101, 111, 114, 97])) {
        return {
          ext: "ogv",
          mime: "video/ogg"
        };
      }
      if (_check(type2, [1, 118, 105, 100, 101, 111, 0])) {
        return {
          ext: "ogm",
          mime: "video/ogg"
        };
      }
      if (_check(type2, [127, 70, 76, 65, 67])) {
        return {
          ext: "oga",
          mime: "audio/ogg"
        };
      }
      if (_check(type2, [83, 112, 101, 101, 120, 32, 32])) {
        return {
          ext: "spx",
          mime: "audio/ogg"
        };
      }
      if (_check(type2, [1, 118, 111, 114, 98, 105, 115])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      return {
        ext: "ogx",
        mime: "application/ogg"
      };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
      return {
        ext: "zip",
        mime: "application/zip"
      };
    }
    if (this.checkString("MThd")) {
      return {
        ext: "mid",
        mime: "audio/midi"
      };
    }
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff",
        mime: "font/woff"
      };
    }
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
      return {
        ext: "woff2",
        mime: "font/woff2"
      };
    }
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
      return {
        ext: "pcap",
        mime: "application/vnd.tcpdump.pcap"
      };
    }
    if (this.checkString("DSD ")) {
      return {
        ext: "dsf",
        mime: "audio/x-dsf"
      };
    }
    if (this.checkString("LZIP")) {
      return {
        ext: "lz",
        mime: "application/x-lzip"
      };
    }
    if (this.checkString("fLaC")) {
      return {
        ext: "flac",
        mime: "audio/flac"
      };
    }
    if (this.check([66, 80, 71, 251])) {
      return {
        ext: "bpg",
        mime: "image/bpg"
      };
    }
    if (this.checkString("wvpk")) {
      return {
        ext: "wv",
        mime: "audio/wavpack"
      };
    }
    if (this.checkString("%PDF")) {
      return {
        ext: "pdf",
        mime: "application/pdf"
      };
    }
    if (this.check([0, 97, 115, 109])) {
      return {
        ext: "wasm",
        mime: "application/wasm"
      };
    }
    if (this.check([73, 73])) {
      const fileType = await this.readTiffHeader(false);
      if (fileType) {
        return fileType;
      }
    }
    if (this.check([77, 77])) {
      const fileType = await this.readTiffHeader(true);
      if (fileType) {
        return fileType;
      }
    }
    if (this.checkString("MAC ")) {
      return {
        ext: "ape",
        mime: "audio/ape"
      };
    }
    if (this.check([26, 69, 223, 163])) {
      async function readField() {
        const msb = await tokenizer.peekNumber(UINT8);
        let mask = 128;
        let ic = 0;
        while ((msb & mask) === 0 && mask !== 0) {
          ++ic;
          mask >>= 1;
        }
        const id2 = new Uint8Array(ic + 1);
        await tokenizer.readBuffer(id2);
        return id2;
      }
      async function readElement() {
        const idField = await readField();
        const lengthField = await readField();
        lengthField[0] ^= 128 >> lengthField.length - 1;
        const nrLength = Math.min(6, lengthField.length);
        const idView = new DataView(idField.buffer);
        const lengthView = new DataView(lengthField.buffer, lengthField.length - nrLength, nrLength);
        return {
          id: getUintBE(idView),
          len: getUintBE(lengthView)
        };
      }
      async function readChildren(children2) {
        while (children2 > 0) {
          const element = await readElement();
          if (element.id === 17026) {
            const rawValue = await tokenizer.readToken(new StringType2(element.len));
            return rawValue.replaceAll(/\00.*$/g, "");
          }
          await tokenizer.ignore(element.len);
          --children2;
        }
      }
      const re = await readElement();
      const documentType = await readChildren(re.len);
      switch (documentType) {
        case "webm":
          return {
            ext: "webm",
            mime: "video/webm"
          };
        case "matroska":
          return {
            ext: "mkv",
            mime: "video/matroska"
          };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) {
      return {
        ext: "sqlite",
        mime: "application/x-sqlite3"
      };
    }
    if (this.check([78, 69, 83, 26])) {
      return {
        ext: "nes",
        mime: "application/x-nintendo-nes-rom"
      };
    }
    if (this.checkString("Cr24")) {
      return {
        ext: "crx",
        mime: "application/x-google-chrome-extension"
      };
    }
    if (this.checkString("MSCF") || this.checkString("ISc(")) {
      return {
        ext: "cab",
        mime: "application/vnd.ms-cab-compressed"
      };
    }
    if (this.check([237, 171, 238, 219])) {
      return {
        ext: "rpm",
        mime: "application/x-rpm"
      };
    }
    if (this.check([197, 208, 211, 198])) {
      return {
        ext: "eps",
        mime: "application/eps"
      };
    }
    if (this.check([40, 181, 47, 253])) {
      return {
        ext: "zst",
        mime: "application/zstd"
      };
    }
    if (this.check([127, 69, 76, 70])) {
      return {
        ext: "elf",
        mime: "application/x-elf"
      };
    }
    if (this.check([33, 66, 68, 78])) {
      return {
        ext: "pst",
        mime: "application/vnd.ms-outlook"
      };
    }
    if (this.checkString("PAR1") || this.checkString("PARE")) {
      return {
        ext: "parquet",
        mime: "application/vnd.apache.parquet"
      };
    }
    if (this.checkString("ttcf")) {
      return {
        ext: "ttc",
        mime: "font/collection"
      };
    }
    if (this.check([207, 250, 237, 254])) {
      return {
        ext: "macho",
        mime: "application/x-mach-binary"
      };
    }
    if (this.check([4, 34, 77, 24])) {
      return {
        ext: "lz4",
        mime: "application/x-lz4"
      };
    }
    if (this.check([79, 84, 84, 79, 0])) {
      return {
        ext: "otf",
        mime: "font/otf"
      };
    }
    if (this.checkString("#!AMR")) {
      return {
        ext: "amr",
        mime: "audio/amr"
      };
    }
    if (this.checkString("{\\rtf")) {
      return {
        ext: "rtf",
        mime: "application/rtf"
      };
    }
    if (this.check([70, 76, 86, 1])) {
      return {
        ext: "flv",
        mime: "video/x-flv"
      };
    }
    if (this.checkString("IMPM")) {
      return {
        ext: "it",
        mime: "audio/x-it"
      };
    }
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
      return {
        ext: "lzh",
        mime: "application/x-lzh-compressed"
      };
    }
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) {
        return {
          ext: "mpg",
          mime: "video/MP1S"
        };
      }
      if (this.check([68], { offset: 4, mask: [196] })) {
        return {
          ext: "mpg",
          mime: "video/MP2P"
        };
      }
    }
    if (this.checkString("ITSF")) {
      return {
        ext: "chm",
        mime: "application/vnd.ms-htmlhelp"
      };
    }
    if (this.check([202, 254, 186, 190])) {
      return {
        ext: "class",
        mime: "application/java-vm"
      };
    }
    if (this.checkString(".RMF")) {
      return {
        ext: "rm",
        mime: "application/vnd.rn-realmedia"
      };
    }
    if (this.checkString("DRACO")) {
      return {
        ext: "drc",
        mime: "application/vnd.google.draco"
      };
    }
    if (this.check([253, 55, 122, 88, 90, 0])) {
      return {
        ext: "xz",
        mime: "application/x-xz"
      };
    }
    if (this.checkString("<?xml ")) {
      return {
        ext: "xml",
        mime: "application/xml"
      };
    }
    if (this.check([55, 122, 188, 175, 39, 28])) {
      return {
        ext: "7z",
        mime: "application/x-7z-compressed"
      };
    }
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
      return {
        ext: "rar",
        mime: "application/x-rar-compressed"
      };
    }
    if (this.checkString("solid ")) {
      return {
        ext: "stl",
        mime: "model/stl"
      };
    }
    if (this.checkString("AC")) {
      const version = new StringType2(4, "latin1").get(this.buffer, 2);
      if (version.match("^d*") && version >= 1000 && version <= 1050) {
        return {
          ext: "dwg",
          mime: "image/vnd.dwg"
        };
      }
    }
    if (this.checkString("070707")) {
      return {
        ext: "cpio",
        mime: "application/x-cpio"
      };
    }
    if (this.checkString("BLENDER")) {
      return {
        ext: "blend",
        mime: "application/x-blender"
      };
    }
    if (this.checkString("!<arch>")) {
      await tokenizer.ignore(8);
      const string6 = await tokenizer.readToken(new StringType2(13, "ascii"));
      if (string6 === "debian-binary") {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      return {
        ext: "ar",
        mime: "application/x-unix-archive"
      };
    }
    if (this.checkString("WEBVTT") && ["\n", "\r", "\t", " ", "\0"].some((char7) => this.checkString(char7, { offset: 6 }))) {
      return {
        ext: "vtt",
        mime: "text/vtt"
      };
    }
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await tokenizer.ignore(8);
      async function readChunkHeader() {
        return {
          length: await tokenizer.readToken(INT32_BE),
          type: await tokenizer.readToken(new StringType2(4, "latin1"))
        };
      }
      do {
        const chunk4 = await readChunkHeader();
        if (chunk4.length < 0) {
          return;
        }
        switch (chunk4.type) {
          case "IDAT":
            return {
              ext: "png",
              mime: "image/png"
            };
          case "acTL":
            return {
              ext: "apng",
              mime: "image/apng"
            };
          default:
            await tokenizer.ignore(chunk4.length + 4);
        }
      } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
      return {
        ext: "png",
        mime: "image/png"
      };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
      return {
        ext: "arrow",
        mime: "application/vnd.apache.arrow.file"
      };
    }
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
      return {
        ext: "glb",
        mime: "model/gltf-binary"
      };
    }
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
      return {
        ext: "mov",
        mime: "video/quicktime"
      };
    }
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
      return {
        ext: "orf",
        mime: "image/x-olympus-orf"
      };
    }
    if (this.checkString("gimp xcf ")) {
      return {
        ext: "xcf",
        mime: "image/x-xcf"
      };
    }
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      const brandMajor = new StringType2(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
      switch (brandMajor) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          if (brandMajor.startsWith("3g")) {
            if (brandMajor.startsWith("3g2")) {
              return { ext: "3g2", mime: "video/3gpp2" };
            }
            return { ext: "3gp", mime: "video/3gpp" };
          }
          return { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (this.check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/vnd.avi"
        };
      }
      if (this.check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/wav"
        };
      }
      if (this.check([81, 76, 67, 77], { offset: 8 })) {
        return {
          ext: "qcp",
          mime: "audio/qcelp"
        };
      }
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
      return {
        ext: "rw2",
        mime: "image/x-panasonic-rw2"
      };
    }
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function readHeader() {
        const guid = new Uint8Array(16);
        await tokenizer.readBuffer(guid);
        return {
          id: guid,
          size: Number(await tokenizer.readToken(UINT64_LE))
        };
      }
      await tokenizer.ignore(30);
      while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
        const header = await readHeader();
        let payload = header.size - 24;
        if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          const typeId = new Uint8Array(16);
          payload -= await tokenizer.readBuffer(typeId);
          if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "audio/x-ms-asf"
            };
          }
          if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
            return {
              ext: "asf",
              mime: "video/x-ms-asf"
            };
          }
          break;
        }
        await tokenizer.ignore(payload);
      }
      return {
        ext: "asf",
        mime: "application/vnd.ms-asf"
      };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
      return {
        ext: "ktx",
        mime: "image/ktx"
      };
    }
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
      return {
        ext: "mie",
        mime: "application/x-mie"
      };
    }
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
      return {
        ext: "shp",
        mime: "application/x-esri-shape"
      };
    }
    if (this.check([255, 79, 255, 81])) {
      return {
        ext: "j2c",
        mime: "image/j2c"
      };
    }
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
      await tokenizer.ignore(20);
      const type2 = await tokenizer.readToken(new StringType2(4, "ascii"));
      switch (type2) {
        case "jp2 ":
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        case "jpx ":
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        case "jpm ":
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        case "mjp2":
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        default:
          return;
      }
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
      return {
        ext: "jxl",
        mime: "image/jxl"
      };
    }
    if (this.check([254, 255])) {
      if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      return;
    }
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
      return {
        ext: "cfb",
        mime: "application/x-cfb"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([97, 99, 115, 112], { offset: 36 })) {
      return {
        ext: "icc",
        mime: "application/vnd.iccprofile"
      };
    }
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) {
      return {
        ext: "ace",
        mime: "application/x-ace-compressed"
      };
    }
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) {
        return {
          ext: "vcf",
          mime: "text/vcard"
        };
      }
      if (this.checkString("VCALENDAR", { offset: 6 })) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
    }
    if (this.checkString("FUJIFILMCCD-RAW")) {
      return {
        ext: "raf",
        mime: "image/x-fujifilm-raf"
      };
    }
    if (this.checkString("Extended Module:")) {
      return {
        ext: "xm",
        mime: "audio/x-xm"
      };
    }
    if (this.checkString("Creative Voice File")) {
      return {
        ext: "voc",
        mime: "audio/x-voc"
      };
    }
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      const jsonSize = new DataView(this.buffer.buffer).getUint32(12, true);
      if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
        try {
          const header = new TextDecoder().decode(this.buffer.subarray(16, jsonSize + 16));
          const json = JSON.parse(header);
          if (json.files) {
            return {
              ext: "asar",
              mime: "application/x-asar"
            };
          }
        } catch {
        }
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
      return {
        ext: "mxf",
        mime: "application/mxf"
      };
    }
    if (this.checkString("SCRM", { offset: 44 })) {
      return {
        ext: "s3m",
        mime: "audio/x-s3m"
      };
    }
    if (this.check([71]) && this.check([71], { offset: 188 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
      return {
        ext: "mts",
        mime: "video/mp2t"
      };
    }
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
      return {
        ext: "mobi",
        mime: "application/x-mobipocket-ebook"
      };
    }
    if (this.check([68, 73, 67, 77], { offset: 128 })) {
      return {
        ext: "dcm",
        mime: "application/dicom"
      };
    }
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
      return {
        ext: "lnk",
        mime: "application/x.ms.shortcut"
      };
    }
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
      return {
        ext: "alias",
        mime: "application/x.apple.alias"
      };
    }
    if (this.checkString("Kaydara FBX Binary  \0")) {
      return {
        ext: "fbx",
        mime: "application/x.autodesk.fbx"
      };
    }
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
      return {
        ext: "eot",
        mime: "application/vnd.ms-fontobject"
      };
    }
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
      return {
        ext: "indd",
        mime: "application/x-indesign"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && tarHeaderChecksumMatches(this.buffer)) {
      return {
        ext: "tar",
        mime: "application/x-tar"
      };
    }
    if (this.check([255, 254])) {
      if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
        return {
          ext: "skp",
          mime: "application/vnd.sketchup.skp"
        };
      }
      return;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
      return {
        ext: "pgp",
        mime: "application/pgp-encrypted"
      };
    }
  };
  detectImprecise = async (tokenizer) => {
    this.buffer = new Uint8Array(reasonableDetectionSizeInBytes);
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(8, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
      return {
        ext: "mpg",
        mime: "video/mpeg"
      };
    }
    if (this.check([0, 1, 0, 0, 0])) {
      return {
        ext: "ttf",
        mime: "font/ttf"
      };
    }
    if (this.check([0, 0, 1, 0])) {
      return {
        ext: "ico",
        mime: "image/x-icon"
      };
    }
    if (this.check([0, 0, 2, 0])) {
      return {
        ext: "cur",
        mime: "image/x-icon"
      };
    }
    await tokenizer.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, tokenizer.fileInfo.size), mayBeLess: true });
    if (this.buffer.length >= 2 + this.options.mpegOffsetTolerance) {
      for (let depth = 0;depth <= this.options.mpegOffsetTolerance; ++depth) {
        const type2 = this.scanMpeg(depth);
        if (type2) {
          return type2;
        }
      }
    }
  };
  async readTiffTag(bigEndian) {
    const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    this.tokenizer.ignore(10);
    switch (tagId) {
      case 50341:
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      case 50706:
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      default:
    }
  }
  async readTiffIFD(bigEndian) {
    const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
    for (let n = 0;n < numberOfTags; ++n) {
      const fileType = await this.readTiffTag(bigEndian);
      if (fileType) {
        return fileType;
      }
    }
  }
  async readTiffHeader(bigEndian) {
    const version = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
    const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
    if (version === 42) {
      if (ifdOffset >= 6) {
        if (this.checkString("CR", { offset: 8 })) {
          return {
            ext: "cr2",
            mime: "image/x-canon-cr2"
          };
        }
        if (ifdOffset >= 8) {
          const someId1 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 8);
          const someId2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 10);
          if (someId1 === 28 && someId2 === 254 || someId1 === 31 && someId2 === 11) {
            return {
              ext: "nef",
              mime: "image/x-nikon-nef"
            };
          }
        }
      }
      await this.tokenizer.ignore(ifdOffset);
      const fileType = await this.readTiffIFD(bigEndian);
      return fileType ?? {
        ext: "tif",
        mime: "image/tiff"
      };
    }
    if (version === 43) {
      return {
        ext: "tif",
        mime: "image/tiff"
      };
    }
  }
  scanMpeg(offset) {
    if (this.check([255, 224], { offset, mask: [255, 224] })) {
      if (this.check([16], { offset: offset + 1, mask: [22] })) {
        if (this.check([8], { offset: offset + 1, mask: [8] })) {
          return {
            ext: "aac",
            mime: "audio/aac"
          };
        }
        return {
          ext: "aac",
          mime: "audio/aac"
        };
      }
      if (this.check([2], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (this.check([4], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp2",
          mime: "audio/mpeg"
        };
      }
      if (this.check([6], { offset: offset + 1, mask: [6] })) {
        return {
          ext: "mp1",
          mime: "audio/mpeg"
        };
      }
    }
  }
}
var reasonableDetectionSizeInBytes = 4100, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm(() => {
  init_lib3();
  init_core();
  init_lib4();
  init_uint8array_extras();
  init_util();
  init_supported();
  supportedExtensions = new Set(extensions);
  supportedMimeTypes = new Set(mimeTypes);
});

// node_modules/file-type/index.js
var exports_file_type = {};
__export(exports_file_type, {
  supportedMimeTypes: () => supportedMimeTypes,
  supportedExtensions: () => supportedExtensions,
  fileTypeStream: () => fileTypeStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromBlob: () => fileTypeFromBlob,
  FileTypeParser: () => FileTypeParser2
});
import { ReadableStream as WebReadableStream } from "stream/web";
import { pipeline, PassThrough, Readable } from "stream";
async function fileTypeFromFile(path, options) {
  return new FileTypeParser2(options).fromFile(path, options);
}
async function fileTypeFromStream(stream2, options) {
  return new FileTypeParser2(options).fromStream(stream2);
}
async function fileTypeStream(readableStream, options = {}) {
  return new FileTypeParser2(options).toDetectionStream(readableStream, options);
}
var FileTypeParser2;
var init_file_type = __esm(() => {
  init_lib();
  init_core2();
  init_core2();
  FileTypeParser2 = class FileTypeParser2 extends FileTypeParser {
    async fromStream(stream2) {
      const tokenizer = await (stream2 instanceof WebReadableStream ? fromWebStream(stream2, this.tokenizerOptions) : fromStream3(stream2, this.tokenizerOptions));
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async fromFile(path) {
      const tokenizer = await fromFile(path);
      try {
        return await super.fromTokenizer(tokenizer);
      } finally {
        await tokenizer.close();
      }
    }
    async toDetectionStream(readableStream, options = {}) {
      if (!(readableStream instanceof Readable)) {
        return super.toDetectionStream(readableStream, options);
      }
      const { sampleSize = reasonableDetectionSizeInBytes } = options;
      return new Promise((resolve, reject2) => {
        readableStream.on("error", reject2);
        readableStream.once("readable", () => {
          (async () => {
            try {
              const pass = new PassThrough;
              const outputStream = pipeline ? pipeline(readableStream, pass, () => {
              }) : readableStream.pipe(pass);
              const chunk4 = readableStream.read(sampleSize) ?? readableStream.read() ?? new Uint8Array(0);
              try {
                pass.fileType = await this.fromBuffer(chunk4);
              } catch (error2) {
                if (error2 instanceof EndOfStreamError) {
                  pass.fileType = undefined;
                } else {
                  reject2(error2);
                }
              }
              resolve(outputStream);
            } catch (error2) {
              reject2(error2);
            }
          })();
        });
      });
    }
  };
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  function identity3(value6) {
    return value6;
  }
  exports.parse = function(source, transform7) {
    return new ArrayParser(source, transform7).parse();
  };

  class ArrayParser {
    constructor(source, transform7) {
      this.source = source;
      this.transform = transform7 || identity3;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested4) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested4)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array7 = require_postgres_array();
  module.exports = {
    create: function(source, transform7) {
      return {
        parse: function() {
          return array7.parse(source, transform7);
        }
      };
    }
  };
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  function getDate(isoDate) {
    var matches = DATE2.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date3 = new Date(year, month, day);
    if (is0To99(year)) {
      date3.setFullYear(year);
    }
    return date3;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type2 = zone[1];
    if (type2 === "Z") {
      return 0;
    }
    var sign3 = type2 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign3 * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE2 = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date3;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date3 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date3.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date3.setTime(date3.getTime() - offset);
      }
    } else {
      date3 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date3.setFullYear(year);
      }
    }
    return date3;
  };
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  function extend4(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  module.exports = extend4;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend4(this, parse4(raw));
  }
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse4(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative2 = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value6 = matches[position];
      if (!value6)
        return parsed;
      value6 = property === "milliseconds" ? parseMilliseconds(value6) : parseInt(value6, 10);
      if (!value6)
        return parsed;
      if (isNegative2 && ~negatives.indexOf(property)) {
        value6 *= -1;
      }
      parsed[property] = value6;
      return parsed;
    }, {});
  }
  var extend4 = require_mutable();
  module.exports = PostgresInterval;
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value6 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value6 = (value6 + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value6 + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value6 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value6 = (value6 + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value6 + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME2 = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME2].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k2 = 0;k2 < Math.floor(backslashes / 2); ++k2) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  function allowNull(fn2) {
    return function nullAllowed(value6) {
      if (value6 === null)
        return value6;
      return fn2(value6);
    };
  }
  function parseBool(value6) {
    if (value6 === null)
      return value6;
    return value6 === "TRUE" || value6 === "t" || value6 === "true" || value6 === "y" || value6 === "yes" || value6 === "on" || value6 === "1";
  }
  function parseBoolArray(value6) {
    if (!value6)
      return null;
    return array7.parse(value6, parseBool);
  }
  function parseBaseTenInt(string6) {
    return parseInt(string6, 10);
  }
  function parseIntegerArray(value6) {
    if (!value6)
      return null;
    return array7.parse(value6, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value6) {
    if (!value6)
      return null;
    return array7.parse(value6, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var array7 = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  var parsePointArray = function(value6) {
    if (!value6) {
      return null;
    }
    var p = arrayParser.create(value6, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value6) {
    if (!value6) {
      return null;
    }
    var p = arrayParser.create(value6, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value6) {
    if (!value6) {
      return null;
    }
    var p = arrayParser.create(value6);
    return p.parse();
  };
  var parseDateArray = function(value6) {
    if (!value6) {
      return null;
    }
    var p = arrayParser.create(value6, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value6) {
    if (!value6) {
      return null;
    }
    var p = arrayParser.create(value6, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value6) {
    if (!value6) {
      return null;
    }
    return array7.parse(value6, allowNull(parseByteA));
  };
  var parseInteger2 = function(value6) {
    return parseInt(value6, 10);
  };
  var parseBigInteger = function(value6) {
    var valStr = String(value6);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value6;
  };
  var parseJsonArray = function(value6) {
    if (!value6) {
      return null;
    }
    return array7.parse(value6, allowNull(JSON.parse));
  };
  var parsePoint = function(value6) {
    if (value6[0] !== "(") {
      return null;
    }
    value6 = value6.substring(1, value6.length - 1).split(",");
    return {
      x: parseFloat(value6[0]),
      y: parseFloat(value6[1])
    };
  };
  var parseCircle = function(value6) {
    if (value6[0] !== "<" && value6[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value6.length - 1; i++) {
      if (!pointParsed) {
        point += value6[i];
      }
      if (value6[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value6[i] === ",") {
        continue;
      }
      radius += value6[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger2);
    register(23, parseInteger2);
    register(26, parseInteger2);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  function readInt8(buffer3) {
    var high = buffer3.readInt32BE(0);
    var low = buffer3.readUInt32BE(4);
    var sign3 = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign3 = "-";
    }
    var result = "";
    var carry;
    var t2;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign3 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign3 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign3 + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t2 = 4294967296 * carry + low;
      digits = "" + t2 % BASE;
      return sign3 + digits + result;
    }
  }
  var BASE = 1e6;
  module.exports = readInt8;
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits2, offset, invert2, callback) {
    offset = offset || 0;
    invert2 = invert2 || false;
    callback = callback || function(lastValue, newValue, bits3) {
      return lastValue * Math.pow(2, bits3) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value6) {
      if (invert2) {
        return ~value6 & 255;
      }
      return value6;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits2 < firstBits) {
      mask = 255 << 8 - bits2 & 255;
      firstBits = bits2;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits2 >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits2 + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits2 + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign3 = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits2) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits2; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits2 - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign3 === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign3 === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value6) {
    if (parseBits(value6, 1) == 1) {
      return -1 * (parseBits(value6, 15, 1, true) + 1);
    }
    return parseBits(value6, 15, 1);
  };
  var parseInt32 = function(value6) {
    if (parseBits(value6, 1) == 1) {
      return -1 * (parseBits(value6, 31, 1, true) + 1);
    }
    return parseBits(value6, 31, 1);
  };
  var parseFloat32 = function(value6) {
    return parseFloatFromBits(value6, 23, 8);
  };
  var parseFloat64 = function(value6) {
    return parseFloatFromBits(value6, 52, 11);
  };
  var parseNumeric = function(value6) {
    var sign3 = parseBits(value6, 16, 32);
    if (sign3 == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value6, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value6, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value6, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale2 = Math.pow(10, parseBits(value6, 16, 48));
    return (sign3 === 0 ? 1 : -1) * Math.round(result * scale2) / scale2;
  };
  var parseDate = function(isUTC, value6) {
    var sign3 = parseBits(value6, 1);
    var rawValue = parseBits(value6, 63, 1);
    var result = new Date((sign3 === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value7) {
      this.usec = value7;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value6) {
    var dim = parseBits(value6, 32);
    var flags = parseBits(value6, 32, 32);
    var elementType = parseBits(value6, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value6, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length4 = parseBits(value6, 32, offset);
      offset += 32;
      if (length4 == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value6, length4 * 8, offset);
        offset += length4 * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value6.toString(this.encoding, offset >> 3, (offset += length4 << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse4 = function(dimension, elementType2) {
      var array7 = [];
      var i2;
      if (dimension.length > 1) {
        var count5 = dimension.shift();
        for (i2 = 0;i2 < count5; i2++) {
          array7[i2] = parse4(dimension, elementType2);
        }
        dimension.unshift(count5);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array7[i2] = parseElement(elementType2);
        }
      }
      return array7;
    };
    return parse4(dims, elementType);
  };
  var parseText = function(value6) {
    return value6.toString("utf8");
  };
  var parseBool = function(value6) {
    if (value6 === null)
      return null;
    return parseBits(value6, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format7) {
    format7 = format7 || "text";
    if (!typeParsers[format7]) {
      return noParse;
    }
    return typeParsers[format7][oid] || noParse;
  }
  function setTypeParser(oid, format7, parseFn) {
    if (typeof format7 == "function") {
      parseFn = format7;
      format7 = "text";
    }
    typeParsers[format7][oid] = parseFn;
  }
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : "sayertindall",
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date3) {
    let offset = -date3.getTimezoneOffset();
    let year = date3.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date3.getMonth() + 1).padStart(2, "0") + "-" + String(date3.getDate()).padStart(2, "0") + "T" + String(date3.getHours()).padStart(2, "0") + ":" + String(date3.getMinutes()).padStart(2, "0") + ":" + String(date3.getSeconds()).padStart(2, "0") + "." + String(date3.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date3) {
    let year = date3.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date3.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date3.getUTCDate()).padStart(2, "0") + "T" + String(date3.getUTCHours()).padStart(2, "0") + ":" + String(date3.getUTCMinutes()).padStart(2, "0") + ":" + String(date3.getUTCSeconds()).padStart(2, "0") + "." + String(date3.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config2, values7, callback) {
    config2 = typeof config2 === "string" ? { text: config2 } : config2;
    if (values7) {
      if (typeof values7 === "function") {
        config2.callback = values7;
      } else {
        config2.values = values7;
      }
    }
    if (callback) {
      config2.callback = callback;
    }
    return config2;
  }
  var defaults = require_defaults();
  var util = import.meta.require("util");
  var { isDate: isDate2 } = util.types || util;
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate2(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value6) {
      return prepareValue(value6);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  function md5(string6) {
    return nodeCrypto.createHash("md5").update(string6, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  }
  function hashByName(hashName, text) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  function randomBytes(length4) {
    return webCrypto.getRandomValues(Buffer.alloc(length4));
  }
  async function md5(string6) {
    try {
      return nodeCrypto.createHash("md5").update(string6, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string6 === "string" ? textEncoder.encode(string6) : string6;
      const hash3 = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash3)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hashByName(hashName, text) {
    return await subtleCrypto.digest(hashName, text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
  var nodeCrypto = import.meta.require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
});

// node_modules/pg/lib/crypto/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length4 = data[index++];
    if (length4 < 128)
      return { length: length4, index };
    const lengthBytes = length4 & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length4 = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length4 = length4 << 8 | data[index++];
    }
    return { length: length4, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value6 = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value6 = value6 << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value6;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  function startSession(mechanisms, stream2) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream2)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream2.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream2 ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream2) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream2 ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream2.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto2.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto2.sha256(clientKey);
    const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_2, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  }
  function parseAttributePairs(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value6 = attrValue.substring(2);
      return [name, value6];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_2, i) => a[i] ^ b[i]));
  }
  var crypto2 = require_utils2();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
  }
  var types = require_pg_types();
  TypeOverrides.prototype.getOverrides = function(format7) {
    switch (format7) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format7, parseFn) {
    if (typeof format7 === "function") {
      parseFn = format7;
      format7 = "text";
    }
    this.getOverrides(format7)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format7) {
    format7 = format7 || "text";
    return this.getOverrides(format7)[oid] || this._types.getTypeParser(oid, format7);
  };
  module.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse4(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config3 = str.split(" ");
      return { host: config3[0], database: config3[1] };
    }
    const config2 = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err2) {
      err2.input && (err2.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config2[entry[0]] = entry[1];
    }
    config2.user = config2.user || decodeURIComponent(result.username);
    config2.password = config2.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config2.host = decodeURI(result.pathname);
      config2.database = result.searchParams.get("db");
      config2.client_encoding = result.searchParams.get("encoding");
      return config2;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config2.host) {
      config2.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config2.port) {
      config2.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config2.database = pathname ? decodeURI(pathname) : null;
    if (config2.ssl === "true" || config2.ssl === "1") {
      config2.ssl = true;
    }
    if (config2.ssl === "0") {
      config2.ssl = false;
    }
    if (config2.sslcert || config2.sslkey || config2.sslrootcert || config2.sslmode) {
      config2.ssl = {};
    }
    const fs = config2.sslcert || config2.sslkey || config2.sslrootcert ? import.meta.require("fs") : null;
    if (config2.sslcert) {
      config2.ssl.cert = fs.readFileSync(config2.sslcert).toString();
    }
    if (config2.sslkey) {
      config2.ssl.key = fs.readFileSync(config2.sslkey).toString();
    }
    if (config2.sslrootcert) {
      config2.ssl.ca = fs.readFileSync(config2.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config2.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config2.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config2.sslrootcert) {
            config2.ssl.checkServerIdentity = function() {
            };
          } else {
            config2.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config2.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config2.ssl.checkServerIdentity = function() {
          };
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config2.sslmode) {
        case "disable": {
          config2.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config2.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config2;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value6]) => {
      if (value6 !== undefined && value6 !== null) {
        c[key] = value6;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config2) {
    const poolConfig = Object.entries(config2).reduce((c, [key, value6]) => {
      if (key === "ssl") {
        const sslConfig = value6;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value6 !== undefined && value6 !== null) {
        if (key === "port") {
          if (value6 !== "") {
            const v = parseInt(value6, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value6}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value6;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse4(str));
  }
  module.exports = parse4;
  parse4.parse = parse4;
  parse4.toClientConfig = toClientConfig;
  parse4.parseIntoClientConfig = parseIntoClientConfig;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = import.meta.require("dns");
  var defaults = require_defaults();
  var parse4 = require_pg_connection_string().parse;
  var val = function(key, config2, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {
    } else {
      envVar = process.env[envVar];
    }
    return config2[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value6) {
    return "'" + ("" + value6).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add8 = function(params, config2, paramName) {
    const value6 = config2[paramName];
    if (value6 !== undefined && value6 !== null) {
      params.push(paramName + "=" + quoteParamValue(value6));
    }
  };

  class ConnectionParameters {
    constructor(config2) {
      config2 = typeof config2 === "string" ? parse4(config2) : config2 || {};
      if (config2.connectionString) {
        config2 = Object.assign({}, config2, parse4(config2.connectionString));
      }
      this.user = val("user", config2);
      this.database = val("database", config2);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config2), 10);
      this.host = val("host", config2);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config2)
      });
      this.binary = val("binary", config2);
      this.options = val("options", config2);
      this.ssl = typeof config2.ssl === "undefined" ? readSSLConfigFromEnvironment() : config2.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config2);
      this.replication = val("replication", config2);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config2, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config2, false);
      this.statement_timeout = val("statement_timeout", config2, false);
      this.lock_timeout = val("lock_timeout", config2, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config2, false);
      this.query_timeout = val("query_timeout", config2, false);
      if (config2.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config2.connectionTimeoutMillis / 1000);
      }
      if (config2.keepAlive === false) {
        this.keepalives = 0;
      } else if (config2.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config2.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config2.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add8(params, this, "user");
      add8(params, this, "password");
      add8(params, this, "port");
      add8(params, this, "application_name");
      add8(params, this, "fallback_application_name");
      add8(params, this, "connect_timeout");
      add8(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add8(params, ssl, "sslmode");
      add8(params, ssl, "sslca");
      add8(params, ssl, "sslkey");
      add8(params, ssl, "sslcert");
      add8(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err2, address) {
        if (err2)
          return cb(err2, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types2) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types2;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match25;
      if (msg.text) {
        match25 = matchRegexp.exec(msg.text);
      } else {
        match25 = matchRegexp.exec(msg.command);
      }
      if (match25) {
        this.command = match25[1];
        if (match25[3]) {
          this.oid = parseInt(match25[2], 10);
          this.rowCount = parseInt(match25[3], 10);
        } else if (match25[2]) {
          this.rowCount = parseInt(match25[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter } = import.meta.require("events");
  var Result = require_result();
  var utils = require_utils();

  class Query extends EventEmitter {
    constructor(config2, values7, callback) {
      super();
      config2 = utils.normalizeQueryConfig(config2, values7, callback);
      this.text = config2.text;
      this.values = config2.values;
      this.rows = config2.rows;
      this.types = config2.types;
      this.name = config2.name;
      this.queryMode = config2.queryMode;
      this.binary = config2.binary;
      this.portal = config2.portal || "";
      this.callback = config2.callback;
      this._rowMode = config2.rowMode;
      if (process.domain && config2.callback) {
        this.callback = process.domain.bind(config2.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err2) {
        this._canceledDueToError = err2;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err2, connection) {
      if (this._canceledDueToError) {
        err2 = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err2);
      }
      this.emit("error", err2);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err2) {
          process.nextTick(() => {
            throw err2;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous2 = connection.parsedStatements[this.name];
      if (this.text && previous2 && this.text !== previous2) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err2) {
        this.handleError(err2, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {
    }
  }
  module.exports = Query;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length4, name) {
      super(message);
      this.length = length4;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length4, chunk4) {
      this.length = length4;
      this.chunk = chunk4;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length4, name, binary, columnCount) {
      this.length = length4;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format7) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format7;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length4, fieldCount) {
      this.length = length4;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length4, parameterCount) {
      this.length = length4;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length4, parameterName, parameterValue) {
      this.length = length4;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length4, salt) {
      this.length = length4;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length4, processID, secretKey) {
      this.length = length4;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length4, processId, channel, payload) {
      this.length = length4;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length4, status3) {
      this.length = length4;
      this.status = status3;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length4, text) {
      this.length = length4;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length4, fields) {
      this.length = length4;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length4, message) {
      this.length = length4;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size21 = 256) {
      this.size = size21;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size21);
    }
    ensure(size21) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size21) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size21;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string6) {
      if (!string6) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string6);
        this.ensure(len + 1);
        this.buffer.write(string6, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string6 = "") {
      const len = Buffer.byteLength(string6);
      this.ensure(len);
      this.buffer.write(string6, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length4 = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length4, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length4 = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length4).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray2 = [];
  var parse4 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types = query2.types || emptyArray2;
    const len = types.length;
    const buffer3 = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer3.addInt32(types[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values7, valueMapper) {
    for (let i = 0;i < values7.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values7[i], i) : values7[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind6 = (config2 = {}) => {
    const portal = config2.portal || "";
    const statement = config2.statement || "";
    const binary = config2.binary || false;
    const values7 = config2.values || emptyArray2;
    const len = values7.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values7, config2.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute2 = (config2) => {
    if (!config2 || !config2.portal && !config2.rows) {
      return emptyExecute;
    }
    const portal = config2.portal || "";
    const rows = config2.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer3 = Buffer.allocUnsafe(16);
    buffer3.writeInt32BE(16, 0);
    buffer3.writeInt16BE(1234, 4);
    buffer3.writeInt16BE(5678, 6);
    buffer3.writeInt32BE(processID, 8);
    buffer3.writeInt32BE(secretKey, 12);
    return buffer3;
  };
  var cstringMessage = (code, string6) => {
    const stringLen = Buffer.byteLength(string6);
    const len = 4 + stringLen + 1;
    const buffer3 = Buffer.allocUnsafe(1 + len);
    buffer3[0] = code;
    buffer3.writeInt32BE(len, 1);
    buffer3.write(string6, 5, "utf-8");
    buffer3[len] = 0;
    return buffer3;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close2 = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk4) => {
    return writer.add(chunk4).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse4,
    bind: bind6,
    execute: execute2,
    describe,
    close: close2,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer3) {
      this.offset = offset;
      this.buffer = buffer3;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length4) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length4);
      this.offset += length4;
      return result;
    }
    cstring() {
      const start5 = this.offset;
      let end6 = start5;
      while (this.buffer[end6++] !== 0) {
      }
      this.offset = end6;
      return this.buffer.toString(this.encoding, start5, end6 - 1);
    }
    bytes(length4) {
      const result = this.buffer.slice(this.offset, this.offset + length4);
      this.offset += length4;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer3, callback) {
      this.mergeBuffer(buffer3);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length4 = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length4;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length4, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer3) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer3.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer3.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer3;
        this.bufferOffset = 0;
        this.bufferLength = buffer3.byteLength;
      }
    }
    handlePacket(offset, code, length4, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length4, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length4, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length4, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length4, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length4, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length4, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length4, bytes);
        case 69:
          return this.parseErrorMessage(offset, length4, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length4, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length4, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length4, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length4, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length4, bytes);
        case 100:
          return this.parseCopyData(offset, length4, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length4, "error");
      }
    }
    parseReadyForQueryMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status3 = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length4, status3);
    }
    parseCommandCompleteMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length4, text);
    }
    parseCopyData(offset, length4, bytes) {
      const chunk4 = bytes.slice(offset, offset + (length4 - 4));
      return new messages_1.CopyDataMessage(length4, chunk4);
    }
    parseCopyInMessage(offset, length4, bytes) {
      return this.parseCopyMessage(offset, length4, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length4, bytes) {
      return this.parseCopyMessage(offset, length4, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length4, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length4, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length4, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length4, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length4, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length4, fields);
    }
    parseParameterStatusMessage(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value6 = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length4, name, value6);
    }
    parseBackendKeyData(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length4, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length4, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length: length4
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length4, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length4 - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length4 - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length4, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\0") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length4, messageValue) : new messages_1.DatabaseError(messageValue, length4, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist2 = __commonJS((exports) => {
  function parse4(stream2, callback) {
    const parser = new parser_1.Parser;
    stream2.on("data", (buffer3) => parser.parse(buffer3, callback));
    return new Promise((resolve) => stream2.on("end", () => resolve()));
  }
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  exports.parse = parse4;
});

// node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = import.meta.require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = import.meta.require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var { parse: parse4, serialize } = require_dist2();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize.flush();
  var syncBuffer = serialize.sync();
  var endBuffer = serialize.end();

  class Connection extends EventEmitter {
    constructor(config2) {
      super();
      config2 = config2 || {};
      this.stream = config2.stream || getStream(config2.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config2);
      }
      this._keepAlive = config2.keepAlive;
      this._keepAliveInitialDelayMillis = config2.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config2.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port2, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port2, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error2) {
        if (self2._ending && (error2.code === "ECONNRESET" || error2.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error2);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer3) {
        const responseCode = buffer3.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = import.meta.require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err2) {
          return self2.emit("error", err2);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream2) {
      parse4(stream2, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize.requestSsl());
    }
    startup(config2) {
      this.stream.write(serialize.startup(config2));
    }
    cancel(processID, secretKey) {
      this._send(serialize.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer3) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer3);
    }
    query(text) {
      this._send(serialize.query(text));
    }
    parse(query) {
      this._send(serialize.parse(query));
    }
    bind(config2) {
      this._send(serialize.bind(config2));
    }
    execute(config2) {
      this._send(serialize.execute(config2));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize.close(msg));
    }
    describe(msg) {
      this._send(serialize.describe(msg));
    }
    sendCopyFromChunk(chunk4) {
      this._send(serialize.copyData(chunk4));
    }
    endCopyFrom() {
      this._send(serialize.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  function transform7(chunk4, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk4);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk4);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error2) {
        return cb(error2);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error2) {
        return cb(error2);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop(incoming) {
    return incoming;
  }
  function split4(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform7;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream2 = new Transform2(options);
    stream2[kLast] = "";
    stream2[kDecoder] = new StringDecoder("utf8");
    stream2.matcher = matcher;
    stream2.mapper = mapper;
    stream2.maxLength = options.maxLength;
    stream2.skipOverflow = options.skipOverflow || false;
    stream2.overflow = false;
    stream2._destroy = function(err2, cb) {
      this._writableState.errorEmitted = false;
      cb(err2);
    };
    return stream2;
  }
  var { Transform: Transform2 } = import.meta.require("stream");
  var { StringDecoder } = import.meta.require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  module.exports = split4;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  function warn2() {
    var isWritable = warnStream instanceof Stream2 && warnStream.writable === true;
    if (isWritable) {
      var args2 = Array.prototype.slice.call(arguments).concat("\n");
      warnStream.write(util.format.apply(util, args2));
    }
  }
  var path = import.meta.require("path");
  var Stream2 = import.meta.require("stream").Stream;
  var split4 = require_split2();
  var util = import.meta.require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream2) {
    var old = warnStream;
    warnStream = stream2;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env3 = rawEnv || process.env;
    var file = env3.PGPASSFILE || (isWin ? path.join(env3.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env3.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn2('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn2('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream2, cb) {
    var pass;
    var lineStream = stream2.pipe(split4());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd2 = function() {
      stream2.destroy();
      cb(pass);
    };
    var onErr = function(err2) {
      stream2.destroy();
      warn2("WARNING: error on reading file: %s", err2);
      cb(undefined);
    };
    stream2.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd2).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value6 = entry[fieldNames[idx]] || "";
      var res = rule(value6);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var fs = import.meta.require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err2, stat2) {
      if (err2 || !helper.usePgPass(stat2, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var utils = require_utils();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils2();

  class Client extends EventEmitter {
    constructor(config2) {
      super();
      this.connectionParameters = new ConnectionParameters(config2);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config2 || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err2) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err2, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err2 = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err2);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error2 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error2);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error2);
            } else {
              this._handleErrorEvent(error2);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error2);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject2) => {
        this._connect((error2) => {
          if (error2) {
            reject2(error2);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err2) => {
          con.emit("error", err2);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err2) {
          this.connection.emit("error", err2);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err2) {
        this.connection.emit("error", err2);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err2) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err2);
      }
      this.emit("error", err2);
    }
    _handleErrorEvent(err2) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err2);
      }
      this._queryable = false;
      this._errorAllQueries(err2);
      this.emit("error", err2);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error2 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error2);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format7, parseFn) {
      return this._types.setTypeParser(oid, format7, parseFn);
    }
    getTypeParser(oid, format7) {
      return this._types.getTypeParser(oid, format7);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config2, values7, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config2 === null || config2 === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config2.submit === "function") {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        result = query = config2;
        if (typeof values7 === "function") {
          query.callback = query.callback || values7;
        }
      } else {
        readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config2, values7, callback);
        if (!query.callback) {
          result = new this._Promise((resolve, reject2) => {
            query.callback = (err2, res) => err2 ? reject2(err2) : resolve(res);
          }).catch((err2) => {
            Error.captureStackTrace(err2);
            throw err2;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error2 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error2, this.connection);
          });
          queryCallback(error2);
          query.callback = () => {
          };
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err2, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err2, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise3, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err2, client) {
      err2 ? rej(err2) : res(client);
    };
    const result = new Promise3(function(resolve, reject2) {
      res = resolve;
      rej = reject2;
    }).catch((err2) => {
      Error.captureStackTrace(err2);
      throw err2;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err2) {
      err2.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err2);
      });
      pool._remove(client);
      pool.emit("error", err2, client);
    };
  }
  var EventEmitter = import.meta.require("events").EventEmitter;
  var NOOP = function() {
  };
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }

  class Pool extends EventEmitter {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {
      };
      this.Client = this.options.Client || Client || require_lib2().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context9 = this;
      client.end(() => {
        context9.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err2 = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err2, res, done14) => {
          clearTimeout(tid);
          response.callback(err2, res, done14);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err2) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err2) {
          this.log("client failed to connect", err2);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err2 = new Error("Connection terminated due to connection timeout", { cause: err2 });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err2, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err3, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err2) => {
            if (err2) {
              client.release(err2);
              return pendingItem.callback(err2, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err2) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err2);
      };
    }
    _release(client, idleListener, err2) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err2, client);
      if (err2 || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values7, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values7 === "function") {
        cb = values7;
        values7 = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err2, client) => {
        if (err2) {
          return cb(err2);
        }
        let clientReleased = false;
        const onError4 = (err3) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err3);
          cb(err3);
        };
        client.once("error", onError4);
        this.log("dispatching query");
        try {
          client.query(text, values7, (err3, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError4);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err3);
            if (err3) {
              return cb(err3);
            }
            return cb(undefined, res);
          });
        } catch (err3) {
          client.release(err3);
          return cb(err3);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err2 = new Error("Called end on pool more than once");
        return cb ? cb(err2) : this.Promise.reject(err2);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util = import.meta.require("util");
  var utils = require_utils();
  var NativeQuery = module.exports = function(config2, values7, callback) {
    EventEmitter.call(this);
    config2 = utils.normalizeQueryConfig(config2, values7, callback);
    this.text = config2.text;
    this.values = config2.values;
    this.name = config2.name;
    this.queryMode = config2.queryMode;
    this.callback = config2.callback;
    this.state = "new";
    this._arrayMode = config2.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util.inherits(NativeQuery, EventEmitter);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err2) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err2[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err2);
    } else {
      this.emit("error", err2);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject2) {
      this._once("end", resolve);
      this._once("error", reject2);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after3 = function(err2, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err2) {
        return self2.handleError(err2);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after3 = process.domain.bind(after3);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values7 = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err2 = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after3(err2);
        }
        return client.native.execute(this.name, values7, after3);
      }
      return client.native.prepare(this.name, this.text, values7.length, function(err2) {
        if (err2)
          return after3(err2);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values7, after3);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err2 = new Error("Query values must be an array");
        return after3(err2);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after3);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after3);
    } else {
      client.native.query(this.text, after3);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error(`Cannot require module "pg-native"`);})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var util = import.meta.require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config2) {
    EventEmitter.call(this);
    config2 = config2 || {};
    this._Promise = config2.Promise || global.Promise;
    this._types = new TypeOverrides(config2.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config2);
    if (config2.nativeConnectionString)
      cp.nativeConnectionString = config2.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util.inherits(Client, EventEmitter);
  Client.prototype._errorAllQueries = function(err2) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err2);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err2, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err2)
        return cb(err2);
      self2.native.connect(conString, function(err3) {
        if (err3) {
          self2.native.end();
          return cb(err3);
        }
        self2._connected = true;
        self2.native.on("error", function(err4) {
          self2._queryable = false;
          self2._errorAllQueries(err4);
          self2.emit("error", err4);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject2) => {
      this._connect((error2) => {
        if (error2) {
          reject2(error2);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config2, values7, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config2 === null || config2 === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config2.submit === "function") {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      result = query = config2;
      if (typeof values7 === "function") {
        config2.callback = values7;
      }
    } else {
      readTimeout = config2.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config2, values7, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject2) => {
          resolveOut = resolve;
          rejectOut = reject2;
        }).catch((err2) => {
          Error.captureStackTrace(err2);
          throw err2;
        });
        query.callback = (err2, res) => err2 ? rejectOut(err2) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error2 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error2, this.connection);
        });
        queryCallback(error2);
        query.callback = () => {
        };
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err2, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err2, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject2) {
        cb = (err2) => err2 ? reject2(err2) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {
      });
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {
  };
  Client.prototype.unref = function() {
  };
  Client.prototype.setTypeParser = function(oid, format7, parseFn) {
    return this._types.setTypeParser(oid, format7, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format7) {
    return this._types.getTypeParser(oid, format7);
  };
});

// node_modules/pg/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist2();
  var { escapeIdentifier, escapeLiteral } = require_utils();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err2) {
          if (err2.code !== "MODULE_NOT_FOUND") {
            throw err2;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/effect/dist/esm/Function.js
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      let ret = arguments[0];
      for (let i = 1;i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var isFunction = (input) => typeof input === "function";
var dual = function(arity, body) {
  if (typeof arity === "function") {
    return function() {
      if (arity(arguments)) {
        return body.apply(this, arguments);
      }
      return (self2) => body(self2, ...arguments);
    };
  }
  switch (arity) {
    case 0:
    case 1:
      throw new RangeError(`Invalid arity ${arity}`);
    case 2:
      return function(a, b) {
        if (arguments.length >= 2) {
          return body(a, b);
        }
        return function(self2) {
          return body(self2, a);
        };
      };
    case 3:
      return function(a, b, c) {
        if (arguments.length >= 3) {
          return body(a, b, c);
        }
        return function(self2) {
          return body(self2, a, b);
        };
      };
    case 4:
      return function(a, b, c, d) {
        if (arguments.length >= 4) {
          return body(a, b, c, d);
        }
        return function(self2) {
          return body(self2, a, b, c);
        };
      };
    case 5:
      return function(a, b, c, d, e) {
        if (arguments.length >= 5) {
          return body(a, b, c, d, e);
        }
        return function(self2) {
          return body(self2, a, b, c, d);
        };
      };
    default:
      return function() {
        if (arguments.length >= arity) {
          return body.apply(this, arguments);
        }
        const args = arguments;
        return function(self2) {
          return body(self2, ...args);
        };
      };
  }
};
var identity = (a) => a;
var constant = (value) => () => value;
var constTrue = /* @__PURE__ */ constant(true);
var constFalse = /* @__PURE__ */ constant(false);
var constNull = /* @__PURE__ */ constant(null);
var constUndefined = /* @__PURE__ */ constant(undefined);
var constVoid = constUndefined;
// node_modules/effect/dist/esm/Equivalence.js
var make = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
var isStrictEquivalent = (x, y) => x === y;
var strict = () => isStrictEquivalent;
var number = /* @__PURE__ */ strict();
var mapInput = /* @__PURE__ */ dual(2, (self2, f) => make((x, y) => self2(f(x), f(y))));
var Date2 = /* @__PURE__ */ mapInput(number, (date) => date.getTime());
var array = (item) => make((self2, that) => {
  if (self2.length !== that.length) {
    return false;
  }
  for (let i = 0;i < self2.length; i++) {
    const isEq = item(self2[i], that[i]);
    if (!isEq) {
      return false;
    }
  }
  return true;
});

// node_modules/effect/dist/esm/internal/doNotation.js
var let_ = (map) => dual(3, (self2, name, f) => map(self2, (a) => ({
  ...a,
  [name]: f(a)
})));
var bindTo = (map) => dual(2, (self2, name) => map(self2, (a) => ({
  [name]: a
})));
var bind = (map, flatMap) => dual(3, (self2, name, f) => flatMap(self2, (a) => map(f(a), (b) => ({
  ...a,
  [name]: b
}))));

// node_modules/effect/dist/esm/GlobalValue.js
var globalStoreId = `effect/GlobalValue`;
var globalStore;
var globalValue = (id, compute) => {
  if (!globalStore) {
    globalThis[globalStoreId] ??= new Map;
    globalStore = globalThis[globalStoreId];
  }
  if (!globalStore.has(id)) {
    globalStore.set(id, compute());
  }
  return globalStore.get(id);
};

// node_modules/effect/dist/esm/Predicate.js
var isTruthy = (input) => !!input;
var isSet = (input) => input instanceof Set;
var isMap = (input) => input instanceof Map;
var isString = (input) => typeof input === "string";
var isNumber = (input) => typeof input === "number";
var isBoolean = (input) => typeof input === "boolean";
var isBigInt = (input) => typeof input === "bigint";
var isSymbol = (input) => typeof input === "symbol";
var isFunction2 = isFunction;
var isUndefined = (input) => input === undefined;
var isNotUndefined = (input) => input !== undefined;
var isNotNull = (input) => input !== null;
var isNever = (_) => false;
var isRecordOrArray = (input) => typeof input === "object" && input !== null;
var isObject = (input) => isRecordOrArray(input) || isFunction2(input);
var hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && (property in self2));
var isTagged = /* @__PURE__ */ dual(2, (self2, tag) => hasProperty(self2, "_tag") && self2["_tag"] === tag);
var isNullable = (input) => input === null || input === undefined;
var isNotNullable = (input) => input !== null && input !== undefined;
var isUint8Array = (input) => input instanceof Uint8Array;
var isDate = (input) => input instanceof Date;
var isIterable = (input) => typeof input === "string" || hasProperty(input, Symbol.iterator);
var isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
var isPromiseLike = (input) => hasProperty(input, "then") && isFunction2(input.then);

// node_modules/effect/dist/esm/internal/errors.js
var getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;

// node_modules/effect/dist/esm/Utils.js
function mul64(out, aHi, aLo, bHi, bLo) {
  let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
  let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
  let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
  c0 = c0 << 16 >>> 0;
  lo = lo + c0 >>> 0;
  if (lo >>> 0 < c0 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  c1 = c1 << 16 >>> 0;
  lo = lo + c1 >>> 0;
  if (lo >>> 0 < c1 >>> 0) {
    hi = hi + 1 >>> 0;
  }
  hi = hi + Math.imul(aLo, bHi) >>> 0;
  hi = hi + Math.imul(aHi, bLo) >>> 0;
  out[0] = hi;
  out[1] = lo;
}
function add64(out, aHi, aLo, bHi, bLo) {
  let hi = aHi + bHi >>> 0;
  const lo = aLo + bLo >>> 0;
  if (lo >>> 0 < aLo >>> 0) {
    hi = hi + 1 | 0;
  }
  out[0] = hi;
  out[1] = lo;
}
function yieldWrapGet(self2) {
  if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
    return self2[YieldWrapTypeId]();
  }
  throw new Error(getBugErrorMessage("yieldWrapGet"));
}
class SingleShotGen {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen(this.self);
  }
}
var defaultIncHi = 335903614;
var defaultIncLo = 4150755663;
var MUL_HI = 1481765933 >>> 0;
var MUL_LO = 1284865837 >>> 0;
var BIT_53 = 9007199254740992;
var BIT_27 = 134217728;

class PCGRandom {
  _state;
  constructor(seedHi, seedLo, incHi, incLo) {
    if (isNullable(seedLo) && isNullable(seedHi)) {
      seedLo = Math.random() * 4294967295 >>> 0;
      seedHi = 0;
    } else if (isNullable(seedLo)) {
      seedLo = seedHi;
      seedHi = 0;
    }
    if (isNullable(incLo) && isNullable(incHi)) {
      incLo = this._state ? this._state[3] : defaultIncLo;
      incHi = this._state ? this._state[2] : defaultIncHi;
    } else if (isNullable(incLo)) {
      incLo = incHi;
      incHi = 0;
    }
    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
    this._next();
    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
    this._next();
    return this;
  }
  getState() {
    return [this._state[0], this._state[1], this._state[2], this._state[3]];
  }
  setState(state) {
    this._state[0] = state[0];
    this._state[1] = state[1];
    this._state[2] = state[2];
    this._state[3] = state[3] | 1;
  }
  integer(max) {
    return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max;
  }
  number() {
    const hi = (this._next() & 67108863) * 1;
    const lo = (this._next() & 134217727) * 1;
    return (hi * BIT_27 + lo) / BIT_53;
  }
  _next() {
    const oldHi = this._state[0] >>> 0;
    const oldLo = this._state[1] >>> 0;
    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
    let xsHi = oldHi >>> 18;
    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
    xsHi = (xsHi ^ oldHi) >>> 0;
    xsLo = (xsLo ^ oldLo) >>> 0;
    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
    const rot = oldHi >>> 27;
    const rot2 = (-rot >>> 0 & 31) >>> 0;
    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
  }
}
var YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");

class YieldWrap {
  #value;
  constructor(value) {
    this.#value = value;
  }
  [YieldWrapTypeId]() {
    return this.#value;
  }
}
var structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
  enabled: false,
  tester: undefined
}));
var standard = {
  effect_internal_function: (body) => {
    return body();
  }
};
var forced = {
  effect_internal_function: (body) => {
    try {
      return body();
    } finally {
    }
  }
};
var isNotOptimizedAway = /* @__PURE__ */ standard.effect_internal_function(() => new Error().stack)?.includes("effect_internal_function") === true;
var internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
var genConstructor = function* () {
}.constructor;
var isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;

// node_modules/effect/dist/esm/Hash.js
var randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => new WeakMap);
var symbol = /* @__PURE__ */ Symbol.for("effect/Hash");
var hash = (self2) => {
  if (structuralRegionState.enabled === true) {
    return 0;
  }
  switch (typeof self2) {
    case "number":
      return number2(self2);
    case "bigint":
      return string(self2.toString(10));
    case "boolean":
      return string(String(self2));
    case "symbol":
      return string(String(self2));
    case "string":
      return string(self2);
    case "undefined":
      return string("undefined");
    case "function":
    case "object": {
      if (self2 === null) {
        return string("null");
      } else if (self2 instanceof Date) {
        return hash(self2.toISOString());
      } else if (self2 instanceof URL) {
        return hash(self2.href);
      } else if (isHash(self2)) {
        return self2[symbol]();
      } else {
        return random(self2);
      }
    }
    default:
      throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  }
};
var random = (self2) => {
  if (!randomHashCache.has(self2)) {
    randomHashCache.set(self2, number2(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
  }
  return randomHashCache.get(self2);
};
var combine = (b) => (self2) => self2 * 53 ^ b;
var optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
var isHash = (u) => hasProperty(u, symbol);
var number2 = (n) => {
  if (n !== n || n === Infinity) {
    return 0;
  }
  let h = n | 0;
  if (h !== n) {
    h ^= n * 4294967295;
  }
  while (n > 4294967295) {
    h ^= n /= 4294967295;
  }
  return optimize(h);
};
var string = (str) => {
  let h = 5381, i = str.length;
  while (i) {
    h = h * 33 ^ str.charCodeAt(--i);
  }
  return optimize(h);
};
var structureKeys = (o, keys) => {
  let h = 12289;
  for (let i = 0;i < keys.length; i++) {
    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));
  }
  return optimize(h);
};
var structure = (o) => structureKeys(o, Object.keys(o));
var array2 = (arr) => {
  let h = 6151;
  for (let i = 0;i < arr.length; i++) {
    h = pipe(h, combine(hash(arr[i])));
  }
  return optimize(h);
};
var cached = function() {
  if (arguments.length === 1) {
    const self3 = arguments[0];
    return function(hash3) {
      Object.defineProperty(self3, symbol, {
        value() {
          return hash3;
        },
        enumerable: false
      });
      return hash3;
    };
  }
  const self2 = arguments[0];
  const hash2 = arguments[1];
  Object.defineProperty(self2, symbol, {
    value() {
      return hash2;
    },
    enumerable: false
  });
  return hash2;
};

// node_modules/effect/dist/esm/Equal.js
function equals() {
  if (arguments.length === 1) {
    return (self2) => compareBoth(self2, arguments[0]);
  }
  return compareBoth(arguments[0], arguments[1]);
}
function compareBoth(self2, that) {
  if (self2 === that) {
    return true;
  }
  const selfType = typeof self2;
  if (selfType !== typeof that) {
    return false;
  }
  if (selfType === "object" || selfType === "function") {
    if (self2 !== null && that !== null) {
      if (isEqual(self2) && isEqual(that)) {
        if (hash(self2) === hash(that) && self2[symbol2](that)) {
          return true;
        } else {
          return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
        }
      } else if (self2 instanceof Date && that instanceof Date) {
        return self2.toISOString() === that.toISOString();
      } else if (self2 instanceof URL && that instanceof URL) {
        return self2.href === that.href;
      }
    }
    if (structuralRegionState.enabled) {
      if (Array.isArray(self2) && Array.isArray(that)) {
        return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
      }
      if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
        const keysSelf = Object.keys(self2);
        const keysThat = Object.keys(that);
        if (keysSelf.length === keysThat.length) {
          for (const key of keysSelf) {
            if (!((key in that) && compareBoth(self2[key], that[key]))) {
              return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
            }
          }
          return true;
        }
      }
      return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
    }
  }
  return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
}
var symbol2 = /* @__PURE__ */ Symbol.for("effect/Equal");
var isEqual = (u) => hasProperty(u, symbol2);
var equivalence = () => equals;

// node_modules/effect/dist/esm/Inspectable.js
var NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
var toJSON = (x) => {
  try {
    if (hasProperty(x, "toJSON") && isFunction2(x["toJSON"]) && x["toJSON"].length === 0) {
      return x.toJSON();
    } else if (Array.isArray(x)) {
      return x.map(toJSON);
    }
  } catch {
    return {};
  }
  return redact(x);
};
var format = (x) => JSON.stringify(x, null, 2);
var BaseProto = {
  toJSON() {
    return toJSON(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var toStringUnknown = (u, whitespace = 2) => {
  if (typeof u === "string") {
    return u;
  }
  try {
    return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
  } catch {
    return String(u);
  }
};
var stringifyCircular = (obj, whitespace) => {
  let cache = [];
  const retVal = JSON.stringify(obj, (_key, value) => typeof value === "object" && value !== null ? cache.includes(value) ? undefined : cache.push(value) && (redactableState.fiberRefs !== undefined && isRedactable(value) ? value[symbolRedactable](redactableState.fiberRefs) : value) : value, whitespace);
  cache = undefined;
  return retVal;
};
var symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
var isRedactable = (u) => typeof u === "object" && u !== null && (symbolRedactable in u);
var redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
  fiberRefs: undefined
}));
var withRedactableContext = (context, f) => {
  const prev = redactableState.fiberRefs;
  redactableState.fiberRefs = context;
  try {
    return f();
  } finally {
    redactableState.fiberRefs = prev;
  }
};
var redact = (u) => {
  if (isRedactable(u) && redactableState.fiberRefs !== undefined) {
    return u[symbolRedactable](redactableState.fiberRefs);
  }
  return u;
};

// node_modules/effect/dist/esm/Pipeable.js
var pipeArguments = (self2, args) => {
  switch (args.length) {
    case 0:
      return self2;
    case 1:
      return args[0](self2);
    case 2:
      return args[1](args[0](self2));
    case 3:
      return args[2](args[1](args[0](self2)));
    case 4:
      return args[3](args[2](args[1](args[0](self2))));
    case 5:
      return args[4](args[3](args[2](args[1](args[0](self2)))));
    case 6:
      return args[5](args[4](args[3](args[2](args[1](args[0](self2))))));
    case 7:
      return args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))));
    case 8:
      return args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2))))))));
    case 9:
      return args[8](args[7](args[6](args[5](args[4](args[3](args[2](args[1](args[0](self2)))))))));
    default: {
      let ret = self2;
      for (let i = 0, len = args.length;i < len; i++) {
        ret = args[i](ret);
      }
      return ret;
    }
  }
};

// node_modules/effect/dist/esm/internal/opCodes/effect.js
var OP_ASYNC = "Async";
var OP_COMMIT = "Commit";
var OP_FAILURE = "Failure";
var OP_ON_FAILURE = "OnFailure";
var OP_ON_SUCCESS = "OnSuccess";
var OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
var OP_SUCCESS = "Success";
var OP_SYNC = "Sync";
var OP_TAG = "Tag";
var OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
var OP_WHILE = "While";
var OP_ITERATOR = "Iterator";
var OP_WITH_RUNTIME = "WithRuntime";
var OP_YIELD = "Yield";
var OP_REVERT_FLAGS = "RevertFlags";

// node_modules/effect/dist/esm/internal/version.js
var moduleVersion = "3.17.14";
var getCurrentVersion = () => moduleVersion;

// node_modules/effect/dist/esm/internal/effectable.js
var EffectTypeId = /* @__PURE__ */ Symbol.for("effect/Effect");
var StreamTypeId = /* @__PURE__ */ Symbol.for("effect/Stream");
var SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
var ChannelTypeId = /* @__PURE__ */ Symbol.for("effect/Channel");
var effectVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _,
  _V: /* @__PURE__ */ getCurrentVersion()
};
var sinkVariance = {
  _A: (_) => _,
  _In: (_) => _,
  _L: (_) => _,
  _E: (_) => _,
  _R: (_) => _
};
var channelVariance = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var EffectPrototype = {
  [EffectTypeId]: effectVariance,
  [StreamTypeId]: effectVariance,
  [SinkTypeId]: sinkVariance,
  [ChannelTypeId]: channelVariance,
  [symbol2](that) {
    return this === that;
  },
  [symbol]() {
    return cached(this, random(this));
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var StructuralPrototype = {
  [symbol]() {
    return cached(this, structure(this));
  },
  [symbol2](that) {
    const selfKeys = Object.keys(this);
    const thatKeys = Object.keys(that);
    if (selfKeys.length !== thatKeys.length) {
      return false;
    }
    for (const key of selfKeys) {
      if (!((key in that) && equals(this[key], that[key]))) {
        return false;
      }
    }
    return true;
  }
};
var CommitPrototype = {
  ...EffectPrototype,
  _op: OP_COMMIT
};
var StructuralCommitPrototype = {
  ...CommitPrototype,
  ...StructuralPrototype
};
var Base = /* @__PURE__ */ function() {
  function Base2() {
  }
  Base2.prototype = CommitPrototype;
  return Base2;
}();

// node_modules/effect/dist/esm/internal/option.js
var TypeId = /* @__PURE__ */ Symbol.for("effect/Option");
var CommonProto = {
  ...EffectPrototype,
  [TypeId]: {
    _A: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "Some",
  _op: "Some",
  [symbol2](that) {
    return isOption(that) && isSome(that) && equals(this.value, that.value);
  },
  [symbol]() {
    return cached(this, combine(hash(this._tag))(hash(this.value)));
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag,
      value: toJSON(this.value)
    };
  }
});
var NoneHash = /* @__PURE__ */ hash("None");
var NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
  _tag: "None",
  _op: "None",
  [symbol2](that) {
    return isOption(that) && isNone(that);
  },
  [symbol]() {
    return NoneHash;
  },
  toJSON() {
    return {
      _id: "Option",
      _tag: this._tag
    };
  }
});
var isOption = (input) => hasProperty(input, TypeId);
var isNone = (fa) => fa._tag === "None";
var isSome = (fa) => fa._tag === "Some";
var none = /* @__PURE__ */ Object.create(NoneProto);
var some = (value) => {
  const a = Object.create(SomeProto);
  a.value = value;
  return a;
};

// node_modules/effect/dist/esm/internal/either.js
var TypeId2 = /* @__PURE__ */ Symbol.for("effect/Either");
var CommonProto2 = {
  ...EffectPrototype,
  [TypeId2]: {
    _R: (_) => _
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  toString() {
    return format(this.toJSON());
  }
};
var RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Right",
  _op: "Right",
  [symbol2](that) {
    return isEither(that) && isRight(that) && equals(this.right, that.right);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.right));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      right: toJSON(this.right)
    };
  }
});
var LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto2), {
  _tag: "Left",
  _op: "Left",
  [symbol2](that) {
    return isEither(that) && isLeft(that) && equals(this.left, that.left);
  },
  [symbol]() {
    return combine(hash(this._tag))(hash(this.left));
  },
  toJSON() {
    return {
      _id: "Either",
      _tag: this._tag,
      left: toJSON(this.left)
    };
  }
});
var isEither = (input) => hasProperty(input, TypeId2);
var isLeft = (ma) => ma._tag === "Left";
var isRight = (ma) => ma._tag === "Right";
var left = (left2) => {
  const a = Object.create(LeftProto);
  a.left = left2;
  return a;
};
var right = (right2) => {
  const a = Object.create(RightProto);
  a.right = right2;
  return a;
};
var getRight = (self2) => isLeft(self2) ? none : some(self2.right);
var fromOption = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? left(onNone()) : right(self2.value));

// node_modules/effect/dist/esm/Either.js
var right2 = right;
var left2 = left;
var fromOption2 = fromOption;
var try_ = (evaluate) => {
  if (isFunction2(evaluate)) {
    try {
      return right2(evaluate());
    } catch (e) {
      return left2(e);
    }
  } else {
    try {
      return right2(evaluate.try());
    } catch (e) {
      return left2(evaluate.catch(e));
    }
  }
};
var isEither2 = isEither;
var isLeft2 = isLeft;
var isRight2 = isRight;
var getEquivalence = ({
  left: left3,
  right: right3
}) => make((x, y) => isLeft2(x) ? isLeft2(y) && left3(x.left, y.left) : isRight2(y) && right3(x.right, y.right));
var mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft2(self2) ? left2(f(self2.left)) : right2(self2.right));
var map = /* @__PURE__ */ dual(2, (self2, f) => isRight2(self2) ? right2(f(self2.right)) : left2(self2.left));
var match = /* @__PURE__ */ dual(2, (self2, {
  onLeft,
  onRight
}) => isLeft2(self2) ? onLeft(self2.left) : onRight(self2.right));
var merge = /* @__PURE__ */ match({
  onLeft: identity,
  onRight: identity
});
var getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
  if (isRight2(self2)) {
    return self2.right;
  }
  throw onLeft(self2.left);
});
var getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));

// node_modules/effect/dist/esm/internal/array.js
var isNonEmptyArray = (self2) => self2.length > 0;

// node_modules/effect/dist/esm/Order.js
var make2 = (compare) => (self2, that) => self2 === that ? 0 : compare(self2, that);
var number3 = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var bigint = /* @__PURE__ */ make2((self2, that) => self2 < that ? -1 : 1);
var mapInput2 = /* @__PURE__ */ dual(2, (self2, f) => make2((b1, b2) => self2(f(b1), f(b2))));
var lessThan = (O) => dual(2, (self2, that) => O(self2, that) === -1);
var greaterThan = (O) => dual(2, (self2, that) => O(self2, that) === 1);
var lessThanOrEqualTo = (O) => dual(2, (self2, that) => O(self2, that) !== 1);
var greaterThanOrEqualTo = (O) => dual(2, (self2, that) => O(self2, that) !== -1);
var min = (O) => dual(2, (self2, that) => self2 === that || O(self2, that) < 1 ? self2 : that);
var max = (O) => dual(2, (self2, that) => self2 === that || O(self2, that) > -1 ? self2 : that);
var clamp = (O) => dual(2, (self2, options) => min(O)(options.maximum, max(O)(options.minimum, self2)));
var between = (O) => dual(2, (self2, options) => !lessThan(O)(self2, options.minimum) && !greaterThan(O)(self2, options.maximum));

// node_modules/effect/dist/esm/Option.js
var none2 = () => none;
var some2 = some;
var isOption2 = isOption;
var isNone2 = isNone;
var isSome2 = isSome;
var match2 = /* @__PURE__ */ dual(2, (self2, {
  onNone,
  onSome
}) => isNone2(self2) ? onNone() : onSome(self2.value));
var getRight2 = getRight;
var getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? onNone() : self2.value);
var orElse = /* @__PURE__ */ dual(2, (self2, that) => isNone2(self2) ? that() : self2);
var orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone2(self2) ? some2(onNone()) : self2);
var fromNullable = (nullableValue) => nullableValue == null ? none2() : some2(nullableValue);
var getOrNull = /* @__PURE__ */ getOrElse(constNull);
var getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
var liftThrowable = (f) => (...a) => {
  try {
    return some2(f(...a));
  } catch {
    return none2();
  }
};
var getOrThrowWith2 = /* @__PURE__ */ dual(2, (self2, onNone) => {
  if (isSome2(self2)) {
    return self2.value;
  }
  throw onNone();
});
var getOrThrow2 = /* @__PURE__ */ getOrThrowWith2(() => new Error("getOrThrow called on a None"));
var map2 = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : some2(f(self2.value)));
var flatMap = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : f(self2.value));
var flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone2(self2) ? none2() : fromNullable(f(self2.value)));
var filterMap = flatMap;
var filter = /* @__PURE__ */ dual(2, (self2, predicate) => filterMap(self2, (b) => predicate(b) ? some(b) : none));
var getEquivalence2 = (isEquivalent) => make((x, y) => isNone2(x) ? isNone2(y) : isNone2(y) ? false : isEquivalent(x.value, y.value));
var containsWith = (isEquivalent) => dual(2, (self2, a) => isNone2(self2) ? false : isEquivalent(self2.value, a));
var _equivalence = /* @__PURE__ */ equivalence();
var contains = /* @__PURE__ */ containsWith(_equivalence);
var exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone2(self2) ? false : refinement(self2.value));
var mergeWith = (f) => (o1, o2) => {
  if (isNone2(o1)) {
    return o2;
  } else if (isNone2(o2)) {
    return o1;
  }
  return some2(f(o1.value, o2.value));
};

// node_modules/effect/dist/esm/Tuple.js
var make3 = (...elements) => elements;

// node_modules/effect/dist/esm/Iterable.js
var unsafeHead = (self2) => {
  const iterator = self2[Symbol.iterator]();
  const result = iterator.next();
  if (result.done)
    throw new Error("unsafeHead: empty iterable");
  return result.value;
};
var findFirst = /* @__PURE__ */ dual(2, (self2, f) => {
  let i = 0;
  for (const a of self2) {
    const o = f(a, i);
    if (isBoolean(o)) {
      if (o) {
        return some2(a);
      }
    } else {
      if (isSome2(o)) {
        return o;
      }
    }
    i++;
  }
  return none2();
});
var constEmpty = {
  [Symbol.iterator]() {
    return constEmptyIterator;
  }
};
var constEmptyIterator = {
  next() {
    return {
      done: true,
      value: undefined
    };
  }
};
var empty = () => constEmpty;

// node_modules/effect/dist/esm/Record.js
var fromEntries = Object.fromEntries;

// node_modules/effect/dist/esm/Array.js
var allocate = (n) => new Array(n);
var makeBy = /* @__PURE__ */ dual(2, (n, f) => {
  const max2 = Math.max(1, Math.floor(n));
  const out = new Array(max2);
  for (let i = 0;i < max2; i++) {
    out[i] = f(i);
  }
  return out;
});
var fromIterable = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
var ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
var match3 = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
var matchLeft = /* @__PURE__ */ dual(2, (self2, {
  onEmpty,
  onNonEmpty
}) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty(self2), tailNonEmpty(self2)) : onEmpty());
var prepend = /* @__PURE__ */ dual(2, (self2, head) => [head, ...self2]);
var append = /* @__PURE__ */ dual(2, (self2, last) => [...self2, last]);
var appendAll = /* @__PURE__ */ dual(2, (self2, that) => fromIterable(self2).concat(fromIterable(that)));
var isArray = Array.isArray;
var isEmptyArray = (self2) => self2.length === 0;
var isEmptyReadonlyArray = isEmptyArray;
var isNonEmptyArray2 = isNonEmptyArray;
var isNonEmptyReadonlyArray = isNonEmptyArray;
var isOutOfBounds = (i, as) => i < 0 || i >= as.length;
var clamp2 = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));
var get = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  return isOutOfBounds(i, self2) ? none2() : some2(self2[i]);
});
var unsafeGet = /* @__PURE__ */ dual(2, (self2, index) => {
  const i = Math.floor(index);
  if (isOutOfBounds(i, self2)) {
    throw new Error(`Index ${i} out of bounds`);
  }
  return self2[i];
});
var head = /* @__PURE__ */ get(0);
var headNonEmpty = /* @__PURE__ */ unsafeGet(0);
var last = (self2) => isNonEmptyReadonlyArray(self2) ? some2(lastNonEmpty(self2)) : none2();
var lastNonEmpty = (self2) => self2[self2.length - 1];
var tailNonEmpty = (self2) => self2.slice(1);
var initNonEmpty = (self2) => self2.slice(0, -1);
var spanIndex = (self2, predicate) => {
  let i = 0;
  for (const a of self2) {
    if (!predicate(a, i)) {
      break;
    }
    i++;
  }
  return i;
};
var span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt(self2, spanIndex(self2, predicate)));
var drop = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = fromIterable(self2);
  return input.slice(clamp2(n, input), input.length);
});
var findFirst2 = findFirst;
var reverse = (self2) => Array.from(self2).reverse();
var sort = /* @__PURE__ */ dual(2, (self2, O) => {
  const out = Array.from(self2);
  out.sort(O);
  return out;
});
var zip = /* @__PURE__ */ dual(2, (self2, that) => zipWith(self2, that, make3));
var zipWith = /* @__PURE__ */ dual(3, (self2, that, f) => {
  const as = fromIterable(self2);
  const bs = fromIterable(that);
  if (isNonEmptyReadonlyArray(as) && isNonEmptyReadonlyArray(bs)) {
    const out = [f(headNonEmpty(as), headNonEmpty(bs))];
    const len = Math.min(as.length, bs.length);
    for (let i = 1;i < len; i++) {
      out[i] = f(as[i], bs[i]);
    }
    return out;
  }
  return [];
});
var modifyNonEmptyLast = /* @__PURE__ */ dual(2, (self2, f) => append(initNonEmpty(self2), f(lastNonEmpty(self2))));
var containsWith2 = (isEquivalent) => dual(2, (self2, a) => {
  for (const i of self2) {
    if (isEquivalent(a, i)) {
      return true;
    }
  }
  return false;
});
var _equivalence2 = /* @__PURE__ */ equivalence();
var splitAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const input = Array.from(self2);
  const _n = Math.floor(n);
  if (isNonEmptyReadonlyArray(input)) {
    if (_n >= 1) {
      return splitNonEmptyAt(input, _n);
    }
    return [[], input];
  }
  return [input, []];
});
var splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
  const _n = Math.max(1, Math.floor(n));
  return _n >= self2.length ? [copy(self2), []] : [prepend(self2.slice(1, _n), headNonEmpty(self2)), self2.slice(_n)];
});
var copy = (self2) => self2.slice();
var unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
  const a = fromIterable(self2);
  const b = fromIterable(that);
  if (isNonEmptyReadonlyArray(a)) {
    if (isNonEmptyReadonlyArray(b)) {
      const dedupe = dedupeWith(isEquivalent);
      return dedupe(appendAll(a, b));
    }
    return a;
  }
  return b;
});
var union = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence2));
var intersectionWith = (isEquivalent) => {
  const has = containsWith2(isEquivalent);
  return dual(2, (self2, that) => fromIterable(self2).filter((a) => has(that, a)));
};
var intersection = /* @__PURE__ */ intersectionWith(_equivalence2);
var empty2 = () => [];
var of = (a) => [a];
var map3 = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
var flatMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  if (isEmptyReadonlyArray(self2)) {
    return [];
  }
  const out = [];
  for (let i = 0;i < self2.length; i++) {
    const inner = f(self2[i], i);
    for (let j = 0;j < inner.length; j++) {
      out.push(inner[j]);
    }
  }
  return out;
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMap2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const as = fromIterable(self2);
  const out = [];
  for (let i = 0;i < as.length; i++) {
    const o = f(as[i], i);
    if (isSome2(o)) {
      out.push(o.value);
    }
  }
  return out;
});
var partitionMap = /* @__PURE__ */ dual(2, (self2, f) => {
  const left3 = [];
  const right3 = [];
  const as = fromIterable(self2);
  for (let i = 0;i < as.length; i++) {
    const e = f(as[i], i);
    if (isLeft2(e)) {
      left3.push(e.left);
    } else {
      right3.push(e.right);
    }
  }
  return [left3, right3];
});
var getSomes = /* @__PURE__ */ filterMap2(identity);
var reduce = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduce((b2, a, i) => f(b2, a, i), b));
var reduceRight = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable(self2).reduceRight((b2, a, i) => f(b2, a, i), b));
var every = /* @__PURE__ */ dual(2, (self2, refinement) => self2.every(refinement));
var unfold = (b, f) => {
  const out = [];
  let next = b;
  let o;
  while (isSome2(o = f(next))) {
    const [a, b2] = o.value;
    out.push(a);
    next = b2;
  }
  return out;
};
var getEquivalence3 = array;
var dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
  const input = fromIterable(self2);
  if (isNonEmptyReadonlyArray(input)) {
    const out = [headNonEmpty(input)];
    const rest = tailNonEmpty(input);
    for (const r of rest) {
      if (out.every((a) => !isEquivalent(r, a))) {
        out.push(r);
      }
    }
    return out;
  }
  return [];
});
var dedupe = (self2) => dedupeWith(self2, equivalence());
var join = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable(self2).join(sep));

// node_modules/fast-check/lib/esm/stream/StreamHelpers.js
function nilHelper() {
  return Nil.nil;
}
function* mapHelper(g, f) {
  for (const v of g) {
    yield f(v);
  }
}
function* flatMapHelper(g, f) {
  for (const v of g) {
    yield* f(v);
  }
}
function* filterHelper(g, f) {
  for (const v of g) {
    if (f(v)) {
      yield v;
    }
  }
}
function* takeNHelper(g, n) {
  for (let i = 0;i < n; ++i) {
    const cur = g.next();
    if (cur.done) {
      break;
    }
    yield cur.value;
  }
}
function* takeWhileHelper(g, f) {
  let cur = g.next();
  while (!cur.done && f(cur.value)) {
    yield cur.value;
    cur = g.next();
  }
}
function* joinHelper(g, others) {
  for (let cur = g.next();!cur.done; cur = g.next()) {
    yield cur.value;
  }
  for (const s of others) {
    for (let cur = s.next();!cur.done; cur = s.next()) {
      yield cur.value;
    }
  }
}

class Nil {
  [Symbol.iterator]() {
    return this;
  }
  next(value) {
    return { value, done: true };
  }
}
Nil.nil = new Nil;

// node_modules/fast-check/lib/esm/stream/Stream.js
function stream(g) {
  return new Stream(g);
}
var safeSymbolIterator = Symbol.iterator;

class Stream {
  static nil() {
    return new Stream(nilHelper());
  }
  static of(...elements) {
    return new Stream(elements[safeSymbolIterator]());
  }
  constructor(g) {
    this.g = g;
  }
  next() {
    return this.g.next();
  }
  [Symbol.iterator]() {
    return this.g;
  }
  map(f) {
    return new Stream(mapHelper(this.g, f));
  }
  flatMap(f) {
    return new Stream(flatMapHelper(this.g, f));
  }
  dropWhile(f) {
    let foundEligible = false;
    function* helper(v) {
      if (foundEligible || !f(v)) {
        foundEligible = true;
        yield v;
      }
    }
    return this.flatMap(helper);
  }
  drop(n) {
    if (n <= 0) {
      return this;
    }
    let idx = 0;
    function helper() {
      return idx++ < n;
    }
    return this.dropWhile(helper);
  }
  takeWhile(f) {
    return new Stream(takeWhileHelper(this.g, f));
  }
  take(n) {
    return new Stream(takeNHelper(this.g, n));
  }
  filter(f) {
    return new Stream(filterHelper(this.g, f));
  }
  every(f) {
    for (const v of this.g) {
      if (!f(v)) {
        return false;
      }
    }
    return true;
  }
  has(f) {
    for (const v of this.g) {
      if (f(v)) {
        return [true, v];
      }
    }
    return [false, null];
  }
  join(...others) {
    return new Stream(joinHelper(this.g, others));
  }
  getNthOrLast(nth) {
    let remaining = nth;
    let last2 = null;
    for (const v of this.g) {
      if (remaining-- === 0)
        return v;
      last2 = v;
    }
    return last2;
  }
}

// node_modules/fast-check/lib/esm/check/symbols.js
function hasCloneMethod(instance) {
  return instance !== null && (typeof instance === "object" || typeof instance === "function") && cloneMethod in instance && typeof instance[cloneMethod] === "function";
}
function cloneIfNeeded(instance) {
  return hasCloneMethod(instance) ? instance[cloneMethod]() : instance;
}
var cloneMethod = Symbol.for("fast-check/cloneMethod");

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Value.js
var safeObjectDefineProperty = Object.defineProperty;

class Value {
  constructor(value_, context, customGetValue = undefined) {
    this.value_ = value_;
    this.context = context;
    this.hasToBeCloned = customGetValue !== undefined || hasCloneMethod(value_);
    this.readOnce = false;
    if (this.hasToBeCloned) {
      safeObjectDefineProperty(this, "value", { get: customGetValue !== undefined ? customGetValue : this.getValue });
    } else {
      this.value = value_;
    }
  }
  getValue() {
    if (this.hasToBeCloned) {
      if (!this.readOnce) {
        this.readOnce = true;
        return this.value_;
      }
      return this.value_[cloneMethod]();
    }
    return this.value_;
  }
}

// node_modules/fast-check/lib/esm/check/arbitrary/definition/Arbitrary.js
var safeObjectAssign = Object.assign;

class Arbitrary {
  filter(refinement) {
    return new FilterArbitrary(this, refinement);
  }
  map(mapper, unmapper) {
    return new MapArbitrary(this, mapper, unmapper);
  }
  chain(chainer) {
    return new ChainArbitrary(this, chainer);
  }
  noShrink() {
    return new NoShrinkArbitrary(this);
  }
  noBias() {
    return new NoBiasArbitrary(this);
  }
}

class ChainArbitrary extends Arbitrary {
  constructor(arb, chainer) {
    super();
    this.arb = arb;
    this.chainer = chainer;
  }
  generate(mrng, biasFactor) {
    const clonedMrng = mrng.clone();
    const src = this.arb.generate(mrng, biasFactor);
    return this.valueChainer(src, mrng, clonedMrng, biasFactor);
  }
  canShrinkWithoutContext(value) {
    return false;
  }
  shrink(value, context) {
    if (this.isSafeContext(context)) {
      return (!context.stoppedForOriginal ? this.arb.shrink(context.originalValue, context.originalContext).map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias)) : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
        const newContext = safeObjectAssign(safeObjectAssign({}, context), {
          chainedContext: dst.context,
          stoppedForOriginal: true
        });
        return new Value(dst.value_, newContext);
      }));
    }
    return Stream.nil();
  }
  valueChainer(v, generateMrng, clonedMrng, biasFactor) {
    const chainedArbitrary = this.chainer(v.value_);
    const dst = chainedArbitrary.generate(generateMrng, biasFactor);
    const context = {
      originalBias: biasFactor,
      originalValue: v.value_,
      originalContext: v.context,
      stoppedForOriginal: false,
      chainedArbitrary,
      chainedContext: dst.context,
      clonedMrng
    };
    return new Value(dst.value_, context);
  }
  isSafeContext(context) {
    return context != null && typeof context === "object" && "originalBias" in context && "originalValue" in context && "originalContext" in context && "stoppedForOriginal" in context && "chainedArbitrary" in context && "chainedContext" in context && "clonedMrng" in context;
  }
}

class MapArbitrary extends Arbitrary {
  constructor(arb, mapper, unmapper) {
    super();
    this.arb = arb;
    this.mapper = mapper;
    this.unmapper = unmapper;
    this.bindValueMapper = (v) => this.valueMapper(v);
  }
  generate(mrng, biasFactor) {
    const g = this.arb.generate(mrng, biasFactor);
    return this.valueMapper(g);
  }
  canShrinkWithoutContext(value) {
    if (this.unmapper !== undefined) {
      try {
        const unmapped = this.unmapper(value);
        return this.arb.canShrinkWithoutContext(unmapped);
      } catch (_err) {
        return false;
      }
    }
    return false;
  }
  shrink(value, context) {
    if (this.isSafeContext(context)) {
      return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
    }
    if (this.unmapper !== undefined) {
      const unmapped = this.unmapper(value);
      return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
    }
    return Stream.nil();
  }
  mapperWithCloneIfNeeded(v) {
    const sourceValue = v.value;
    const mappedValue = this.mapper(sourceValue);
    if (v.hasToBeCloned && (typeof mappedValue === "object" && mappedValue !== null || typeof mappedValue === "function") && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {
      Object.defineProperty(mappedValue, cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
    }
    return [mappedValue, sourceValue];
  }
  valueMapper(v) {
    const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
    const context = { originalValue: sourceValue, originalContext: v.context };
    return new Value(mappedValue, context);
  }
  isSafeContext(context) {
    return context != null && typeof context === "object" && "originalValue" in context && "originalContext" in context;
  }
}

class FilterArbitrary extends Arbitrary {
  constructor(arb, refinement) {
    super();
    this.arb = arb;
    this.refinement = refinement;
    this.bindRefinementOnValue = (v) => this.refinementOnValue(v);
  }
  generate(mrng, biasFactor) {
    while (true) {
      const g = this.arb.generate(mrng, biasFactor);
      if (this.refinementOnValue(g)) {
        return g;
      }
    }
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
  }
  shrink(value, context) {
    return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
  }
  refinementOnValue(v) {
    return this.refinement(v.value);
  }
}

class NoShrinkArbitrary extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, biasFactor) {
    return this.arb.generate(mrng, biasFactor);
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(_value, _context) {
    return Stream.nil();
  }
  noShrink() {
    return this;
  }
}

class NoBiasArbitrary extends Arbitrary {
  constructor(arb) {
    super();
    this.arb = arb;
  }
  generate(mrng, _biasFactor) {
    return this.arb.generate(mrng, undefined);
  }
  canShrinkWithoutContext(value) {
    return this.arb.canShrinkWithoutContext(value);
  }
  shrink(value, context) {
    return this.arb.shrink(value, context);
  }
  noBias() {
    return this;
  }
}

// node_modules/fast-check/lib/esm/utils/apply.js
function safeExtractApply(f) {
  try {
    return f.apply;
  } catch (err) {
    return;
  }
}
function safeApplyHacky(f, instance, args) {
  const ff = f;
  ff[ApplySymbol] = untouchedApply;
  const out = ff[ApplySymbol](instance, args);
  delete ff[ApplySymbol];
  return out;
}
function safeApply(f, instance, args) {
  if (safeExtractApply(f) === untouchedApply) {
    return f.apply(instance, args);
  }
  return safeApplyHacky(f, instance, args);
}
var untouchedApply = Function.prototype.apply;
var ApplySymbol = Symbol("apply");

// node_modules/fast-check/lib/esm/utils/globals.js
function extractIndexOf(instance) {
  try {
    return instance.indexOf;
  } catch (err) {
    return;
  }
}
function extractMap(instance) {
  try {
    return instance.map;
  } catch (err) {
    return;
  }
}
function extractPush(instance) {
  try {
    return instance.push;
  } catch (err) {
    return;
  }
}
function extractSlice(instance) {
  try {
    return instance.slice;
  } catch (err) {
    return;
  }
}
function safeIndexOf(instance, ...args) {
  if (extractIndexOf(instance) === untouchedIndexOf) {
    return instance.indexOf(...args);
  }
  return safeApply(untouchedIndexOf, instance, args);
}
function safeMap(instance, fn) {
  if (extractMap(instance) === untouchedMap) {
    return instance.map(fn);
  }
  return safeApply(untouchedMap, instance, [fn]);
}
function safePush(instance, ...args) {
  if (extractPush(instance) === untouchedPush) {
    return instance.push(...args);
  }
  return safeApply(untouchedPush, instance, args);
}
function safeSlice(instance, ...args) {
  if (extractSlice(instance) === untouchedSlice) {
    return instance.slice(...args);
  }
  return safeApply(untouchedSlice, instance, args);
}
function extractMapSet(instance) {
  try {
    return instance.set;
  } catch (err) {
    return;
  }
}
function extractMapGet(instance) {
  try {
    return instance.get;
  } catch (err) {
    return;
  }
}
function safeMapSet(instance, key, value) {
  if (extractMapSet(instance) === untouchedMapSet) {
    return instance.set(key, value);
  }
  return safeApply(untouchedMapSet, instance, [key, value]);
}
function safeMapGet(instance, key) {
  if (extractMapGet(instance) === untouchedMapGet) {
    return instance.get(key);
  }
  return safeApply(untouchedMapGet, instance, [key]);
}
var untouchedForEach = Array.prototype.forEach;
var untouchedIndexOf = Array.prototype.indexOf;
var untouchedJoin = Array.prototype.join;
var untouchedMap = Array.prototype.map;
var untouchedFilter = Array.prototype.filter;
var untouchedPush = Array.prototype.push;
var untouchedPop = Array.prototype.pop;
var untouchedSplice = Array.prototype.splice;
var untouchedSlice = Array.prototype.slice;
var untouchedSort = Array.prototype.sort;
var untouchedEvery = Array.prototype.every;
var untouchedGetTime = Date.prototype.getTime;
var untouchedToISOString = Date.prototype.toISOString;
var untouchedAdd = Set.prototype.add;
var untouchedHas = Set.prototype.has;
var untouchedSet = WeakMap.prototype.set;
var untouchedGet = WeakMap.prototype.get;
var untouchedMapSet = Map.prototype.set;
var untouchedMapGet = Map.prototype.get;
var untouchedSplit = String.prototype.split;
var untouchedStartsWith = String.prototype.startsWith;
var untouchedEndsWith = String.prototype.endsWith;
var untouchedSubstring = String.prototype.substring;
var untouchedToLowerCase = String.prototype.toLowerCase;
var untouchedToUpperCase = String.prototype.toUpperCase;
var untouchedPadStart = String.prototype.padStart;
var untouchedCharCodeAt = String.prototype.charCodeAt;
var untouchedNormalize = String.prototype.normalize;
var untouchedReplace = String.prototype.replace;
var untouchedNumberToString = Number.prototype.toString;

// node_modules/fast-check/lib/esm/stream/LazyIterableIterator.js
function makeLazy(producer) {
  return new LazyIterableIterator(producer);
}

class LazyIterableIterator {
  constructor(producer) {
    this.producer = producer;
  }
  [Symbol.iterator]() {
    if (this.it === undefined) {
      this.it = this.producer();
    }
    return this.it;
  }
  next() {
    if (this.it === undefined) {
      this.it = this.producer();
    }
    return this.it.next();
  }
}

// node_modules/fast-check/lib/esm/check/runner/configuration/GlobalParameters.js
function readConfigureGlobal() {
  return globalParameters;
}
var globalParameters = {};

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BiasNumericRange.js
function integerLogLike(v) {
  return safeMathFloor(safeMathLog(v) / safeMathLog(2));
}
function biasNumericRange(min2, max2, logLike) {
  if (min2 === max2) {
    return [{ min: min2, max: max2 }];
  }
  if (min2 < 0 && max2 > 0) {
    const logMin = logLike(-min2);
    const logMax = logLike(max2);
    return [
      { min: -logMin, max: logMax },
      { min: max2 - logMax, max: max2 },
      { min: min2, max: min2 + logMin }
    ];
  }
  const logGap = logLike(max2 - min2);
  const arbCloseToMin = { min: min2, max: min2 + logGap };
  const arbCloseToMax = { min: max2 - logGap, max: max2 };
  return min2 < 0 ? [arbCloseToMax, arbCloseToMin] : [arbCloseToMin, arbCloseToMax];
}
var safeMathFloor = Math.floor;
var safeMathLog = Math.log;

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/ShrinkInteger.js
function halvePosInteger(n) {
  return safeMathFloor2(n / 2);
}
function halveNegInteger(n) {
  return safeMathCeil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
  const realGap = current - target;
  function* shrinkDecr() {
    let previous = tryTargetAsap ? undefined : target;
    const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
    for (let toremove = gap;toremove > 0; toremove = halvePosInteger(toremove)) {
      const next = toremove === realGap ? target : current - toremove;
      yield new Value(next, previous);
      previous = next;
    }
  }
  function* shrinkIncr() {
    let previous = tryTargetAsap ? undefined : target;
    const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
    for (let toremove = gap;toremove < 0; toremove = halveNegInteger(toremove)) {
      const next = toremove === realGap ? target : current - toremove;
      yield new Value(next, previous);
      previous = next;
    }
  }
  return realGap > 0 ? stream(shrinkDecr()) : stream(shrinkIncr());
}
var safeMathCeil = Math.ceil;
var safeMathFloor2 = Math.floor;

// node_modules/fast-check/lib/esm/arbitrary/_internals/IntegerArbitrary.js
var safeMathSign = Math.sign;
var safeNumberIsInteger = Number.isInteger;
var safeObjectIs = Object.is;

class IntegerArbitrary extends Arbitrary {
  constructor(min2, max2) {
    super();
    this.min = min2;
    this.max = max2;
  }
  generate(mrng, biasFactor) {
    const range = this.computeGenerateRange(mrng, biasFactor);
    return new Value(mrng.nextInt(range.min, range.max), undefined);
  }
  canShrinkWithoutContext(value) {
    return typeof value === "number" && safeNumberIsInteger(value) && !safeObjectIs(value, -0) && this.min <= value && value <= this.max;
  }
  shrink(current, context) {
    if (!IntegerArbitrary.isValidContext(current, context)) {
      const target = this.defaultTarget();
      return shrinkInteger(current, target, true);
    }
    if (this.isLastChanceTry(current, context)) {
      return Stream.of(new Value(context, undefined));
    }
    return shrinkInteger(current, context, false);
  }
  defaultTarget() {
    if (this.min <= 0 && this.max >= 0) {
      return 0;
    }
    return this.min < 0 ? this.max : this.min;
  }
  computeGenerateRange(mrng, biasFactor) {
    if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
      return { min: this.min, max: this.max };
    }
    const ranges = biasNumericRange(this.min, this.max, integerLogLike);
    if (ranges.length === 1) {
      return ranges[0];
    }
    const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
    return id < 0 ? ranges[0] : ranges[id + 1];
  }
  isLastChanceTry(current, context) {
    if (current > 0)
      return current === context + 1 && current > this.min;
    if (current < 0)
      return current === context - 1 && current < this.max;
    return false;
  }
  static isValidContext(current, context) {
    if (context === undefined) {
      return false;
    }
    if (typeof context !== "number") {
      throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
    }
    if (context !== 0 && safeMathSign(current) !== safeMathSign(context)) {
      throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
    }
    return true;
  }
}

// node_modules/fast-check/lib/esm/arbitrary/integer.js
function buildCompleteIntegerConstraints(constraints) {
  const min2 = constraints.min !== undefined ? constraints.min : -2147483648;
  const max2 = constraints.max !== undefined ? constraints.max : 2147483647;
  return { min: min2, max: max2 };
}
function integer(constraints = {}) {
  const fullConstraints = buildCompleteIntegerConstraints(constraints);
  if (fullConstraints.min > fullConstraints.max) {
    throw new Error("fc.integer maximum value should be equal or greater than the minimum one");
  }
  if (!safeNumberIsInteger2(fullConstraints.min)) {
    throw new Error("fc.integer minimum value should be an integer");
  }
  if (!safeNumberIsInteger2(fullConstraints.max)) {
    throw new Error("fc.integer maximum value should be an integer");
  }
  return new IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}
var safeNumberIsInteger2 = Number.isInteger;

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/DepthContext.js
function getDepthContextFor(contextMeta) {
  if (contextMeta === undefined) {
    return { depth: 0 };
  }
  if (typeof contextMeta !== "string") {
    return contextMeta;
  }
  const cachedContext = safeMapGet(depthContextCache, contextMeta);
  if (cachedContext !== undefined) {
    return cachedContext;
  }
  const context = { depth: 0 };
  safeMapSet(depthContextCache, contextMeta, context);
  return context;
}
var depthContextCache = new Map;

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/NoopSlicedGenerator.js
class NoopSlicedGenerator {
  constructor(arb, mrng, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.biasFactor = biasFactor;
  }
  attemptExact() {
    return;
  }
  next() {
    return this.arb.generate(this.mrng, this.biasFactor);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/implementations/SlicedBasedGenerator.js
var safeMathMin = Math.min;
var safeMathMax = Math.max;

class SlicedBasedGenerator {
  constructor(arb, mrng, slices, biasFactor) {
    this.arb = arb;
    this.mrng = mrng;
    this.slices = slices;
    this.biasFactor = biasFactor;
    this.activeSliceIndex = 0;
    this.nextIndexInSlice = 0;
    this.lastIndexInSlice = -1;
  }
  attemptExact(targetLength) {
    if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
      const eligibleIndices = [];
      for (let index = 0;index !== this.slices.length; ++index) {
        const slice = this.slices[index];
        if (slice.length === targetLength) {
          safePush(eligibleIndices, index);
        }
      }
      if (eligibleIndices.length === 0) {
        return;
      }
      this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
      this.nextIndexInSlice = 0;
      this.lastIndexInSlice = targetLength - 1;
    }
  }
  next() {
    if (this.nextIndexInSlice <= this.lastIndexInSlice) {
      return new Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);
    }
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      return this.arb.generate(this.mrng, this.biasFactor);
    }
    this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
    const slice = this.slices[this.activeSliceIndex];
    if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
      this.nextIndexInSlice = 1;
      this.lastIndexInSlice = slice.length - 1;
      return new Value(slice[0], undefined);
    }
    const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
    const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
    this.nextIndexInSlice = safeMathMin(rangeBoundaryA, rangeBoundaryB);
    this.lastIndexInSlice = safeMathMax(rangeBoundaryA, rangeBoundaryB);
    return new Value(slice[this.nextIndexInSlice++], undefined);
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/BuildSlicedGenerator.js
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
  if (biasFactor === undefined || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
    return new NoopSlicedGenerator(arb, mrng, biasFactor);
  }
  return new SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/ArrayArbitrary.js
function biasedMaxLength(minLength, maxLength) {
  if (minLength === maxLength) {
    return minLength;
  }
  return minLength + safeMathFloor3(safeMathLog2(maxLength - minLength) / safeMathLog2(2));
}
var safeMathFloor3 = Math.floor;
var safeMathLog2 = Math.log;
var safeMathMax2 = Math.max;
var safeArrayIsArray = Array.isArray;

class ArrayArbitrary extends Arbitrary {
  constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {
    super();
    this.arb = arb;
    this.minLength = minLength;
    this.maxGeneratedLength = maxGeneratedLength;
    this.maxLength = maxLength;
    this.setBuilder = setBuilder;
    this.customSlices = customSlices;
    this.lengthArb = integer({ min: minLength, max: maxGeneratedLength });
    this.depthContext = getDepthContextFor(depthIdentifier);
  }
  preFilter(tab) {
    if (this.setBuilder === undefined) {
      return tab;
    }
    const s = this.setBuilder();
    for (let index = 0;index !== tab.length; ++index) {
      s.tryAdd(tab[index]);
    }
    return s.getData();
  }
  static makeItCloneable(vs, shrinkables) {
    vs[cloneMethod] = () => {
      const cloned = [];
      for (let idx = 0;idx !== shrinkables.length; ++idx) {
        safePush(cloned, shrinkables[idx].value);
      }
      this.makeItCloneable(cloned, shrinkables);
      return cloned;
    };
    return vs;
  }
  generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    let numSkippedInRow = 0;
    const s = setBuilder();
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
      const current = slicedGenerator.next();
      if (s.tryAdd(current)) {
        numSkippedInRow = 0;
      } else {
        numSkippedInRow += 1;
      }
    }
    return s.getData();
  }
  safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  generateNItems(N, mrng, biasFactorItems) {
    const items = [];
    const slicedGenerator = buildSlicedGenerator(this.arb, mrng, this.customSlices, biasFactorItems);
    slicedGenerator.attemptExact(N);
    for (let index = 0;index !== N; ++index) {
      const current = slicedGenerator.next();
      safePush(items, current);
    }
    return items;
  }
  safeGenerateNItems(N, mrng, biasFactorItems) {
    const depthImpact = safeMathMax2(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
    this.depthContext.depth += depthImpact;
    try {
      return this.generateNItems(N, mrng, biasFactorItems);
    } finally {
      this.depthContext.depth -= depthImpact;
    }
  }
  wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
    const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
    let cloneable = false;
    const vs = [];
    const itemsContexts = [];
    for (let idx = 0;idx !== items.length; ++idx) {
      const s = items[idx];
      cloneable = cloneable || s.hasToBeCloned;
      safePush(vs, s.value);
      safePush(itemsContexts, s.context);
    }
    if (cloneable) {
      ArrayArbitrary.makeItCloneable(vs, items);
    }
    const context = {
      shrunkOnce,
      lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined ? itemsRawLengthContext : undefined,
      itemsContexts,
      startIndex
    };
    return new Value(vs, context);
  }
  generate(mrng, biasFactor) {
    const biasMeta = this.applyBias(mrng, biasFactor);
    const targetSize = biasMeta.size;
    const items = this.setBuilder !== undefined ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems) : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
    return this.wrapper(items, false, undefined, 0);
  }
  applyBias(mrng, biasFactor) {
    if (biasFactor === undefined) {
      return { size: this.lengthArb.generate(mrng, undefined).value };
    }
    if (this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
    }
    if (mrng.nextInt(1, biasFactor) !== 1) {
      return { size: this.lengthArb.generate(mrng, undefined).value };
    }
    if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
      return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
    }
    const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
    const targetSizeValue = integer({ min: this.minLength, max: maxBiasedLength }).generate(mrng, undefined);
    return { size: targetSizeValue.value, biasFactorItems: biasFactor };
  }
  canShrinkWithoutContext(value) {
    if (!safeArrayIsArray(value) || this.minLength > value.length || value.length > this.maxLength) {
      return false;
    }
    for (let index = 0;index !== value.length; ++index) {
      if (!(index in value)) {
        return false;
      }
      if (!this.arb.canShrinkWithoutContext(value[index])) {
        return false;
      }
    }
    const filtered = this.preFilter(safeMap(value, (item) => new Value(item, undefined)));
    return filtered.length === value.length;
  }
  shrinkItemByItem(value, safeContext, endIndex) {
    const shrinks = [];
    for (let index = safeContext.startIndex;index < endIndex; ++index) {
      safePush(shrinks, makeLazy(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v) => {
        const beforeCurrent = safeMap(safeSlice(value, 0, index), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i]));
        const afterCurrent = safeMap(safeSlice(value, index + 1), (v2, i) => new Value(cloneIfNeeded(v2), safeContext.itemsContexts[i + index + 1]));
        return [
          [...beforeCurrent, v, ...afterCurrent],
          undefined,
          index
        ];
      })));
    }
    return Stream.nil().join(...shrinks);
  }
  shrinkImpl(value, context) {
    if (value.length === 0) {
      return Stream.nil();
    }
    const safeContext = context !== undefined ? context : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };
    return this.lengthArb.shrink(value.length, safeContext.lengthContext).drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0).map((lengthValue) => {
      const sliceStart = value.length - lengthValue.value;
      return [
        safeMap(safeSlice(value, sliceStart), (v, index) => new Value(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
        lengthValue.context,
        0
      ];
    }).join(makeLazy(() => value.length > this.minLength ? this.shrinkItemByItem(value, safeContext, 1) : this.shrinkItemByItem(value, safeContext, value.length))).join(value.length > this.minLength ? makeLazy(() => {
      const subContext = {
        shrunkOnce: false,
        lengthContext: undefined,
        itemsContexts: safeSlice(safeContext.itemsContexts, 1),
        startIndex: 0
      };
      return this.shrinkImpl(safeSlice(value, 1), subContext).filter((v) => this.minLength <= v[0].length + 1).map((v) => {
        return [[new Value(cloneIfNeeded(value[0]), safeContext.itemsContexts[0]), ...v[0]], undefined, 0];
      });
    }) : Stream.nil());
  }
  shrink(value, context) {
    return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
  }
}

// node_modules/fast-check/lib/esm/arbitrary/_internals/helpers/MaxLengthFromMinLength.js
function maxLengthFromMinLength(minLength, size) {
  switch (size) {
    case "xsmall":
      return safeMathFloor4(1.1 * minLength) + 1;
    case "small":
      return 2 * minLength + 10;
    case "medium":
      return 11 * minLength + 100;
    case "large":
      return 101 * minLength + 1000;
    case "xlarge":
      return 1001 * minLength + 1e4;
    default:
      throw new Error(`Unable to compute lengths based on received size: ${size}`);
  }
}
function relativeSizeToSize(size, defaultSize) {
  const sizeInRelative = safeIndexOf(orderedRelativeSize, size);
  if (sizeInRelative === -1) {
    return size;
  }
  const defaultSizeInSize = safeIndexOf(orderedSize, defaultSize);
  if (defaultSizeInSize === -1) {
    throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
  }
  const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
  return resultingSizeInSize < 0 ? orderedSize[0] : resultingSizeInSize >= orderedSize.length ? orderedSize[orderedSize.length - 1] : orderedSize[resultingSizeInSize];
}
function maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength) {
  const { baseSize: defaultSize = DefaultSize, defaultSizeToMaxWhenMaxSpecified } = readConfigureGlobal() || {};
  const definedSize = size !== undefined ? size : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? "max" : defaultSize;
  if (definedSize === "max") {
    return maxLength;
  }
  const finalSize = relativeSizeToSize(definedSize, defaultSize);
  return safeMathMin2(maxLengthFromMinLength(minLength, finalSize), maxLength);
}
var safeMathFloor4 = Math.floor;
var safeMathMin2 = Math.min;
var MaxLengthUpperBound = 2147483647;
var orderedSize = ["xsmall", "small", "medium", "large", "xlarge"];
var orderedRelativeSize = ["-4", "-3", "-2", "-1", "=", "+1", "+2", "+3", "+4"];
var DefaultSize = "small";

// node_modules/fast-check/lib/esm/arbitrary/array.js
function array4(arb, constraints = {}) {
  const size = constraints.size;
  const minLength = constraints.minLength || 0;
  const maxLengthOrUnset = constraints.maxLength;
  const depthIdentifier = constraints.depthIdentifier;
  const maxLength = maxLengthOrUnset !== undefined ? maxLengthOrUnset : MaxLengthUpperBound;
  const specifiedMaxLength = maxLengthOrUnset !== undefined;
  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength);
  const customSlices = constraints.experimentalCustomSlices || [];
  return new ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, undefined, customSlices);
}
// node_modules/effect/dist/esm/internal/schema/util.js
function formatUnknown(input, whitespace = 0) {
  const seen = new WeakSet;
  const gap = !whitespace ? "" : typeof whitespace === "number" ? " ".repeat(whitespace) : whitespace;
  const ind = (d) => gap.repeat(d);
  const safeToString = (x) => {
    try {
      const s = x.toString();
      return typeof s === "string" ? s : String(s);
    } catch {
      return "[toString threw]";
    }
  };
  const wrap = (v, body) => {
    const ctor = v?.constructor;
    return ctor && ctor !== Object.prototype.constructor && ctor.name ? `${ctor.name}(${body})` : body;
  };
  const ownKeys = (o) => {
    try {
      return Reflect.ownKeys(o);
    } catch {
      return ["[ownKeys threw]"];
    }
  };
  function go(v, d = 0) {
    if (Array.isArray(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      if (!gap || v.length <= 1)
        return `[${v.map((x) => go(x, d)).join(",")}]`;
      const inner = v.map((x) => go(x, d + 1)).join(",\n" + ind(d + 1));
      return `[\n${ind(d + 1)}${inner}\n${ind(d)}]`;
    }
    if (isDate(v))
      return formatDate(v);
    if (hasProperty(v, "toString") && isFunction2(v["toString"]) && v["toString"] !== Object.prototype.toString)
      return safeToString(v);
    if (isString(v))
      return JSON.stringify(v);
    if (isNumber(v) || v == null || isBoolean(v) || isSymbol(v))
      return String(v);
    if (isBigInt(v))
      return String(v) + "n";
    if (v instanceof Set || v instanceof Map) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      return `${v.constructor.name}(${go(Array.from(v), d)})`;
    }
    if (isObject(v)) {
      if (seen.has(v))
        return CIRCULAR;
      seen.add(v);
      const keys = ownKeys(v);
      if (!gap || keys.length <= 1) {
        const body2 = `{${keys.map((k) => `${formatPropertyKey(k)}:${go(v[k], d)}`).join(",")}}`;
        return wrap(v, body2);
      }
      const body = `{\n${keys.map((k) => `${ind(d + 1)}${formatPropertyKey(k)}: ${go(v[k], d + 1)}`).join(",\n")}\n${ind(d)}}`;
      return wrap(v, body);
    }
    return String(v);
  }
  return go(input, 0);
}
function formatPropertyKey(name) {
  return isString(name) ? JSON.stringify(name) : String(name);
}
var getKeysForIndexSignature = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature(input, parameter.from);
  }
};
var memoizeThunk = (f) => {
  let done = false;
  let a;
  return () => {
    if (done) {
      return a;
    }
    a = f();
    done = true;
    return a;
  };
};
var formatDate = (date) => {
  try {
    return date.toISOString();
  } catch {
    return String(date);
  }
};
var CIRCULAR = "[Circular]";
var isNonEmpty = (x) => Array.isArray(x);
var isSingle = (x) => !Array.isArray(x);
var formatPathKey = (key) => `[${formatPropertyKey(key)}]`;
var formatPath = (path) => isNonEmpty(path) ? path.map(formatPathKey).join("") : formatPathKey(path);

// node_modules/effect/dist/esm/internal/schema/errors.js
var getErrorMessage = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `\nat path: ${formatPath(path)}`;
  }
  if (details !== undefined) {
    out += `\ndetails: ${details}`;
  }
  if (ast) {
    out += `\nschema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage("Duplicate index signature", `${type} index signature`);
var getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);

// node_modules/effect/dist/esm/internal/schema/schemaId.js
var DateFromSelfSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");

// node_modules/effect/dist/esm/Number.js
var Order = number3;
var clamp3 = /* @__PURE__ */ clamp(Order);
var remainder = /* @__PURE__ */ dual(2, (dividend, divisor) => {
  const selfDecCount = (dividend.toString().split(".")[1] || "").length;
  const divisorDecCount = (divisor.toString().split(".")[1] || "").length;
  const decCount = selfDecCount > divisorDecCount ? selfDecCount : divisorDecCount;
  const selfInt = parseInt(dividend.toFixed(decCount).replace(".", ""));
  const divisorInt = parseInt(divisor.toFixed(decCount).replace(".", ""));
  return selfInt % divisorInt / Math.pow(10, decCount);
});
var parse = (s) => {
  if (s === "NaN") {
    return some(NaN);
  }
  if (s === "Infinity") {
    return some(Infinity);
  }
  if (s === "-Infinity") {
    return some(-Infinity);
  }
  if (s.trim() === "") {
    return none;
  }
  const n = Number(s);
  return Number.isNaN(n) ? none : some(n);
};

// node_modules/effect/dist/esm/RegExp.js
var escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");

// node_modules/effect/dist/esm/SchemaAST.js
function changeMap(as, f) {
  let changed = false;
  const out = allocate(as.length);
  for (let i = 0;i < as.length; i++) {
    const a = as[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as;
}
function getBrands(ast) {
  return match2(getBrandAnnotation(ast), {
    onNone: () => "",
    onSome: (brands) => brands.map((brand) => ` & Brand<${formatUnknown(brand)}>`).join("")
  });
}
var BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
var SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
var MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
var MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
var IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
var TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
var AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
var DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
var ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
var DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
var JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
var ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
var PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
var EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
var DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
var ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
var BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
var ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
var DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
var SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
var StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
var getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
var getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
var getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
var getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
var getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
var getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
var getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
var getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
var getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
var getParseIssueTitleAnnotation = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
var getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
var getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
var getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
var getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
var hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
var JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
var getJSONIdentifier = (annotated) => orElse(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
class Declaration {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown, encodeUnknown, annotations = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown;
    this.encodeUnknown = encodeUnknown;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var createASTGuard = (tag) => (ast) => ast._tag === tag;
class Literal {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal, annotations = {}) {
    this.literal = literal;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isLiteral = /* @__PURE__ */ createASTGuard("Literal");
class UniqueSymbol {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol3, annotations = {}) {
    this.symbol = symbol3;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
class UndefinedKeyword {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
  [TitleAnnotationId]: "undefined"
});
class VoidKeyword {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var voidKeyword = /* @__PURE__ */ new VoidKeyword({
  [TitleAnnotationId]: "void"
});
class NeverKeyword {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var neverKeyword = /* @__PURE__ */ new NeverKeyword({
  [TitleAnnotationId]: "never"
});
class UnknownKeyword {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
  [TitleAnnotationId]: "unknown"
});
class AnyKeyword {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var anyKeyword = /* @__PURE__ */ new AnyKeyword({
  [TitleAnnotationId]: "any"
});
class StringKeyword {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var stringKeyword = /* @__PURE__ */ new StringKeyword({
  [TitleAnnotationId]: "string",
  [DescriptionAnnotationId]: "a string"
});
var isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");

class NumberKeyword {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var numberKeyword = /* @__PURE__ */ new NumberKeyword({
  [TitleAnnotationId]: "number",
  [DescriptionAnnotationId]: "a number"
});
class BooleanKeyword {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
  [TitleAnnotationId]: "boolean",
  [DescriptionAnnotationId]: "a boolean"
});
class BigIntKeyword {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var bigIntKeyword = /* @__PURE__ */ new BigIntKeyword({
  [TitleAnnotationId]: "bigint",
  [DescriptionAnnotationId]: "a bigint"
});
class SymbolKeyword {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var symbolKeyword = /* @__PURE__ */ new SymbolKeyword({
  [TitleAnnotationId]: "symbol",
  [DescriptionAnnotationId]: "a symbol"
});
var isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");

class ObjectKeyword {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations = {}) {
    this.annotations = annotations;
  }
  toString() {
    return formatKeyword(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var objectKeyword = /* @__PURE__ */ new ObjectKeyword({
  [TitleAnnotationId]: "object",
  [DescriptionAnnotationId]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Type {
  type;
  annotations;
  constructor(type, annotations = {}) {
    this.type = type;
    this.annotations = annotations;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType extends Type {
  isOptional;
  constructor(type, isOptional, annotations = {}) {
    super(type, annotations);
    this.isOptional = isOptional;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
    }
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTuple(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatTuple = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head2, tail) => {
      const formattedHead = String(head2);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature extends OptionalType {
  name;
  isReadonly;
  constructor(name, type, isOptional, isReadonly, annotations) {
    super(type, isOptional, annotations);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter(ast.from);
  }
  return false;
};

class IndexSignature {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type, isReadonly) {
    this.type = type;
    this.isReadonly = isReadonly;
    if (isParameter(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations = {}) {
    this.annotations = annotations;
    const keys = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
      }
      keys[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
      if (isStringKeyword(encodedParameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword(encodedParameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = propertySignatures;
    this.indexSignatures = indexSignatures;
  }
  toString() {
    return getOrElse(getExpected(this), () => formatTypeLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var formatIndexSignatures = (iss) => iss.map(String).join("; ");
var formatTypeLiteral = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten2 = (candidates) => flatMap2(candidates, (ast) => isUnion(ast) ? flatten2(ast.types) : [ast]);
var unify = (candidates) => {
  const cs = sortCandidates(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword];
      case "UnknownKeyword":
        return [unknownKeyword];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type = typeof ast.literal;
        switch (type) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap[type];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union {
  types;
  annotations;
  static make = (types, annotations) => {
    return isMembers(types) ? new Union(types, annotations) : types.length === 1 ? types[0] : neverKeyword;
  };
  static unify = (candidates, annotations) => {
    return Union.make(unify(flatten2(candidates)), annotations);
  };
  _tag = "Union";
  constructor(types, annotations = {}) {
    this.types = types;
    this.annotations = annotations;
  }
  toString() {
    return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isMembers = (as) => as.length > 1;
var isUnion = /* @__PURE__ */ createASTGuard("Union");
var toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations = {}) {
    this.f = f;
    this.annotations = annotations;
    this.f = memoizeThunk(f);
  }
  toString() {
    return getExpected(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
    toJSONMemoMap.set(ast, out);
    return out;
  }
}
class Refinement {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter2, annotations = {}) {
    this.from = from;
    this.filter = filter2;
    this.annotations = annotations;
  }
  toString() {
    return getIdentifierAnnotation(this).pipe(getOrElse(() => match2(getOrElseExpected(this), {
      onNone: () => `{ ${this.from} | filter }`,
      onSome: (expected) => isRefinement(this.from) ? String(this.from) + " & " + expected : expected
    })));
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations(this.annotations)
    };
  }
}
var isRefinement = /* @__PURE__ */ createASTGuard("Refinement");
var defaultParseOption = {};
var annotations = (ast, overrides) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  const base = {
    ...ast.annotations
  };
  delete base[IdentifierAnnotationId];
  const value = {
    ...base,
    ...overrides
  };
  const surrogate = getSurrogateAnnotation(ast);
  if (isSome2(surrogate)) {
    value[SurrogateAnnotationId] = annotations(surrogate.value, overrides);
  }
  d.annotations.value = value;
  return Object.create(Object.getPrototypeOf(ast), d);
};
var STRING_KEYWORD_PATTERN = "[\\s\\S]*?";
var NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralSpanTypePattern = (type, capture) => {
  switch (type._tag) {
    case "Literal":
      return escape(String(type.literal));
    case "StringKeyword":
      return STRING_KEYWORD_PATTERN;
    case "NumberKeyword":
      return NUMBER_KEYWORD_PATTERN;
    case "TemplateLiteral":
      return getTemplateLiteralPattern(type, capture, false);
    case "Union":
      return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2, capture)).join("|");
  }
};
var handleTemplateLiteralSpanTypeParens = (type, s, capture, top) => {
  if (isUnion(type)) {
    if (capture && !top) {
      return `(?:${s})`;
    }
  } else if (!capture || !top) {
    return s;
  }
  return `(${s})`;
};
var getTemplateLiteralPattern = (ast, capture, top) => {
  let pattern = ``;
  if (ast.head !== "") {
    const head2 = escape(ast.head);
    pattern += capture && top ? `(${head2})` : head2;
  }
  for (const span2 of ast.spans) {
    const spanPattern = getTemplateLiteralSpanTypePattern(span2.type, capture);
    pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern, capture, top);
    if (span2.literal !== "") {
      const literal = escape(span2.literal);
      pattern += capture && top ? `(${literal})` : literal;
    }
  }
  return pattern;
};
var getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast, false, true)}\$`);
var pickAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id)) {
      if (out === undefined) {
        out = {};
      }
      out[id] = annotated.annotations[id];
    }
  }
  return out;
};
var preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
var typeAST = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, typeAST);
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = typeAST(e.type);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, typeAST);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type(type)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (p) => {
        const type = typeAST(p.type);
        return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = typeAST(is.type);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap(ast.types, typeAST);
      return types === ast.types ? ast : Union.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend(() => typeAST(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST(ast.from);
      return from === ast.from ? ast : new Refinement(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const preserve = preserveTransformationAnnotations(ast);
      return typeAST(preserve !== undefined ? annotations(ast.to, preserve) : ast.to);
    }
  }
  return ast;
};
var getTransformationFrom = (ast) => {
  switch (ast._tag) {
    case "Transformation":
      return ast.from;
    case "Refinement":
      return getTransformationFrom(ast.from);
    case "Suspend":
      return getTransformationFrom(ast.f());
  }
};
var encodedAST_ = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown);
    }
    case "TupleType": {
      const elements = changeMap(ast.elements, (e) => {
        const type = encodedAST_(e.type, isBound);
        return type === e.type ? e : new OptionalType(type, e.isOptional);
      });
      const restASTs = getRestASTs(ast.rest);
      const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type(ast2)), ast.isReadonly);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
        const type = encodedAST_(ps.type, isBound);
        return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap(ast.indexSignatures, (is) => {
        const type = encodedAST_(is.type, isBound);
        return type === is.type ? is : new IndexSignature(is.parameter, type, is.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures);
    }
    case "Union": {
      const types = changeMap(ast.types, (ast2) => encodedAST_(ast2, isBound));
      return types === ast.types ? ast : Union.make(types);
    }
    case "Suspend": {
      let borrowedAnnotations = undefined;
      const identifier = getJSONIdentifier(ast);
      if (isSome2(identifier)) {
        const suffix = isBound ? "Bound" : "";
        borrowedAnnotations = {
          [JSONIdentifierAnnotationId]: `${identifier.value}Encoded${suffix}`
        };
      }
      return new Suspend(() => encodedAST_(ast.f(), isBound), borrowedAnnotations);
    }
    case "Refinement": {
      const from = encodedAST_(ast.from, isBound);
      if (isBound) {
        if (from === ast.from)
          return ast;
        if (getTransformationFrom(ast.from) === undefined && hasStableFilter(ast)) {
          return new Refinement(from, ast.filter, ast.annotations);
        }
        return from;
      } else {
        return from;
      }
    }
    case "Transformation":
      return encodedAST_(ast.from, isBound);
  }
  return ast;
};
var encodedAST = (ast) => encodedAST_(ast, false);
var toJSONAnnotations = (annotations2) => {
  const out = {};
  for (const k of Object.getOwnPropertySymbols(annotations2)) {
    out[String(k)] = annotations2[k];
  }
  return out;
};
var getEncodedParameter = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getEncodedParameter(ast.from);
  }
};
var formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
var getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse(() => getDescriptionAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), map2((s) => s + getBrands(ast)));
var getExpected = (ast) => orElse(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
// node_modules/effect/dist/esm/BigDecimal.js
var FINITE_INT_REGEX = /^[+-]?\d+$/;
var TypeId3 = /* @__PURE__ */ Symbol.for("effect/BigDecimal");
var BigDecimalProto = {
  [TypeId3]: TypeId3,
  [symbol]() {
    const normalized = normalize(this);
    return pipe(hash(normalized.value), combine(number2(normalized.scale)), cached(this));
  },
  [symbol2](that) {
    return isBigDecimal(that) && equals2(this, that);
  },
  toString() {
    return `BigDecimal(${format2(this)})`;
  },
  toJSON() {
    return {
      _id: "BigDecimal",
      value: String(this.value),
      scale: this.scale
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isBigDecimal = (u) => hasProperty(u, TypeId3);
var make4 = (value, scale) => {
  const o = Object.create(BigDecimalProto);
  o.value = value;
  o.scale = scale;
  return o;
};
var unsafeMakeNormalized = (value, scale) => {
  if (value !== bigint0 && value % bigint10 === bigint0) {
    throw new RangeError("Value must be normalized");
  }
  const o = make4(value, scale);
  o.normalized = o;
  return o;
};
var bigint0 = /* @__PURE__ */ BigInt(0);
var bigint10 = /* @__PURE__ */ BigInt(10);
var zero = /* @__PURE__ */ unsafeMakeNormalized(bigint0, 0);
var normalize = (self2) => {
  if (self2.normalized === undefined) {
    if (self2.value === bigint0) {
      self2.normalized = zero;
    } else {
      const digits = `${self2.value}`;
      let trail = 0;
      for (let i = digits.length - 1;i >= 0; i--) {
        if (digits[i] === "0") {
          trail++;
        } else {
          break;
        }
      }
      if (trail === 0) {
        self2.normalized = self2;
      }
      const value = BigInt(digits.substring(0, digits.length - trail));
      const scale = self2.scale - trail;
      self2.normalized = unsafeMakeNormalized(value, scale);
    }
  }
  return self2.normalized;
};
var scale = /* @__PURE__ */ dual(2, (self2, scale2) => {
  if (scale2 > self2.scale) {
    return make4(self2.value * bigint10 ** BigInt(scale2 - self2.scale), scale2);
  }
  if (scale2 < self2.scale) {
    return make4(self2.value / bigint10 ** BigInt(self2.scale - scale2), scale2);
  }
  return self2;
});
var Order2 = /* @__PURE__ */ make2((self2, that) => {
  const scmp = number3(sign(self2), sign(that));
  if (scmp !== 0) {
    return scmp;
  }
  if (self2.scale > that.scale) {
    return bigint(self2.value, scale(that, self2.scale).value);
  }
  if (self2.scale < that.scale) {
    return bigint(scale(self2, that.scale).value, that.value);
  }
  return bigint(self2.value, that.value);
});
var lessThan2 = /* @__PURE__ */ lessThan(Order2);
var lessThanOrEqualTo2 = /* @__PURE__ */ lessThanOrEqualTo(Order2);
var greaterThan2 = /* @__PURE__ */ greaterThan(Order2);
var greaterThanOrEqualTo2 = /* @__PURE__ */ greaterThanOrEqualTo(Order2);
var between2 = /* @__PURE__ */ between(Order2);
var clamp4 = /* @__PURE__ */ clamp(Order2);
var sign = (n) => n.value === bigint0 ? 0 : n.value < bigint0 ? -1 : 1;
var abs = (n) => n.value < bigint0 ? make4(-n.value, n.scale) : n;
var Equivalence = /* @__PURE__ */ make((self2, that) => {
  if (self2.scale > that.scale) {
    return scale(that, self2.scale).value === self2.value;
  }
  if (self2.scale < that.scale) {
    return scale(self2, that.scale).value === that.value;
  }
  return self2.value === that.value;
});
var equals2 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(self2, that));
var unsafeFromNumber = (n) => getOrThrowWith2(safeFromNumber(n), () => new RangeError(`Number must be finite, got ${n}`));
var fromNumber = unsafeFromNumber;
var safeFromNumber = (n) => {
  if (!Number.isFinite(n)) {
    return none2();
  }
  const string2 = `${n}`;
  if (string2.includes("e")) {
    return fromString(string2);
  }
  const [lead, trail = ""] = string2.split(".");
  return some2(make4(BigInt(`${lead}${trail}`), trail.length));
};
var fromString = (s) => {
  if (s === "") {
    return some2(zero);
  }
  let base;
  let exp;
  const seperator = s.search(/[eE]/);
  if (seperator !== -1) {
    const trail = s.slice(seperator + 1);
    base = s.slice(0, seperator);
    exp = Number(trail);
    if (base === "" || !Number.isSafeInteger(exp) || !FINITE_INT_REGEX.test(trail)) {
      return none2();
    }
  } else {
    base = s;
    exp = 0;
  }
  let digits;
  let offset;
  const dot = base.search(/\./);
  if (dot !== -1) {
    const lead = base.slice(0, dot);
    const trail = base.slice(dot + 1);
    digits = `${lead}${trail}`;
    offset = trail.length;
  } else {
    digits = base;
    offset = 0;
  }
  if (!FINITE_INT_REGEX.test(digits)) {
    return none2();
  }
  const scale2 = offset - exp;
  if (!Number.isSafeInteger(scale2)) {
    return none2();
  }
  return some2(make4(BigInt(digits), scale2));
};
var format2 = (n) => {
  const normalized = normalize(n);
  if (Math.abs(normalized.scale) >= 16) {
    return toExponential(normalized);
  }
  const negative = normalized.value < bigint0;
  const absolute = negative ? `${normalized.value}`.substring(1) : `${normalized.value}`;
  let before;
  let after;
  if (normalized.scale >= absolute.length) {
    before = "0";
    after = "0".repeat(normalized.scale - absolute.length) + absolute;
  } else {
    const location = absolute.length - normalized.scale;
    if (location > absolute.length) {
      const zeros = location - absolute.length;
      before = `${absolute}${"0".repeat(zeros)}`;
      after = "";
    } else {
      after = absolute.slice(location);
      before = absolute.slice(0, location);
    }
  }
  const complete = after === "" ? before : `${before}.${after}`;
  return negative ? `-${complete}` : complete;
};
var toExponential = (n) => {
  if (isZero(n)) {
    return "0e+0";
  }
  const normalized = normalize(n);
  const digits = `${abs(normalized).value}`;
  const head2 = digits.slice(0, 1);
  const tail = digits.slice(1);
  let output = `${isNegative(normalized) ? "-" : ""}${head2}`;
  if (tail !== "") {
    output += `.${tail}`;
  }
  const exp = tail.length - normalized.scale;
  return `${output}e${exp >= 0 ? "+" : ""}${exp}`;
};
var unsafeToNumber = (n) => Number(format2(n));
var isZero = (n) => n.value === bigint0;
var isNegative = (n) => n.value < bigint0;
var isPositive = (n) => n.value > bigint0;
// node_modules/effect/dist/esm/BigInt.js
var Order3 = bigint;
var clamp5 = /* @__PURE__ */ clamp(Order3);
var toNumber = (b) => {
  if (b > BigInt(Number.MAX_SAFE_INTEGER) || b < BigInt(Number.MIN_SAFE_INTEGER)) {
    return none2();
  }
  return some2(Number(b));
};
var fromString2 = (s) => {
  try {
    return s.trim() === "" ? none2() : some2(BigInt(s));
  } catch {
    return none2();
  }
};
var fromNumber2 = (n) => {
  if (n > Number.MAX_SAFE_INTEGER || n < Number.MIN_SAFE_INTEGER) {
    return none2();
  }
  try {
    return some2(BigInt(n));
  } catch {
    return none2();
  }
};
// node_modules/effect/dist/esm/Boolean.js
var not = (self2) => !self2;
// node_modules/effect/dist/esm/Context.js
var exports_Context = {};
__export(exports_Context, {
  unsafeMake: () => unsafeMake,
  unsafeGet: () => unsafeGet3,
  pick: () => pick2,
  omit: () => omit2,
  mergeAll: () => mergeAll2,
  merge: () => merge3,
  make: () => make6,
  isTag: () => isTag2,
  isReference: () => isReference2,
  isContext: () => isContext2,
  getOrElse: () => getOrElse3,
  getOption: () => getOption2,
  get: () => get3,
  empty: () => empty4,
  add: () => add2,
  Tag: () => Tag2,
  Reference: () => Reference2,
  GenericTag: () => GenericTag
});

// node_modules/effect/dist/esm/internal/context.js
var TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
var ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
var STMSymbolKey = "effect/STM";
var STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
var TagProto = {
  ...EffectPrototype,
  _op: "Tag",
  [STMTypeId]: effectVariance,
  [TagTypeId]: {
    _Service: (_) => _,
    _Identifier: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Tag",
      key: this.key,
      stack: this.stack
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  of(self2) {
    return self2;
  },
  context(self2) {
    return make5(this, self2);
  }
};
var ReferenceProto = {
  ...TagProto,
  [ReferenceTypeId]: ReferenceTypeId
};
var makeGenericTag = (key) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  const tag = Object.create(TagProto);
  Object.defineProperty(tag, "stack", {
    get() {
      return creationError.stack;
    }
  });
  tag.key = key;
  return tag;
};
var Tag = (id) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return TagClass;
};
var Reference = () => (id, options) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function ReferenceClass() {
  }
  Object.setPrototypeOf(ReferenceClass, ReferenceProto);
  ReferenceClass.key = id;
  ReferenceClass.defaultValue = options.defaultValue;
  Object.defineProperty(ReferenceClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return ReferenceClass;
};
var TypeId4 = /* @__PURE__ */ Symbol.for("effect/Context");
var ContextProto = {
  [TypeId4]: {
    _Services: (_) => _
  },
  [symbol2](that) {
    if (isContext(that)) {
      if (this.unsafeMap.size === that.unsafeMap.size) {
        for (const k of this.unsafeMap.keys()) {
          if (!that.unsafeMap.has(k) || !equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
            return false;
          }
        }
        return true;
      }
    }
    return false;
  },
  [symbol]() {
    return cached(this, number2(this.unsafeMap.size));
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Context",
      services: Array.from(this.unsafeMap).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var makeContext = (unsafeMap) => {
  const context = Object.create(ContextProto);
  context.unsafeMap = unsafeMap;
  return context;
};
var serviceNotFoundError = (tag) => {
  const error = new Error(`Service not found${tag.key ? `: ${String(tag.key)}` : ""}`);
  if (tag.stack) {
    const lines = tag.stack.split("\n");
    if (lines.length > 2) {
      const afterAt = lines[2].match(/at (.*)/);
      if (afterAt) {
        error.message = error.message + ` (defined at ${afterAt[1]})`;
      }
    }
  }
  if (error.stack) {
    const lines = error.stack.split("\n");
    lines.splice(1, 3);
    error.stack = lines.join("\n");
  }
  return error;
};
var isContext = (u) => hasProperty(u, TypeId4);
var isTag = (u) => hasProperty(u, TagTypeId);
var isReference = (u) => hasProperty(u, ReferenceTypeId);
var _empty = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map);
var empty3 = () => _empty;
var make5 = (tag, service) => makeContext(new Map([[tag.key, service]]));
var add = /* @__PURE__ */ dual(3, (self2, tag, service) => {
  const map4 = new Map(self2.unsafeMap);
  map4.set(tag.key, service);
  return makeContext(map4);
});
var defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => new Map);
var getDefaultValue = (tag) => {
  if (defaultValueCache.has(tag.key)) {
    return defaultValueCache.get(tag.key);
  }
  const value = tag.defaultValue();
  defaultValueCache.set(tag.key, value);
  return value;
};
var unsafeGetReference = (self2, tag) => {
  return self2.unsafeMap.has(tag.key) ? self2.unsafeMap.get(tag.key) : getDefaultValue(tag);
};
var unsafeGet2 = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    if (ReferenceTypeId in tag)
      return getDefaultValue(tag);
    throw serviceNotFoundError(tag);
  }
  return self2.unsafeMap.get(tag.key);
});
var get2 = unsafeGet2;
var getOrElse2 = /* @__PURE__ */ dual(3, (self2, tag, orElse2) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? getDefaultValue(tag) : orElse2();
  }
  return self2.unsafeMap.get(tag.key);
});
var getOption = /* @__PURE__ */ dual(2, (self2, tag) => {
  if (!self2.unsafeMap.has(tag.key)) {
    return isReference(tag) ? some(getDefaultValue(tag)) : none;
  }
  return some(self2.unsafeMap.get(tag.key));
});
var merge2 = /* @__PURE__ */ dual(2, (self2, that) => {
  const map4 = new Map(self2.unsafeMap);
  for (const [tag, s] of that.unsafeMap) {
    map4.set(tag, s);
  }
  return makeContext(map4);
});
var mergeAll = (...ctxs) => {
  const map4 = new Map;
  for (const ctx of ctxs) {
    for (const [tag, s] of ctx.unsafeMap) {
      map4.set(tag, s);
    }
  }
  return makeContext(map4);
};
var pick = (...tags) => (self2) => {
  const tagSet = new Set(tags.map((_) => _.key));
  const newEnv = new Map;
  for (const [tag, s] of self2.unsafeMap.entries()) {
    if (tagSet.has(tag)) {
      newEnv.set(tag, s);
    }
  }
  return makeContext(newEnv);
};
var omit = (...tags) => (self2) => {
  const newEnv = new Map(self2.unsafeMap);
  for (const tag of tags) {
    newEnv.delete(tag.key);
  }
  return makeContext(newEnv);
};

// node_modules/effect/dist/esm/Context.js
var GenericTag = makeGenericTag;
var unsafeMake = makeContext;
var isContext2 = isContext;
var isTag2 = isTag;
var isReference2 = isReference;
var empty4 = empty3;
var make6 = make5;
var add2 = add;
var get3 = get2;
var getOrElse3 = getOrElse2;
var unsafeGet3 = unsafeGet2;
var getOption2 = getOption;
var merge3 = merge2;
var mergeAll2 = mergeAll;
var pick2 = pick;
var omit2 = omit;
var Tag2 = Tag;
var Reference2 = Reference;

// node_modules/effect/dist/esm/Chunk.js
function copy2(src, srcPos, dest, destPos, len) {
  for (let i = srcPos;i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
var TypeId5 = /* @__PURE__ */ Symbol.for("effect/Chunk");
var emptyArray = [];
var getEquivalence4 = (isEquivalent) => make((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value, i) => isEquivalent(value, unsafeGet4(that, i))));
var _equivalence3 = /* @__PURE__ */ getEquivalence4(equals);
var ChunkProto = {
  [TypeId5]: {
    _A: (_) => _
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Chunk",
      values: toReadonlyArray(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isChunk(that) && _equivalence3(this, that);
  },
  [symbol]() {
    return cached(this, array2(toReadonlyArray(this)));
  },
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray": {
        return this.backing.array[Symbol.iterator]();
      }
      case "IEmpty": {
        return emptyArray[Symbol.iterator]();
      }
      default: {
        return toReadonlyArray(this)[Symbol.iterator]();
      }
    }
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeChunk = (backing) => {
  const chunk = Object.create(ChunkProto);
  chunk.backing = backing;
  switch (backing._tag) {
    case "IEmpty": {
      chunk.length = 0;
      chunk.depth = 0;
      chunk.left = chunk;
      chunk.right = chunk;
      break;
    }
    case "IConcat": {
      chunk.length = backing.left.length + backing.right.length;
      chunk.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
      chunk.left = backing.left;
      chunk.right = backing.right;
      break;
    }
    case "IArray": {
      chunk.length = backing.array.length;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISingleton": {
      chunk.length = 1;
      chunk.depth = 0;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
    case "ISlice": {
      chunk.length = backing.length;
      chunk.depth = backing.chunk.depth + 1;
      chunk.left = _empty2;
      chunk.right = _empty2;
      break;
    }
  }
  return chunk;
};
var isChunk = (u) => hasProperty(u, TypeId5);
var _empty2 = /* @__PURE__ */ makeChunk({
  _tag: "IEmpty"
});
var empty5 = () => _empty2;
var make7 = (...as) => unsafeFromNonEmptyArray(as);
var of2 = (a) => makeChunk({
  _tag: "ISingleton",
  a
});
var fromIterable2 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable(self2));
var copyToArray = (self2, array5, initial) => {
  switch (self2.backing._tag) {
    case "IArray": {
      copy2(self2.backing.array, 0, array5, initial, self2.length);
      break;
    }
    case "IConcat": {
      copyToArray(self2.left, array5, initial);
      copyToArray(self2.right, array5, initial + self2.left.length);
      break;
    }
    case "ISingleton": {
      array5[initial] = self2.backing.a;
      break;
    }
    case "ISlice": {
      let i = 0;
      let j = initial;
      while (i < self2.length) {
        array5[j] = unsafeGet4(self2, i);
        i += 1;
        j += 1;
      }
      break;
    }
  }
};
var toReadonlyArray_ = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      return emptyArray;
    }
    case "IArray": {
      return self2.backing.array;
    }
    default: {
      const arr = new Array(self2.length);
      copyToArray(self2, arr, 0);
      self2.backing = {
        _tag: "IArray",
        array: arr
      };
      self2.left = _empty2;
      self2.right = _empty2;
      self2.depth = 0;
      return arr;
    }
  }
};
var toReadonlyArray = toReadonlyArray_;
var reverseChunk = (self2) => {
  switch (self2.backing._tag) {
    case "IEmpty":
    case "ISingleton":
      return self2;
    case "IArray": {
      return makeChunk({
        _tag: "IArray",
        array: reverse(self2.backing.array)
      });
    }
    case "IConcat": {
      return makeChunk({
        _tag: "IConcat",
        left: reverse2(self2.backing.right),
        right: reverse2(self2.backing.left)
      });
    }
    case "ISlice":
      return unsafeFromArray(reverse(toReadonlyArray(self2)));
  }
};
var reverse2 = reverseChunk;
var get4 = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none2() : some2(unsafeGet4(self2, index)));
var unsafeFromArray = (self2) => self2.length === 0 ? empty5() : self2.length === 1 ? of2(self2[0]) : makeChunk({
  _tag: "IArray",
  array: self2
});
var unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
var unsafeGet4 = /* @__PURE__ */ dual(2, (self2, index) => {
  switch (self2.backing._tag) {
    case "IEmpty": {
      throw new Error(`Index out of bounds`);
    }
    case "ISingleton": {
      if (index !== 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.a;
    }
    case "IArray": {
      if (index >= self2.length || index < 0) {
        throw new Error(`Index out of bounds`);
      }
      return self2.backing.array[index];
    }
    case "IConcat": {
      return index < self2.left.length ? unsafeGet4(self2.left, index) : unsafeGet4(self2.right, index - self2.left.length);
    }
    case "ISlice": {
      return unsafeGet4(self2.backing.chunk, index + self2.backing.offset);
    }
  }
});
var append2 = /* @__PURE__ */ dual(2, (self2, a) => appendAll2(self2, of2(a)));
var prepend2 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll2(of2(elem), self2));
var take = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return _empty2;
  } else if (n >= self2.length) {
    return self2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          length: n,
          offset: self2.backing.offset
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: take(self2.right, n - self2.left.length)
          });
        }
        return take(self2.left, n);
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: 0,
          length: n
        });
      }
    }
  }
});
var drop2 = /* @__PURE__ */ dual(2, (self2, n) => {
  if (n <= 0) {
    return self2;
  } else if (n >= self2.length) {
    return _empty2;
  } else {
    switch (self2.backing._tag) {
      case "ISlice": {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2.backing.chunk,
          offset: self2.backing.offset + n,
          length: self2.backing.length - n
        });
      }
      case "IConcat": {
        if (n > self2.left.length) {
          return drop2(self2.right, n - self2.left.length);
        }
        return makeChunk({
          _tag: "IConcat",
          left: drop2(self2.left, n),
          right: self2.right
        });
      }
      default: {
        return makeChunk({
          _tag: "ISlice",
          chunk: self2,
          offset: n,
          length: self2.length - n
        });
      }
    }
  }
});
var appendAll2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self2;
  }
  const diff = that.depth - self2.depth;
  if (Math.abs(diff) <= 1) {
    return makeChunk({
      _tag: "IConcat",
      left: self2,
      right: that
    });
  } else if (diff < -1) {
    if (self2.left.depth >= self2.right.depth) {
      const nr = appendAll2(self2.right, that);
      return makeChunk({
        _tag: "IConcat",
        left: self2.left,
        right: nr
      });
    } else {
      const nrr = appendAll2(self2.right.right, that);
      if (nrr.depth === self2.depth - 3) {
        const nr = makeChunk({
          _tag: "IConcat",
          left: self2.right.left,
          right: nrr
        });
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nl = makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: self2.right.left
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = appendAll2(self2, that.left);
      return makeChunk({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = appendAll2(self2, that.left.left);
      if (nll.depth === that.depth - 3) {
        const nl = makeChunk({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = makeChunk({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return makeChunk({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
var isEmpty = (self2) => self2.length === 0;
var isNonEmpty2 = (self2) => self2.length > 0;
var head2 = /* @__PURE__ */ get4(0);
var unsafeHead2 = (self2) => unsafeGet4(self2, 0);
var headNonEmpty2 = unsafeHead2;
var splitAt2 = /* @__PURE__ */ dual(2, (self2, n) => [take(self2, n), drop2(self2, n)]);
var tailNonEmpty2 = (self2) => drop2(self2, 1);

// node_modules/effect/dist/esm/Duration.js
var TypeId6 = /* @__PURE__ */ Symbol.for("effect/Duration");
var bigint02 = /* @__PURE__ */ BigInt(0);
var bigint24 = /* @__PURE__ */ BigInt(24);
var bigint60 = /* @__PURE__ */ BigInt(60);
var bigint1e3 = /* @__PURE__ */ BigInt(1000);
var bigint1e6 = /* @__PURE__ */ BigInt(1e6);
var bigint1e9 = /* @__PURE__ */ BigInt(1e9);
var DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
var decode = (input) => {
  if (isDuration(input)) {
    return input;
  } else if (isNumber(input)) {
    return millis(input);
  } else if (isBigInt(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero2;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
  } else if (isString(input)) {
    const match4 = DURATION_REGEX.exec(input);
    if (match4) {
      const [_, valueStr, unit] = match4;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
var zeroValue = {
  _tag: "Millis",
  millis: 0
};
var infinityValue = {
  _tag: "Infinity"
};
var DurationProto = {
  [TypeId6]: TypeId6,
  [symbol]() {
    return cached(this, structure(this.value));
  },
  [symbol2](that) {
    return isDuration(that) && equals3(this, that);
  },
  toString() {
    return `Duration(${format3(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make8 = (input) => {
  const duration = Object.create(DurationProto);
  if (isNumber(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1e6))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint02) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
var isDuration = (u) => hasProperty(u, TypeId6);
var isZero2 = (self2) => {
  switch (self2.value._tag) {
    case "Millis": {
      return self2.value.millis === 0;
    }
    case "Nanos": {
      return self2.value.nanos === bigint02;
    }
    case "Infinity": {
      return false;
    }
  }
};
var zero2 = /* @__PURE__ */ make8(0);
var infinity = /* @__PURE__ */ make8(Infinity);
var nanos = (nanos2) => make8(nanos2);
var micros = (micros2) => make8(micros2 * bigint1e3);
var millis = (millis2) => make8(millis2);
var seconds = (seconds2) => make8(seconds2 * 1000);
var minutes = (minutes2) => make8(minutes2 * 60000);
var hours = (hours2) => make8(hours2 * 3600000);
var days = (days2) => make8(days2 * 86400000);
var weeks = (weeks2) => make8(weeks2 * 604800000);
var toMillis = (self2) => match4(self2, {
  onMillis: (millis2) => millis2,
  onNanos: (nanos2) => Number(nanos2) / 1e6
});
var toNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return none2();
    case "Nanos":
      return some2(_self.value.nanos);
    case "Millis":
      return some2(BigInt(Math.round(_self.value.millis * 1e6)));
  }
};
var unsafeToNanos = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1e6));
  }
};
var toHrTime = (self2) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1e6)];
  }
};
var match4 = /* @__PURE__ */ dual(2, (self2, options) => {
  const _self = decode(self2);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
var matchWith = /* @__PURE__ */ dual(3, (self2, that, options) => {
  const _self = decode(self2);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
var Order4 = /* @__PURE__ */ make2((self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0,
  onNanos: (self3, that2) => self3 < that2 ? -1 : self3 > that2 ? 1 : 0
}));
var between3 = /* @__PURE__ */ between(/* @__PURE__ */ mapInput2(Order4, decode));
var Equivalence2 = (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 === that2,
  onNanos: (self3, that2) => self3 === that2
});
var _clamp = /* @__PURE__ */ clamp(Order4);
var clamp6 = /* @__PURE__ */ dual(2, (self2, options) => _clamp(decode(self2), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
var lessThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 < that2,
  onNanos: (self3, that2) => self3 < that2
}));
var lessThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 <= that2,
  onNanos: (self3, that2) => self3 <= that2
}));
var greaterThan3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 > that2,
  onNanos: (self3, that2) => self3 > that2
}));
var greaterThanOrEqualTo3 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
  onMillis: (self3, that2) => self3 >= that2,
  onNanos: (self3, that2) => self3 >= that2
}));
var equals3 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence2(decode(self2), decode(that)));
var parts = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos2 = unsafeToNanos(duration);
  const ms = nanos2 / bigint1e6;
  const sec = ms / bigint1e3;
  const min2 = sec / bigint60;
  const hr = min2 / bigint60;
  const days2 = hr / bigint24;
  return {
    days: Number(days2),
    hours: Number(hr % bigint24),
    minutes: Number(min2 % bigint60),
    seconds: Number(sec % bigint60),
    millis: Number(ms % bigint1e3),
    nanos: Number(nanos2 % bigint1e6)
  };
};
var format3 = (self2) => {
  const duration = decode(self2);
  if (duration.value._tag === "Infinity") {
    return "Infinity";
  }
  if (isZero2(duration)) {
    return "0";
  }
  const fragments = parts(duration);
  const pieces = [];
  if (fragments.days !== 0) {
    pieces.push(`${fragments.days}d`);
  }
  if (fragments.hours !== 0) {
    pieces.push(`${fragments.hours}h`);
  }
  if (fragments.minutes !== 0) {
    pieces.push(`${fragments.minutes}m`);
  }
  if (fragments.seconds !== 0) {
    pieces.push(`${fragments.seconds}s`);
  }
  if (fragments.millis !== 0) {
    pieces.push(`${fragments.millis}ms`);
  }
  if (fragments.nanos !== 0) {
    pieces.push(`${fragments.nanos}ns`);
  }
  return pieces.join(" ");
};

// node_modules/effect/dist/esm/internal/hashMap/config.js
var SIZE = 5;
var BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
var MASK = BUCKET_SIZE - 1;
var MAX_INDEX_NODE = BUCKET_SIZE / 2;
var MIN_ARRAY_NODE = BUCKET_SIZE / 4;

// node_modules/effect/dist/esm/internal/hashMap/bitwise.js
function popcount(x) {
  x -= x >> 1 & 1431655765;
  x = (x & 858993459) + (x >> 2 & 858993459);
  x = x + (x >> 4) & 252645135;
  x += x >> 8;
  x += x >> 16;
  return x & 127;
}
function hashFragment(shift, h) {
  return h >>> shift & MASK;
}
function toBitmap(x) {
  return 1 << x;
}
function fromBitmap(bitmap, bit) {
  return popcount(bitmap & bit - 1);
}

// node_modules/effect/dist/esm/internal/stack.js
var make9 = (value, previous) => ({
  value,
  previous
});

// node_modules/effect/dist/esm/internal/hashMap/array.js
function arrayUpdate(mutate, at, v, arr) {
  let out = arr;
  if (!mutate) {
    const len = arr.length;
    out = new Array(len);
    for (let i = 0;i < len; ++i)
      out[i] = arr[i];
  }
  out[at] = v;
  return out;
}
function arraySpliceOut(mutate, at, arr) {
  const newLen = arr.length - 1;
  let i = 0;
  let g = 0;
  let out = arr;
  if (mutate) {
    i = g = at;
  } else {
    out = new Array(newLen);
    while (i < at)
      out[g++] = arr[i++];
  }
  ++i;
  while (i <= newLen)
    out[g++] = arr[i++];
  if (mutate) {
    out.length = newLen;
  }
  return out;
}
function arraySpliceIn(mutate, at, v, arr) {
  const len = arr.length;
  if (mutate) {
    let i2 = len;
    while (i2 >= at)
      arr[i2--] = arr[i2];
    arr[at] = v;
    return arr;
  }
  let i = 0, g = 0;
  const out = new Array(len + 1);
  while (i < at)
    out[g++] = arr[i++];
  out[at] = v;
  while (i < len)
    out[++g] = arr[i++];
  return out;
}

// node_modules/effect/dist/esm/internal/hashMap/node.js
function isEmptyNode(a) {
  return isTagged(a, "EmptyNode");
}
function isLeafNode(node) {
  return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
}
function canEditNode(node, edit) {
  return isEmptyNode(node) ? false : edit === node.edit;
}
function pack(edit, count, removed, elements) {
  const children = new Array(count - 1);
  let g = 0;
  let bitmap = 0;
  for (let i = 0, len = elements.length;i < len; ++i) {
    if (i !== removed) {
      const elem = elements[i];
      if (elem && !isEmptyNode(elem)) {
        children[g++] = elem;
        bitmap |= 1 << i;
      }
    }
  }
  return new IndexedNode(edit, bitmap, children);
}
function expand(edit, frag, child, bitmap, subNodes) {
  const arr = [];
  let bit = bitmap;
  let count = 0;
  for (let i = 0;bit; ++i) {
    if (bit & 1)
      arr[i] = subNodes[count++];
    bit >>>= 1;
  }
  arr[frag] = child;
  return new ArrayNode(edit, count + 1, arr);
}
function mergeLeavesInner(edit, shift, h1, n1, h2, n2) {
  if (h1 === h2)
    return new CollisionNode(edit, h1, [n2, n1]);
  const subH1 = hashFragment(shift, h1);
  const subH2 = hashFragment(shift, h2);
  if (subH1 === subH2) {
    return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
  } else {
    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
  }
}
function mergeLeaves(edit, shift, h1, n1, h2, n2) {
  let stack = undefined;
  let currentShift = shift;
  while (true) {
    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
    if (typeof res === "function") {
      stack = make9(res, stack);
      currentShift = currentShift + SIZE;
    } else {
      let final = res;
      while (stack != null) {
        final = stack.value(final);
        stack = stack.previous;
      }
      return final;
    }
  }
}

class EmptyNode {
  _tag = "EmptyNode";
  modify(edit, _shift, f, hash2, key, size) {
    const v = f(none2());
    if (isNone2(v))
      return new EmptyNode;
    ++size.value;
    return new LeafNode(edit, hash2, key, v);
  }
}

class LeafNode {
  edit;
  hash;
  key;
  value;
  _tag = "LeafNode";
  constructor(edit, hash2, key, value) {
    this.edit = edit;
    this.hash = hash2;
    this.key = key;
    this.value = value;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (equals(key, this.key)) {
      const v2 = f(this.value);
      if (v2 === this.value)
        return this;
      else if (isNone2(v2)) {
        --size.value;
        return new EmptyNode;
      }
      if (canEditNode(this, edit)) {
        this.value = v2;
        return this;
      }
      return new LeafNode(edit, hash2, key, v2);
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
}

class CollisionNode {
  edit;
  hash;
  children;
  _tag = "CollisionNode";
  constructor(edit, hash2, children) {
    this.edit = edit;
    this.hash = hash2;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    if (hash2 === this.hash) {
      const canEdit = canEditNode(this, edit);
      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);
      if (list === this.children)
        return this;
      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
    }
    const v = f(none2());
    if (isNone2(v))
      return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
  }
  updateCollisionList(mutate, edit, hash2, list, f, key, size) {
    const len = list.length;
    for (let i = 0;i < len; ++i) {
      const child = list[i];
      if ("key" in child && equals(key, child.key)) {
        const value = child.value;
        const newValue2 = f(value);
        if (newValue2 === value)
          return list;
        if (isNone2(newValue2)) {
          --size.value;
          return arraySpliceOut(mutate, i, list);
        }
        return arrayUpdate(mutate, i, new LeafNode(edit, hash2, key, newValue2), list);
      }
    }
    const newValue = f(none2());
    if (isNone2(newValue))
      return list;
    ++size.value;
    return arrayUpdate(mutate, len, new LeafNode(edit, hash2, key, newValue), list);
  }
}

class IndexedNode {
  edit;
  mask;
  children;
  _tag = "IndexedNode";
  constructor(edit, mask, children) {
    this.edit = edit;
    this.mask = mask;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    const mask = this.mask;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const bit = toBitmap(frag);
    const indx = fromBitmap(mask, bit);
    const exists2 = mask & bit;
    const canEdit = canEditNode(this, edit);
    if (!exists2) {
      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash2, key, size);
      if (!_newChild)
        return this;
      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
    }
    const current = children[indx];
    const child = current.modify(edit, shift + SIZE, f, hash2, key, size);
    if (current === child)
      return this;
    let bitmap = mask;
    let newChildren;
    if (isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap)
        return new EmptyNode;
      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
        return children[indx ^ 1];
      }
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return new IndexedNode(edit, bitmap, newChildren);
  }
}

class ArrayNode {
  edit;
  size;
  children;
  _tag = "ArrayNode";
  constructor(edit, size, children) {
    this.edit = edit;
    this.size = size;
    this.children = children;
  }
  modify(edit, shift, f, hash2, key, size) {
    let count = this.size;
    const children = this.children;
    const frag = hashFragment(shift, hash2);
    const child = children[frag];
    const newChild = (child || new EmptyNode).modify(edit, shift + SIZE, f, hash2, key, size);
    if (child === newChild)
      return this;
    const canEdit = canEditNode(this, edit);
    let newChildren;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count;
      if (count <= MIN_ARRAY_NODE) {
        return pack(edit, count, frag, children);
      }
      newChildren = arrayUpdate(canEdit, frag, new EmptyNode, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count;
      this.children = newChildren;
      return this;
    }
    return new ArrayNode(edit, count, newChildren);
  }
}

// node_modules/effect/dist/esm/internal/hashMap.js
var HashMapSymbolKey = "effect/HashMap";
var HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
var HashMapProto = {
  [HashMapTypeId]: HashMapTypeId,
  [Symbol.iterator]() {
    return new HashMapIterator(this, (k, v) => [k, v]);
  },
  [symbol]() {
    let hash2 = hash(HashMapSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isHashMap(that)) {
      if (that._size !== this._size) {
        return false;
      }
      for (const item of this) {
        const elem = pipe(that, getHash(item[0], hash(item[0])));
        if (isNone2(elem)) {
          return false;
        } else {
          if (!equals(item[1], elem.value)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl = (editable, edit, root, size) => {
  const map4 = Object.create(HashMapProto);
  map4._editable = editable;
  map4._edit = edit;
  map4._root = root;
  map4._size = size;
  return map4;
};

class HashMapIterator {
  map;
  f;
  v;
  constructor(map4, f) {
    this.map = map4;
    this.f = f;
    this.v = visitLazy(this.map._root, this.f, undefined);
  }
  next() {
    if (isNone2(this.v)) {
      return {
        done: true,
        value: undefined
      };
    }
    const v0 = this.v.value;
    this.v = applyCont(v0.cont);
    return {
      done: false,
      value: v0.value
    };
  }
  [Symbol.iterator]() {
    return new HashMapIterator(this.map, this.f);
  }
}
var applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none2();
var visitLazy = (node, f, cont = undefined) => {
  switch (node._tag) {
    case "LeafNode": {
      if (isSome2(node.value)) {
        return some2({
          value: f(node.key, node.value.value),
          cont
        });
      }
      return applyCont(cont);
    }
    case "CollisionNode":
    case "ArrayNode":
    case "IndexedNode": {
      const children = node.children;
      return visitLazyChildren(children.length, children, 0, f, cont);
    }
    default: {
      return applyCont(cont);
    }
  }
};
var visitLazyChildren = (len, children, i, f, cont) => {
  while (i < len) {
    const child = children[i++];
    if (child && !isEmptyNode(child)) {
      return visitLazy(child, f, [len, children, i, f, cont]);
    }
  }
  return applyCont(cont);
};
var _empty3 = /* @__PURE__ */ makeImpl(false, 0, /* @__PURE__ */ new EmptyNode, 0);
var empty6 = () => _empty3;
var fromIterable3 = (entries) => {
  const map4 = beginMutation(empty6());
  for (const entry of entries) {
    set2(map4, entry[0], entry[1]);
  }
  return endMutation(map4);
};
var isHashMap = (u) => hasProperty(u, HashMapTypeId);
var isEmpty2 = (self2) => self2 && isEmptyNode(self2._root);
var get5 = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash(key)));
var getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
  let node = self2._root;
  let shift = 0;
  while (true) {
    switch (node._tag) {
      case "LeafNode": {
        return equals(key, node.key) ? node.value : none2();
      }
      case "CollisionNode": {
        if (hash2 === node.hash) {
          const children = node.children;
          for (let i = 0, len = children.length;i < len; ++i) {
            const child = children[i];
            if ("key" in child && equals(key, child.key)) {
              return child.value;
            }
          }
        }
        return none2();
      }
      case "IndexedNode": {
        const frag = hashFragment(shift, hash2);
        const bit = toBitmap(frag);
        if (node.mask & bit) {
          node = node.children[fromBitmap(node.mask, bit)];
          shift += SIZE;
          break;
        }
        return none2();
      }
      case "ArrayNode": {
        node = node.children[hashFragment(shift, hash2)];
        if (node) {
          shift += SIZE;
          break;
        }
        return none2();
      }
      default:
        return none2();
    }
  }
});
var has = /* @__PURE__ */ dual(2, (self2, key) => isSome2(getHash(self2, key, hash(key))));
var set2 = /* @__PURE__ */ dual(3, (self2, key, value) => modifyAt(self2, key, () => some2(value)));
var setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
  if (self2._editable) {
    self2._root = newRoot;
    self2._size = newSize;
    return self2;
  }
  return newRoot === self2._root ? self2 : makeImpl(self2._editable, self2._edit, newRoot, newSize);
});
var keys = (self2) => new HashMapIterator(self2, (key) => key);
var size = (self2) => self2._size;
var beginMutation = (self2) => makeImpl(true, self2._edit + 1, self2._root, self2._size);
var endMutation = (self2) => {
  self2._editable = false;
  return self2;
};
var mutate = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation(self2);
  f(transient);
  return endMutation(transient);
});
var modifyAt = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash(key), f));
var modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
  const size2 = {
    value: self2._size
  };
  const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
  return pipe(self2, setTree(newRoot, size2.value));
});
var remove2 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt(self2, key, none2));
var map4 = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, empty6(), (map5, value, key) => set2(map5, key, f(value, key))));
var forEach = /* @__PURE__ */ dual(2, (self2, f) => reduce3(self2, undefined, (_, value, key) => f(value, key)));
var reduce3 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  const root = self2._root;
  if (root._tag === "LeafNode") {
    return isSome2(root.value) ? f(zero3, root.value.value, root.key) : zero3;
  }
  if (root._tag === "EmptyNode") {
    return zero3;
  }
  const toVisit = [root.children];
  let children;
  while (children = toVisit.pop()) {
    for (let i = 0, len = children.length;i < len; ) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        if (child._tag === "LeafNode") {
          if (isSome2(child.value)) {
            zero3 = f(zero3, child.value.value, child.key);
          }
        } else {
          toVisit.push(child.children);
        }
      }
    }
  }
  return zero3;
});

// node_modules/effect/dist/esm/internal/hashSet.js
var HashSetSymbolKey = "effect/HashSet";
var HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
var HashSetProto = {
  [HashSetTypeId]: HashSetTypeId,
  [Symbol.iterator]() {
    return keys(this._keyMap);
  },
  [symbol]() {
    return cached(this, combine(hash(this._keyMap))(hash(HashSetSymbolKey)));
  },
  [symbol2](that) {
    if (isHashSet(that)) {
      return size(this._keyMap) === size(that._keyMap) && equals(this._keyMap, that._keyMap);
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "HashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (keyMap) => {
  const set3 = Object.create(HashSetProto);
  set3._keyMap = keyMap;
  return set3;
};
var isHashSet = (u) => hasProperty(u, HashSetTypeId);
var _empty4 = /* @__PURE__ */ makeImpl2(/* @__PURE__ */ empty6());
var empty7 = () => _empty4;
var fromIterable4 = (elements) => {
  const set3 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set3, value);
  }
  return endMutation2(set3);
};
var make10 = (...elements) => {
  const set3 = beginMutation2(empty7());
  for (const value of elements) {
    add3(set3, value);
  }
  return endMutation2(set3);
};
var has2 = /* @__PURE__ */ dual(2, (self2, value) => has(self2._keyMap, value));
var size2 = (self2) => size(self2._keyMap);
var beginMutation2 = (self2) => makeImpl2(beginMutation(self2._keyMap));
var endMutation2 = (self2) => {
  self2._keyMap._editable = false;
  return self2;
};
var mutate2 = /* @__PURE__ */ dual(2, (self2, f) => {
  const transient = beginMutation2(self2);
  f(transient);
  return endMutation2(transient);
});
var add3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (set2(value, true)(self2._keyMap), self2) : makeImpl2(set2(value, true)(self2._keyMap)));
var remove3 = /* @__PURE__ */ dual(2, (self2, value) => self2._keyMap._editable ? (remove2(value)(self2._keyMap), self2) : makeImpl2(remove2(value)(self2._keyMap)));
var difference2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(self2, (set3) => {
  for (const value of that) {
    remove3(set3, value);
  }
}));
var union2 = /* @__PURE__ */ dual(2, (self2, that) => mutate2(empty7(), (set3) => {
  forEach2(self2, (value) => add3(set3, value));
  for (const value of that) {
    add3(set3, value);
  }
}));
var forEach2 = /* @__PURE__ */ dual(2, (self2, f) => forEach(self2._keyMap, (_, k) => f(k)));
var reduce4 = /* @__PURE__ */ dual(3, (self2, zero3, f) => reduce3(self2._keyMap, zero3, (z, _, a) => f(z, a)));

// node_modules/effect/dist/esm/HashSet.js
var isHashSet2 = isHashSet;
var empty8 = empty7;
var fromIterable5 = fromIterable4;
var make11 = make10;
var has3 = has2;
var size3 = size2;
var add4 = add3;
var remove4 = remove3;
var difference3 = difference2;
var union3 = union2;
var forEach3 = forEach2;
var reduce5 = reduce4;

// node_modules/effect/dist/esm/MutableRef.js
var TypeId7 = /* @__PURE__ */ Symbol.for("effect/MutableRef");
var MutableRefProto = {
  [TypeId7]: TypeId7,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableRef",
      current: toJSON(this.current)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make12 = (value) => {
  const ref = Object.create(MutableRefProto);
  ref.current = value;
  return ref;
};
var compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
  if (equals(oldValue, self2.current)) {
    self2.current = newValue;
    return true;
  }
  return false;
});
var get6 = (self2) => self2.current;
var set3 = /* @__PURE__ */ dual(2, (self2, value) => {
  self2.current = value;
  return self2;
});

// node_modules/effect/dist/esm/internal/fiberId.js
var FiberIdSymbolKey = "effect/FiberId";
var FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
var OP_NONE = "None";
var OP_RUNTIME = "Runtime";
var OP_COMPOSITE = "Composite";
var emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);

class None {
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_NONE;
  id = -1;
  startTimeMillis = -1;
  [symbol]() {
    return emptyHash;
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_NONE;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Runtime {
  id;
  startTimeMillis;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_RUNTIME;
  constructor(id, startTimeMillis) {
    this.id = id;
    this.startTimeMillis = startTimeMillis;
  }
  [symbol]() {
    return cached(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      id: this.id,
      startTimeMillis: this.startTimeMillis
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}

class Composite {
  left;
  right;
  [FiberIdTypeId] = FiberIdTypeId;
  _tag = OP_COMPOSITE;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  _hash;
  [symbol]() {
    return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine(hash(this.left)), combine(hash(this.right)), cached(this));
  }
  [symbol2](that) {
    return isFiberId(that) && that._tag === OP_COMPOSITE && equals(this.left, that.left) && equals(this.right, that.right);
  }
  toString() {
    return format(this.toJSON());
  }
  toJSON() {
    return {
      _id: "FiberId",
      _tag: this._tag,
      left: toJSON(this.left),
      right: toJSON(this.right)
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var none3 = /* @__PURE__ */ new None;
var runtime = (id, startTimeMillis) => {
  return new Runtime(id, startTimeMillis);
};
var composite = (left3, right3) => {
  return new Composite(left3, right3);
};
var isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
var combine2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2._tag === OP_NONE) {
    return that;
  }
  if (that._tag === OP_NONE) {
    return self2;
  }
  return new Composite(self2, that);
});
var ids = (self2) => {
  switch (self2._tag) {
    case OP_NONE: {
      return empty8();
    }
    case OP_RUNTIME: {
      return make11(self2.id);
    }
    case OP_COMPOSITE: {
      return pipe(ids(self2.left), union3(ids(self2.right)));
    }
  }
};
var _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make12(0));
var threadName = (self2) => {
  const identifiers = Array.from(ids(self2)).map((n) => `#${n}`).join(",");
  return identifiers;
};
var unsafeMake2 = () => {
  const id = get6(_fiberCounter);
  pipe(_fiberCounter, set3(id + 1));
  return new Runtime(id, Date.now());
};

// node_modules/effect/dist/esm/FiberId.js
var none4 = none3;
var runtime2 = runtime;
var composite2 = composite;
var isFiberId2 = isFiberId;
var combine3 = combine2;
var threadName2 = threadName;
var unsafeMake3 = unsafeMake2;

// node_modules/effect/dist/esm/HashMap.js
var isHashMap2 = isHashMap;
var empty9 = empty6;
var fromIterable6 = fromIterable3;
var isEmpty3 = isEmpty2;
var get7 = get5;
var set4 = set2;
var keys2 = keys;
var mutate3 = mutate;
var modifyAt2 = modifyAt;
var map6 = map4;
var forEach4 = forEach;
var reduce6 = reduce3;

// node_modules/effect/dist/esm/List.js
var TypeId8 = /* @__PURE__ */ Symbol.for("effect/List");
var toArray2 = (self2) => fromIterable(self2);
var getEquivalence5 = (isEquivalent) => mapInput(getEquivalence3(isEquivalent), toArray2);
var _equivalence4 = /* @__PURE__ */ getEquivalence5(equals);
var ConsProto = {
  [TypeId8]: TypeId8,
  _tag: "Cons",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Cons",
      values: toArray2(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag && _equivalence4(this, that);
  },
  [symbol]() {
    return cached(this, array2(toArray2(this)));
  },
  [Symbol.iterator]() {
    let done = false;
    let self2 = this;
    return {
      next() {
        if (done) {
          return this.return();
        }
        if (self2._tag === "Nil") {
          done = true;
          return this.return();
        }
        const value = self2.head;
        self2 = self2.tail;
        return {
          done,
          value
        };
      },
      return(value) {
        if (!done) {
          done = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeCons = (head3, tail) => {
  const cons = Object.create(ConsProto);
  cons.head = head3;
  cons.tail = tail;
  return cons;
};
var NilHash = /* @__PURE__ */ string("Nil");
var NilProto = {
  [TypeId8]: TypeId8,
  _tag: "Nil",
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "List",
      _tag: "Nil"
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  [symbol]() {
    return NilHash;
  },
  [symbol2](that) {
    return isList(that) && this._tag === that._tag;
  },
  [Symbol.iterator]() {
    return {
      next() {
        return {
          done: true,
          value: undefined
        };
      }
    };
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var _Nil = /* @__PURE__ */ Object.create(NilProto);
var isList = (u) => hasProperty(u, TypeId8);
var isNil = (self2) => self2._tag === "Nil";
var isCons = (self2) => self2._tag === "Cons";
var nil = () => _Nil;
var cons = (head3, tail) => makeCons(head3, tail);
var empty10 = nil;
var of3 = (value) => makeCons(value, _Nil);
var fromIterable7 = (prefix) => {
  const iterator = prefix[Symbol.iterator]();
  let next;
  if ((next = iterator.next()) && !next.done) {
    const result = makeCons(next.value, _Nil);
    let curr = result;
    while ((next = iterator.next()) && !next.done) {
      const temp = makeCons(next.value, _Nil);
      curr.tail = temp;
      curr = temp;
    }
    return result;
  } else {
    return _Nil;
  }
};
var appendAll3 = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
var prepend3 = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
var prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
  if (isNil(self2)) {
    return prefix;
  } else if (isNil(prefix)) {
    return self2;
  } else {
    const result = makeCons(prefix.head, self2);
    let curr = result;
    let that = prefix.tail;
    while (!isNil(that)) {
      const temp = makeCons(that.head, self2);
      curr.tail = temp;
      curr = temp;
      that = that.tail;
    }
    return result;
  }
});
var reduce7 = /* @__PURE__ */ dual(3, (self2, zero3, f) => {
  let acc = zero3;
  let these = self2;
  while (!isNil(these)) {
    acc = f(acc, these.head);
    these = these.tail;
  }
  return acc;
});
var reverse3 = (self2) => {
  let result = empty10();
  let these = self2;
  while (!isNil(these)) {
    result = prepend3(result, these.head);
    these = these.tail;
  }
  return result;
};

// node_modules/effect/dist/esm/internal/data.js
var ArrayProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(Array.prototype), {
  [symbol]() {
    return cached(this, array2(this));
  },
  [symbol2](that) {
    if (Array.isArray(that) && this.length === that.length) {
      return this.every((v, i) => equals(v, that[i]));
    } else {
      return false;
    }
  }
});
var Structural = /* @__PURE__ */ function() {
  function Structural2(args) {
    if (args) {
      Object.assign(this, args);
    }
  }
  Structural2.prototype = StructuralPrototype;
  return Structural2;
}();
var struct = (as) => Object.assign(Object.create(StructuralPrototype), as);

// node_modules/effect/dist/esm/internal/differ/chunkPatch.js
function variance(a) {
  return a;
}
var ChunkPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferChunkPatch");
var PatchProto = {
  ...Structural.prototype,
  [ChunkPatchTypeId]: {
    _Value: variance,
    _Patch: variance
  }
};

// node_modules/effect/dist/esm/internal/differ/contextPatch.js
function variance2(a) {
  return a;
}
var ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
var PatchProto2 = {
  ...Structural.prototype,
  [ContextPatchTypeId]: {
    _Value: variance2,
    _Patch: variance2
  }
};
var EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "Empty"
});
var _empty5 = /* @__PURE__ */ Object.create(EmptyProto);
var empty11 = () => _empty5;
var AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AndThen"
});
var makeAndThen = (first, second) => {
  const o = Object.create(AndThenProto);
  o.first = first;
  o.second = second;
  return o;
};
var AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "AddService"
});
var makeAddService = (key, service) => {
  const o = Object.create(AddServiceProto);
  o.key = key;
  o.service = service;
  return o;
};
var RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "RemoveService"
});
var makeRemoveService = (key) => {
  const o = Object.create(RemoveServiceProto);
  o.key = key;
  return o;
};
var UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto2), {
  _tag: "UpdateService"
});
var makeUpdateService = (key, update) => {
  const o = Object.create(UpdateServiceProto);
  o.key = key;
  o.update = update;
  return o;
};
var diff = (oldValue, newValue) => {
  const missingServices = new Map(oldValue.unsafeMap);
  let patch = empty11();
  for (const [tag, newService] of newValue.unsafeMap.entries()) {
    if (missingServices.has(tag)) {
      const old = missingServices.get(tag);
      missingServices.delete(tag);
      if (!equals(old, newService)) {
        patch = combine4(makeUpdateService(tag, () => newService))(patch);
      }
    } else {
      missingServices.delete(tag);
      patch = combine4(makeAddService(tag, newService))(patch);
    }
  }
  for (const [tag] of missingServices.entries()) {
    patch = combine4(makeRemoveService(tag))(patch);
  }
  return patch;
};
var combine4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
var patch = /* @__PURE__ */ dual(2, (self2, context) => {
  if (self2._tag === "Empty") {
    return context;
  }
  let wasServiceUpdated = false;
  let patches = of2(self2);
  const updatedContext = new Map(context.unsafeMap);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AddService": {
        updatedContext.set(head3.key, head3.service);
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(prepend2(tail, head3.second), head3.first);
        break;
      }
      case "RemoveService": {
        updatedContext.delete(head3.key);
        patches = tail;
        break;
      }
      case "UpdateService": {
        updatedContext.set(head3.key, head3.update(updatedContext.get(head3.key)));
        wasServiceUpdated = true;
        patches = tail;
        break;
      }
    }
  }
  if (!wasServiceUpdated) {
    return makeContext(updatedContext);
  }
  const map7 = new Map;
  for (const [tag] of context.unsafeMap) {
    if (updatedContext.has(tag)) {
      map7.set(tag, updatedContext.get(tag));
      updatedContext.delete(tag);
    }
  }
  for (const [tag, s] of updatedContext) {
    map7.set(tag, s);
  }
  return makeContext(map7);
});

// node_modules/effect/dist/esm/internal/differ/hashMapPatch.js
function variance3(a) {
  return a;
}
var HashMapPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashMapPatch");
var PatchProto3 = {
  ...Structural.prototype,
  [HashMapPatchTypeId]: {
    _Value: variance3,
    _Key: variance3,
    _Patch: variance3
  }
};

// node_modules/effect/dist/esm/internal/differ/hashSetPatch.js
function variance4(a) {
  return a;
}
var HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
var PatchProto4 = {
  ...Structural.prototype,
  [HashSetPatchTypeId]: {
    _Value: variance4,
    _Key: variance4,
    _Patch: variance4
  }
};
var EmptyProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Empty"
});
var _empty6 = /* @__PURE__ */ Object.create(EmptyProto2);
var empty12 = () => _empty6;
var AndThenProto2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "AndThen"
});
var makeAndThen2 = (first, second) => {
  const o = Object.create(AndThenProto2);
  o.first = first;
  o.second = second;
  return o;
};
var AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Add"
});
var makeAdd = (value) => {
  const o = Object.create(AddProto);
  o.value = value;
  return o;
};
var RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto4), {
  _tag: "Remove"
});
var makeRemove = (value) => {
  const o = Object.create(RemoveProto);
  o.value = value;
  return o;
};
var diff2 = (oldValue, newValue) => {
  const [removed, patch2] = reduce5([oldValue, empty12()], ([set5, patch3], value) => {
    if (has3(value)(set5)) {
      return [remove4(value)(set5), patch3];
    }
    return [set5, combine5(makeAdd(value))(patch3)];
  })(newValue);
  return reduce5(patch2, (patch3, value) => combine5(makeRemove(value))(patch3))(removed);
};
var combine5 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen2(self2, that));
var patch2 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let set5 = oldValue;
  let patches = of2(self2);
  while (isNonEmpty2(patches)) {
    const head3 = headNonEmpty2(patches);
    const tail = tailNonEmpty2(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        patches = prepend2(head3.first)(prepend2(head3.second)(tail));
        break;
      }
      case "Add": {
        set5 = add4(head3.value)(set5);
        patches = tail;
        break;
      }
      case "Remove": {
        set5 = remove4(head3.value)(set5);
        patches = tail;
      }
    }
  }
  return set5;
});

// node_modules/effect/dist/esm/internal/differ/orPatch.js
function variance5(a) {
  return a;
}
var OrPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferOrPatch");
var PatchProto5 = {
  ...Structural.prototype,
  [OrPatchTypeId]: {
    _Value: variance5,
    _Key: variance5,
    _Patch: variance5
  }
};

// node_modules/effect/dist/esm/internal/differ/readonlyArrayPatch.js
function variance6(a) {
  return a;
}
var ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
var PatchProto6 = {
  ...Structural.prototype,
  [ReadonlyArrayPatchTypeId]: {
    _Value: variance6,
    _Patch: variance6
  }
};
var EmptyProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Empty"
});
var _empty7 = /* @__PURE__ */ Object.create(EmptyProto3);
var empty13 = () => _empty7;
var AndThenProto3 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "AndThen"
});
var makeAndThen3 = (first, second) => {
  const o = Object.create(AndThenProto3);
  o.first = first;
  o.second = second;
  return o;
};
var AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Append"
});
var makeAppend = (values3) => {
  const o = Object.create(AppendProto);
  o.values = values3;
  return o;
};
var SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Slice"
});
var makeSlice = (from, until) => {
  const o = Object.create(SliceProto);
  o.from = from;
  o.until = until;
  return o;
};
var UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto6), {
  _tag: "Update"
});
var makeUpdate = (index, patch3) => {
  const o = Object.create(UpdateProto);
  o.index = index;
  o.patch = patch3;
  return o;
};
var diff3 = (options) => {
  let i = 0;
  let patch3 = empty13();
  while (i < options.oldValue.length && i < options.newValue.length) {
    const oldElement = options.oldValue[i];
    const newElement = options.newValue[i];
    const valuePatch = options.differ.diff(oldElement, newElement);
    if (!equals(valuePatch, options.differ.empty)) {
      patch3 = combine6(patch3, makeUpdate(i, valuePatch));
    }
    i = i + 1;
  }
  if (i < options.oldValue.length) {
    patch3 = combine6(patch3, makeSlice(0, i));
  }
  if (i < options.newValue.length) {
    patch3 = combine6(patch3, makeAppend(drop(i)(options.newValue)));
  }
  return patch3;
};
var combine6 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen3(self2, that));
var patch3 = /* @__PURE__ */ dual(3, (self2, oldValue, differ) => {
  if (self2._tag === "Empty") {
    return oldValue;
  }
  let readonlyArray = oldValue.slice();
  let patches = of(self2);
  while (isNonEmptyArray2(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case "Empty": {
        patches = tail;
        break;
      }
      case "AndThen": {
        tail.unshift(head3.first, head3.second);
        patches = tail;
        break;
      }
      case "Append": {
        for (const value of head3.values) {
          readonlyArray.push(value);
        }
        patches = tail;
        break;
      }
      case "Slice": {
        readonlyArray = readonlyArray.slice(head3.from, head3.until);
        patches = tail;
        break;
      }
      case "Update": {
        readonlyArray[head3.index] = differ.patch(head3.patch, readonlyArray[head3.index]);
        patches = tail;
        break;
      }
    }
  }
  return readonlyArray;
});

// node_modules/effect/dist/esm/internal/differ.js
var DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
var DifferProto = {
  [DifferTypeId]: {
    _P: identity,
    _V: identity
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make15 = (params) => {
  const differ = Object.create(DifferProto);
  differ.empty = params.empty;
  differ.diff = params.diff;
  differ.combine = params.combine;
  differ.patch = params.patch;
  return differ;
};
var environment = () => make15({
  empty: empty11(),
  combine: (first, second) => combine4(second)(first),
  diff: (oldValue, newValue) => diff(oldValue, newValue),
  patch: (patch7, oldValue) => patch(oldValue)(patch7)
});
var hashSet = () => make15({
  empty: empty12(),
  combine: (first, second) => combine5(second)(first),
  diff: (oldValue, newValue) => diff2(oldValue, newValue),
  patch: (patch7, oldValue) => patch2(oldValue)(patch7)
});
var readonlyArray = (differ) => make15({
  empty: empty13(),
  combine: (first, second) => combine6(first, second),
  diff: (oldValue, newValue) => diff3({
    oldValue,
    newValue,
    differ
  }),
  patch: (patch7, oldValue) => patch3(patch7, oldValue, differ)
});
var update = () => updateWith((_, a) => a);
var updateWith = (f) => make15({
  empty: identity,
  combine: (first, second) => {
    if (first === identity) {
      return second;
    }
    if (second === identity) {
      return first;
    }
    return (a) => second(first(a));
  },
  diff: (oldValue, newValue) => {
    if (equals(oldValue, newValue)) {
      return identity;
    }
    return constant(newValue);
  },
  patch: (patch7, oldValue) => f(oldValue, patch7(oldValue))
});

// node_modules/effect/dist/esm/internal/runtimeFlagsPatch.js
var BIT_MASK = 255;
var BIT_SHIFT = 8;
var active = (patch7) => patch7 & BIT_MASK;
var enabled = (patch7) => patch7 >> BIT_SHIFT & BIT_MASK;
var make16 = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
var empty17 = /* @__PURE__ */ make16(0, 0);
var enable = (flag) => make16(flag, flag);
var disable = (flag) => make16(flag, 0);
var exclude = /* @__PURE__ */ dual(2, (self2, flag) => make16(active(self2) & ~flag, enabled(self2)));
var andThen = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
var invert = (n) => ~n >>> 0 & BIT_MASK;

// node_modules/effect/dist/esm/internal/runtimeFlags.js
var None2 = 0;
var Interruption = 1 << 0;
var OpSupervision = 1 << 1;
var RuntimeMetrics = 1 << 2;
var WindDown = 1 << 4;
var CooperativeYielding = 1 << 5;
var cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
var disable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 & ~flag);
var enable2 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
var interruptible = (self2) => interruption(self2) && !windDown(self2);
var interruption = (self2) => isEnabled(self2, Interruption);
var isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
var make17 = (...flags) => flags.reduce((a, b) => a | b, 0);
var none5 = /* @__PURE__ */ make17(None2);
var runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
var windDown = (self2) => isEnabled(self2, WindDown);
var diff7 = /* @__PURE__ */ dual(2, (self2, that) => make16(self2 ^ that, that));
var patch7 = /* @__PURE__ */ dual(2, (self2, patch8) => self2 & (invert(active(patch8)) | enabled(patch8)) | active(patch8) & enabled(patch8));
var differ = /* @__PURE__ */ make15({
  empty: empty17,
  diff: (oldValue, newValue) => diff7(oldValue, newValue),
  combine: (first, second) => andThen(second)(first),
  patch: (_patch, oldValue) => patch7(oldValue, _patch)
});

// node_modules/effect/dist/esm/RuntimeFlagsPatch.js
var empty18 = empty17;
var enable3 = enable;
var disable3 = disable;
var exclude2 = exclude;

// node_modules/effect/dist/esm/internal/blockedRequests.js
var empty19 = {
  _tag: "Empty"
};
var par = (self2, that) => ({
  _tag: "Par",
  left: self2,
  right: that
});
var seq = (self2, that) => ({
  _tag: "Seq",
  left: self2,
  right: that
});
var single = (dataSource, blockedRequest) => ({
  _tag: "Single",
  dataSource,
  blockedRequest
});
var flatten3 = (self2) => {
  let current = of3(self2);
  let updated = empty10();
  while (true) {
    const [parallel, sequential] = reduce7(current, [parallelCollectionEmpty(), empty10()], ([parallel2, sequential2], blockedRequest) => {
      const [par2, seq2] = step(blockedRequest);
      return [parallelCollectionCombine(parallel2, par2), appendAll3(sequential2, seq2)];
    });
    updated = merge4(updated, parallel);
    if (isNil(sequential)) {
      return reverse3(updated);
    }
    current = sequential;
  }
  throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var step = (requests) => {
  let current = requests;
  let parallel = parallelCollectionEmpty();
  let stack = empty10();
  let sequential = empty10();
  while (true) {
    switch (current._tag) {
      case "Empty": {
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
      case "Par": {
        stack = cons(current.right, stack);
        current = current.left;
        break;
      }
      case "Seq": {
        const left3 = current.left;
        const right3 = current.right;
        switch (left3._tag) {
          case "Empty": {
            current = right3;
            break;
          }
          case "Par": {
            const l = left3.left;
            const r = left3.right;
            current = par(seq(l, right3), seq(r, right3));
            break;
          }
          case "Seq": {
            const l = left3.left;
            const r = left3.right;
            current = seq(l, seq(r, right3));
            break;
          }
          case "Single": {
            current = left3;
            sequential = cons(right3, sequential);
            break;
          }
        }
        break;
      }
      case "Single": {
        parallel = parallelCollectionAdd(parallel, current);
        if (isNil(stack)) {
          return [parallel, sequential];
        }
        current = stack.head;
        stack = stack.tail;
        break;
      }
    }
  }
  throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
};
var merge4 = (sequential, parallel) => {
  if (isNil(sequential)) {
    return of3(parallelCollectionToSequentialCollection(parallel));
  }
  if (parallelCollectionIsEmpty(parallel)) {
    return sequential;
  }
  const seqHeadKeys = sequentialCollectionKeys(sequential.head);
  const parKeys = parallelCollectionKeys(parallel);
  if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals(seqHeadKeys[0], parKeys[0])) {
    return cons(sequentialCollectionCombine(sequential.head, parallelCollectionToSequentialCollection(parallel)), sequential.tail);
  }
  return cons(parallelCollectionToSequentialCollection(parallel), sequential);
};
var EntryTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/Entry");

class EntryImpl {
  request;
  result;
  listeners;
  ownerId;
  state;
  [EntryTypeId] = blockedRequestVariance;
  constructor(request, result, listeners, ownerId, state) {
    this.request = request;
    this.result = result;
    this.listeners = listeners;
    this.ownerId = ownerId;
    this.state = state;
  }
}
var blockedRequestVariance = {
  _R: (_) => _
};
var makeEntry = (options) => new EntryImpl(options.request, options.result, options.listeners, options.ownerId, options.state);
var RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
var parallelVariance = {
  _R: (_) => _
};

class ParallelImpl {
  map;
  [RequestBlockParallelTypeId] = parallelVariance;
  constructor(map7) {
    this.map = map7;
  }
}
var parallelCollectionEmpty = () => new ParallelImpl(empty9());
var parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt2(self2.map, blockedRequest.dataSource, (_) => orElseSome(map2(_, append2(blockedRequest.blockedRequest)), () => of2(blockedRequest.blockedRequest))));
var parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce6(self2.map, that.map, (map7, value, key) => set4(map7, key, match2(get7(map7, key), {
  onNone: () => value,
  onSome: (other) => appendAll2(value, other)
}))));
var parallelCollectionIsEmpty = (self2) => isEmpty3(self2.map);
var parallelCollectionKeys = (self2) => Array.from(keys2(self2.map));
var parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map6(self2.map, (x) => of2(x)));
var SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
var sequentialVariance = {
  _R: (_) => _
};

class SequentialImpl {
  map;
  [SequentialCollectionTypeId] = sequentialVariance;
  constructor(map7) {
    this.map = map7;
  }
}
var sequentialCollectionMake = (map7) => new SequentialImpl(map7);
var sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce6(that.map, self2.map, (map7, value, key) => set4(map7, key, match2(get7(map7, key), {
  onNone: () => empty5(),
  onSome: (a) => appendAll2(a, value)
}))));
var sequentialCollectionKeys = (self2) => Array.from(keys2(self2.map));
var sequentialCollectionToChunk = (self2) => Array.from(self2.map);

// node_modules/effect/dist/esm/internal/opCodes/cause.js
var OP_DIE = "Die";
var OP_EMPTY = "Empty";
var OP_FAIL = "Fail";
var OP_INTERRUPT = "Interrupt";
var OP_PARALLEL = "Parallel";
var OP_SEQUENTIAL = "Sequential";

// node_modules/effect/dist/esm/internal/cause.js
var CauseSymbolKey = "effect/Cause";
var CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
var variance7 = {
  _E: (_) => _
};
var proto = {
  [CauseTypeId]: variance7,
  [symbol]() {
    return pipe(hash(CauseSymbolKey), combine(hash(flattenCause(this))), cached(this));
  },
  [symbol2](that) {
    return isCause(that) && causeEquals(this, that);
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toJSON() {
    switch (this._tag) {
      case "Empty":
        return {
          _id: "Cause",
          _tag: this._tag
        };
      case "Die":
        return {
          _id: "Cause",
          _tag: this._tag,
          defect: toJSON(this.defect)
        };
      case "Interrupt":
        return {
          _id: "Cause",
          _tag: this._tag,
          fiberId: this.fiberId.toJSON()
        };
      case "Fail":
        return {
          _id: "Cause",
          _tag: this._tag,
          failure: toJSON(this.error)
        };
      case "Sequential":
      case "Parallel":
        return {
          _id: "Cause",
          _tag: this._tag,
          left: toJSON(this.left),
          right: toJSON(this.right)
        };
    }
  },
  toString() {
    return pretty(this);
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
};
var empty20 = /* @__PURE__ */ (() => {
  const o = /* @__PURE__ */ Object.create(proto);
  o._tag = OP_EMPTY;
  return o;
})();
var fail = (error) => {
  const o = Object.create(proto);
  o._tag = OP_FAIL;
  o.error = error;
  return o;
};
var die = (defect) => {
  const o = Object.create(proto);
  o._tag = OP_DIE;
  o.defect = defect;
  return o;
};
var interrupt = (fiberId) => {
  const o = Object.create(proto);
  o._tag = OP_INTERRUPT;
  o.fiberId = fiberId;
  return o;
};
var parallel = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_PARALLEL;
  o.left = left3;
  o.right = right3;
  return o;
};
var sequential = (left3, right3) => {
  const o = Object.create(proto);
  o._tag = OP_SEQUENTIAL;
  o.left = left3;
  o.right = right3;
  return o;
};
var isCause = (u) => hasProperty(u, CauseTypeId);
var isEmptyType = (self2) => self2._tag === OP_EMPTY;
var isFailType = (self2) => self2._tag === OP_FAIL;
var isDieType = (self2) => self2._tag === OP_DIE;
var isEmpty5 = (self2) => {
  if (self2._tag === OP_EMPTY) {
    return true;
  }
  return reduce8(self2, true, (acc, cause) => {
    switch (cause._tag) {
      case OP_EMPTY: {
        return some2(acc);
      }
      case OP_DIE:
      case OP_FAIL:
      case OP_INTERRUPT: {
        return some2(false);
      }
      default: {
        return none2();
      }
    }
  });
};
var isInterrupted = (self2) => isSome2(interruptOption(self2));
var isInterruptedOnly = (self2) => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self2);
var failures = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_FAIL ? some2(pipe(list, prepend2(cause.error))) : none2()));
var defects = (self2) => reverse2(reduce8(self2, empty5(), (list, cause) => cause._tag === OP_DIE ? some2(pipe(list, prepend2(cause.defect))) : none2()));
var interruptors = (self2) => reduce8(self2, empty8(), (set5, cause) => cause._tag === OP_INTERRUPT ? some2(pipe(set5, add4(cause.fiberId))) : none2());
var failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL ? some2(cause.error) : none2());
var failureOrCause = (self2) => {
  const option = failureOption(self2);
  switch (option._tag) {
    case "None": {
      return right2(self2);
    }
    case "Some": {
      return left2(option.value);
    }
  }
};
var interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT ? some2(cause.fiberId) : none2());
var keepDefects = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: () => none2(),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var keepDefectsAndElectFailures = (self2) => match5(self2, {
  onEmpty: none2(),
  onFail: (failure) => some2(die(failure)),
  onDie: (defect) => some2(die(defect)),
  onInterrupt: () => none2(),
  onSequential: mergeWith(sequential),
  onParallel: mergeWith(parallel)
});
var stripFailures = (self2) => match5(self2, {
  onEmpty: empty20,
  onFail: () => empty20,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var electFailures = (self2) => match5(self2, {
  onEmpty: empty20,
  onFail: die,
  onDie: die,
  onInterrupt: interrupt,
  onSequential: sequential,
  onParallel: parallel
});
var flatMap6 = /* @__PURE__ */ dual(2, (self2, f) => match5(self2, {
  onEmpty: empty20,
  onFail: (error) => f(error),
  onDie: (defect) => die(defect),
  onInterrupt: (fiberId) => interrupt(fiberId),
  onSequential: (left3, right3) => sequential(left3, right3),
  onParallel: (left3, right3) => parallel(left3, right3)
}));
var flatten4 = (self2) => flatMap6(self2, identity);
var causeEquals = (left3, right3) => {
  let leftStack = of2(left3);
  let rightStack = of2(right3);
  while (isNonEmpty2(leftStack) && isNonEmpty2(rightStack)) {
    const [leftParallel, leftSequential] = pipe(headNonEmpty2(leftStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    const [rightParallel, rightSequential] = pipe(headNonEmpty2(rightStack), reduce8([empty8(), empty5()], ([parallel2, sequential2], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return some2([pipe(parallel2, union3(par2)), pipe(sequential2, appendAll2(seq2))]);
    }));
    if (!equals(leftParallel, rightParallel)) {
      return false;
    }
    leftStack = leftSequential;
    rightStack = rightSequential;
  }
  return true;
};
var flattenCause = (cause) => {
  return flattenCauseLoop(of2(cause), empty5());
};
var flattenCauseLoop = (causes, flattened) => {
  while (true) {
    const [parallel2, sequential2] = pipe(causes, reduce([empty8(), empty5()], ([parallel3, sequential3], cause) => {
      const [par2, seq2] = evaluateCause(cause);
      return [pipe(parallel3, union3(par2)), pipe(sequential3, appendAll2(seq2))];
    }));
    const updated = size3(parallel2) > 0 ? pipe(flattened, prepend2(parallel2)) : flattened;
    if (isEmpty(sequential2)) {
      return reverse2(updated);
    }
    causes = sequential2;
    flattened = updated;
  }
  throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
};
var find = /* @__PURE__ */ dual(2, (self2, pf) => {
  const stack = [self2];
  while (stack.length > 0) {
    const item = stack.pop();
    const option = pf(item);
    switch (option._tag) {
      case "None": {
        switch (item._tag) {
          case OP_SEQUENTIAL:
          case OP_PARALLEL: {
            stack.push(item.right);
            stack.push(item.left);
            break;
          }
        }
        break;
      }
      case "Some": {
        return option;
      }
    }
  }
  return none2();
});
var evaluateCause = (self2) => {
  let cause = self2;
  const stack = [];
  let _parallel = empty8();
  let _sequential = empty5();
  while (cause !== undefined) {
    switch (cause._tag) {
      case OP_EMPTY: {
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_FAIL: {
        _parallel = add4(_parallel, make7(cause._tag, cause.error));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_DIE: {
        _parallel = add4(_parallel, make7(cause._tag, cause.defect));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_INTERRUPT: {
        _parallel = add4(_parallel, make7(cause._tag, cause.fiberId));
        if (stack.length === 0) {
          return [_parallel, _sequential];
        }
        cause = stack.pop();
        break;
      }
      case OP_SEQUENTIAL: {
        switch (cause.left._tag) {
          case OP_EMPTY: {
            cause = cause.right;
            break;
          }
          case OP_SEQUENTIAL: {
            cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));
            break;
          }
          case OP_PARALLEL: {
            cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));
            break;
          }
          default: {
            _sequential = prepend2(_sequential, cause.right);
            cause = cause.left;
            break;
          }
        }
        break;
      }
      case OP_PARALLEL: {
        stack.push(cause.right);
        cause = cause.left;
        break;
      }
    }
  }
  throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
};
var IsInterruptedOnlyCauseReducer = {
  emptyCase: constTrue,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: constTrue,
  sequentialCase: (_, left3, right3) => left3 && right3,
  parallelCase: (_, left3, right3) => left3 && right3
};
var OP_SEQUENTIAL_CASE = "SequentialCase";
var OP_PARALLEL_CASE = "ParallelCase";
var match5 = /* @__PURE__ */ dual(2, (self2, {
  onDie,
  onEmpty,
  onFail,
  onInterrupt,
  onParallel,
  onSequential
}) => {
  return reduceWithContext(self2, undefined, {
    emptyCase: () => onEmpty,
    failCase: (_, error) => onFail(error),
    dieCase: (_, defect) => onDie(defect),
    interruptCase: (_, fiberId) => onInterrupt(fiberId),
    sequentialCase: (_, left3, right3) => onSequential(left3, right3),
    parallelCase: (_, left3, right3) => onParallel(left3, right3)
  });
});
var reduce8 = /* @__PURE__ */ dual(3, (self2, zero3, pf) => {
  let accumulator = zero3;
  let cause = self2;
  const causes = [];
  while (cause !== undefined) {
    const option = pf(accumulator, cause);
    accumulator = isSome2(option) ? option.value : accumulator;
    switch (cause._tag) {
      case OP_SEQUENTIAL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      case OP_PARALLEL: {
        causes.push(cause.right);
        cause = cause.left;
        break;
      }
      default: {
        cause = undefined;
        break;
      }
    }
    if (cause === undefined && causes.length > 0) {
      cause = causes.pop();
    }
  }
  return accumulator;
});
var reduceWithContext = /* @__PURE__ */ dual(3, (self2, context, reducer) => {
  const input = [self2];
  const output = [];
  while (input.length > 0) {
    const cause = input.pop();
    switch (cause._tag) {
      case OP_EMPTY: {
        output.push(right2(reducer.emptyCase(context)));
        break;
      }
      case OP_FAIL: {
        output.push(right2(reducer.failCase(context, cause.error)));
        break;
      }
      case OP_DIE: {
        output.push(right2(reducer.dieCase(context, cause.defect)));
        break;
      }
      case OP_INTERRUPT: {
        output.push(right2(reducer.interruptCase(context, cause.fiberId)));
        break;
      }
      case OP_SEQUENTIAL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_SEQUENTIAL_CASE
        }));
        break;
      }
      case OP_PARALLEL: {
        input.push(cause.right);
        input.push(cause.left);
        output.push(left2({
          _tag: OP_PARALLEL_CASE
        }));
        break;
      }
    }
  }
  const accumulator = [];
  while (output.length > 0) {
    const either2 = output.pop();
    switch (either2._tag) {
      case "Left": {
        switch (either2.left._tag) {
          case OP_SEQUENTIAL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.sequentialCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
          case OP_PARALLEL_CASE: {
            const left3 = accumulator.pop();
            const right3 = accumulator.pop();
            const value = reducer.parallelCase(context, left3, right3);
            accumulator.push(value);
            break;
          }
        }
        break;
      }
      case "Right": {
        accumulator.push(either2.right);
        break;
      }
    }
  }
  if (accumulator.length === 0) {
    throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return accumulator.pop();
});
var pretty = (cause, options) => {
  if (isInterruptedOnly(cause)) {
    return "All fibers interrupted without errors.";
  }
  return prettyErrors(cause).map(function(e) {
    if (options?.renderErrorCause !== true || e.cause === undefined) {
      return e.stack;
    }
    return `${e.stack} {\n${renderErrorCause(e.cause, "  ")}\n}`;
  }).join("\n");
};
var renderErrorCause = (cause, prefix) => {
  const lines = cause.stack.split("\n");
  let stack = `${prefix}[cause]: ${lines[0]}`;
  for (let i = 1, len = lines.length;i < len; i++) {
    stack += `\n${prefix}${lines[i]}`;
  }
  if (cause.cause) {
    stack += ` {\n${renderErrorCause(cause.cause, `${prefix}  `)}\n${prefix}}`;
  }
  return stack;
};

class PrettyError extends globalThis.Error {
  span = undefined;
  constructor(originalError) {
    const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 1;
    super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
      cause: new PrettyError(originalError.cause)
    } : undefined);
    if (this.message === "") {
      this.message = "An error has occurred";
    }
    Error.stackTraceLimit = prevLimit;
    this.name = originalError instanceof Error ? originalError.name : "Error";
    if (originalErrorIsObject) {
      if (spanSymbol in originalError) {
        this.span = originalError[spanSymbol];
      }
      Object.keys(originalError).forEach((key) => {
        if (!(key in this)) {
          this[key] = originalError[key];
        }
      });
    }
    this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
  }
}
var prettyErrorMessage = (u) => {
  if (typeof u === "string") {
    return u;
  }
  if (typeof u === "object" && u !== null && u instanceof Error) {
    return u.message;
  }
  try {
    if (hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
      return u["toString"]();
    }
  } catch {
  }
  return stringifyCircular(u);
};
var locationRegex = /\((.*)\)/g;
var spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => new WeakMap);
var prettyErrorStack = (message, stack, span2) => {
  const out = [message];
  const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
  for (let i = 1;i < lines.length; i++) {
    if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
      i++;
      continue;
    }
    if (lines[i].includes("Generator.next")) {
      break;
    }
    if (lines[i].includes("effect_internal_function")) {
      break;
    }
    out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
  }
  if (span2) {
    let current = span2;
    let i = 0;
    while (current && current._tag === "Span" && i < 10) {
      const stackFn = spanToTrace.get(current);
      if (typeof stackFn === "function") {
        const stack2 = stackFn();
        if (typeof stack2 === "string") {
          const locationMatchAll = stack2.matchAll(locationRegex);
          let match6 = false;
          for (const [, location] of locationMatchAll) {
            match6 = true;
            out.push(`    at ${current.name} (${location})`);
          }
          if (!match6) {
            out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
      } else {
        out.push(`    at ${current.name}`);
      }
      current = getOrUndefined(current.parent);
      i++;
    }
  }
  return out.join("\n");
};
var spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
var prettyErrors = (cause) => reduceWithContext(cause, undefined, {
  emptyCase: () => [],
  dieCase: (_, unknownError) => {
    return [new PrettyError(unknownError)];
  },
  failCase: (_, error) => {
    return [new PrettyError(error)];
  },
  interruptCase: () => [],
  parallelCase: (_, l, r) => [...l, ...r],
  sequentialCase: (_, l, r) => [...l, ...r]
});

// node_modules/effect/dist/esm/internal/opCodes/deferred.js
var OP_STATE_PENDING = "Pending";
var OP_STATE_DONE = "Done";

// node_modules/effect/dist/esm/internal/deferred.js
var DeferredSymbolKey = "effect/Deferred";
var DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
var deferredVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var pending = (joiners) => {
  return {
    _tag: OP_STATE_PENDING,
    joiners
  };
};
var done = (effect) => {
  return {
    _tag: OP_STATE_DONE,
    effect
  };
};

// node_modules/effect/dist/esm/internal/singleShotGen.js
class SingleShotGen2 {
  self;
  called = false;
  constructor(self2) {
    this.self = self2;
  }
  next(a) {
    return this.called ? {
      value: a,
      done: true
    } : (this.called = true, {
      value: this.self,
      done: false
    });
  }
  return(a) {
    return {
      value: a,
      done: true
    };
  }
  throw(e) {
    throw e;
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(this.self);
  }
}

// node_modules/effect/dist/esm/internal/core.js
var blocked = (blockedRequests, _continue) => {
  const effect = new EffectPrimitive("Blocked");
  effect.effect_instruction_i0 = blockedRequests;
  effect.effect_instruction_i1 = _continue;
  return effect;
};
var runRequestBlock = (blockedRequests) => {
  const effect = new EffectPrimitive("RunBlocked");
  effect.effect_instruction_i0 = blockedRequests;
  return effect;
};
var EffectTypeId2 = /* @__PURE__ */ Symbol.for("effect/Effect");

class RevertFlags {
  patch;
  op;
  _op = OP_REVERT_FLAGS;
  constructor(patch8, op) {
    this.patch = patch8;
    this.op = op;
  }
}

class EffectPrimitive {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Effect",
      _op: this._op,
      effect_instruction_i0: toJSON(this.effect_instruction_i0),
      effect_instruction_i1: toJSON(this.effect_instruction_i1),
      effect_instruction_i2: toJSON(this.effect_instruction_i2)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveFailure {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Failure" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get cause() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      cause: this.cause.toJSON()
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}

class EffectPrimitiveSuccess {
  _op;
  effect_instruction_i0 = undefined;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  trace = undefined;
  [EffectTypeId2] = effectVariance;
  constructor(_op) {
    this._op = _op;
    this._tag = _op;
  }
  [symbol2](that) {
    return exitIsExit(that) && that._op === "Success" && equals(this.effect_instruction_i0, that.effect_instruction_i0);
  }
  [symbol]() {
    return pipe(string(this._tag), combine(hash(this.effect_instruction_i0)), cached(this));
  }
  get value() {
    return this.effect_instruction_i0;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toJSON() {
    return {
      _id: "Exit",
      _tag: this._op,
      value: toJSON(this.value)
    };
  }
  toString() {
    return format(this.toJSON());
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
}
var isEffect = (u) => hasProperty(u, EffectTypeId2);
var withFiberRuntime = (withRuntime) => {
  const effect = new EffectPrimitive(OP_WITH_RUNTIME);
  effect.effect_instruction_i0 = withRuntime;
  return effect;
};
var acquireUseRelease = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask((restore) => flatMap7(acquire, (a) => flatMap7(exit(suspend(() => restore(use(a)))), (exit) => {
  return suspend(() => release(a, exit)).pipe(matchCauseEffect({
    onFailure: (cause) => {
      switch (exit._tag) {
        case OP_FAILURE:
          return failCause(sequential(exit.effect_instruction_i0, cause));
        case OP_SUCCESS:
          return failCause(cause);
      }
    },
    onSuccess: () => exit
  }));
}))));
var as = /* @__PURE__ */ dual(2, (self2, value) => flatMap7(self2, () => succeed(value)));
var asVoid = (self2) => as(self2, undefined);
var custom = function() {
  const wrapper = new EffectPrimitive(OP_COMMIT);
  switch (arguments.length) {
    case 2: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.commit = arguments[1];
      break;
    }
    case 3: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.commit = arguments[2];
      break;
    }
    case 4: {
      wrapper.effect_instruction_i0 = arguments[0];
      wrapper.effect_instruction_i1 = arguments[1];
      wrapper.effect_instruction_i2 = arguments[2];
      wrapper.commit = arguments[3];
      break;
    }
    default: {
      throw new Error(getBugErrorMessage("you're not supposed to end up here"));
    }
  }
  return wrapper;
};
var unsafeAsync = (register, blockingOn = none4) => {
  const effect = new EffectPrimitive(OP_ASYNC);
  let cancelerRef = undefined;
  effect.effect_instruction_i0 = (resume) => {
    cancelerRef = register(resume);
  };
  effect.effect_instruction_i1 = blockingOn;
  return onInterrupt(effect, (_) => isEffect(cancelerRef) ? cancelerRef : void_);
};
var asyncInterrupt = (register, blockingOn = none4) => suspend(() => unsafeAsync(register, blockingOn));
var async_ = (resume, blockingOn = none4) => {
  return custom(resume, function() {
    let backingResume = undefined;
    let pendingEffect = undefined;
    function proxyResume(effect2) {
      if (backingResume) {
        backingResume(effect2);
      } else if (pendingEffect === undefined) {
        pendingEffect = effect2;
      }
    }
    const effect = new EffectPrimitive(OP_ASYNC);
    effect.effect_instruction_i0 = (resume2) => {
      backingResume = resume2;
      if (pendingEffect) {
        resume2(pendingEffect);
      }
    };
    effect.effect_instruction_i1 = blockingOn;
    let cancelerRef = undefined;
    let controllerRef = undefined;
    if (this.effect_instruction_i0.length !== 1) {
      controllerRef = new AbortController;
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
    } else {
      cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
    }
    return cancelerRef || controllerRef ? onInterrupt(effect, (_) => {
      if (controllerRef) {
        controllerRef.abort();
      }
      return cancelerRef ?? void_;
    }) : effect;
  });
};
var catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var catchAll = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: f,
  onSuccess: succeed
}));
var catchIf = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return predicate(either2.left) ? f(either2.left) : failCause(cause);
    case "Right":
      return failCause(either2.right);
  }
}));
var catchSome = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const either2 = failureOrCause(cause);
  switch (either2._tag) {
    case "Left":
      return pipe(pf(either2.left), getOrElse(() => failCause(cause)));
    case "Right":
      return failCause(either2.right);
  }
}));
var checkInterruptible = (f) => withFiberRuntime((_, status) => f(interruption(status.runtimeFlags)));
var originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
var capture = (obj, span2) => {
  if (isSome2(span2)) {
    return new Proxy(obj, {
      has(target, p) {
        return p === spanSymbol || p === originalSymbol || p in target;
      },
      get(target, p) {
        if (p === spanSymbol) {
          return span2.value;
        }
        if (p === originalSymbol) {
          return obj;
        }
        return target[p];
      }
    });
  }
  return obj;
};
var die2 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime((fiber) => failCause(die(capture(defect, currentSpanFromFiber(fiber))))) : failCause(die(defect));
var dieMessage = (message) => failCauseSync(() => die(new RuntimeException(message)));
var dieSync = (evaluate) => flatMap7(sync(evaluate), die2);
var either2 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(left2(e)),
  onSuccess: (a) => succeed(right2(a))
});
var exit = (self2) => matchCause(self2, {
  onFailure: exitFailCause,
  onSuccess: exitSucceed
});
var fail2 = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime((fiber) => failCause(fail(capture(error, currentSpanFromFiber(fiber))))) : failCause(fail(error));
var failSync = (evaluate) => flatMap7(sync(evaluate), fail2);
var failCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var failCauseSync = (evaluate) => flatMap7(sync(evaluate), failCause);
var fiberId = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.id()));
var fiberIdWith = (f) => withFiberRuntime((state) => f(state.id()));
var flatMap7 = /* @__PURE__ */ dual(2, (self2, f) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = f;
  return effect;
});
var andThen2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return b;
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((a2) => resume(succeed(a2)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
    });
  }
  return succeed(b);
}));
var step2 = (self2) => {
  const effect = new EffectPrimitive("OnStep");
  effect.effect_instruction_i0 = self2;
  return effect;
};
var flatten5 = (self2) => flatMap7(self2, identity);
var flip = (self2) => matchEffect(self2, {
  onFailure: succeed,
  onSuccess: fail2
});
var matchCause = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => succeed(options.onFailure(cause)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var matchCauseEffect = /* @__PURE__ */ dual(2, (self2, options) => {
  const effect = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
  effect.effect_instruction_i0 = self2;
  effect.effect_instruction_i1 = options.onFailure;
  effect.effect_instruction_i2 = options.onSuccess;
  return effect;
});
var matchEffect = /* @__PURE__ */ dual(2, (self2, options) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(electFailures(cause));
    }
    const failures2 = failures(cause);
    if (failures2.length > 0) {
      return options.onFailure(unsafeHead2(failures2));
    }
    return failCause(cause);
  },
  onSuccess: options.onSuccess
}));
var forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  const ret = allocate(arr.length);
  let i = 0;
  return as(whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: (b) => {
      ret[i++] = b;
    }
  }), ret);
}));
var forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend(() => {
  const arr = fromIterable(self2);
  let i = 0;
  return whileLoop({
    while: () => i < arr.length,
    body: () => f(arr[i], i),
    step: () => {
      i++;
    }
  });
}));
var if_ = /* @__PURE__ */ dual((args) => typeof args[0] === "boolean" || isEffect(args[0]), (self2, options) => isEffect(self2) ? flatMap7(self2, (b) => b ? options.onTrue() : options.onFalse()) : self2 ? options.onTrue() : options.onFalse());
var interrupt2 = /* @__PURE__ */ flatMap7(fiberId, (fiberId2) => interruptWith(fiberId2));
var interruptWith = (fiberId2) => failCause(interrupt(fiberId2));
var interruptible2 = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var interruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = enable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var intoDeferred = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask((restore) => flatMap7(exit(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
var map9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(self2, (a) => sync(() => f(a))));
var mapBoth = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => failSync(() => options.onFailure(e)),
  onSuccess: (a) => sync(() => options.onSuccess(a))
}));
var mapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const either3 = failureOrCause(cause);
    switch (either3._tag) {
      case "Left": {
        return failSync(() => f(either3.left));
      }
      case "Right": {
        return failCause(either3.right);
      }
    }
  },
  onSuccess: succeed
}));
var onError = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, (exit2) => exitIsSuccess(exit2) ? void_ : cleanup(exit2.effect_instruction_i0)));
var onExit = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => {
    const result = exitFailCause(cause1);
    return matchCauseEffect(cleanup(result), {
      onFailure: (cause2) => exitFailCause(sequential(cause1, cause2)),
      onSuccess: () => result
    });
  },
  onSuccess: (success) => {
    const result = exitSucceed(success);
    return zipRight(cleanup(result), result);
  }
})));
var onInterrupt = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit(self2, exitMatch({
  onFailure: (cause) => isInterruptedOnly(cause) ? asVoid(cleanup(interruptors(cause))) : void_,
  onSuccess: () => void_
})));
var orElse2 = /* @__PURE__ */ dual(2, (self2, that) => attemptOrElse(self2, that, succeed));
var orDie = (self2) => orDieWith(self2, identity);
var orDieWith = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
  onFailure: (e) => die2(f(e)),
  onSuccess: succeed
}));
var partitionMap2 = partitionMap;
var runtimeFlags = /* @__PURE__ */ withFiberRuntime((_, status) => succeed(status.runtimeFlags));
var succeed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var suspend = (evaluate) => {
  const effect = new EffectPrimitive(OP_COMMIT);
  effect.commit = evaluate;
  return effect;
};
var sync = (thunk) => {
  const effect = new EffectPrimitive(OP_SYNC);
  effect.effect_instruction_i0 = thunk;
  return effect;
};
var tap = /* @__PURE__ */ dual((args) => args.length === 3 || args.length === 2 && !(isObject(args[1]) && ("onlyEffect" in args[1])), (self2, f) => flatMap7(self2, (a) => {
  const b = typeof f === "function" ? f(a) : f;
  if (isEffect(b)) {
    return as(b, a);
  } else if (isPromiseLike(b)) {
    return unsafeAsync((resume) => {
      b.then((_) => resume(succeed(a)), (e) => resume(fail2(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
    });
  }
  return succeed(a);
}));
var transplant = (f) => withFiberRuntime((state) => {
  const scopeOverride = state.getFiberRef(currentForkScopeOverride);
  const scope = pipe(scopeOverride, getOrElse(() => state.scope()));
  return f(fiberRefLocally(currentForkScopeOverride, some2(scope)));
});
var attemptOrElse = /* @__PURE__ */ dual(3, (self2, that, onSuccess) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const defects2 = defects(cause);
    if (defects2.length > 0) {
      return failCause(getOrThrow2(keepDefectsAndElectFailures(cause)));
    }
    return that();
  },
  onSuccess
}));
var uninterruptible = (self2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = () => self2;
  return effect;
};
var uninterruptibleMask = (f) => custom(f, function() {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = disable3(Interruption);
  effect.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible2)) : internalCall(() => this.effect_instruction_i0(uninterruptible));
  return effect;
});
var void_ = /* @__PURE__ */ succeed(undefined);
var updateRuntimeFlags = (patch8) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = patch8;
  effect.effect_instruction_i1 = undefined;
  return effect;
};
var whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap7(condition, (b) => {
  if (b) {
    return pipe(self2, map9(some2));
  }
  return succeed(none2());
}));
var whileLoop = (options) => {
  const effect = new EffectPrimitive(OP_WHILE);
  effect.effect_instruction_i0 = options.while;
  effect.effect_instruction_i1 = options.body;
  effect.effect_instruction_i2 = options.step;
  return effect;
};
var fromIterator = (iterator) => suspend(() => {
  const effect = new EffectPrimitive(OP_ITERATOR);
  effect.effect_instruction_i0 = iterator();
  return effect;
});
var gen = function() {
  const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
  return fromIterator(() => f(pipe));
};
var fnUntraced = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args) {
  return fromIterator(() => body.apply(this, args));
} : function(...args) {
  let effect = fromIterator(() => body.apply(this, args));
  for (const x of pipeables) {
    effect = x(effect, ...args);
  }
  return effect;
}, "length", {
  value: body.length,
  configurable: true
});
var withConcurrency = /* @__PURE__ */ dual(2, (self2, concurrency) => fiberRefLocally(self2, currentConcurrency, concurrency));
var withRequestBatching = /* @__PURE__ */ dual(2, (self2, requestBatching) => fiberRefLocally(self2, currentRequestBatching, requestBatching));
var withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update2) => {
  const effect = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
  effect.effect_instruction_i0 = update2;
  effect.effect_instruction_i1 = () => self2;
  return effect;
});
var withTracerEnabled = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerEnabled, enabled2));
var withTracerTiming = /* @__PURE__ */ dual(2, (effect, enabled2) => fiberRefLocally(effect, currentTracerTimingEnabled, enabled2));
var yieldNow = (options) => {
  const effect = new EffectPrimitive(OP_YIELD);
  return typeof options?.priority !== "undefined" ? withSchedulingPriority(effect, options.priority) : effect;
};
var zip2 = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, (a) => map9(that, (b) => [a, b])));
var zipLeft = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, (a) => as(that, a)));
var zipRight = /* @__PURE__ */ dual(2, (self2, that) => flatMap7(self2, () => that));
var zipWith2 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap7(self2, (a) => map9(that, (b) => f(a, b))));
var never = /* @__PURE__ */ asyncInterrupt(() => {
  const interval = setInterval(() => {
  }, 2 ** 31 - 1);
  return sync(() => clearInterval(interval));
});
var interruptFiber = (self2) => flatMap7(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
var interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap7(self2.interruptAsFork(fiberId2), () => self2.await));
var logLevelAll = {
  _tag: "All",
  syslog: 0,
  label: "ALL",
  ordinal: Number.MIN_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelFatal = {
  _tag: "Fatal",
  syslog: 2,
  label: "FATAL",
  ordinal: 50000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelError = {
  _tag: "Error",
  syslog: 3,
  label: "ERROR",
  ordinal: 40000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelWarning = {
  _tag: "Warning",
  syslog: 4,
  label: "WARN",
  ordinal: 30000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelInfo = {
  _tag: "Info",
  syslog: 6,
  label: "INFO",
  ordinal: 20000,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelDebug = {
  _tag: "Debug",
  syslog: 7,
  label: "DEBUG",
  ordinal: 1e4,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelTrace = {
  _tag: "Trace",
  syslog: 7,
  label: "TRACE",
  ordinal: 0,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var logLevelNone = {
  _tag: "None",
  syslog: 7,
  label: "OFF",
  ordinal: Number.MAX_SAFE_INTEGER,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var FiberRefSymbolKey = "effect/FiberRef";
var FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
var fiberRefVariance = {
  _A: (_) => _
};
var fiberRefGet = (self2) => withFiberRuntime((fiber) => exitSucceed(fiber.getFiberRef(self2)));
var fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap7(fiberRefGet(self2), f));
var fiberRefSet = /* @__PURE__ */ dual(2, (self2, value) => fiberRefModify(self2, () => [undefined, value]));
var fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime((state) => {
  const [b, a] = f(state.getFiberRef(self2));
  state.setFiberRef(self2, a);
  return succeed(b);
}));
var fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value) => acquireUseRelease(zipLeft(fiberRefGet(self2), fiberRefSet(self2, value)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
var fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
var fiberRefUnsafeMake = (initial, options) => fiberRefUnsafeMakePatch(initial, {
  differ: update(),
  fork: options?.fork ?? identity,
  join: options?.join
});
var fiberRefUnsafeMakeHashSet = (initial) => {
  const differ2 = hashSet();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeReadonlyArray = (initial) => {
  const differ2 = readonlyArray(update());
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakeContext = (initial) => {
  const differ2 = environment();
  return fiberRefUnsafeMakePatch(initial, {
    differ: differ2,
    fork: differ2.empty
  });
};
var fiberRefUnsafeMakePatch = (initial, options) => {
  const _fiberRef = {
    ...CommitPrototype,
    [FiberRefTypeId]: fiberRefVariance,
    initial,
    commit() {
      return fiberRefGet(this);
    },
    diff: (oldValue, newValue) => options.differ.diff(oldValue, newValue),
    combine: (first, second) => options.differ.combine(first, second),
    patch: (patch8) => (oldValue) => options.differ.patch(patch8, oldValue),
    fork: options.fork,
    join: options.join ?? ((_, n) => n)
  };
  return _fiberRef;
};
var fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ,
  fork: differ.empty
});
var currentContext = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty4()));
var currentSchedulingPriority = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
var currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
var currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty9()));
var currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
var currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty10()));
var withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority, scheduler));
var withMaxOpsBeforeYield = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
var currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
var currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
var currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelDebug)));
var currentVersionMismatchErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/versionMismatchErrorLogLevel"), () => fiberRefUnsafeMake(some2(logLevelWarning)));
var withUnhandledErrorLogLevel = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
var currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty2()));
var metricLabels = /* @__PURE__ */ fiberRefGet(currentMetricLabels);
var currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none2(), {
  fork: () => none2(),
  join: (parent, _) => parent
}));
var currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty20, {
  fork: () => empty20,
  join: (parent, _) => parent
}));
var currentTracerEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
var currentTracerTimingEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
var currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty9()));
var currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty5()));
var ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
var CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
var scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid(finalizer));
var scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
var scopeClose = (self2, exit2) => self2.close(exit2);
var scopeFork = (self2, strategy) => self2.fork(strategy);
var YieldableError = /* @__PURE__ */ function() {
  class YieldableError2 extends globalThis.Error {
    commit() {
      return fail2(this);
    }
    toJSON() {
      const obj = {
        ...this
      };
      if (this.message)
        obj.message = this.message;
      if (this.cause)
        obj.cause = this.cause;
      return obj;
    }
    [NodeInspectSymbol]() {
      if (this.toString !== globalThis.Error.prototype.toString) {
        return this.stack ? `${this.toString()}\n${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
      } else if ("Bun" in globalThis) {
        return pretty(fail(this), {
          renderErrorCause: true
        });
      }
      return this;
    }
  }
  Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
  return YieldableError2;
}();
var makeException = (proto2, tag) => {

  class Base2 extends YieldableError {
    _tag = tag;
  }
  Object.assign(Base2.prototype, proto2);
  Base2.prototype.name = tag;
  return Base2;
};
var RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
var RuntimeException = /* @__PURE__ */ makeException({
  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}, "RuntimeException");
var InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
var InterruptedException = /* @__PURE__ */ makeException({
  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}, "InterruptedException");
var isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
var IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
var IllegalArgumentException = /* @__PURE__ */ makeException({
  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}, "IllegalArgumentException");
var NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
var NoSuchElementException = /* @__PURE__ */ makeException({
  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}, "NoSuchElementException");
var isNoSuchElementException = (u) => hasProperty(u, NoSuchElementExceptionTypeId);
var InvalidPubSubCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InvalidPubSubCapacityException");
var InvalidPubSubCapacityException = /* @__PURE__ */ makeException({
  [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}, "InvalidPubSubCapacityException");
var ExceededCapacityExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/ExceededCapacityException");
var ExceededCapacityException = /* @__PURE__ */ makeException({
  [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}, "ExceededCapacityException");
var TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
var TimeoutException = /* @__PURE__ */ makeException({
  [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}, "TimeoutException");
var timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format3(duration)}'`);
var UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
var UnknownException = /* @__PURE__ */ function() {

  class UnknownException2 extends YieldableError {
    _tag = "UnknownException";
    error;
    constructor(cause, message) {
      super(message ?? "An unknown error occurred", {
        cause
      });
      this.error = cause;
    }
  }
  Object.assign(UnknownException2.prototype, {
    [UnknownExceptionTypeId]: UnknownExceptionTypeId,
    name: "UnknownException"
  });
  return UnknownException2;
}();
var exitIsExit = (u) => isEffect(u) && ("_tag" in u) && (u._tag === "Success" || u._tag === "Failure");
var exitIsFailure = (self2) => self2._tag === "Failure";
var exitIsSuccess = (self2) => self2._tag === "Success";
var exitAs = /* @__PURE__ */ dual(2, (self2, value) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return exitSucceed(value);
    }
  }
});
var exitAsVoid = (self2) => exitAs(self2, undefined);
var exitCollectAll = (exits, options) => exitCollectAllInternal(exits, options?.parallel ? parallel : sequential);
var exitDie = (defect) => exitFailCause(die(defect));
var exitFail = (error) => exitFailCause(fail(error));
var exitFailCause = (cause) => {
  const effect = new EffectPrimitiveFailure(OP_FAILURE);
  effect.effect_instruction_i0 = cause;
  return effect;
};
var exitFlatMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      return exitFailCause(self2.effect_instruction_i0);
    }
    case OP_SUCCESS: {
      return f(self2.effect_instruction_i0);
    }
  }
});
var exitFlatten = (self2) => pipe(self2, exitFlatMap(identity));
var exitInterrupt = (fiberId2) => exitFailCause(interrupt(fiberId2));
var exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return exitFailCause(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return exitSucceed(f(self2.effect_instruction_i0));
  }
});
var exitMatch = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE:
      return onFailure(self2.effect_instruction_i0);
    case OP_SUCCESS:
      return onSuccess(self2.effect_instruction_i0);
  }
});
var exitSucceed = (value) => {
  const effect = new EffectPrimitiveSuccess(OP_SUCCESS);
  effect.effect_instruction_i0 = value;
  return effect;
};
var exitVoid = /* @__PURE__ */ exitSucceed(undefined);
var exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
  onFailure,
  onSuccess
}) => {
  switch (self2._tag) {
    case OP_FAILURE: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitFailCause(self2.effect_instruction_i0);
        case OP_FAILURE: {
          return exitFailCause(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
        }
      }
    }
    case OP_SUCCESS: {
      switch (that._tag) {
        case OP_SUCCESS:
          return exitSucceed(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
        case OP_FAILURE:
          return exitFailCause(that.effect_instruction_i0);
      }
    }
  }
});
var exitCollectAllInternal = (exits, combineCauses) => {
  const list = fromIterable2(exits);
  if (!isNonEmpty2(list)) {
    return none2();
  }
  return pipe(tailNonEmpty2(list), reduce(pipe(headNonEmpty2(list), exitMap(of2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
    onSuccess: (list2, value) => pipe(list2, prepend2(value)),
    onFailure: combineCauses
  }))), exitMap(reverse2), exitMap((chunk) => toReadonlyArray(chunk)), some2);
};
var deferredUnsafeMake = (fiberId2) => {
  const _deferred = {
    ...CommitPrototype,
    [DeferredTypeId]: deferredVariance,
    state: make12(pending([])),
    commit() {
      return deferredAwait(this);
    },
    blockingOn: fiberId2
  };
  return _deferred;
};
var deferredMake = () => flatMap7(fiberId, (id) => deferredMakeAs(id));
var deferredMakeAs = (fiberId2) => sync(() => deferredUnsafeMake(fiberId2));
var deferredAwait = (self2) => asyncInterrupt((resume) => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return resume(state.effect);
    }
    case OP_STATE_PENDING: {
      state.joiners.push(resume);
      return deferredInterruptJoiner(self2, resume);
    }
  }
}, self2.blockingOn);
var deferredComplete = /* @__PURE__ */ dual(2, (self2, effect) => intoDeferred(effect, self2));
var deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect) => sync(() => {
  const state = get6(self2.state);
  switch (state._tag) {
    case OP_STATE_DONE: {
      return false;
    }
    case OP_STATE_PENDING: {
      set3(self2.state, done(effect));
      for (let i = 0, len = state.joiners.length;i < len; i++) {
        state.joiners[i](effect);
      }
      return true;
    }
  }
}));
var deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
var deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause(cause)));
var deferredInterrupt = (self2) => flatMap7(fiberId, (fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
var deferredSucceed = /* @__PURE__ */ dual(2, (self2, value) => deferredCompleteWith(self2, succeed(value)));
var deferredUnsafeDone = (self2, effect) => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    set3(self2.state, done(effect));
    for (let i = 0, len = state.joiners.length;i < len; i++) {
      state.joiners[i](effect);
    }
  }
};
var deferredInterruptJoiner = (self2, joiner) => sync(() => {
  const state = get6(self2.state);
  if (state._tag === OP_STATE_PENDING) {
    const index = state.joiners.indexOf(joiner);
    if (index >= 0) {
      state.joiners.splice(index, 1);
    }
  }
});
var constContext = /* @__PURE__ */ withFiberRuntime((fiber) => exitSucceed(fiber.currentContext));
var context = () => constContext;
var contextWithEffect = (f) => flatMap7(context(), f);
var provideContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext, context2)(self2));
var provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext, (parent) => merge3(parent, context2))(self2));
var mapInputContext = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext(self2, f(context2))));
var filterEffectOrElse = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => flatMap7(options.predicate(a), (pass) => pass ? succeed(a) : options.orElse(a))));
var filterEffectOrFail = /* @__PURE__ */ dual(2, (self2, options) => filterEffectOrElse(self2, {
  predicate: options.predicate,
  orElse: (a) => fail2(options.orFailWith(a))
}));
var currentSpanFromFiber = (fiber) => {
  const span2 = fiber.currentSpan;
  return span2 !== undefined && span2._tag === "Span" ? some2(span2) : none2();
};
var NoopSpanProto = {
  _tag: "Span",
  spanId: "noop",
  traceId: "noop",
  sampled: false,
  status: {
    _tag: "Ended",
    startTime: /* @__PURE__ */ BigInt(0),
    endTime: /* @__PURE__ */ BigInt(0),
    exit: exitVoid
  },
  attributes: /* @__PURE__ */ new Map,
  links: [],
  kind: "internal",
  attribute() {
  },
  event() {
  },
  end() {
  },
  addLinks() {
  }
};
var noopSpan = (options) => Object.assign(Object.create(NoopSpanProto), options);

// node_modules/effect/dist/esm/Deferred.js
var _await = deferredAwait;
var done2 = deferredDone;
var interrupt3 = deferredInterrupt;
var unsafeMake4 = deferredUnsafeMake;

// node_modules/effect/dist/esm/Exit.js
var isExit = exitIsExit;
var isSuccess = exitIsSuccess;
var die3 = exitDie;
var fail3 = exitFail;
var failCause2 = exitFailCause;
var flatten6 = exitFlatten;
var interrupt4 = exitInterrupt;
var match6 = exitMatch;
var succeed2 = exitSucceed;

// node_modules/effect/dist/esm/MutableHashMap.js
var TypeId9 = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
var MutableHashMapProto = {
  [TypeId9]: TypeId9,
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};

class MutableHashMapIterator {
  self;
  referentialIterator;
  bucketIterator;
  constructor(self2) {
    this.self = self2;
    this.referentialIterator = self2.referential[Symbol.iterator]();
  }
  next() {
    if (this.bucketIterator !== undefined) {
      return this.bucketIterator.next();
    }
    const result = this.referentialIterator.next();
    if (result.done) {
      this.bucketIterator = new BucketIterator(this.self.buckets.values());
      return this.next();
    }
    return result;
  }
  [Symbol.iterator]() {
    return new MutableHashMapIterator(this.self);
  }
}

class BucketIterator {
  backing;
  constructor(backing) {
    this.backing = backing;
  }
  currentBucket;
  next() {
    if (this.currentBucket === undefined) {
      const result2 = this.backing.next();
      if (result2.done) {
        return result2;
      }
      this.currentBucket = result2.value[Symbol.iterator]();
    }
    const result = this.currentBucket.next();
    if (result.done) {
      this.currentBucket = undefined;
      return this.next();
    }
    return result;
  }
}
var empty21 = () => {
  const self2 = Object.create(MutableHashMapProto);
  self2.referential = new Map;
  self2.buckets = new Map;
  self2.bucketsSize = 0;
  return self2;
};
var get8 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    return self2.referential.has(key) ? some2(self2.referential.get(key)) : none2();
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return none2();
  }
  return getFromBucket(self2, bucket, key);
});
var getFromBucket = (self2, bucket, key, remove6 = false) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      const value = bucket[i][1];
      if (remove6) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
      }
      return some2(value);
    }
  }
  return none2();
};
var has4 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(get8(self2, key)));
var set5 = /* @__PURE__ */ dual(3, (self2, key, value) => {
  if (isEqual(key) === false) {
    self2.referential.set(key, value);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    self2.buckets.set(hash2, [[key, value]]);
    self2.bucketsSize++;
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  bucket.push([key, value]);
  self2.bucketsSize++;
  return self2;
});
var removeFromBucket = (self2, bucket, key) => {
  for (let i = 0, len = bucket.length;i < len; i++) {
    if (key[symbol2](bucket[i][0])) {
      bucket.splice(i, 1);
      self2.bucketsSize--;
      return;
    }
  }
};
var remove6 = /* @__PURE__ */ dual(2, (self2, key) => {
  if (isEqual(key) === false) {
    self2.referential.delete(key);
    return self2;
  }
  const hash2 = key[symbol]();
  const bucket = self2.buckets.get(hash2);
  if (bucket === undefined) {
    return self2;
  }
  removeFromBucket(self2, bucket, key);
  if (bucket.length === 0) {
    self2.buckets.delete(hash2);
  }
  return self2;
});
var size4 = (self2) => {
  return self2.referential.size + self2.bucketsSize;
};

// node_modules/effect/dist/esm/MutableList.js
var TypeId10 = /* @__PURE__ */ Symbol.for("effect/MutableList");
var MutableListProto = {
  [TypeId10]: TypeId10,
  [Symbol.iterator]() {
    let done3 = false;
    let head3 = this.head;
    return {
      next() {
        if (done3) {
          return this.return();
        }
        if (head3 == null) {
          done3 = true;
          return this.return();
        }
        const value = head3.value;
        head3 = head3.next;
        return {
          done: done3,
          value
        };
      },
      return(value) {
        if (!done3) {
          done3 = true;
        }
        return {
          done: true,
          value
        };
      }
    };
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableList",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeNode = (value) => ({
  value,
  removed: false,
  prev: undefined,
  next: undefined
});
var empty22 = () => {
  const list = Object.create(MutableListProto);
  list.head = undefined;
  list.tail = undefined;
  list._length = 0;
  return list;
};
var isEmpty6 = (self2) => length(self2) === 0;
var length = (self2) => self2._length;
var append3 = /* @__PURE__ */ dual(2, (self2, value) => {
  const node = makeNode(value);
  if (self2.head === undefined) {
    self2.head = node;
  }
  if (self2.tail === undefined) {
    self2.tail = node;
  } else {
    self2.tail.next = node;
    node.prev = self2.tail;
    self2.tail = node;
  }
  self2._length += 1;
  return self2;
});
var shift = (self2) => {
  const head3 = self2.head;
  if (head3 !== undefined) {
    remove7(self2, head3);
    return head3.value;
  }
  return;
};
var remove7 = (self2, node) => {
  if (node.removed) {
    return;
  }
  node.removed = true;
  if (node.prev !== undefined && node.next !== undefined) {
    node.prev.next = node.next;
    node.next.prev = node.prev;
  } else if (node.prev !== undefined) {
    self2.tail = node.prev;
    node.prev.next = undefined;
  } else if (node.next !== undefined) {
    self2.head = node.next;
    node.next.prev = undefined;
  } else {
    self2.tail = undefined;
    self2.head = undefined;
  }
  if (self2._length > 0) {
    self2._length -= 1;
  }
};

// node_modules/effect/dist/esm/MutableQueue.js
var TypeId11 = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
var EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
var MutableQueueProto = {
  [TypeId11]: TypeId11,
  [Symbol.iterator]() {
    return Array.from(this.queue)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableQueue",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make19 = (capacity) => {
  const queue = Object.create(MutableQueueProto);
  queue.queue = empty22();
  queue.capacity = capacity;
  return queue;
};
var unbounded = () => make19(undefined);
var offer = /* @__PURE__ */ dual(2, (self2, value) => {
  const queueLength = length(self2.queue);
  if (self2.capacity !== undefined && queueLength === self2.capacity) {
    return false;
  }
  append3(value)(self2.queue);
  return true;
});
var poll = /* @__PURE__ */ dual(2, (self2, def) => {
  if (isEmpty6(self2.queue)) {
    return def;
  }
  return shift(self2.queue);
});

// node_modules/effect/dist/esm/internal/clock.js
var ClockSymbolKey = "effect/Clock";
var ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
var clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
var MAX_TIMER_MILLIS = 2 ** 31 - 1;
var globalClockScheduler = {
  unsafeSchedule(task, duration) {
    const millis2 = toMillis(duration);
    if (millis2 > MAX_TIMER_MILLIS) {
      return constFalse;
    }
    let completed = false;
    const handle = setTimeout(() => {
      completed = true;
      task();
    }, millis2);
    return () => {
      clearTimeout(handle);
      return !completed;
    };
  }
};
var performanceNowNanos = /* @__PURE__ */ function() {
  const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
  if (typeof performance === "undefined") {
    return () => BigInt(Date.now()) * bigint1e62;
  }
  let origin;
  return () => {
    if (origin === undefined) {
      origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
    }
    return origin + BigInt(Math.round(performance.now() * 1e6));
  };
}();
var processOrPerformanceNow = /* @__PURE__ */ function() {
  const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : undefined;
  if (!processHrtime) {
    return performanceNowNanos;
  }
  const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
  return () => origin + processHrtime.bigint();
}();

class ClockImpl {
  [ClockTypeId] = ClockTypeId;
  unsafeCurrentTimeMillis() {
    return Date.now();
  }
  unsafeCurrentTimeNanos() {
    return processOrPerformanceNow();
  }
  currentTimeMillis = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeMillis());
  currentTimeNanos = /* @__PURE__ */ sync(() => this.unsafeCurrentTimeNanos());
  scheduler() {
    return succeed(globalClockScheduler);
  }
  sleep(duration) {
    return async_((resume) => {
      const canceler = globalClockScheduler.unsafeSchedule(() => resume(void_), duration);
      return asVoid(sync(canceler));
    });
  }
}
var make20 = () => new ClockImpl;

// node_modules/effect/dist/esm/internal/opCodes/configError.js
var OP_AND = "And";
var OP_OR = "Or";
var OP_INVALID_DATA = "InvalidData";
var OP_MISSING_DATA = "MissingData";
var OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
var OP_UNSUPPORTED = "Unsupported";

// node_modules/effect/dist/esm/internal/configError.js
var ConfigErrorSymbolKey = "effect/ConfigError";
var ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
var proto2 = {
  _tag: "ConfigError",
  [ConfigErrorTypeId]: ConfigErrorTypeId
};
var And = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_AND;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} and ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var Or = (self2, that) => {
  const error = Object.create(proto2);
  error._op = OP_OR;
  error.left = self2;
  error.right = that;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      return `${this.left} or ${this.right}`;
    }
  });
  Object.defineProperty(error, "message", {
    enumerable: false,
    get() {
      return this.toString();
    }
  });
  return error;
};
var InvalidData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_INVALID_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Invalid data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var MissingData = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_MISSING_DATA;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Missing data at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var SourceUnavailable = (path, message, cause, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_SOURCE_UNAVAILABLE;
  error.path = path;
  error.message = message;
  error.cause = cause;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Source unavailable at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var Unsupported = (path, message, options = {
  pathDelim: "."
}) => {
  const error = Object.create(proto2);
  error._op = OP_UNSUPPORTED;
  error.path = path;
  error.message = message;
  Object.defineProperty(error, "toString", {
    enumerable: false,
    value() {
      const path2 = pipe(this.path, join(options.pathDelim));
      return `(Unsupported operation at ${path2}: "${this.message}")`;
    }
  });
  return error;
};
var prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
  switch (self2._op) {
    case OP_AND: {
      return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_OR: {
      return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
    }
    case OP_INVALID_DATA: {
      return InvalidData([...prefix, ...self2.path], self2.message);
    }
    case OP_MISSING_DATA: {
      return MissingData([...prefix, ...self2.path], self2.message);
    }
    case OP_SOURCE_UNAVAILABLE: {
      return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
    }
    case OP_UNSUPPORTED: {
      return Unsupported([...prefix, ...self2.path], self2.message);
    }
  }
});

// node_modules/effect/dist/esm/internal/configProvider/pathPatch.js
var empty23 = {
  _tag: "Empty"
};
var patch8 = /* @__PURE__ */ dual(2, (path, patch9) => {
  let input = of3(patch9);
  let output = path;
  while (isCons(input)) {
    const patch10 = input.head;
    switch (patch10._tag) {
      case "Empty": {
        input = input.tail;
        break;
      }
      case "AndThen": {
        input = cons(patch10.first, cons(patch10.second, input.tail));
        break;
      }
      case "MapName": {
        output = map3(output, patch10.f);
        input = input.tail;
        break;
      }
      case "Nested": {
        output = prepend(output, patch10.name);
        input = input.tail;
        break;
      }
      case "Unnested": {
        const containsName = pipe(head(output), contains(patch10.name));
        if (containsName) {
          output = tailNonEmpty(output);
          input = input.tail;
        } else {
          return left2(MissingData(output, `Expected ${patch10.name} to be in path in ConfigProvider#unnested`));
        }
        break;
      }
    }
  }
  return right2(output);
});

// node_modules/effect/dist/esm/internal/opCodes/config.js
var OP_CONSTANT = "Constant";
var OP_FAIL2 = "Fail";
var OP_FALLBACK = "Fallback";
var OP_DESCRIBED = "Described";
var OP_LAZY = "Lazy";
var OP_MAP_OR_FAIL = "MapOrFail";
var OP_NESTED = "Nested";
var OP_PRIMITIVE = "Primitive";
var OP_SEQUENCE = "Sequence";
var OP_HASHMAP = "HashMap";
var OP_ZIP_WITH = "ZipWith";

// node_modules/effect/dist/esm/internal/configProvider.js
var concat = (l, r) => [...l, ...r];
var ConfigProviderSymbolKey = "effect/ConfigProvider";
var ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
var configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
var FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
var FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
var make22 = (options) => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var makeFlat = (options) => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
var fromFlat = (flat) => make22({
  load: (config) => flatMap7(fromFlatLoop(flat, empty2(), config, false), (chunk) => match2(head(chunk), {
    onNone: () => fail2(MissingData(empty2(), `Expected a single value having structure: ${config}`)),
    onSome: succeed
  })),
  flattened: flat
});
var fromEnv = (options) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = (path) => pipe(path, join(pathDelim));
  const unmakePathString = (pathString) => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && ("env" in process) && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? some2(current[pathString]) : none2();
    return pipe(valueOpt, mapError(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap7((value) => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = (path) => sync(() => {
    const current = getEnv();
    const keys3 = Object.keys(current);
    const keyPaths = keys3.map((value) => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter((keyPath) => {
      for (let i = 0;i < path.length; i++) {
        const pathComponent = pipe(path, unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
    return fromIterable5(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: empty23
  }));
};
var extend = (leftDef, rightDef, left3, right3) => {
  const leftPad = unfold(left3.length, (index) => index >= right3.length ? none2() : some2([leftDef(index), index + 1]));
  const rightPad = unfold(right3.length, (index) => index >= left3.length ? none2() : some2([rightDef(index), index + 1]));
  const leftExtension = concat(left3, leftPad);
  const rightExtension = concat(right3, rightPad);
  return [leftExtension, rightExtension];
};
var appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
var fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OP_CONSTANT: {
      return succeed(of(op.value));
    }
    case OP_DESCRIBED: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config, split));
    }
    case OP_FAIL2: {
      return fail2(MissingData(prefix, op.message));
    }
    case OP_FALLBACK: {
      return pipe(suspend(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll((error1) => {
        if (op.condition(error1)) {
          return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll((error2) => fail2(Or(error1, error2))));
        }
        return fail2(error1);
      }));
    }
    case OP_LAZY: {
      return suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
    }
    case OP_MAP_OR_FAIL: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError(prefixed(appendConfigPath(prefix, op.original))))))));
    }
    case OP_NESTED: {
      return suspend(() => fromFlatLoop(flat, concat(prefix, of(op.name)), op.config, split));
    }
    case OP_PRIMITIVE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.load(prefix2, op, split), flatMap7((values3) => {
        if (values3.length === 0) {
          const name = pipe(last(prefix2), getOrElse(() => "<n/a>"));
          return fail2(MissingData([], `Expected ${op.description} with name ${name}`));
        }
        return succeed(values3);
      }))));
    }
    case OP_SEQUENCE: {
      return pipe(patch8(prefix, flat.patch), flatMap7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap7(indicesFrom), flatMap7((indices) => {
        if (indices.length === 0) {
          return suspend(() => map9(fromFlatLoop(flat, prefix, op.config, true), of));
        }
        return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append(prefix, `[${index}]`), op.config, true)), map9((chunkChunk) => {
          const flattened = flatten(chunkChunk);
          if (flattened.length === 0) {
            return of(empty2());
          }
          return of(flattened);
        }));
      }))));
    }
    case OP_HASHMAP: {
      return suspend(() => pipe(patch8(prefix, flat.patch), flatMap7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap7((keys3) => {
        return pipe(keys3, forEachSequential((key) => fromFlatLoop(flat, concat(prefix2, of(key)), op.valueConfig, split)), map9((matrix) => {
          if (matrix.length === 0) {
            return of(empty9());
          }
          return pipe(transpose(matrix), map3((values3) => fromIterable6(zip(fromIterable(keys3), values3))));
        }));
      })))));
    }
    case OP_ZIP_WITH: {
      return suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either2, flatMap7((left3) => pipe(fromFlatLoop(flat, prefix, op.right, split), either2, flatMap7((right3) => {
        if (isLeft2(left3) && isLeft2(right3)) {
          return fail2(And(left3.left, right3.left));
        }
        if (isLeft2(left3) && isRight2(right3)) {
          return fail2(left3.left);
        }
        if (isRight2(left3) && isLeft2(right3)) {
          return fail2(right3.left);
        }
        if (isRight2(left3) && isRight2(right3)) {
          const path = pipe(prefix, join("."));
          const fail4 = fromFlatLoopFail(prefix, path);
          const [lefts, rights] = extend(fail4, fail4, pipe(left3.right, map3(right2)), pipe(right3.right, map3(right2)));
          return pipe(lefts, zip(rights), forEachSequential(([left4, right4]) => pipe(zip2(left4, right4), map9(([left5, right5]) => op.zip(left5, right5)))));
        }
        throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
      })))));
    }
  }
};
var fromFlatLoopFail = (prefix, path) => (index) => left2(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
var splitPathString = (text, delim) => {
  const split = text.split(new RegExp(`\\s*${escape(delim)}\\s*`));
  return split;
};
var parsePrimitive = (text, path, primitive, delimiter, split) => {
  if (!split) {
    return pipe(primitive.parse(text), mapBoth({
      onFailure: prefixed(path),
      onSuccess: of
    }));
  }
  return pipe(splitPathString(text, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError(prefixed(path)));
};
var transpose = (array5) => {
  return Object.keys(array5[0]).map((column) => array5.map((row) => row[column]));
};
var indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth({
  onFailure: () => empty2(),
  onSuccess: sort(Order)
}), either2, map9(merge));
var QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
var parseQuotedIndex = (str) => {
  const match7 = str.match(QUOTED_INDEX_REGEX);
  if (match7 !== null) {
    const matchedIndex = match7[2];
    return pipe(matchedIndex !== undefined && matchedIndex.length > 0 ? some2(matchedIndex) : none2(), flatMap(parseInteger));
  }
  return none2();
};
var parseInteger = (str) => {
  const parsedIndex = Number.parseInt(str);
  return Number.isNaN(parsedIndex) ? none2() : some2(parsedIndex);
};

// node_modules/effect/dist/esm/internal/defaultServices/console.js
var TypeId12 = /* @__PURE__ */ Symbol.for("effect/Console");
var consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
var defaultConsole = {
  [TypeId12]: TypeId12,
  assert(condition, ...args) {
    return sync(() => {
      console.assert(condition, ...args);
    });
  },
  clear: /* @__PURE__ */ sync(() => {
    console.clear();
  }),
  count(label) {
    return sync(() => {
      console.count(label);
    });
  },
  countReset(label) {
    return sync(() => {
      console.countReset(label);
    });
  },
  debug(...args) {
    return sync(() => {
      console.debug(...args);
    });
  },
  dir(item, options) {
    return sync(() => {
      console.dir(item, options);
    });
  },
  dirxml(...args) {
    return sync(() => {
      console.dirxml(...args);
    });
  },
  error(...args) {
    return sync(() => {
      console.error(...args);
    });
  },
  group(options) {
    return options?.collapsed ? sync(() => console.groupCollapsed(options?.label)) : sync(() => console.group(options?.label));
  },
  groupEnd: /* @__PURE__ */ sync(() => {
    console.groupEnd();
  }),
  info(...args) {
    return sync(() => {
      console.info(...args);
    });
  },
  log(...args) {
    return sync(() => {
      console.log(...args);
    });
  },
  table(tabularData, properties) {
    return sync(() => {
      console.table(tabularData, properties);
    });
  },
  time(label) {
    return sync(() => console.time(label));
  },
  timeEnd(label) {
    return sync(() => console.timeEnd(label));
  },
  timeLog(label, ...args) {
    return sync(() => {
      console.timeLog(label, ...args);
    });
  },
  trace(...args) {
    return sync(() => {
      console.trace(...args);
    });
  },
  warn(...args) {
    return sync(() => {
      console.warn(...args);
    });
  },
  unsafe: console
};

// node_modules/effect/dist/esm/internal/random.js
var RandomSymbolKey = "effect/Random";
var RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
var randomTag = /* @__PURE__ */ GenericTag("effect/Random");

class RandomImpl {
  seed;
  [RandomTypeId] = RandomTypeId;
  PRNG;
  constructor(seed) {
    this.seed = seed;
    this.PRNG = new PCGRandom(seed);
  }
  get next() {
    return sync(() => this.PRNG.number());
  }
  get nextBoolean() {
    return map9(this.next, (n) => n > 0.5);
  }
  get nextInt() {
    return sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
  }
  nextRange(min2, max2) {
    return map9(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => this.PRNG.integer(max2 - min2) + min2);
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var shuffleWith = (elements, nextIntBounded) => {
  return suspend(() => pipe(sync(() => Array.from(elements)), flatMap7((buffer) => {
    const numbers = [];
    for (let i = buffer.length;i >= 2; i = i - 1) {
      numbers.push(i);
    }
    return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map9((k) => swap(buffer, n - 1, k)))), as(fromIterable2(buffer)));
  })));
};
var swap = (buffer, index1, index2) => {
  const tmp = buffer[index1];
  buffer[index1] = buffer[index2];
  buffer[index2] = tmp;
  return buffer;
};
var make23 = (seed) => new RandomImpl(hash(seed));

class FixedRandomImpl {
  values;
  [RandomTypeId] = RandomTypeId;
  index = 0;
  constructor(values3) {
    this.values = values3;
    if (values3.length === 0) {
      throw new Error("Requires at least one value");
    }
  }
  getNextValue() {
    const value = this.values[this.index];
    this.index = (this.index + 1) % this.values.length;
    return value;
  }
  get next() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number") {
        return Math.max(0, Math.min(1, value));
      }
      return hash(value) / 2147483647;
    });
  }
  get nextBoolean() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "boolean") {
        return value;
      }
      return hash(value) % 2 === 0;
    });
  }
  get nextInt() {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.round(value);
      }
      return Math.abs(hash(value));
    });
  }
  nextRange(min2, max2) {
    return map9(this.next, (n) => (max2 - min2) * n + min2);
  }
  nextIntBetween(min2, max2) {
    return sync(() => {
      const value = this.getNextValue();
      if (typeof value === "number" && Number.isFinite(value)) {
        return Math.max(min2, Math.min(max2 - 1, Math.round(value)));
      }
      const hash2 = Math.abs(hash(value));
      return min2 + hash2 % (max2 - min2);
    });
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
}
var fixed = (values3) => new FixedRandomImpl(values3);

// node_modules/effect/dist/esm/internal/tracer.js
var TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
var make24 = (options) => ({
  [TracerTypeId]: TracerTypeId,
  ...options
});
var tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
var spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
var randomHexString = /* @__PURE__ */ function() {
  const characters = "abcdef0123456789";
  const charactersLength = characters.length;
  return function(length2) {
    let result = "";
    for (let i = 0;i < length2; i++) {
      result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
  };
}();

class NativeSpan {
  name;
  parent;
  context;
  startTime;
  kind;
  _tag = "Span";
  spanId;
  traceId = "native";
  sampled = true;
  status;
  attributes;
  events = [];
  links;
  constructor(name, parent, context2, links, startTime, kind) {
    this.name = name;
    this.parent = parent;
    this.context = context2;
    this.startTime = startTime;
    this.kind = kind;
    this.status = {
      _tag: "Started",
      startTime
    };
    this.attributes = new Map;
    this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
    this.spanId = randomHexString(16);
    this.links = Array.from(links);
  }
  end(endTime, exit2) {
    this.status = {
      _tag: "Ended",
      endTime,
      exit: exit2,
      startTime: this.status.startTime
    };
  }
  attribute(key, value) {
    this.attributes.set(key, value);
  }
  event(name, startTime, attributes) {
    this.events.push([name, startTime, attributes ?? {}]);
  }
  addLinks(links) {
    this.links.push(...links);
  }
}
var nativeTracer = /* @__PURE__ */ make24({
  span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
  context: (f) => f()
});
var addSpanStackTrace = (options) => {
  if (options?.captureStackTrace === false) {
    return options;
  } else if (options?.captureStackTrace !== undefined && typeof options.captureStackTrace !== "boolean") {
    return options;
  }
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 3;
  const traceError = new Error;
  Error.stackTraceLimit = limit;
  let cache = false;
  return {
    ...options,
    captureStackTrace: () => {
      if (cache !== false) {
        return cache;
      }
      if (traceError.stack !== undefined) {
        const stack = traceError.stack.split("\n");
        if (stack[3] !== undefined) {
          cache = stack[3].trim();
          return cache;
        }
      }
    }
  };
};
var DisablePropagation = /* @__PURE__ */ Reference2()("effect/Tracer/DisablePropagation", {
  defaultValue: constFalse
});

// node_modules/effect/dist/esm/internal/defaultServices.js
var liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty4(), /* @__PURE__ */ add2(clockTag, /* @__PURE__ */ make20()), /* @__PURE__ */ add2(consoleTag, defaultConsole), /* @__PURE__ */ add2(randomTag, /* @__PURE__ */ make23(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add2(tracerTag, nativeTracer));
var currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
var sleep = (duration) => {
  const decodedDuration = decode(duration);
  return clockWith((clock) => clock.sleep(decodedDuration));
};
var defaultServicesWith = (f) => withFiberRuntime((fiber) => f(fiber.currentDefaultServices));
var clockWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
var currentTimeMillis = /* @__PURE__ */ clockWith((clock) => clock.currentTimeMillis);
var currentTimeNanos = /* @__PURE__ */ clockWith((clock) => clock.currentTimeNanos);
var withClock = /* @__PURE__ */ dual(2, (effect, c) => fiberRefLocallyWith(currentServices, add2(clockTag, c))(effect));
var withConfigProvider = /* @__PURE__ */ dual(2, (self2, provider) => fiberRefLocallyWith(currentServices, add2(configProviderTag, provider))(self2));
var configProviderWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(configProviderTag.key)));
var config = (config2) => configProviderWith((_) => _.load(config2));
var randomWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(randomTag.key)));
var withRandom = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(randomTag, value))(effect));
var tracerWith = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
var withTracer = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(currentServices, add2(tracerTag, value))(effect));

// node_modules/effect/dist/esm/Clock.js
var sleep2 = sleep;
var currentTimeMillis2 = currentTimeMillis;
var currentTimeNanos2 = currentTimeNanos;
var clockWith2 = clockWith;
var Clock = clockTag;

// node_modules/effect/dist/esm/internal/fiberRefs.js
function unsafeMake5(fiberRefLocals) {
  return new FiberRefsImpl(fiberRefLocals);
}
function empty24() {
  return unsafeMake5(new Map);
}
var FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");

class FiberRefsImpl {
  locals;
  [FiberRefsSym] = FiberRefsSym;
  constructor(locals) {
    this.locals = locals;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
  const ref = _ref;
  let parentStack = _parentStack;
  let childStack = _childStack;
  let childModified = _childModified;
  let ret = undefined;
  while (ret === undefined) {
    if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
      const parentFiberId = headNonEmpty(parentStack)[0];
      const parentAncestors = tailNonEmpty(parentStack);
      const childFiberId = headNonEmpty(childStack)[0];
      const childRefValue = headNonEmpty(childStack)[1];
      const childAncestors = tailNonEmpty(childStack);
      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
        childStack = childAncestors;
        childModified = true;
      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
        parentStack = parentAncestors;
      } else {
        if (parentFiberId.id < childFiberId.id) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.id > childFiberId.id) {
          parentStack = parentAncestors;
        } else {
          ret = [childRefValue, childModified];
        }
      }
    } else {
      ret = [ref.initial, true];
    }
  }
  return ret;
};
var joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
  const parentFiberRefs = new Map(self2.locals);
  that.locals.forEach((childStack, fiberRef) => {
    const childValue = childStack[0][1];
    if (!childStack[0][0][symbol2](fiberId2)) {
      if (!parentFiberRefs.has(fiberRef)) {
        if (equals(childValue, fiberRef.initial)) {
          return;
        }
        parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
        return;
      }
      const parentStack = parentFiberRefs.get(fiberRef);
      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
      if (wasModified) {
        const patch9 = fiberRef.diff(ancestor, childValue);
        const oldValue = parentStack[0][1];
        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch9)(oldValue));
        if (!equals(oldValue, newValue)) {
          let newStack;
          const parentFiberId = parentStack[0][0];
          if (parentFiberId[symbol2](fiberId2)) {
            newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
          } else {
            newStack = [[fiberId2, newValue], ...parentStack];
          }
          parentFiberRefs.set(fiberRef, newStack);
        }
      }
    }
  });
  return new FiberRefsImpl(parentFiberRefs);
});
var forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
  const map10 = new Map;
  unsafeForkAs(self2, map10, childId);
  return new FiberRefsImpl(map10);
});
var unsafeForkAs = (self2, map10, fiberId2) => {
  self2.locals.forEach((stack, fiberRef) => {
    const oldValue = stack[0][1];
    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
    if (equals(oldValue, newValue)) {
      map10.set(fiberRef, stack);
    } else {
      map10.set(fiberRef, [[fiberId2, newValue], ...stack]);
    }
  });
};
var fiberRefs = (self2) => fromIterable5(self2.locals.keys());
var setAll = (self2) => forEachSequentialDiscard(fiberRefs(self2), (fiberRef) => fiberRefSet(fiberRef, getOrDefault(self2, fiberRef)));
var delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  const locals = new Map(self2.locals);
  locals.delete(fiberRef);
  return new FiberRefsImpl(locals);
});
var get9 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
  if (!self2.locals.has(fiberRef)) {
    return none2();
  }
  return some2(headNonEmpty(self2.locals.get(fiberRef))[1]);
});
var getOrDefault = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get9(self2, fiberRef), getOrElse(() => fiberRef.initial)));
var updateAs = /* @__PURE__ */ dual(2, (self2, {
  fiberId: fiberId2,
  fiberRef,
  value
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map([[fiberRef, [[fiberId2, value]]]]));
  }
  const locals = new Map(self2.locals);
  unsafeUpdateAs(locals, fiberId2, fiberRef, value);
  return new FiberRefsImpl(locals);
});
var unsafeUpdateAs = (locals, fiberId2, fiberRef, value) => {
  const oldStack = locals.get(fiberRef) ?? [];
  let newStack;
  if (isNonEmptyReadonlyArray(oldStack)) {
    const [currentId, currentValue] = headNonEmpty(oldStack);
    if (currentId[symbol2](fiberId2)) {
      if (equals(currentValue, value)) {
        return;
      } else {
        newStack = [[fiberId2, value], ...oldStack.slice(1)];
      }
    } else {
      newStack = [[fiberId2, value], ...oldStack];
    }
  } else {
    newStack = [[fiberId2, value]];
  }
  locals.set(fiberRef, newStack);
};
var updateManyAs = /* @__PURE__ */ dual(2, (self2, {
  entries: entries2,
  forkAs: forkAs2
}) => {
  if (self2.locals.size === 0) {
    return new FiberRefsImpl(new Map(entries2));
  }
  const locals = new Map(self2.locals);
  if (forkAs2 !== undefined) {
    unsafeForkAs(self2, locals, forkAs2);
  }
  entries2.forEach(([fiberRef, values3]) => {
    if (values3.length === 1) {
      unsafeUpdateAs(locals, values3[0][0], fiberRef, values3[0][1]);
    } else {
      values3.forEach(([fiberId2, value]) => {
        unsafeUpdateAs(locals, fiberId2, fiberRef, value);
      });
    }
  });
  return new FiberRefsImpl(locals);
});

// node_modules/effect/dist/esm/FiberRefs.js
var get10 = get9;
var getOrDefault2 = getOrDefault;
var joinAs2 = joinAs;
var setAll2 = setAll;
var updateManyAs2 = updateManyAs;
var empty25 = empty24;

// node_modules/effect/dist/esm/LogLevel.js
var All = logLevelAll;
var Fatal = logLevelFatal;
var Error2 = logLevelError;
var Warning = logLevelWarning;
var Info = logLevelInfo;
var Debug = logLevelDebug;
var Trace = logLevelTrace;
var None3 = logLevelNone;
var Order5 = /* @__PURE__ */ pipe(Order, /* @__PURE__ */ mapInput2((level) => level.ordinal));
var greaterThan4 = /* @__PURE__ */ greaterThan(Order5);
var fromLiteral = (literal) => {
  switch (literal) {
    case "All":
      return All;
    case "Debug":
      return Debug;
    case "Error":
      return Error2;
    case "Fatal":
      return Fatal;
    case "Info":
      return Info;
    case "Trace":
      return Trace;
    case "None":
      return None3;
    case "Warning":
      return Warning;
  }
};

// node_modules/effect/dist/esm/internal/logSpan.js
var make25 = (label, startTime) => ({
  label,
  startTime
});
var formatLabel = (key) => key.replace(/[\s="]/g, "_");
var render = (now) => (self2) => {
  const label = formatLabel(self2.label);
  return `${label}=${now - self2.startTime}ms`;
};

// node_modules/effect/dist/esm/LogSpan.js
var make26 = make25;

// node_modules/effect/dist/esm/Ref.js
var exports_Ref = {};
__export(exports_Ref, {
  updateSomeAndGet: () => updateSomeAndGet2,
  updateSome: () => updateSome2,
  updateAndGet: () => updateAndGet2,
  update: () => update3,
  unsafeMake: () => unsafeMake7,
  setAndGet: () => setAndGet2,
  set: () => set7,
  modifySome: () => modifySome2,
  modify: () => modify4,
  make: () => make28,
  getAndUpdateSome: () => getAndUpdateSome2,
  getAndUpdate: () => getAndUpdate2,
  getAndSet: () => getAndSet2,
  get: () => get12,
  RefTypeId: () => RefTypeId2
});

// node_modules/effect/dist/esm/Effectable.js
var EffectPrototype2 = EffectPrototype;
var CommitPrototype2 = CommitPrototype;
var Base2 = Base;
class Class extends Base2 {
}

// node_modules/effect/dist/esm/Readable.js
var TypeId13 = /* @__PURE__ */ Symbol.for("effect/Readable");
var Proto = {
  [TypeId13]: TypeId13,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/ref.js
var RefTypeId = /* @__PURE__ */ Symbol.for("effect/Ref");
var refVariance = {
  _A: (_) => _
};

class RefImpl extends Class {
  ref;
  commit() {
    return this.get;
  }
  [RefTypeId] = refVariance;
  [TypeId13] = TypeId13;
  constructor(ref) {
    super();
    this.ref = ref;
    this.get = sync(() => get6(this.ref));
  }
  get;
  modify(f) {
    return sync(() => {
      const current = get6(this.ref);
      const [b, a] = f(current);
      if (current !== a) {
        set3(a)(this.ref);
      }
      return b;
    });
  }
}
var unsafeMake6 = (value) => new RefImpl(make12(value));
var make27 = (value) => sync(() => unsafeMake6(value));
var get11 = (self2) => self2.get;
var set6 = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [undefined, value]));
var getAndSet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify((a) => [a, value]));
var getAndUpdate = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [a, f(a)]));
var getAndUpdateSome = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [value, value];
    }
    case "Some": {
      return [value, option.value];
    }
  }
}));
var setAndGet = /* @__PURE__ */ dual(2, (self2, value) => self2.modify(() => [value, value]));
var modify3 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
var modifySome = /* @__PURE__ */ dual(3, (self2, fallback, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [fallback, value];
    }
    case "Some": {
      return option.value;
    }
  }
}));
var update2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, f(a)]));
var updateAndGet = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => {
  const result = f(a);
  return [result, result];
}));
var updateSome = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [undefined, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet = /* @__PURE__ */ dual(2, (self2, pf) => self2.modify((value) => {
  const option = pf(value);
  switch (option._tag) {
    case "None": {
      return [value, value];
    }
    case "Some": {
      return [option.value, option.value];
    }
  }
}));

// node_modules/effect/dist/esm/Ref.js
var RefTypeId2 = RefTypeId;
var make28 = make27;
var get12 = get11;
var getAndSet2 = getAndSet;
var getAndUpdate2 = getAndUpdate;
var getAndUpdateSome2 = getAndUpdateSome;
var modify4 = modify3;
var modifySome2 = modifySome;
var set7 = set6;
var setAndGet2 = setAndGet;
var update3 = update2;
var updateAndGet2 = updateAndGet;
var updateSome2 = updateSome;
var updateSomeAndGet2 = updateSomeAndGet;
var unsafeMake7 = unsafeMake6;

// node_modules/effect/dist/esm/Tracer.js
var tracerWith2 = tracerWith;

// node_modules/effect/dist/esm/internal/fiberRefs/patch.js
var OP_EMPTY2 = "Empty";
var OP_ADD = "Add";
var OP_REMOVE = "Remove";
var OP_UPDATE = "Update";
var OP_AND_THEN = "AndThen";
var empty26 = {
  _tag: OP_EMPTY2
};
var diff8 = (oldValue, newValue) => {
  const missingLocals = new Map(oldValue.locals);
  let patch9 = empty26;
  for (const [fiberRef, pairs] of newValue.locals.entries()) {
    const newValue2 = headNonEmpty(pairs)[1];
    const old = missingLocals.get(fiberRef);
    if (old !== undefined) {
      const oldValue2 = headNonEmpty(old)[1];
      if (!equals(oldValue2, newValue2)) {
        patch9 = combine10({
          _tag: OP_UPDATE,
          fiberRef,
          patch: fiberRef.diff(oldValue2, newValue2)
        })(patch9);
      }
    } else {
      patch9 = combine10({
        _tag: OP_ADD,
        fiberRef,
        value: newValue2
      })(patch9);
    }
    missingLocals.delete(fiberRef);
  }
  for (const [fiberRef] of missingLocals.entries()) {
    patch9 = combine10({
      _tag: OP_REMOVE,
      fiberRef
    })(patch9);
  }
  return patch9;
};
var combine10 = /* @__PURE__ */ dual(2, (self2, that) => ({
  _tag: OP_AND_THEN,
  first: self2,
  second: that
}));
var patch9 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
  let fiberRefs2 = oldValue;
  let patches = of(self2);
  while (isNonEmptyReadonlyArray(patches)) {
    const head3 = headNonEmpty(patches);
    const tail = tailNonEmpty(patches);
    switch (head3._tag) {
      case OP_EMPTY2: {
        patches = tail;
        break;
      }
      case OP_ADD: {
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.value
        });
        patches = tail;
        break;
      }
      case OP_REMOVE: {
        fiberRefs2 = delete_(fiberRefs2, head3.fiberRef);
        patches = tail;
        break;
      }
      case OP_UPDATE: {
        const value = getOrDefault(fiberRefs2, head3.fiberRef);
        fiberRefs2 = updateAs(fiberRefs2, {
          fiberId: fiberId2,
          fiberRef: head3.fiberRef,
          value: head3.fiberRef.patch(head3.patch)(value)
        });
        patches = tail;
        break;
      }
      case OP_AND_THEN: {
        patches = prepend(head3.first)(prepend(head3.second)(tail));
        break;
      }
    }
  }
  return fiberRefs2;
});

// node_modules/effect/dist/esm/internal/metric/label.js
var MetricLabelSymbolKey = "effect/MetricLabel";
var MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);

class MetricLabelImpl {
  key;
  value;
  [MetricLabelTypeId] = MetricLabelTypeId;
  _hash;
  constructor(key, value) {
    this.key = key;
    this.value = value;
    this._hash = string(MetricLabelSymbolKey + this.key + this.value);
  }
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isMetricLabel(that) && this.key === that.key && this.value === that.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make29 = (key, value) => {
  return new MetricLabelImpl(key, value);
};
var isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);

// node_modules/effect/dist/esm/internal/core-effect.js
var annotateLogs = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentLogAnnotations, typeof args[1] === "string" ? set4(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations2));
});
var asSome = (self2) => map9(self2, some2);
var asSomeError = (self2) => mapError(self2, some2);
var try_2 = (arg) => {
  let evaluate;
  let onFailure = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    onFailure = arg.catch;
  }
  return suspend(() => {
    try {
      return succeed(internalCall(evaluate));
    } catch (error) {
      return fail2(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
    }
  });
};
var _catch = /* @__PURE__ */ dual(3, (self2, tag, options) => catchAll(self2, (e) => {
  if (hasProperty(e, tag) && e[tag] === options.failure) {
    return options.onFailure(e);
  }
  return fail2(e);
}));
var catchAllDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      return f(option.value.defect);
    }
  }
}));
var catchSomeCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause) => {
    const option = f(cause);
    switch (option._tag) {
      case "None": {
        return failCause(cause);
      }
      case "Some": {
        return option.value;
      }
    }
  },
  onSuccess: succeed
}));
var catchSomeDefect = /* @__PURE__ */ dual(2, (self2, pf) => catchAllCause(self2, (cause) => {
  const option = find(cause, (_) => isDieType(_) ? some2(_) : none2());
  switch (option._tag) {
    case "None": {
      return failCause(cause);
    }
    case "Some": {
      const optionEffect = pf(option.value.defect);
      return optionEffect._tag === "Some" ? optionEffect.value : failCause(cause);
    }
  }
}));
var catchTag = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, ...args) => {
  const f = args[args.length - 1];
  let predicate;
  if (args.length === 2) {
    predicate = isTagged(args[0]);
  } else {
    predicate = (e) => {
      const tag = hasProperty(e, "_tag") ? e["_tag"] : undefined;
      if (!tag)
        return false;
      for (let i = 0;i < args.length - 1; i++) {
        if (args[i] === tag)
          return true;
      }
      return false;
    };
  }
  return catchIf(self2, predicate, f);
});
var catchTags = /* @__PURE__ */ dual(2, (self2, cases) => {
  let keys3;
  return catchIf(self2, (e) => {
    keys3 ??= Object.keys(cases);
    return hasProperty(e, "_tag") && isString(e["_tag"]) && keys3.includes(e["_tag"]);
  }, (e) => cases[e["_tag"]](e));
});
var cause = (self2) => matchCause(self2, {
  onFailure: identity,
  onSuccess: () => empty20
});
var clockWith3 = clockWith2;
var clock = /* @__PURE__ */ clockWith3(succeed);
var delay = /* @__PURE__ */ dual(2, (self2, duration) => zipRight(sleep2(duration), self2));
var descriptorWith = (f) => withFiberRuntime((state, status) => f({
  id: state.id(),
  status,
  interruptors: interruptors(state.getFiberRef(currentInterruptedCause))
}));
var allowInterrupt = /* @__PURE__ */ descriptorWith((descriptor) => size3(descriptor.interruptors) > 0 ? interrupt2 : void_);
var descriptor = /* @__PURE__ */ descriptorWith(succeed);
var diffFiberRefs = (self2) => summarized(self2, fiberRefs2, diff8);
var diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip2(fiberRefs2, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff8(refs, refsNew), diff7(flags, flagsNew)]);
var Do = /* @__PURE__ */ succeed({});
var bind2 = /* @__PURE__ */ bind(map9, flatMap7);
var bindTo2 = /* @__PURE__ */ bindTo(map9);
var let_2 = /* @__PURE__ */ let_(map9);
var dropUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap7(dropping, (bool) => {
      if (bool) {
        builder.push(a);
        return succeed(true);
      }
      return predicate(a, index);
    });
  }
  return map9(dropping, () => builder);
}));
var dropWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let dropping = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    dropping = flatMap7(dropping, (d) => map9(d ? predicate(a, index) : succeed(false), (b) => {
      if (!b) {
        builder.push(a);
      }
      return b;
    }));
  }
  return map9(dropping, () => builder);
}));
var contextWith = (f) => map9(context(), f);
var eventually = (self2) => orElse2(self2, () => flatMap7(yieldNow(), () => eventually(self2)));
var filterMap4 = /* @__PURE__ */ dual(2, (elements, pf) => map9(forEachSequential(elements, identity), filterMap2(pf)));
var filterOrDie = /* @__PURE__ */ dual(3, (self2, predicate, orDieWith2) => filterOrElse(self2, predicate, (a) => dieSync(() => orDieWith2(a))));
var filterOrDieMessage = /* @__PURE__ */ dual(3, (self2, predicate, message) => filterOrElse(self2, predicate, () => dieMessage(message)));
var filterOrElse = /* @__PURE__ */ dual(3, (self2, predicate, orElse3) => flatMap7(self2, (a) => predicate(a) ? succeed(a) : orElse3(a)));
var liftPredicate = /* @__PURE__ */ dual(3, (self2, predicate, orFailWith) => suspend(() => predicate(self2) ? succeed(self2) : fail2(orFailWith(self2))));
var filterOrFail = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, predicate, orFailWith) => filterOrElse(self2, predicate, (a) => orFailWith === undefined ? fail2(new NoSuchElementException) : failSync(() => orFailWith(a))));
var findFirst4 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, 0, predicate, next.value);
  }
  return succeed(none2());
}));
var findLoop = (iterator, index, f, value) => flatMap7(f(value, index), (result) => {
  if (result) {
    return succeed(some2(value));
  }
  const next = iterator.next();
  if (!next.done) {
    return findLoop(iterator, index + 1, f, next.value);
  }
  return succeed(none2());
});
var firstSuccessOf = (effects) => suspend(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty2(list)) {
    return dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return pipe(tailNonEmpty2(list), reduce(headNonEmpty2(list), (left3, right3) => orElse2(left3, () => right3)));
});
var flipWith = /* @__PURE__ */ dual(2, (self2, f) => flip(f(flip(self2))));
var match7 = /* @__PURE__ */ dual(2, (self2, options) => matchEffect(self2, {
  onFailure: (e) => succeed(options.onFailure(e)),
  onSuccess: (a) => succeed(options.onSuccess(a))
}));
var every5 = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => forAllLoop(elements[Symbol.iterator](), 0, predicate)));
var forAllLoop = (iterator, index, f) => {
  const next = iterator.next();
  return next.done ? succeed(true) : flatMap7(f(next.value, index), (b) => b ? forAllLoop(iterator, index + 1, f) : succeed(b));
};
var forever = (self2) => {
  const loop = flatMap7(flatMap7(self2, () => yieldNow()), () => loop);
  return loop;
};
var fiberRefs2 = /* @__PURE__ */ withFiberRuntime((state) => succeed(state.getFiberRefs()));
var head3 = (self2) => flatMap7(self2, (as2) => {
  const iterator = as2[Symbol.iterator]();
  const next = iterator.next();
  if (next.done) {
    return fail2(new NoSuchElementException);
  }
  return succeed(next.value);
});
var ignore = (self2) => match7(self2, {
  onFailure: constVoid,
  onSuccess: constVoid
});
var ignoreLogged = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => logDebug(cause2, "An error was silently ignored because it is not anticipated to be useful"),
  onSuccess: () => void_
});
var inheritFiberRefs = (childFiberRefs) => updateFiberRefs((parentFiberId, parentFiberRefs) => joinAs2(parentFiberRefs, parentFiberId, childFiberRefs));
var isFailure = (self2) => match7(self2, {
  onFailure: constTrue,
  onSuccess: constFalse
});
var isSuccess2 = (self2) => match7(self2, {
  onFailure: constFalse,
  onSuccess: constTrue
});
var iterate = (initial, options) => suspend(() => {
  if (options.while(initial)) {
    return flatMap7(options.body(initial), (z2) => iterate(z2, options));
  }
  return succeed(initial);
});
var logWithLevel = (level) => (...message) => {
  const levelOption = fromNullable(level);
  let cause2 = undefined;
  for (let i = 0, len = message.length;i < len; i++) {
    const msg = message[i];
    if (isCause(msg)) {
      if (cause2 !== undefined) {
        cause2 = sequential(cause2, msg);
      } else {
        cause2 = msg;
      }
      message = [...message.slice(0, i), ...message.slice(i + 1)];
      i--;
    }
  }
  if (cause2 === undefined) {
    cause2 = empty20;
  }
  return withFiberRuntime((fiberState) => {
    fiberState.log(message, cause2, levelOption);
    return void_;
  });
};
var log = /* @__PURE__ */ logWithLevel();
var logTrace = /* @__PURE__ */ logWithLevel(Trace);
var logDebug = /* @__PURE__ */ logWithLevel(Debug);
var logInfo = /* @__PURE__ */ logWithLevel(Info);
var logWarning = /* @__PURE__ */ logWithLevel(Warning);
var logError = /* @__PURE__ */ logWithLevel(Error2);
var logFatal = /* @__PURE__ */ logWithLevel(Fatal);
var withLogSpan = /* @__PURE__ */ dual(2, (effect, label) => flatMap7(currentTimeMillis2, (now) => fiberRefLocallyWith(effect, currentLogSpan, prepend3(make26(label, now)))));
var logAnnotations = /* @__PURE__ */ fiberRefGet(currentLogAnnotations);
var loop = (initial, options) => options.discard ? loopDiscard(initial, options.while, options.step, options.body) : map9(loopInternal(initial, options.while, options.step, options.body), fromIterable);
var loopInternal = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap7(body(initial), (a) => map9(loopInternal(inc(initial), cont, inc, body), prepend3(a))) : sync(() => empty10()));
var loopDiscard = (initial, cont, inc, body) => suspend(() => cont(initial) ? flatMap7(body(initial), () => loopDiscard(inc(initial), cont, inc, body)) : void_);
var mapAccum2 = /* @__PURE__ */ dual(3, (elements, initial, f) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let result = succeed(initial);
  let next;
  let i = 0;
  while (!(next = iterator.next()).done) {
    const index = i++;
    const value = next.value;
    result = flatMap7(result, (state) => map9(f(state, value, index), ([z, b]) => {
      builder.push(b);
      return z;
    }));
  }
  return map9(result, (z) => [z, builder]);
}));
var mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (c) => failCauseSync(() => f(c)),
  onSuccess: succeed
}));
var memoize = (self2) => pipe(deferredMake(), flatMap7((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred(deferred), once, map9((complete) => zipRight(complete, pipe(deferredAwait(deferred), flatMap7(([patch10, a]) => as(zip2(patchFiberRefs(patch10[0]), updateRuntimeFlags(patch10[1])), a))))))));
var merge5 = (self2) => matchEffect(self2, {
  onFailure: (e) => succeed(e),
  onSuccess: succeed
});
var negate = (self2) => map9(self2, (b) => !b);
var none6 = (self2) => flatMap7(self2, (option) => {
  switch (option._tag) {
    case "None":
      return void_;
    case "Some":
      return fail2(new NoSuchElementException);
  }
});
var once = (self2) => map9(make28(true), (ref) => asVoid(whenEffect(self2, getAndSet2(ref, false))));
var option = (self2) => matchEffect(self2, {
  onFailure: () => succeed(none2()),
  onSuccess: (a) => succeed(some2(a))
});
var orElseFail = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => failSync(evaluate)));
var orElseSucceed = /* @__PURE__ */ dual(2, (self2, evaluate) => orElse2(self2, () => sync(evaluate)));
var parallelErrors = (self2) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const errors = fromIterable(failures(cause2));
    return errors.length === 0 ? failCause(cause2) : fail2(errors);
  },
  onSuccess: succeed
});
var patchFiberRefs = (patch10) => updateFiberRefs((fiberId2, fiberRefs3) => pipe(patch10, patch9(fiberId2, fiberRefs3)));
var promise = (evaluate) => evaluate.length >= 1 ? async_((resolve, signal) => {
  try {
    evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
}) : async_((resolve) => {
  try {
    evaluate().then((a) => resolve(succeed(a)), (e) => resolve(die2(e)));
  } catch (e) {
    resolve(die2(e));
  }
});
var provideService = /* @__PURE__ */ dual(3, (self2, tag, service) => contextWithEffect((env) => provideContext(self2, add2(env, tag, service))));
var provideServiceEffect = /* @__PURE__ */ dual(3, (self2, tag, effect) => contextWithEffect((env) => flatMap7(effect, (service) => provideContext(self2, pipe(env, add2(tag, service))))));
var random2 = /* @__PURE__ */ randomWith(succeed);
var reduce10 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduce((acc, el, i) => flatMap7(acc, (a) => f(a, el, i)), succeed(zero3)));
var reduceRight2 = /* @__PURE__ */ dual(3, (elements, zero3, f) => fromIterable(elements).reduceRight((acc, el, i) => flatMap7(acc, (a) => f(el, a, i)), succeed(zero3)));
var reduceWhile = /* @__PURE__ */ dual(3, (elements, zero3, options) => flatMap7(sync(() => elements[Symbol.iterator]()), (iterator) => reduceWhileLoop(iterator, 0, zero3, options.while, options.body)));
var reduceWhileLoop = (iterator, index, state, predicate, f) => {
  const next = iterator.next();
  if (!next.done && predicate(state)) {
    return flatMap7(f(state, next.value, index), (nextState) => reduceWhileLoop(iterator, index + 1, nextState, predicate, f));
  }
  return succeed(state);
};
var repeatN = /* @__PURE__ */ dual(2, (self2, n) => suspend(() => repeatNLoop(self2, n)));
var repeatNLoop = (self2, n) => flatMap7(self2, (a) => n <= 0 ? succeed(a) : zipRight(yieldNow(), repeatNLoop(self2, n - 1)));
var sandbox = (self2) => matchCauseEffect(self2, {
  onFailure: fail2,
  onSuccess: succeed
});
var setFiberRefs = (fiberRefs3) => suspend(() => setAll2(fiberRefs3));
var sleep3 = sleep2;
var succeedNone = /* @__PURE__ */ succeed(/* @__PURE__ */ none2());
var succeedSome = (value) => succeed(some2(value));
var summarized = /* @__PURE__ */ dual(3, (self2, summary, f) => flatMap7(summary, (start) => flatMap7(self2, (value) => map9(summary, (end) => [f(start, end), value]))));
var tagMetrics = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  return labelMetrics(arguments[0], typeof arguments[1] === "string" ? [make29(arguments[1], arguments[2])] : Object.entries(arguments[1]).map(([k, v]) => make29(k, v)));
});
var labelMetrics = /* @__PURE__ */ dual(2, (self2, labels) => fiberRefLocallyWith(self2, currentMetricLabels, (old) => union(old, labels)));
var takeUntil = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let effect = succeed(false);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    effect = flatMap7(effect, (bool) => {
      if (bool) {
        return succeed(true);
      }
      builder.push(a);
      return predicate(a, index);
    });
  }
  return map9(effect, () => builder);
}));
var takeWhile = /* @__PURE__ */ dual(2, (elements, predicate) => suspend(() => {
  const iterator = elements[Symbol.iterator]();
  const builder = [];
  let next;
  let taking = succeed(true);
  let i = 0;
  while ((next = iterator.next()) && !next.done) {
    const a = next.value;
    const index = i++;
    taking = flatMap7(taking, (taking2) => pipe(taking2 ? predicate(a, index) : succeed(false), map9((bool) => {
      if (bool) {
        builder.push(a);
      }
      return bool;
    })));
  }
  return map9(taking, () => builder);
}));
var tapBoth = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left": {
        return zipRight(onFailure(either3.left), failCause(cause2));
      }
      case "Right": {
        return failCause(cause2);
      }
    }
  },
  onSuccess: (a) => as(onSuccess(a), a)
}));
var tapDefect = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause2) => match2(keepDefects(cause2), {
  onNone: () => failCause(cause2),
  onSome: (a) => zipRight(f(a), failCause(cause2))
})));
var tapError = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => {
    const either3 = failureOrCause(cause2);
    switch (either3._tag) {
      case "Left":
        return zipRight(f(either3.left), failCause(cause2));
      case "Right":
        return failCause(cause2);
    }
  },
  onSuccess: succeed
}));
var tapErrorTag = /* @__PURE__ */ dual(3, (self2, k, f) => tapError(self2, (e) => {
  if (isTagged(e, k)) {
    return f(e);
  }
  return void_;
}));
var tapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect(self2, {
  onFailure: (cause2) => zipRight(f(cause2), failCause(cause2)),
  onSuccess: succeed
}));
var timed = (self2) => timedWith(self2, currentTimeNanos2);
var timedWith = /* @__PURE__ */ dual(2, (self2, nanos2) => summarized(self2, nanos2, (start, end) => nanos(end - start)));
var tracerWith3 = tracerWith2;
var tracer = /* @__PURE__ */ tracerWith3(succeed);
var tryPromise = (arg) => {
  let evaluate;
  let catcher = undefined;
  if (typeof arg === "function") {
    evaluate = arg;
  } else {
    evaluate = arg.try;
    catcher = arg.catch;
  }
  const fail4 = (e) => catcher ? failSync(() => catcher(e)) : fail2(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
  if (evaluate.length >= 1) {
    return async_((resolve, signal) => {
      try {
        evaluate(signal).then((a) => resolve(succeed(a)), (e) => resolve(fail4(e)));
      } catch (e) {
        resolve(fail4(e));
      }
    });
  }
  return async_((resolve) => {
    try {
      evaluate().then((a) => resolve(succeed(a)), (e) => resolve(fail4(e)));
    } catch (e) {
      resolve(fail4(e));
    }
  });
};
var tryMap = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => try_2({
  try: () => options.try(a),
  catch: options.catch
})));
var tryMapPromise = /* @__PURE__ */ dual(2, (self2, options) => flatMap7(self2, (a) => tryPromise({
  try: options.try.length >= 1 ? (signal) => options.try(a, signal) : () => options.try(a),
  catch: options.catch
})));
var unless = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? succeedNone : asSome(self2)));
var unlessEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap7(condition, (b) => b ? succeedNone : asSome(self2)));
var unsandbox = (self2) => mapErrorCause(self2, flatten4);
var updateFiberRefs = (f) => withFiberRuntime((state) => {
  state.setFiberRefs(f(state.id(), state.getFiberRefs()));
  return void_;
});
var updateService = /* @__PURE__ */ dual(3, (self2, tag, f) => mapInputContext(self2, (context2) => add2(context2, tag, f(unsafeGet3(context2, tag)))));
var when = /* @__PURE__ */ dual(2, (self2, condition) => suspend(() => condition() ? map9(self2, some2) : succeed(none2())));
var whenFiberRef = /* @__PURE__ */ dual(3, (self2, fiberRef, predicate) => flatMap7(fiberRefGet(fiberRef), (s) => predicate(s) ? map9(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var whenRef = /* @__PURE__ */ dual(3, (self2, ref, predicate) => flatMap7(get12(ref), (s) => predicate(s) ? map9(self2, (a) => [s, some2(a)]) : succeed([s, none2()])));
var withMetric = /* @__PURE__ */ dual(2, (self2, metric) => metric(self2));
var serviceFunctionEffect = (getService, f) => (...args) => flatMap7(getService, (a) => f(a)(...args));
var serviceFunction = (getService, f) => (...args) => map9(getService, (a) => f(a)(...args));
var serviceFunctions = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return (...args) => flatMap7(getService, (s) => s[prop](...args));
  }
});
var serviceConstants = (getService) => new Proxy({}, {
  get(_target, prop, _receiver) {
    return flatMap7(getService, (s) => isEffect(s[prop]) ? s[prop] : succeed(s[prop]));
  }
});
var serviceMembers = (getService) => ({
  functions: serviceFunctions(getService),
  constants: serviceConstants(getService)
});
var serviceOption = (tag) => map9(context(), getOption2(tag));
var serviceOptional = (tag) => flatMap7(context(), getOption2(tag));
var annotateCurrentSpan = function() {
  const args = arguments;
  return ignore(flatMap7(currentSpan, (span2) => sync(() => {
    if (typeof args[0] === "string") {
      span2.attribute(args[0], args[1]);
    } else {
      for (const key in args[0]) {
        span2.attribute(key, args[0][key]);
      }
    }
  })));
};
var linkSpanCurrent = function() {
  const args = arguments;
  const links = Array.isArray(args[0]) ? args[0] : [{
    _tag: "SpanLink",
    span: args[0],
    attributes: args[1] ?? {}
  }];
  return ignore(flatMap7(currentSpan, (span2) => sync(() => span2.addLinks(links))));
};
var annotateSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), function() {
  const args = arguments;
  return fiberRefLocallyWith(args[0], currentTracerSpanAnnotations, typeof args[1] === "string" ? set4(args[1], args[2]) : (annotations2) => Object.entries(args[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations2));
});
var currentParentSpan = /* @__PURE__ */ serviceOptional(spanTag);
var currentSpan = /* @__PURE__ */ flatMap7(/* @__PURE__ */ context(), (context2) => {
  const span2 = context2.unsafeMap.get(spanTag.key);
  return span2 !== undefined && span2._tag === "Span" ? succeed(span2) : fail2(new NoSuchElementException);
});
var linkSpans = /* @__PURE__ */ dual((args) => isEffect(args[0]), (self2, span2, attributes) => fiberRefLocallyWith(self2, currentTracerSpanLinks, append2({
  _tag: "SpanLink",
  span: span2,
  attributes: attributes ?? {}
})));
var bigint03 = /* @__PURE__ */ BigInt(0);
var filterDisablePropagation = /* @__PURE__ */ flatMap((span2) => get3(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none2() : some2(span2));
var unsafeMakeSpan = (fiber, name, options) => {
  const disablePropagation = !fiber.getFiberRef(currentTracerEnabled) || options.context && get3(options.context, DisablePropagation);
  const context2 = fiber.getFiberRef(currentContext);
  const parent = options.parent ? some2(options.parent) : options.root ? none2() : filterDisablePropagation(getOption2(context2, spanTag));
  let span2;
  if (disablePropagation) {
    span2 = noopSpan({
      name,
      parent,
      context: add2(options.context ?? empty4(), DisablePropagation, true)
    });
  } else {
    const services = fiber.getFiberRef(currentServices);
    const tracer2 = get3(services, tracerTag);
    const clock2 = get3(services, Clock);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const fiberRefs3 = fiber.getFiberRefs();
    const annotationsFromEnv = get10(fiberRefs3, currentTracerSpanAnnotations);
    const linksFromEnv = get10(fiberRefs3, currentTracerSpanLinks);
    const links = linksFromEnv._tag === "Some" ? options.links !== undefined ? [...toReadonlyArray(linksFromEnv.value), ...options.links ?? []] : toReadonlyArray(linksFromEnv.value) : options.links ?? empty2();
    span2 = tracer2.span(name, parent, options.context ?? empty4(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, options.kind ?? "internal");
    if (annotationsFromEnv._tag === "Some") {
      forEach4(annotationsFromEnv.value, (value, key) => span2.attribute(key, value));
    }
    if (options.attributes !== undefined) {
      Object.entries(options.attributes).forEach(([k, v]) => span2.attribute(k, v));
    }
  }
  if (typeof options.captureStackTrace === "function") {
    spanToTrace.set(span2, options.captureStackTrace);
  }
  return span2;
};
var makeSpan = (name, options) => {
  options = addSpanStackTrace(options);
  return withFiberRuntime((fiber) => succeed(unsafeMakeSpan(fiber, name, options)));
};
var spanAnnotations = /* @__PURE__ */ fiberRefGet(currentTracerSpanAnnotations);
var spanLinks = /* @__PURE__ */ fiberRefGet(currentTracerSpanLinks);
var endSpan = (span2, exit2, clock2, timingEnabled) => sync(() => {
  if (span2.status._tag === "Ended") {
    return;
  }
  if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
    span2.attribute("code.stacktrace", spanToTrace.get(span2)());
  }
  span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint03, exit2);
});
var useSpan = (name, ...args) => {
  const options = addSpanStackTrace(args.length === 1 ? undefined : args[0]);
  const evaluate = args[args.length - 1];
  return withFiberRuntime((fiber) => {
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock2 = get3(fiber.getFiberRef(currentServices), clockTag);
    return onExit(evaluate(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  });
};
var withParentSpan = /* @__PURE__ */ dual(2, (self2, span2) => provideService(self2, spanTag, span2));
var withSpan = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return useSpan(name, options, (span2) => withParentSpan(self2, span2));
  }
  return (self2) => useSpan(name, options, (span2) => withParentSpan(self2, span2));
};
var functionWithSpan = (options) => function() {
  let captureStackTrace = options.captureStackTrace ?? false;
  if (options.captureStackTrace !== false) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error;
    Error.stackTraceLimit = limit;
    let cache = false;
    captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (error.stack) {
        const stack = error.stack.trim().split("\n");
        cache = stack.slice(2).join("\n").trim();
        return cache;
      }
    };
  }
  return suspend(() => {
    const opts = typeof options.options === "function" ? options.options.apply(null, arguments) : options.options;
    return withSpan(suspend(() => internalCall(() => options.body.apply(this, arguments))), opts.name, {
      ...opts,
      captureStackTrace
    });
  });
};
var fromNullable2 = (value) => value == null ? fail2(new NoSuchElementException) : succeed(value);
var optionFromOptional = (self2) => catchAll(map9(self2, some2), (error) => isNoSuchElementException(error) ? succeedNone : fail2(error));

// node_modules/effect/dist/esm/internal/executionStrategy.js
var OP_SEQUENTIAL2 = "Sequential";
var OP_PARALLEL2 = "Parallel";
var OP_PARALLEL_N = "ParallelN";
var sequential2 = {
  _tag: OP_SEQUENTIAL2
};
var parallel2 = {
  _tag: OP_PARALLEL2
};
var parallelN = (parallelism) => ({
  _tag: OP_PARALLEL_N,
  parallelism
});
var isSequential = (self2) => self2._tag === OP_SEQUENTIAL2;
var isParallel = (self2) => self2._tag === OP_PARALLEL2;

// node_modules/effect/dist/esm/ExecutionStrategy.js
var sequential3 = sequential2;
var parallel3 = parallel2;
var parallelN2 = parallelN;

// node_modules/effect/dist/esm/FiberRefsPatch.js
var diff9 = diff8;
var patch10 = patch9;

// node_modules/effect/dist/esm/internal/fiberStatus.js
var FiberStatusSymbolKey = "effect/FiberStatus";
var FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
var OP_DONE = "Done";
var OP_RUNNING = "Running";
var OP_SUSPENDED = "Suspended";
var DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE}`);

class Done {
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_DONE;
  [symbol]() {
    return DoneHash;
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_DONE;
  }
}

class Running {
  runtimeFlags;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_RUNNING;
  constructor(runtimeFlags2) {
    this.runtimeFlags = runtimeFlags2;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;
  }
}

class Suspended {
  runtimeFlags;
  blockingOn;
  [FiberStatusTypeId] = FiberStatusTypeId;
  _tag = OP_SUSPENDED;
  constructor(runtimeFlags2, blockingOn) {
    this.runtimeFlags = runtimeFlags2;
    this.blockingOn = blockingOn;
  }
  [symbol]() {
    return pipe(hash(FiberStatusSymbolKey), combine(hash(this._tag)), combine(hash(this.runtimeFlags)), combine(hash(this.blockingOn)), cached(this));
  }
  [symbol2](that) {
    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals(this.blockingOn, that.blockingOn);
  }
}
var done3 = /* @__PURE__ */ new Done;
var running = (runtimeFlags2) => new Running(runtimeFlags2);
var suspended = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
var isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
var isDone = (self2) => self2._tag === OP_DONE;

// node_modules/effect/dist/esm/FiberStatus.js
var done4 = done3;
var running2 = running;
var suspended2 = suspended;
var isDone2 = isDone;

// node_modules/effect/dist/esm/Micro.js
function defaultEvaluate(_fiber) {
  return exitDie2(`Micro.evaluate: Not implemented`);
}
var TypeId14 = /* @__PURE__ */ Symbol.for("effect/Micro");
var MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
var MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
var microCauseVariance = {
  _E: identity
};

class MicroCauseImpl extends globalThis.Error {
  _tag;
  traces;
  [MicroCauseTypeId];
  constructor(_tag, originalError, traces) {
    const causeName = `MicroCause.${_tag}`;
    let name;
    let message;
    let stack;
    if (originalError instanceof globalThis.Error) {
      name = `(${causeName}) ${originalError.name}`;
      message = originalError.message;
      const messageLines = message.split("\n").length;
      stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
    } else {
      name = causeName;
      message = toStringUnknown(originalError, 0);
      stack = `${name}: ${message}`;
    }
    if (traces.length > 0) {
      stack += `\n    ${traces.join("\n    ")}`;
    }
    super(message);
    this._tag = _tag;
    this.traces = traces;
    this[MicroCauseTypeId] = microCauseVariance;
    this.name = name;
    this.stack = stack;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  toString() {
    return this.stack;
  }
  [NodeInspectSymbol]() {
    return this.stack;
  }
}
class Die extends MicroCauseImpl {
  defect;
  constructor(defect, traces = []) {
    super("Die", defect, traces);
    this.defect = defect;
  }
}
var causeDie = (defect, traces = []) => new Die(defect, traces);

class Interrupt extends MicroCauseImpl {
  constructor(traces = []) {
    super("Interrupt", "interrupted", traces);
  }
}
var causeInterrupt = (traces = []) => new Interrupt(traces);
var causeIsInterrupt = (self2) => self2._tag === "Interrupt";
var MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
var fiberVariance = {
  _A: identity,
  _E: identity
};

class MicroFiberImpl {
  context;
  interruptible;
  [MicroFiberTypeId];
  _stack = [];
  _observers = [];
  _exit;
  _children;
  currentOpCount = 0;
  constructor(context2, interruptible3 = true) {
    this.context = context2;
    this.interruptible = interruptible3;
    this[MicroFiberTypeId] = fiberVariance;
  }
  getRef(ref) {
    return unsafeGetReference(this.context, ref);
  }
  addObserver(cb) {
    if (this._exit) {
      cb(this._exit);
      return constVoid;
    }
    this._observers.push(cb);
    return () => {
      const index = this._observers.indexOf(cb);
      if (index >= 0) {
        this._observers.splice(index, 1);
      }
    };
  }
  _interrupted = false;
  unsafeInterrupt() {
    if (this._exit) {
      return;
    }
    this._interrupted = true;
    if (this.interruptible) {
      this.evaluate(exitInterrupt2);
    }
  }
  unsafePoll() {
    return this._exit;
  }
  evaluate(effect) {
    if (this._exit) {
      return;
    } else if (this._yielded !== undefined) {
      const yielded = this._yielded;
      this._yielded = undefined;
      yielded();
    }
    const exit2 = this.runLoop(effect);
    if (exit2 === Yield) {
      return;
    }
    const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
    if (interruptChildren !== undefined) {
      return this.evaluate(flatMap8(interruptChildren, () => exit2));
    }
    this._exit = exit2;
    for (let i = 0;i < this._observers.length; i++) {
      this._observers[i](exit2);
    }
    this._observers.length = 0;
  }
  runLoop(effect) {
    let yielding = false;
    let current = effect;
    this.currentOpCount = 0;
    try {
      while (true) {
        this.currentOpCount++;
        if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
          yielding = true;
          const prev = current;
          current = flatMap8(yieldNow2, () => prev);
        }
        current = current[evaluate](this);
        if (current === Yield) {
          const yielded = this._yielded;
          if (MicroExitTypeId in yielded) {
            this._yielded = undefined;
            return yielded;
          }
          return Yield;
        }
      }
    } catch (error) {
      if (!hasProperty(current, evaluate)) {
        return exitDie2(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
      }
      return exitDie2(error);
    }
  }
  getCont(symbol3) {
    while (true) {
      const op = this._stack.pop();
      if (!op)
        return;
      const cont = op[ensureCont] && op[ensureCont](this);
      if (cont)
        return {
          [symbol3]: cont
        };
      if (op[symbol3])
        return op;
    }
  }
  _yielded = undefined;
  yieldWith(value) {
    this._yielded = value;
    return Yield;
  }
  children() {
    return this._children ??= new Set;
  }
}
var fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
  interruptChildren: undefined
}));
var identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
var args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
var evaluate = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
var successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
var failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
var ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
var Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
var microVariance = {
  _A: identity,
  _E: identity,
  _R: identity
};
var MicroProto = {
  ...EffectPrototype2,
  _op: "Micro",
  [TypeId14]: microVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [Symbol.iterator]() {
    return new SingleShotGen(new YieldWrap(this));
  },
  toJSON() {
    return {
      _id: "Micro",
      op: this[identifier],
      ...args in this ? {
        args: this[args]
      } : undefined
    };
  },
  toString() {
    return format(this);
  },
  [NodeInspectSymbol]() {
    return format(this);
  }
};
var makePrimitiveProto = (options) => ({
  ...MicroProto,
  [identifier]: options.op,
  [evaluate]: options.eval ?? defaultEvaluate,
  [successCont]: options.contA,
  [failureCont]: options.contE,
  [ensureCont]: options.ensure
});
var makePrimitive = (options) => {
  const Proto2 = makePrimitiveProto(options);
  return function() {
    const self2 = Object.create(Proto2);
    self2[args] = options.single === false ? arguments : arguments[0];
    return self2;
  };
};
var makeExit = (options) => {
  const Proto2 = {
    ...makePrimitiveProto(options),
    [MicroExitTypeId]: MicroExitTypeId,
    _tag: options.op,
    get [options.prop]() {
      return this[args];
    },
    toJSON() {
      return {
        _id: "MicroExit",
        _tag: options.op,
        [options.prop]: this[args]
      };
    },
    [symbol2](that) {
      return isMicroExit(that) && that._tag === options.op && equals(this[args], that[args]);
    },
    [symbol]() {
      return cached(this, combine(string(options.op))(hash(this[args])));
    }
  };
  return function(value) {
    const self2 = Object.create(Proto2);
    self2[args] = value;
    self2[successCont] = undefined;
    self2[failureCont] = undefined;
    self2[ensureCont] = undefined;
    return self2;
  };
};
var succeed3 = /* @__PURE__ */ makeExit({
  op: "Success",
  prop: "value",
  eval(fiber) {
    const cont = fiber.getCont(successCont);
    return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var failCause3 = /* @__PURE__ */ makeExit({
  op: "Failure",
  prop: "cause",
  eval(fiber) {
    let cont = fiber.getCont(failureCont);
    while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
      cont = fiber.getCont(failureCont);
    }
    return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
  }
});
var yieldNowWith = /* @__PURE__ */ makePrimitive({
  op: "Yield",
  eval(fiber) {
    let resumed = false;
    fiber.getRef(CurrentScheduler).scheduleTask(() => {
      if (resumed)
        return;
      fiber.evaluate(exitVoid2);
    }, this[args] ?? 0);
    return fiber.yieldWith(() => {
      resumed = true;
    });
  }
});
var yieldNow2 = /* @__PURE__ */ yieldNowWith(0);
var void_2 = /* @__PURE__ */ succeed3(undefined);
var withMicroFiber = /* @__PURE__ */ makePrimitive({
  op: "WithMicroFiber",
  eval(fiber) {
    return this[args](fiber);
  }
});
var flatMap8 = /* @__PURE__ */ dual(2, (self2, f) => {
  const onSuccess = Object.create(OnSuccessProto);
  onSuccess[args] = self2;
  onSuccess[successCont] = f;
  return onSuccess;
});
var OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccess",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
var exitSucceed2 = succeed3;
var exitFailCause2 = failCause3;
var exitInterrupt2 = /* @__PURE__ */ exitFailCause2(/* @__PURE__ */ causeInterrupt());
var exitDie2 = (defect) => exitFailCause2(causeDie(defect));
var exitVoid2 = /* @__PURE__ */ exitSucceed2(undefined);
var setImmediate2 = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);

class MicroSchedulerDefault {
  tasks = [];
  running = false;
  scheduleTask(task, _priority) {
    this.tasks.push(task);
    if (!this.running) {
      this.running = true;
      setImmediate2(this.afterScheduled);
    }
  }
  afterScheduled = () => {
    this.running = false;
    this.runTasks();
  };
  runTasks() {
    const tasks = this.tasks;
    this.tasks = [];
    for (let i = 0, len = tasks.length;i < len; i++) {
      tasks[i]();
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
  }
  flush() {
    while (this.tasks.length > 0) {
      this.runTasks();
    }
  }
}
var updateContext = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
  const prev = fiber.context;
  fiber.context = f(prev);
  return onExit2(self2, () => {
    fiber.context = prev;
    return void_2;
  });
}));
var provideContext2 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext(self2, merge3(provided)));
class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference2()("effect/Micro/currentMaxOpsBeforeYield", {
  defaultValue: () => 2048
})) {
}
class CurrentScheduler extends (/* @__PURE__ */ Reference2()("effect/Micro/currentScheduler", {
  defaultValue: () => new MicroSchedulerDefault
})) {
}
var matchCauseEffect2 = /* @__PURE__ */ dual(2, (self2, options) => {
  const primitive = Object.create(OnSuccessAndFailureProto);
  primitive[args] = self2;
  primitive[successCont] = options.onSuccess;
  primitive[failureCont] = options.onFailure;
  return primitive;
});
var OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
  op: "OnSuccessAndFailure",
  eval(fiber) {
    fiber._stack.push(this);
    return this[args];
  }
});
var onExit2 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask2((restore) => matchCauseEffect2(restore(self2), {
  onFailure: (cause2) => flatMap8(f(exitFailCause2(cause2)), () => failCause3(cause2)),
  onSuccess: (a) => flatMap8(f(exitSucceed2(a)), () => succeed3(a))
})));
var setInterruptible = /* @__PURE__ */ makePrimitive({
  op: "SetInterruptible",
  ensure(fiber) {
    fiber.interruptible = this[args];
    if (fiber._interrupted && fiber.interruptible) {
      return () => exitInterrupt2;
    }
  }
});
var interruptible3 = (self2) => withMicroFiber((fiber) => {
  if (fiber.interruptible)
    return self2;
  fiber.interruptible = true;
  fiber._stack.push(setInterruptible(false));
  if (fiber._interrupted)
    return exitInterrupt2;
  return self2;
});
var uninterruptibleMask2 = (f) => withMicroFiber((fiber) => {
  if (!fiber.interruptible)
    return f(identity);
  fiber.interruptible = false;
  fiber._stack.push(setInterruptible(true));
  return f(interruptible3);
});
var runFork = (effect, options) => {
  const fiber = new MicroFiberImpl(CurrentScheduler.context(options?.scheduler ?? new MicroSchedulerDefault));
  fiber.evaluate(effect);
  if (options?.signal) {
    if (options.signal.aborted) {
      fiber.unsafeInterrupt();
    } else {
      const abort = () => fiber.unsafeInterrupt();
      options.signal.addEventListener("abort", abort, {
        once: true
      });
      fiber.addObserver(() => options.signal.removeEventListener("abort", abort));
    }
  }
  return fiber;
};

// node_modules/effect/dist/esm/Scheduler.js
class PriorityBuckets {
  buckets = [];
  scheduleTask(task, priority) {
    const length2 = this.buckets.length;
    let bucket = undefined;
    let index = 0;
    for (;index < length2; index++) {
      if (this.buckets[index][0] <= priority) {
        bucket = this.buckets[index];
      } else {
        break;
      }
    }
    if (bucket && bucket[0] === priority) {
      bucket[1].push(task);
    } else if (index === length2) {
      this.buckets.push([priority, [task]]);
    } else {
      this.buckets.splice(index, 0, [priority, [task]]);
    }
  }
}

class MixedScheduler {
  maxNextTickBeforeTimer;
  running = false;
  tasks = /* @__PURE__ */ new PriorityBuckets;
  constructor(maxNextTickBeforeTimer) {
    this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
  }
  starveInternal(depth) {
    const tasks = this.tasks.buckets;
    this.tasks.buckets = [];
    for (const [_, toRun] of tasks) {
      for (let i = 0;i < toRun.length; i++) {
        toRun[i]();
      }
    }
    if (this.tasks.buckets.length === 0) {
      this.running = false;
    } else {
      this.starve(depth);
    }
  }
  starve(depth = 0) {
    if (depth >= this.maxNextTickBeforeTimer) {
      setTimeout(() => this.starveInternal(0), 0);
    } else {
      Promise.resolve(undefined).then(() => this.starveInternal(depth + 1));
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  scheduleTask(task, priority) {
    this.tasks.scheduleTask(task, priority);
    if (!this.running) {
      this.running = true;
      this.starve();
    }
  }
}
var defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));

class SyncScheduler {
  tasks = /* @__PURE__ */ new PriorityBuckets;
  deferred = false;
  scheduleTask(task, priority) {
    if (this.deferred) {
      defaultScheduler.scheduleTask(task, priority);
    } else {
      this.tasks.scheduleTask(task, priority);
    }
  }
  shouldYield(fiber) {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority) : false;
  }
  flush() {
    while (this.tasks.buckets.length > 0) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0;i < toRun.length; i++) {
          toRun[i]();
        }
      }
    }
    this.deferred = true;
  }
}
var currentScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
var withScheduler = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler, scheduler));

// node_modules/effect/dist/esm/internal/completedRequestMap.js
var currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(new Map));

// node_modules/effect/dist/esm/internal/concurrency.js
var match9 = (concurrency, sequential4, unbounded2, bounded) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return unbounded2();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded(concurrency2) : sequential4());
    default:
      return concurrency > 1 ? bounded(concurrency) : sequential4();
  }
};
var matchSimple = (concurrency, sequential4, concurrent) => {
  switch (concurrency) {
    case undefined:
      return sequential4();
    case "unbounded":
      return concurrent();
    case "inherit":
      return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" || concurrency2 > 1 ? concurrent() : sequential4());
    default:
      return concurrency > 1 ? concurrent() : sequential4();
  }
};

// node_modules/effect/dist/esm/internal/fiberMessage.js
var OP_INTERRUPT_SIGNAL = "InterruptSignal";
var OP_STATEFUL = "Stateful";
var OP_RESUME = "Resume";
var OP_YIELD_NOW = "YieldNow";
var interruptSignal = (cause2) => ({
  _tag: OP_INTERRUPT_SIGNAL,
  cause: cause2
});
var stateful = (onFiber) => ({
  _tag: OP_STATEFUL,
  onFiber
});
var resume = (effect) => ({
  _tag: OP_RESUME,
  effect
});
var yieldNow3 = () => ({
  _tag: OP_YIELD_NOW
});

// node_modules/effect/dist/esm/internal/fiberScope.js
var FiberScopeSymbolKey = "effect/FiberScope";
var FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);

class Global {
  [FiberScopeTypeId] = FiberScopeTypeId;
  fiberId = none4;
  roots = /* @__PURE__ */ new Set;
  add(_runtimeFlags, child) {
    this.roots.add(child);
    child.addObserver(() => {
      this.roots.delete(child);
    });
  }
}

class Local {
  fiberId;
  parent;
  [FiberScopeTypeId] = FiberScopeTypeId;
  constructor(fiberId2, parent) {
    this.fiberId = fiberId2;
    this.parent = parent;
  }
  add(_runtimeFlags, child) {
    this.parent.tell(stateful((parentFiber) => {
      parentFiber.addChild(child);
      child.addObserver(() => {
        parentFiber.removeChild(child);
      });
    }));
  }
}
var unsafeMake8 = (fiber) => {
  return new Local(fiber.id(), fiber);
};
var globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global);

// node_modules/effect/dist/esm/internal/fiber.js
var FiberSymbolKey = "effect/Fiber";
var FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
var fiberVariance2 = {
  _E: (_) => _,
  _A: (_) => _
};
var fiberProto = {
  [FiberTypeId]: fiberVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var RuntimeFiberSymbolKey = "effect/Fiber";
var RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
var isRuntimeFiber = (self2) => (RuntimeFiberTypeId in self2);
var _await2 = (self2) => self2.await;
var inheritAll = (self2) => self2.inheritAll;
var interruptAllAs = /* @__PURE__ */ dual(2, /* @__PURE__ */ fnUntraced(function* (fibers, fiberId2) {
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber)) {
      fiber.unsafeInterruptAsFork(fiberId2);
      continue;
    }
    yield* fiber.interruptAsFork(fiberId2);
  }
  for (const fiber of fibers) {
    if (isRuntimeFiber(fiber) && fiber.unsafePoll()) {
      continue;
    }
    yield* fiber.await;
  }
}));
var interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
var join2 = (self2) => zipLeft(flatten5(self2.await), self2.inheritAll);
var _never = {
  ...CommitPrototype,
  commit() {
    return join2(this);
  },
  ...fiberProto,
  id: () => none4,
  await: never,
  children: /* @__PURE__ */ succeed([]),
  inheritAll: never,
  poll: /* @__PURE__ */ succeed(/* @__PURE__ */ none2()),
  interruptAsFork: () => never
};
var currentFiberURI = "effect/FiberCurrent";

// node_modules/effect/dist/esm/internal/logger.js
var LoggerSymbolKey = "effect/Logger";
var LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
var loggerVariance = {
  _Message: (_) => _,
  _Output: (_) => _
};
var makeLogger = (log2) => ({
  [LoggerTypeId]: loggerVariance,
  log: log2,
  pipe() {
    return pipeArguments(this, arguments);
  }
});
var none7 = {
  [LoggerTypeId]: loggerVariance,
  log: constVoid,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var textOnly = /^[^\s"=]*$/;
var format4 = (quoteValue, whitespace) => ({
  annotations: annotations2,
  cause: cause2,
  date,
  fiberId: fiberId2,
  logLevel,
  message,
  spans
}) => {
  const formatValue = (value) => value.match(textOnly) ? value : quoteValue(value);
  const format5 = (label, value) => `${formatLabel(label)}=${formatValue(value)}`;
  const append4 = (label, value) => " " + format5(label, value);
  let out = format5("timestamp", date.toISOString());
  out += append4("level", logLevel.label);
  out += append4("fiber", threadName(fiberId2));
  const messages = ensure(message);
  for (let i = 0;i < messages.length; i++) {
    out += append4("message", toStringUnknown(messages[i], whitespace));
  }
  if (!isEmptyType(cause2)) {
    out += append4("cause", pretty(cause2, {
      renderErrorCause: true
    }));
  }
  for (const span2 of spans) {
    out += " " + render(date.getTime())(span2);
  }
  for (const [label, value] of annotations2) {
    out += append4(label, toStringUnknown(value, whitespace));
  }
  return out;
};
var escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
var stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(escapeDoubleQuotes));
var logfmtLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format4(JSON.stringify, 0));
var colors = {
  bold: "1",
  red: "31",
  green: "32",
  yellow: "33",
  blue: "34",
  cyan: "36",
  white: "37",
  gray: "90",
  black: "30",
  bgBrightRed: "101"
};
var logLevelColors = {
  None: [],
  All: [],
  Trace: [colors.gray],
  Debug: [colors.blue],
  Info: [colors.green],
  Warning: [colors.yellow],
  Error: [colors.red],
  Fatal: [colors.bgBrightRed, colors.black]
};
var hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
var processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
var hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;

// node_modules/effect/dist/esm/internal/metric/boundaries.js
var MetricBoundariesSymbolKey = "effect/MetricBoundaries";
var MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);

class MetricBoundariesImpl {
  values;
  [MetricBoundariesTypeId] = MetricBoundariesTypeId;
  constructor(values3) {
    this.values = values3;
    this._hash = pipe(string(MetricBoundariesSymbolKey), combine(array2(this.values)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricBoundaries(u) && equals(this.values, u.values);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
var fromIterable8 = (iterable) => {
  const values3 = pipe(iterable, appendAll(of2(Number.POSITIVE_INFINITY)), dedupe);
  return new MetricBoundariesImpl(values3);
};
var exponential = (options) => pipe(makeBy(options.count - 1, (i) => options.start * Math.pow(options.factor, i)), unsafeFromArray, fromIterable8);

// node_modules/effect/dist/esm/internal/metric/keyType.js
var MetricKeyTypeSymbolKey = "effect/MetricKeyType";
var MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
var CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
var CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
var FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
var FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
var GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
var GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
var HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
var HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
var SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
var SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
var metricKeyTypeVariance = {
  _In: (_) => _,
  _Out: (_) => _
};

class CounterKeyType {
  incremental;
  bigint;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [CounterKeyTypeTypeId] = CounterKeyTypeTypeId;
  constructor(incremental, bigint3) {
    this.incremental = incremental;
    this.bigint = bigint3;
    this._hash = string(CounterKeyTypeSymbolKey);
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isCounterKey(that);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
class HistogramKeyType {
  boundaries;
  [MetricKeyTypeTypeId] = metricKeyTypeVariance;
  [HistogramKeyTypeTypeId] = HistogramKeyTypeTypeId;
  constructor(boundaries) {
    this.boundaries = boundaries;
    this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine(hash(this.boundaries)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](that) {
    return isHistogramKey(that) && equals(this.boundaries, that.boundaries);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter = (options) => new CounterKeyType(options?.incremental ?? false, options?.bigint ?? false);
var histogram = (boundaries) => {
  return new HistogramKeyType(boundaries);
};
var isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
var isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
var isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
var isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
var isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);

// node_modules/effect/dist/esm/internal/metric/key.js
var MetricKeySymbolKey = "effect/MetricKey";
var MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
var metricKeyVariance = {
  _Type: (_) => _
};
var arrayEquivilence = /* @__PURE__ */ getEquivalence3(equals);

class MetricKeyImpl {
  name;
  keyType;
  description;
  tags;
  [MetricKeyTypeId] = metricKeyVariance;
  constructor(name, keyType, description, tags = []) {
    this.name = name;
    this.keyType = keyType;
    this.description = description;
    this.tags = tags;
    this._hash = pipe(string(this.name + this.description), combine(hash(this.keyType)), combine(array2(this.tags)));
  }
  _hash;
  [symbol]() {
    return this._hash;
  }
  [symbol2](u) {
    return isMetricKey(u) && this.name === u.name && equals(this.keyType, u.keyType) && equals(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
var counter2 = (name, options) => new MetricKeyImpl(name, counter(options), fromNullable(options?.description));
var histogram2 = (name, boundaries, description) => new MetricKeyImpl(name, histogram(boundaries), fromNullable(description));
var taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union(self2.tags, extraTags)));

// node_modules/effect/dist/esm/internal/metric/state.js
var MetricStateSymbolKey = "effect/MetricState";
var MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
var CounterStateSymbolKey = "effect/MetricState/Counter";
var CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
var FrequencyStateSymbolKey = "effect/MetricState/Frequency";
var FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
var GaugeStateSymbolKey = "effect/MetricState/Gauge";
var GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
var HistogramStateSymbolKey = "effect/MetricState/Histogram";
var HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
var SummaryStateSymbolKey = "effect/MetricState/Summary";
var SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
var metricStateVariance = {
  _A: (_) => _
};

class CounterState {
  count;
  [MetricStateTypeId] = metricStateVariance;
  [CounterStateTypeId] = CounterStateTypeId;
  constructor(count) {
    this.count = count;
  }
  [symbol]() {
    return pipe(hash(CounterStateSymbolKey), combine(hash(this.count)), cached(this));
  }
  [symbol2](that) {
    return isCounterState(that) && this.count === that.count;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var arrayEquals = /* @__PURE__ */ getEquivalence3(equals);

class FrequencyState {
  occurrences;
  [MetricStateTypeId] = metricStateVariance;
  [FrequencyStateTypeId] = FrequencyStateTypeId;
  constructor(occurrences) {
    this.occurrences = occurrences;
  }
  _hash;
  [symbol]() {
    return pipe(string(FrequencyStateSymbolKey), combine(array2(fromIterable(this.occurrences.entries()))), cached(this));
  }
  [symbol2](that) {
    return isFrequencyState(that) && arrayEquals(fromIterable(this.occurrences.entries()), fromIterable(that.occurrences.entries()));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class GaugeState {
  value;
  [MetricStateTypeId] = metricStateVariance;
  [GaugeStateTypeId] = GaugeStateTypeId;
  constructor(value) {
    this.value = value;
  }
  [symbol]() {
    return pipe(hash(GaugeStateSymbolKey), combine(hash(this.value)), cached(this));
  }
  [symbol2](u) {
    return isGaugeState(u) && this.value === u.value;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class HistogramState {
  buckets;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [HistogramStateTypeId] = HistogramStateTypeId;
  constructor(buckets, count, min2, max2, sum) {
    this.buckets = buckets;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum;
  }
  [symbol]() {
    return pipe(hash(HistogramStateSymbolKey), combine(hash(this.buckets)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isHistogramState(that) && equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}

class SummaryState {
  error;
  quantiles;
  count;
  min;
  max;
  sum;
  [MetricStateTypeId] = metricStateVariance;
  [SummaryStateTypeId] = SummaryStateTypeId;
  constructor(error, quantiles, count, min2, max2, sum) {
    this.error = error;
    this.quantiles = quantiles;
    this.count = count;
    this.min = min2;
    this.max = max2;
    this.sum = sum;
  }
  [symbol]() {
    return pipe(hash(SummaryStateSymbolKey), combine(hash(this.error)), combine(hash(this.quantiles)), combine(hash(this.count)), combine(hash(this.min)), combine(hash(this.max)), combine(hash(this.sum)), cached(this));
  }
  [symbol2](that) {
    return isSummaryState(that) && this.error === that.error && equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var counter3 = (count) => new CounterState(count);
var frequency2 = (occurrences) => {
  return new FrequencyState(occurrences);
};
var gauge2 = (count) => new GaugeState(count);
var histogram3 = (options) => new HistogramState(options.buckets, options.count, options.min, options.max, options.sum);
var summary2 = (options) => new SummaryState(options.error, options.quantiles, options.count, options.min, options.max, options.sum);
var isCounterState = (u) => hasProperty(u, CounterStateTypeId);
var isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
var isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
var isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
var isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);

// node_modules/effect/dist/esm/internal/metric/hook.js
var MetricHookSymbolKey = "effect/MetricHook";
var MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
var metricHookVariance = {
  _In: (_) => _,
  _Out: (_) => _
};
var make30 = (options) => ({
  [MetricHookTypeId]: metricHookVariance,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
var bigint04 = /* @__PURE__ */ BigInt(0);
var counter4 = (key) => {
  let sum = key.keyType.bigint ? bigint04 : 0;
  const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value) => value >= bigint04 : (value) => value >= 0 : (_value) => true;
  const update4 = (value) => {
    if (canUpdate(value)) {
      sum = sum + value;
    }
  };
  return make30({
    get: () => counter3(sum),
    update: update4,
    modify: update4
  });
};
var frequency3 = (key) => {
  const values3 = new Map;
  for (const word of key.keyType.preregisteredWords) {
    values3.set(word, 0);
  }
  const update4 = (word) => {
    const slotCount = values3.get(word) ?? 0;
    values3.set(word, slotCount + 1);
  };
  return make30({
    get: () => frequency2(values3),
    update: update4,
    modify: update4
  });
};
var gauge3 = (_key, startAt) => {
  let value = startAt;
  return make30({
    get: () => gauge2(value),
    update: (v) => {
      value = v;
    },
    modify: (v) => {
      value = value + v;
    }
  });
};
var histogram4 = (key) => {
  const bounds = key.keyType.boundaries.values;
  const size6 = bounds.length;
  const values3 = new Uint32Array(size6 + 1);
  const boundaries = new Float64Array(size6);
  let count = 0;
  let sum = 0;
  let min2 = Number.MAX_VALUE;
  let max2 = Number.MIN_VALUE;
  pipe(bounds, sort(Order), map3((n, i) => {
    boundaries[i] = n;
  }));
  const update4 = (value) => {
    let from = 0;
    let to = size6;
    while (from !== to) {
      const mid = Math.floor(from + (to - from) / 2);
      const boundary = boundaries[mid];
      if (value <= boundary) {
        to = mid;
      } else {
        from = mid;
      }
      if (to === from + 1) {
        if (value <= boundaries[from]) {
          to = from;
        } else {
          from = to;
        }
      }
    }
    values3[from] = values3[from] + 1;
    count = count + 1;
    sum = sum + value;
    if (value < min2) {
      min2 = value;
    }
    if (value > max2) {
      max2 = value;
    }
  };
  const getBuckets = () => {
    const builder = allocate(size6);
    let cumulated = 0;
    for (let i = 0;i < size6; i++) {
      const boundary = boundaries[i];
      const value = values3[i];
      cumulated = cumulated + value;
      builder[i] = [boundary, cumulated];
    }
    return builder;
  };
  return make30({
    get: () => histogram3({
      buckets: getBuckets(),
      count,
      min: min2,
      max: max2,
      sum
    }),
    update: update4,
    modify: update4
  });
};
var summary3 = (key) => {
  const {
    error,
    maxAge,
    maxSize,
    quantiles
  } = key.keyType;
  const sortedQuantiles = pipe(quantiles, sort(Order));
  const values3 = allocate(maxSize);
  let head4 = 0;
  let count = 0;
  let sum = 0;
  let min2 = 0;
  let max2 = 0;
  const snapshot = (now) => {
    const builder = [];
    let i = 0;
    while (i !== maxSize - 1) {
      const item = values3[i];
      if (item != null) {
        const [t, v] = item;
        const age = millis(now - t);
        if (greaterThanOrEqualTo3(age, zero2) && lessThanOrEqualTo3(age, maxAge)) {
          builder.push(v);
        }
      }
      i = i + 1;
    }
    return calculateQuantiles(error, sortedQuantiles, sort(builder, Order));
  };
  const observe = (value, timestamp) => {
    if (maxSize > 0) {
      head4 = head4 + 1;
      const target = head4 % maxSize;
      values3[target] = [timestamp, value];
    }
    min2 = count === 0 ? value : Math.min(min2, value);
    max2 = count === 0 ? value : Math.max(max2, value);
    count = count + 1;
    sum = sum + value;
  };
  return make30({
    get: () => summary2({
      error,
      quantiles: snapshot(Date.now()),
      count,
      min: min2,
      max: max2,
      sum
    }),
    update: ([value, timestamp]) => observe(value, timestamp),
    modify: ([value, timestamp]) => observe(value, timestamp)
  });
};
var calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
  const sampleCount = sortedSamples.length;
  if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
    return empty2();
  }
  const head4 = sortedQuantiles[0];
  const tail = sortedQuantiles.slice(1);
  const resolvedHead = resolveQuantile(error, sampleCount, none2(), 0, head4, sortedSamples);
  const resolved = of(resolvedHead);
  tail.forEach((quantile) => {
    resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
  });
  return map3(resolved, (rq) => [rq.quantile, rq.value]);
};
var resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
  let error_1 = error;
  let sampleCount_1 = sampleCount;
  let current_1 = current;
  let consumed_1 = consumed;
  let quantile_1 = quantile;
  let rest_1 = rest;
  let error_2 = error;
  let sampleCount_2 = sampleCount;
  let current_2 = current;
  let consumed_2 = consumed;
  let quantile_2 = quantile;
  let rest_2 = rest;
  while (true) {
    if (!isNonEmptyReadonlyArray(rest_1)) {
      return {
        quantile: quantile_1,
        value: none2(),
        consumed: consumed_1,
        rest: []
      };
    }
    if (quantile_1 === 1) {
      return {
        quantile: quantile_1,
        value: some2(lastNonEmpty(rest_1)),
        consumed: consumed_1 + rest_1.length,
        rest: []
      };
    }
    const headValue = headNonEmpty(rest_1);
    const sameHead = span(rest_1, (n) => n === headValue);
    const desired = quantile_1 * sampleCount_1;
    const allowedError = error_1 / 2 * desired;
    const candConsumed = consumed_1 + sameHead[0].length;
    const candError = Math.abs(candConsumed - desired);
    if (candConsumed < desired - allowedError) {
      error_2 = error_1;
      sampleCount_2 = sampleCount_1;
      current_2 = head(rest_1);
      consumed_2 = candConsumed;
      quantile_2 = quantile_1;
      rest_2 = sameHead[1];
      error_1 = error_2;
      sampleCount_1 = sampleCount_2;
      current_1 = current_2;
      consumed_1 = consumed_2;
      quantile_1 = quantile_2;
      rest_1 = rest_2;
      continue;
    }
    if (candConsumed > desired + allowedError) {
      const valueToReturn = isNone2(current_1) ? some2(headValue) : current_1;
      return {
        quantile: quantile_1,
        value: valueToReturn,
        consumed: consumed_1,
        rest: rest_1
      };
    }
    switch (current_1._tag) {
      case "None": {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      case "Some": {
        const prevError = Math.abs(desired - current_1.value);
        if (candError < prevError) {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        return {
          quantile: quantile_1,
          value: some2(current_1.value),
          consumed: consumed_1,
          rest: rest_1
        };
      }
    }
  }
  throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
};

// node_modules/effect/dist/esm/internal/metric/pair.js
var MetricPairSymbolKey = "effect/MetricPair";
var MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
var metricPairVariance = {
  _Type: (_) => _
};
var unsafeMake9 = (metricKey, metricState) => {
  return {
    [MetricPairTypeId]: metricPairVariance,
    metricKey,
    metricState,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
};

// node_modules/effect/dist/esm/internal/metric/registry.js
var MetricRegistrySymbolKey = "effect/MetricRegistry";
var MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);

class MetricRegistryImpl {
  [MetricRegistryTypeId] = MetricRegistryTypeId;
  map = /* @__PURE__ */ empty21();
  snapshot() {
    const result = [];
    for (const [key, hook] of this.map) {
      result.push(unsafeMake9(key, hook.get()));
    }
    return result;
  }
  get(key) {
    const hook = pipe(this.map, get8(key), getOrUndefined);
    if (hook == null) {
      if (isCounterKey(key.keyType)) {
        return this.getCounter(key);
      }
      if (isGaugeKey(key.keyType)) {
        return this.getGauge(key);
      }
      if (isFrequencyKey(key.keyType)) {
        return this.getFrequency(key);
      }
      if (isHistogramKey(key.keyType)) {
        return this.getHistogram(key);
      }
      if (isSummaryKey(key.keyType)) {
        return this.getSummary(key);
      }
      throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
    } else {
      return hook;
    }
  }
  getCounter(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const counter5 = counter4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set5(key, counter5));
      }
      value = counter5;
    }
    return value;
  }
  getFrequency(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const frequency4 = frequency3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set5(key, frequency4));
      }
      value = frequency4;
    }
    return value;
  }
  getGauge(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const gauge4 = gauge3(key, key.keyType.bigint ? BigInt(0) : 0);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set5(key, gauge4));
      }
      value = gauge4;
    }
    return value;
  }
  getHistogram(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const histogram5 = histogram4(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set5(key, histogram5));
      }
      value = histogram5;
    }
    return value;
  }
  getSummary(key) {
    let value = pipe(this.map, get8(key), getOrUndefined);
    if (value == null) {
      const summary4 = summary3(key);
      if (!pipe(this.map, has4(key))) {
        pipe(this.map, set5(key, summary4));
      }
      value = summary4;
    }
    return value;
  }
}
var make31 = () => {
  return new MetricRegistryImpl;
};

// node_modules/effect/dist/esm/internal/metric.js
var MetricSymbolKey = "effect/Metric";
var MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
var metricVariance = {
  _Type: (_) => _,
  _In: (_) => _,
  _Out: (_) => _
};
var globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make31());
var make32 = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
  const metric = Object.assign((effect) => tap(effect, (a) => update4(metric, a)), {
    [MetricTypeId]: metricVariance,
    keyType,
    unsafeUpdate,
    unsafeValue,
    unsafeModify,
    register() {
      this.unsafeValue([]);
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  return metric;
};
var counter5 = (name, options) => fromMetricKey(counter2(name, options));
var fromMetricKey = (key) => {
  let untaggedHook;
  const hookCache = new WeakMap;
  const hook = (extraTags) => {
    if (extraTags.length === 0) {
      if (untaggedHook !== undefined) {
        return untaggedHook;
      }
      untaggedHook = globalMetricRegistry.get(key);
      return untaggedHook;
    }
    let hook2 = hookCache.get(extraTags);
    if (hook2 !== undefined) {
      return hook2;
    }
    hook2 = globalMetricRegistry.get(taggedWithLabels(key, extraTags));
    hookCache.set(extraTags, hook2);
    return hook2;
  };
  return make32(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
};
var histogram5 = (name, boundaries, description) => fromMetricKey(histogram2(name, boundaries, description));
var tagged = /* @__PURE__ */ dual(3, (self2, key, value) => taggedWithLabels2(self2, [make29(key, value)]));
var taggedWithLabels2 = /* @__PURE__ */ dual(2, (self2, extraTags) => {
  return make32(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union(extraTags, extraTags1)));
});
var update4 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync(() => self2.unsafeUpdate(input, tags))));

// node_modules/effect/dist/esm/internal/request.js
var RequestSymbolKey = "effect/Request";
var RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
var requestVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var RequestPrototype = {
  ...StructuralPrototype,
  [RequestTypeId]: requestVariance
};
var isRequest = (u) => hasProperty(u, RequestTypeId);
var Class2 = /* @__PURE__ */ function() {
  function Class3(args2) {
    if (args2) {
      Object.assign(this, args2);
    }
  }
  Class3.prototype = RequestPrototype;
  return Class3;
}();
var complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map10) => sync(() => {
  if (map10.has(self2)) {
    const entry = map10.get(self2);
    if (!entry.state.completed) {
      entry.state.completed = true;
      deferredUnsafeDone(entry.result, result);
    }
  }
})));
class Listeners {
  count = 0;
  observers = /* @__PURE__ */ new Set;
  interrupted = false;
  addObserver(f) {
    this.observers.add(f);
  }
  removeObserver(f) {
    this.observers.delete(f);
  }
  increment() {
    this.count++;
    this.observers.forEach((f) => f(this.count));
  }
  decrement() {
    this.count--;
    this.observers.forEach((f) => f(this.count));
  }
}

// node_modules/effect/dist/esm/internal/redBlackTree/iterator.js
var Direction = {
  Forward: 0,
  Backward: 1 << 0
};

class RedBlackTreeIterator {
  self;
  stack;
  direction;
  count = 0;
  constructor(self2, stack, direction) {
    this.self = self2;
    this.stack = stack;
    this.direction = direction;
  }
  clone() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction);
  }
  reversed() {
    return new RedBlackTreeIterator(this.self, this.stack.slice(), this.direction === Direction.Forward ? Direction.Backward : Direction.Forward);
  }
  next() {
    const entry = this.entry;
    this.count++;
    if (this.direction === Direction.Forward) {
      this.moveNext();
    } else {
      this.movePrev();
    }
    switch (entry._tag) {
      case "None": {
        return {
          done: true,
          value: this.count
        };
      }
      case "Some": {
        return {
          done: false,
          value: entry.value
        };
      }
    }
  }
  get key() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].key);
    }
    return none2();
  }
  get value() {
    if (this.stack.length > 0) {
      return some2(this.stack[this.stack.length - 1].value);
    }
    return none2();
  }
  get entry() {
    return map2(last(this.stack), (node) => [node.key, node.value]);
  }
  get index() {
    let idx = 0;
    const stack = this.stack;
    if (stack.length === 0) {
      const r = this.self._root;
      if (r != null) {
        return r.count;
      }
      return 0;
    } else if (stack[stack.length - 1].left != null) {
      idx = stack[stack.length - 1].left.count;
    }
    for (let s = stack.length - 2;s >= 0; --s) {
      if (stack[s + 1] === stack[s].right) {
        ++idx;
        if (stack[s].left != null) {
          idx += stack[s].left.count;
        }
      }
    }
    return idx;
  }
  moveNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n.right != null) {
      n = n.right;
      while (n != null) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasNext() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].right != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].left === stack[s]) {
        return true;
      }
    }
    return false;
  }
  movePrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return;
    }
    let n = stack[stack.length - 1];
    if (n != null && n.left != null) {
      n = n.left;
      while (n != null) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  }
  get hasPrev() {
    const stack = this.stack;
    if (stack.length === 0) {
      return false;
    }
    if (stack[stack.length - 1].left != null) {
      return true;
    }
    for (let s = stack.length - 1;s > 0; --s) {
      if (stack[s - 1].right === stack[s]) {
        return true;
      }
    }
    return false;
  }
}

// node_modules/effect/dist/esm/internal/redBlackTree/node.js
var Color = {
  Red: 0,
  Black: 1 << 0
};
var repaint = ({
  count,
  key,
  left: left3,
  right: right3,
  value
}, color) => ({
  color,
  key,
  value,
  left: left3,
  right: right3,
  count
});
var recount = (node) => {
  node.count = 1 + (node.left?.count ?? 0) + (node.right?.count ?? 0);
};

// node_modules/effect/dist/esm/internal/redBlackTree.js
var RedBlackTreeSymbolKey = "effect/RedBlackTree";
var RedBlackTreeTypeId = /* @__PURE__ */ Symbol.for(RedBlackTreeSymbolKey);
var redBlackTreeVariance = {
  _Key: (_) => _,
  _Value: (_) => _
};
var RedBlackTreeProto = {
  [RedBlackTreeTypeId]: redBlackTreeVariance,
  [symbol]() {
    let hash2 = hash(RedBlackTreeSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isRedBlackTree(that)) {
      if ((this._root?.count ?? 0) !== (that._root?.count ?? 0)) {
        return false;
      }
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries2[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  [Symbol.iterator]() {
    const stack = [];
    let n = this._root;
    while (n != null) {
      stack.push(n);
      n = n.left;
    }
    return new RedBlackTreeIterator(this, stack, Direction.Forward);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "RedBlackTree",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (ord, root) => {
  const tree = Object.create(RedBlackTreeProto);
  tree._ord = ord;
  tree._root = root;
  return tree;
};
var isRedBlackTree = (u) => hasProperty(u, RedBlackTreeTypeId);
var empty27 = (ord) => makeImpl3(ord, undefined);
var fromIterable9 = /* @__PURE__ */ dual(2, (entries2, ord) => {
  let tree = empty27(ord);
  for (const [key, value] of entries2) {
    tree = insert(tree, key, value);
  }
  return tree;
});
var findFirst5 = /* @__PURE__ */ dual(2, (self2, key) => {
  const cmp = self2._ord;
  let node = self2._root;
  while (node !== undefined) {
    const d = cmp(key, node.key);
    if (equals(key, node.key)) {
      return some2(node.value);
    }
    if (d <= 0) {
      node = node.left;
    } else {
      node = node.right;
    }
  }
  return none2();
});
var has5 = /* @__PURE__ */ dual(2, (self2, key) => isSome2(findFirst5(self2, key)));
var insert = /* @__PURE__ */ dual(3, (self2, key, value) => {
  const cmp = self2._ord;
  let n = self2._root;
  const n_stack = [];
  const d_stack = [];
  while (n != null) {
    const d = cmp(key, n.key);
    n_stack.push(n);
    d_stack.push(d);
    if (d <= 0) {
      n = n.left;
    } else {
      n = n.right;
    }
  }
  n_stack.push({
    color: Color.Red,
    key,
    value,
    left: undefined,
    right: undefined,
    count: 1
  });
  for (let s = n_stack.length - 2;s >= 0; --s) {
    const n2 = n_stack[s];
    if (d_stack[s] <= 0) {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n_stack[s + 1],
        right: n2.right,
        count: n2.count + 1
      };
    } else {
      n_stack[s] = {
        color: n2.color,
        key: n2.key,
        value: n2.value,
        left: n2.left,
        right: n_stack[s + 1],
        count: n2.count + 1
      };
    }
  }
  for (let s = n_stack.length - 1;s > 1; --s) {
    const p = n_stack[s - 1];
    const n3 = n_stack[s];
    if (p.color === Color.Black || n3.color === Color.Black) {
      break;
    }
    const pp = n_stack[s - 2];
    if (pp.left === p) {
      if (p.left === n3) {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.left = p.right;
          p.color = Color.Black;
          p.right = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = p;
            } else {
              ppp.right = p;
            }
          }
          break;
        }
      } else {
        const y = pp.right;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.right = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.right = n3.left;
          pp.color = Color.Red;
          pp.left = n3.right;
          n3.color = Color.Black;
          n3.left = p;
          n3.right = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.left === pp) {
              ppp.left = n3;
            } else {
              ppp.right = n3;
            }
          }
          break;
        }
      }
    } else {
      if (p.right === n3) {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          pp.color = Color.Red;
          pp.right = p.left;
          p.color = Color.Black;
          p.left = pp;
          n_stack[s - 2] = p;
          n_stack[s - 1] = n3;
          recount(pp);
          recount(p);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = p;
            } else {
              ppp.left = p;
            }
          }
          break;
        }
      } else {
        const y = pp.left;
        if (y && y.color === Color.Red) {
          p.color = Color.Black;
          pp.left = repaint(y, Color.Black);
          pp.color = Color.Red;
          s -= 1;
        } else {
          p.left = n3.right;
          pp.color = Color.Red;
          pp.right = n3.left;
          n3.color = Color.Black;
          n3.right = p;
          n3.left = pp;
          n_stack[s - 2] = n3;
          n_stack[s - 1] = p;
          recount(pp);
          recount(p);
          recount(n3);
          if (s >= 3) {
            const ppp = n_stack[s - 3];
            if (ppp.right === pp) {
              ppp.right = n3;
            } else {
              ppp.left = n3;
            }
          }
          break;
        }
      }
    }
  }
  n_stack[0].color = Color.Black;
  return makeImpl3(self2._ord, n_stack[0]);
});
var keysForward = (self2) => keys3(self2, Direction.Forward);
var keys3 = (self2, direction) => {
  const begin = self2[Symbol.iterator]();
  let count = 0;
  return {
    [Symbol.iterator]: () => keys3(self2, direction),
    next: () => {
      count++;
      const entry = begin.key;
      if (direction === Direction.Forward) {
        begin.moveNext();
      } else {
        begin.movePrev();
      }
      switch (entry._tag) {
        case "None": {
          return {
            done: true,
            value: count
          };
        }
        case "Some": {
          return {
            done: false,
            value: entry.value
          };
        }
      }
    }
  };
};

// node_modules/effect/dist/esm/RedBlackTree.js
var fromIterable10 = fromIterable9;
var has6 = has5;
var keys4 = keysForward;

// node_modules/effect/dist/esm/SortedSet.js
var TypeId15 = /* @__PURE__ */ Symbol.for("effect/SortedSet");
var SortedSetProto = {
  [TypeId15]: {
    _A: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.keyTree), combine(hash(TypeId15)), cached(this));
  },
  [symbol2](that) {
    return isSortedSet(that) && equals(this.keyTree, that.keyTree);
  },
  [Symbol.iterator]() {
    return keys4(this.keyTree);
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromTree = (keyTree) => {
  const a = Object.create(SortedSetProto);
  a.keyTree = keyTree;
  return a;
};
var isSortedSet = (u) => hasProperty(u, TypeId15);
var fromIterable11 = /* @__PURE__ */ dual(2, (iterable, ord) => fromTree(fromIterable10(Array.from(iterable).map((k) => [k, true]), ord)));
var every6 = /* @__PURE__ */ dual(2, (self2, predicate) => {
  for (const value of self2) {
    if (!predicate(value)) {
      return false;
    }
  }
  return true;
});
var has7 = /* @__PURE__ */ dual(2, (self2, value) => has6(self2.keyTree, value));
var isSubset2 = /* @__PURE__ */ dual(2, (self2, that) => every6(self2, (a) => has7(that, a)));
var values3 = (self2) => keys4(self2.keyTree);
var getEquivalence6 = () => (a, b) => isSubset2(a, b) && isSubset2(b, a);

// node_modules/effect/dist/esm/internal/supervisor.js
var SupervisorSymbolKey = "effect/Supervisor";
var SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
var supervisorVariance = {
  _T: (_) => _
};

class ProxySupervisor {
  underlying;
  value0;
  [SupervisorTypeId] = supervisorVariance;
  constructor(underlying, value0) {
    this.underlying = underlying;
    this.value0 = value0;
  }
  get value() {
    return this.value0;
  }
  onStart(context2, effect, parent, fiber) {
    this.underlying.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.underlying.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.underlying.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.underlying.onSuspend(fiber);
  }
  onResume(fiber) {
    this.underlying.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}

class Zip {
  left;
  right;
  _tag = "Zip";
  [SupervisorTypeId] = supervisorVariance;
  constructor(left3, right3) {
    this.left = left3;
    this.right = right3;
  }
  get value() {
    return zip2(this.left.value, this.right.value);
  }
  onStart(context2, effect, parent, fiber) {
    this.left.onStart(context2, effect, parent, fiber);
    this.right.onStart(context2, effect, parent, fiber);
  }
  onEnd(value, fiber) {
    this.left.onEnd(value, fiber);
    this.right.onEnd(value, fiber);
  }
  onEffect(fiber, effect) {
    this.left.onEffect(fiber, effect);
    this.right.onEffect(fiber, effect);
  }
  onSuspend(fiber) {
    this.left.onSuspend(fiber);
    this.right.onSuspend(fiber);
  }
  onResume(fiber) {
    this.left.onResume(fiber);
    this.right.onResume(fiber);
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
}
var isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");

class Track {
  [SupervisorTypeId] = supervisorVariance;
  fibers = /* @__PURE__ */ new Set;
  get value() {
    return sync(() => Array.from(this.fibers));
  }
  onStart(_context, _effect, _parent, fiber) {
    this.fibers.add(fiber);
  }
  onEnd(_value, fiber) {
    this.fibers.delete(fiber);
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}

class Const {
  effect;
  [SupervisorTypeId] = supervisorVariance;
  constructor(effect) {
    this.effect = effect;
  }
  get value() {
    return this.effect;
  }
  onStart(_context, _effect, _parent, _fiber) {
  }
  onEnd(_value, _fiber) {
  }
  onEffect(_fiber, _effect) {
  }
  onSuspend(_fiber) {
  }
  onResume(_fiber) {
  }
  map(f) {
    return new ProxySupervisor(this, pipe(this.value, map9(f)));
  }
  zip(right3) {
    return new Zip(this, right3);
  }
  onRun(execution, _fiber) {
    return execution();
  }
}
var unsafeTrack = () => {
  return new Track;
};
var track = /* @__PURE__ */ sync(unsafeTrack);
var fromEffect = (effect) => {
  return new Const(effect);
};
var none8 = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect(void_));

// node_modules/effect/dist/esm/Differ.js
var make34 = make15;

// node_modules/effect/dist/esm/internal/supervisor/patch.js
var OP_EMPTY3 = "Empty";
var OP_ADD_SUPERVISOR = "AddSupervisor";
var OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
var OP_AND_THEN2 = "AndThen";
var empty29 = {
  _tag: OP_EMPTY3
};
var combine11 = (self2, that) => {
  return {
    _tag: OP_AND_THEN2,
    first: self2,
    second: that
  };
};
var patch11 = (self2, supervisor) => {
  return patchLoop(supervisor, of2(self2));
};
var patchLoop = (_supervisor, _patches) => {
  let supervisor = _supervisor;
  let patches = _patches;
  while (isNonEmpty2(patches)) {
    const head4 = headNonEmpty2(patches);
    switch (head4._tag) {
      case OP_EMPTY3: {
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_ADD_SUPERVISOR: {
        supervisor = supervisor.zip(head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_REMOVE_SUPERVISOR: {
        supervisor = removeSupervisor(supervisor, head4.supervisor);
        patches = tailNonEmpty2(patches);
        break;
      }
      case OP_AND_THEN2: {
        patches = prepend2(head4.first)(prepend2(head4.second)(tailNonEmpty2(patches)));
        break;
      }
    }
  }
  return supervisor;
};
var removeSupervisor = (self2, that) => {
  if (equals(self2, that)) {
    return none8;
  } else {
    if (isZip(self2)) {
      return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
    } else {
      return self2;
    }
  }
};
var toSet2 = (self2) => {
  if (equals(self2, none8)) {
    return empty8();
  } else {
    if (isZip(self2)) {
      return pipe(toSet2(self2.left), union3(toSet2(self2.right)));
    } else {
      return make11(self2);
    }
  }
};
var diff10 = (oldValue, newValue) => {
  if (equals(oldValue, newValue)) {
    return empty29;
  }
  const oldSupervisors = toSet2(oldValue);
  const newSupervisors = toSet2(newValue);
  const added = pipe(newSupervisors, difference3(oldSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_ADD_SUPERVISOR,
    supervisor
  })));
  const removed = pipe(oldSupervisors, difference3(newSupervisors), reduce5(empty29, (patch12, supervisor) => combine11(patch12, {
    _tag: OP_REMOVE_SUPERVISOR,
    supervisor
  })));
  return combine11(added, removed);
};
var differ2 = /* @__PURE__ */ make34({
  empty: empty29,
  patch: patch11,
  combine: combine11,
  diff: diff10
});

// node_modules/effect/dist/esm/internal/fiberRuntime.js
var fiberStarted = /* @__PURE__ */ counter5("effect_fiber_started", {
  incremental: true
});
var fiberActive = /* @__PURE__ */ counter5("effect_fiber_active");
var fiberSuccesses = /* @__PURE__ */ counter5("effect_fiber_successes", {
  incremental: true
});
var fiberFailures = /* @__PURE__ */ counter5("effect_fiber_failures", {
  incremental: true
});
var fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram5("effect_fiber_lifetimes", /* @__PURE__ */ exponential({
  start: 0.5,
  factor: 2,
  count: 35
})), "time_unit", "milliseconds");
var EvaluationSignalContinue = "Continue";
var EvaluationSignalDone = "Done";
var EvaluationSignalYieldNow = "Yield";
var runtimeFiberVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var absurd = (_) => {
  throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
};
var YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
var yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
  currentOp: null
}));
var contOpSuccess = {
  [OP_ON_SUCCESS]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i1(value));
  },
  ["OnStep"]: (_, _cont, value) => {
    return exitSucceed(exitSucceed(value));
  },
  [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {
    return internalCall(() => cont.effect_instruction_i2(value));
  },
  [OP_REVERT_FLAGS]: (self2, cont, value) => {
    self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
    if (interruptible(self2.currentRuntimeFlags) && self2.isInterrupted()) {
      return exitFailCause(self2.getInterruptedCause());
    } else {
      return exitSucceed(value);
    }
  },
  [OP_WHILE]: (self2, cont, value) => {
    internalCall(() => cont.effect_instruction_i2(value));
    if (internalCall(() => cont.effect_instruction_i0())) {
      self2.pushStack(cont);
      return internalCall(() => cont.effect_instruction_i1());
    } else {
      return void_;
    }
  },
  [OP_ITERATOR]: (self2, cont, value) => {
    const state = internalCall(() => cont.effect_instruction_i0.next(value));
    if (state.done)
      return exitSucceed(state.value);
    self2.pushStack(cont);
    return yieldWrapGet(state.value);
  }
};
var drainQueueWhileRunningTable = {
  [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
    self2.processNewInterruptSignal(message.cause);
    return interruptible(runtimeFlags2) ? exitFailCause(message.cause) : cur;
  },
  [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
    throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
  },
  [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
    message.onFiber(self2, running2(runtimeFlags2));
    return cur;
  },
  [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
    return flatMap7(yieldNow(), () => cur);
  }
};
var runBlockedRequests = (self2) => forEachSequentialDiscard(flatten3(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential4]) => {
  const map10 = new Map;
  const arr = [];
  for (const block of sequential4) {
    arr.push(toReadonlyArray(block));
    for (const entry of block) {
      map10.set(entry.request, entry);
    }
  }
  const flat = arr.flat();
  return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
    entry.listeners.interrupted = true;
  })), currentRequestMap, map10);
}, false, false));
var _version = /* @__PURE__ */ getCurrentVersion();

class FiberRuntime extends Class {
  [FiberTypeId] = fiberVariance2;
  [RuntimeFiberTypeId] = runtimeFiberVariance;
  _fiberRefs;
  _fiberId;
  _queue = /* @__PURE__ */ new Array;
  _children = null;
  _observers = /* @__PURE__ */ new Array;
  _running = false;
  _stack = [];
  _asyncInterruptor = null;
  _asyncBlockingOn = null;
  _exitValue = null;
  _steps = [];
  _isYielding = false;
  currentRuntimeFlags;
  currentOpCount = 0;
  currentSupervisor;
  currentScheduler;
  currentTracer;
  currentSpan;
  currentContext;
  currentDefaultServices;
  constructor(fiberId2, fiberRefs0, runtimeFlags0) {
    super();
    this.currentRuntimeFlags = runtimeFlags0;
    this._fiberId = fiberId2;
    this._fiberRefs = fiberRefs0;
    if (runtimeMetrics(runtimeFlags0)) {
      const tags = this.getFiberRef(currentMetricLabels);
      fiberStarted.unsafeUpdate(1, tags);
      fiberActive.unsafeUpdate(1, tags);
    }
    this.refreshRefCache();
  }
  commit() {
    return join2(this);
  }
  id() {
    return this._fiberId;
  }
  resume(effect) {
    this.tell(resume(effect));
  }
  get status() {
    return this.ask((_, status) => status);
  }
  get runtimeFlags() {
    return this.ask((state, status) => {
      if (isDone2(status)) {
        return state.currentRuntimeFlags;
      }
      return status.runtimeFlags;
    });
  }
  scope() {
    return unsafeMake8(this);
  }
  get children() {
    return this.ask((fiber) => Array.from(fiber.getChildren()));
  }
  getChildren() {
    if (this._children === null) {
      this._children = new Set;
    }
    return this._children;
  }
  getInterruptedCause() {
    return this.getFiberRef(currentInterruptedCause);
  }
  fiberRefs() {
    return this.ask((fiber) => fiber.getFiberRefs());
  }
  ask(f) {
    return suspend(() => {
      const deferred = deferredUnsafeMake(this._fiberId);
      this.tell(stateful((fiber, status) => {
        deferredUnsafeDone(deferred, sync(() => f(fiber, status)));
      }));
      return deferredAwait(deferred);
    });
  }
  tell(message) {
    this._queue.push(message);
    if (!this._running) {
      this._running = true;
      this.drainQueueLaterOnExecutor();
    }
  }
  get await() {
    return async_((resume2) => {
      const cb = (exit2) => resume2(succeed(exit2));
      this.tell(stateful((fiber, _) => {
        if (fiber._exitValue !== null) {
          cb(this._exitValue);
        } else {
          fiber.addObserver(cb);
        }
      }));
      return sync(() => this.tell(stateful((fiber, _) => {
        fiber.removeObserver(cb);
      })));
    }, this.id());
  }
  get inheritAll() {
    return withFiberRuntime((parentFiber, parentStatus) => {
      const parentFiberId = parentFiber.id();
      const parentFiberRefs = parentFiber.getFiberRefs();
      const parentRuntimeFlags = parentStatus.runtimeFlags;
      const childFiberRefs = this.getFiberRefs();
      const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
      parentFiber.setFiberRefs(updatedFiberRefs);
      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
      const patch12 = pipe(diff7(parentRuntimeFlags, updatedRuntimeFlags), exclude2(Interruption), exclude2(WindDown));
      return updateRuntimeFlags(patch12);
    });
  }
  get poll() {
    return sync(() => fromNullable(this._exitValue));
  }
  unsafePoll() {
    return this._exitValue;
  }
  interruptAsFork(fiberId2) {
    return sync(() => this.tell(interruptSignal(interrupt(fiberId2))));
  }
  unsafeInterruptAsFork(fiberId2) {
    this.tell(interruptSignal(interrupt(fiberId2)));
  }
  addObserver(observer) {
    if (this._exitValue !== null) {
      observer(this._exitValue);
    } else {
      this._observers.push(observer);
    }
  }
  removeObserver(observer) {
    this._observers = this._observers.filter((o) => o !== observer);
  }
  getFiberRefs() {
    this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
    return this._fiberRefs;
  }
  unsafeDeleteFiberRef(fiberRef) {
    this._fiberRefs = delete_(this._fiberRefs, fiberRef);
  }
  getFiberRef(fiberRef) {
    if (this._fiberRefs.locals.has(fiberRef)) {
      return this._fiberRefs.locals.get(fiberRef)[0][1];
    }
    return fiberRef.initial;
  }
  setFiberRef(fiberRef, value) {
    this._fiberRefs = updateAs(this._fiberRefs, {
      fiberId: this._fiberId,
      fiberRef,
      value
    });
    this.refreshRefCache();
  }
  refreshRefCache() {
    this.currentDefaultServices = this.getFiberRef(currentServices);
    this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
    this.currentSupervisor = this.getFiberRef(currentSupervisor);
    this.currentScheduler = this.getFiberRef(currentScheduler);
    this.currentContext = this.getFiberRef(currentContext);
    this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
  }
  setFiberRefs(fiberRefs3) {
    this._fiberRefs = fiberRefs3;
    this.refreshRefCache();
  }
  addChild(child) {
    this.getChildren().add(child);
  }
  removeChild(child) {
    this.getChildren().delete(child);
  }
  transferChildren(scope) {
    const children = this._children;
    this._children = null;
    if (children !== null && children.size > 0) {
      for (const child of children) {
        if (child._exitValue === null) {
          scope.add(this.currentRuntimeFlags, child);
        }
      }
    }
  }
  drainQueueOnCurrentThread() {
    let recurse = true;
    while (recurse) {
      let evaluationSignal = EvaluationSignalContinue;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        while (evaluationSignal === EvaluationSignalContinue) {
          evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
        }
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
      }
      if (this._queue.length > 0 && !this._running) {
        this._running = true;
        if (evaluationSignal === EvaluationSignalYieldNow) {
          this.drainQueueLaterOnExecutor();
          recurse = false;
        } else {
          recurse = true;
        }
      } else {
        recurse = false;
      }
    }
  }
  drainQueueLaterOnExecutor() {
    this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority));
  }
  drainQueueWhileRunning(runtimeFlags2, cur0) {
    let cur = cur0;
    while (this._queue.length > 0) {
      const message = this._queue.splice(0, 1)[0];
      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
    }
    return cur;
  }
  isInterrupted() {
    return !isEmpty5(this.getFiberRef(currentInterruptedCause));
  }
  addInterruptedCause(cause2) {
    const oldSC = this.getFiberRef(currentInterruptedCause);
    this.setFiberRef(currentInterruptedCause, sequential(oldSC, cause2));
  }
  processNewInterruptSignal(cause2) {
    this.addInterruptedCause(cause2);
    this.sendInterruptSignalToAllChildren();
  }
  sendInterruptSignalToAllChildren() {
    if (this._children === null || this._children.size === 0) {
      return false;
    }
    let told = false;
    for (const child of this._children) {
      child.tell(interruptSignal(interrupt(this.id())));
      told = true;
    }
    return told;
  }
  interruptAllChildren() {
    if (this.sendInterruptSignalToAllChildren()) {
      const it = this._children.values();
      this._children = null;
      let isDone3 = false;
      const body = () => {
        const next = it.next();
        if (!next.done) {
          return asVoid(next.value.await);
        } else {
          return sync(() => {
            isDone3 = true;
          });
        }
      };
      return whileLoop({
        while: () => !isDone3,
        body,
        step: () => {
        }
      });
    }
    return null;
  }
  reportExitValue(exit2) {
    if (runtimeMetrics(this.currentRuntimeFlags)) {
      const tags = this.getFiberRef(currentMetricLabels);
      const startTimeMillis = this.id().startTimeMillis;
      const endTimeMillis = Date.now();
      fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
      fiberActive.unsafeUpdate(-1, tags);
      switch (exit2._tag) {
        case OP_SUCCESS: {
          fiberSuccesses.unsafeUpdate(1, tags);
          break;
        }
        case OP_FAILURE: {
          fiberFailures.unsafeUpdate(1, tags);
          break;
        }
      }
    }
    if (exit2._tag === "Failure") {
      const level = this.getFiberRef(currentUnhandledErrorLogLevel);
      if (!isInterruptedOnly(exit2.cause) && level._tag === "Some") {
        this.log("Fiber terminated with an unhandled error", exit2.cause, level);
      }
    }
  }
  setExitValue(exit2) {
    this._exitValue = exit2;
    this.reportExitValue(exit2);
    for (let i = this._observers.length - 1;i >= 0; i--) {
      this._observers[i](exit2);
    }
    this._observers = [];
  }
  getLoggers() {
    return this.getFiberRef(currentLoggers);
  }
  log(message, cause2, overrideLogLevel) {
    const logLevel = isSome2(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
    const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
    if (greaterThan4(minimumLogLevel, logLevel)) {
      return;
    }
    const spans = this.getFiberRef(currentLogSpan);
    const annotations2 = this.getFiberRef(currentLogAnnotations);
    const loggers = this.getLoggers();
    const contextMap = this.getFiberRefs();
    if (size3(loggers) > 0) {
      const clockService = get3(this.getFiberRef(currentServices), clockTag);
      const date = new Date(clockService.unsafeCurrentTimeMillis());
      withRedactableContext(contextMap, () => {
        for (const logger of loggers) {
          logger.log({
            fiberId: this.id(),
            logLevel,
            message,
            cause: cause2,
            context: contextMap,
            spans,
            annotations: annotations2,
            date
          });
        }
      });
    }
  }
  evaluateMessageWhileSuspended(message) {
    switch (message._tag) {
      case OP_YIELD_NOW: {
        return EvaluationSignalYieldNow;
      }
      case OP_INTERRUPT_SIGNAL: {
        this.processNewInterruptSignal(message.cause);
        if (this._asyncInterruptor !== null) {
          this._asyncInterruptor(exitFailCause(message.cause));
          this._asyncInterruptor = null;
        }
        return EvaluationSignalContinue;
      }
      case OP_RESUME: {
        this._asyncInterruptor = null;
        this._asyncBlockingOn = null;
        this.evaluateEffect(message.effect);
        return EvaluationSignalContinue;
      }
      case OP_STATEFUL: {
        message.onFiber(this, this._exitValue !== null ? done4 : suspended2(this.currentRuntimeFlags, this._asyncBlockingOn));
        return EvaluationSignalContinue;
      }
      default: {
        return absurd(message);
      }
    }
  }
  evaluateEffect(effect0) {
    this.currentSupervisor.onResume(this);
    try {
      let effect = interruptible(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause(this.getInterruptedCause()) : effect0;
      while (effect !== null) {
        const eff = effect;
        const exit2 = this.runLoop(eff);
        if (exit2 === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          yieldedOpChannel.currentOp = null;
          if (op._op === OP_YIELD) {
            if (cooperativeYielding(this.currentRuntimeFlags)) {
              this.tell(yieldNow3());
              this.tell(resume(exitVoid));
              effect = null;
            } else {
              effect = exitVoid;
            }
          } else if (op._op === OP_ASYNC) {
            effect = null;
          }
        } else {
          this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable2(WindDown));
          const interruption2 = this.interruptAllChildren();
          if (interruption2 !== null) {
            effect = flatMap7(interruption2, () => exit2);
          } else {
            if (this._queue.length === 0) {
              this.setExitValue(exit2);
            } else {
              this.tell(resume(exit2));
            }
            effect = null;
          }
        }
      }
    } finally {
      this.currentSupervisor.onSuspend(this);
    }
  }
  start(effect) {
    if (!this._running) {
      this._running = true;
      const prev = globalThis[currentFiberURI];
      globalThis[currentFiberURI] = this;
      try {
        this.evaluateEffect(effect);
      } finally {
        this._running = false;
        globalThis[currentFiberURI] = prev;
        if (this._queue.length > 0) {
          this.drainQueueLaterOnExecutor();
        }
      }
    } else {
      this.tell(resume(effect));
    }
  }
  startFork(effect) {
    this.tell(resume(effect));
  }
  patchRuntimeFlags(oldRuntimeFlags, patch12) {
    const newRuntimeFlags = patch7(oldRuntimeFlags, patch12);
    globalThis[currentFiberURI] = this;
    this.currentRuntimeFlags = newRuntimeFlags;
    return newRuntimeFlags;
  }
  initiateAsync(runtimeFlags2, asyncRegister) {
    let alreadyCalled = false;
    const callback = (effect) => {
      if (!alreadyCalled) {
        alreadyCalled = true;
        this.tell(resume(effect));
      }
    };
    if (interruptible(runtimeFlags2)) {
      this._asyncInterruptor = callback;
    }
    try {
      asyncRegister(callback);
    } catch (e) {
      callback(failCause(die(e)));
    }
  }
  pushStack(cont) {
    this._stack.push(cont);
    if (cont._op === "OnStep") {
      this._steps.push({
        refs: this.getFiberRefs(),
        flags: this.currentRuntimeFlags
      });
    }
  }
  popStack() {
    const item = this._stack.pop();
    if (item) {
      if (item._op === "OnStep") {
        this._steps.pop();
      }
      return item;
    }
    return;
  }
  getNextSuccessCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_FAILURE) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  getNextFailCont() {
    let frame = this.popStack();
    while (frame) {
      if (frame._op !== OP_ON_SUCCESS && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
        return frame;
      }
      frame = this.popStack();
    }
  }
  [OP_TAG](op) {
    return sync(() => unsafeGet3(this.currentContext, op));
  }
  ["Left"](op) {
    return fail2(op.left);
  }
  ["None"](_) {
    return fail2(new NoSuchElementException);
  }
  ["Right"](op) {
    return exitSucceed(op.right);
  }
  ["Some"](op) {
    return exitSucceed(op.value);
  }
  ["Micro"](op) {
    return unsafeAsync((microResume) => {
      let resume2 = microResume;
      const fiber = runFork(provideContext2(op, this.currentContext));
      fiber.addObserver((exit2) => {
        if (exit2._tag === "Success") {
          return resume2(exitSucceed(exit2.value));
        }
        switch (exit2.cause._tag) {
          case "Interrupt": {
            return resume2(exitFailCause(interrupt(none4)));
          }
          case "Fail": {
            return resume2(fail2(exit2.cause.error));
          }
          case "Die": {
            return resume2(die2(exit2.cause.defect));
          }
        }
      });
      return unsafeAsync((abortResume) => {
        resume2 = (_) => {
          abortResume(void_);
        };
        fiber.unsafeInterrupt();
      });
    });
  }
  [OP_SYNC](op) {
    const value = internalCall(() => op.effect_instruction_i0());
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, value);
    } else {
      yieldedOpChannel.currentOp = exitSucceed(value);
      return YieldedOp;
    }
  }
  [OP_SUCCESS](op) {
    const oldCur = op;
    const cont = this.getNextSuccessCont();
    if (cont !== undefined) {
      if (!(cont._op in contOpSuccess)) {
        absurd(cont);
      }
      return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
    } else {
      yieldedOpChannel.currentOp = oldCur;
      return YieldedOp;
    }
  }
  [OP_FAILURE](op) {
    const cause2 = op.effect_instruction_i0;
    const cont = this.getNextFailCont();
    if (cont !== undefined) {
      switch (cont._op) {
        case OP_ON_FAILURE:
        case OP_ON_SUCCESS_AND_FAILURE: {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return internalCall(() => cont.effect_instruction_i1(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case "OnStep": {
          if (!(interruptible(this.currentRuntimeFlags) && this.isInterrupted())) {
            return exitSucceed(exitFailCause(cause2));
          } else {
            return exitFailCause(stripFailures(cause2));
          }
        }
        case OP_REVERT_FLAGS: {
          this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
          if (interruptible(this.currentRuntimeFlags) && this.isInterrupted()) {
            return exitFailCause(sequential(cause2, this.getInterruptedCause()));
          } else {
            return exitFailCause(cause2);
          }
        }
        default: {
          absurd(cont);
        }
      }
    } else {
      yieldedOpChannel.currentOp = exitFailCause(cause2);
      return YieldedOp;
    }
  }
  [OP_WITH_RUNTIME](op) {
    return internalCall(() => op.effect_instruction_i0(this, running2(this.currentRuntimeFlags)));
  }
  ["Blocked"](op) {
    const refs = this.getFiberRefs();
    const flags = this.currentRuntimeFlags;
    if (this._steps.length > 0) {
      const frames = [];
      const snap = this._steps[this._steps.length - 1];
      let frame = this.popStack();
      while (frame && frame._op !== "OnStep") {
        frames.push(frame);
        frame = this.popStack();
      }
      this.setFiberRefs(snap.refs);
      this.currentRuntimeFlags = snap.flags;
      const patchRefs = diff9(snap.refs, refs);
      const patchFlags = diff7(snap.flags, flags);
      return exitSucceed(blocked(op.effect_instruction_i0, withFiberRuntime((newFiber) => {
        while (frames.length > 0) {
          newFiber.pushStack(frames.pop());
        }
        newFiber.setFiberRefs(patch10(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
        newFiber.currentRuntimeFlags = patch7(patchFlags)(newFiber.currentRuntimeFlags);
        return op.effect_instruction_i1;
      })));
    }
    return uninterruptibleMask((restore) => flatMap7(forkDaemon(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
  }
  ["RunBlocked"](op) {
    return runBlockedRequests(op.effect_instruction_i0);
  }
  [OP_UPDATE_RUNTIME_FLAGS](op) {
    const updateFlags = op.effect_instruction_i0;
    const oldRuntimeFlags = this.currentRuntimeFlags;
    const newRuntimeFlags = patch7(oldRuntimeFlags, updateFlags);
    if (interruptible(newRuntimeFlags) && this.isInterrupted()) {
      return exitFailCause(this.getInterruptedCause());
    } else {
      this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
      if (op.effect_instruction_i1) {
        const revertFlags = diff7(newRuntimeFlags, oldRuntimeFlags);
        this.pushStack(new RevertFlags(revertFlags, op));
        return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
      } else {
        return exitVoid;
      }
    }
  }
  [OP_ON_SUCCESS](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  ["OnStep"](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ON_SUCCESS_AND_FAILURE](op) {
    this.pushStack(op);
    return op.effect_instruction_i0;
  }
  [OP_ASYNC](op) {
    this._asyncBlockingOn = op.effect_instruction_i1;
    this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_YIELD](op) {
    this._isYielding = false;
    yieldedOpChannel.currentOp = op;
    return YieldedOp;
  }
  [OP_WHILE](op) {
    const check = op.effect_instruction_i0;
    const body = op.effect_instruction_i1;
    if (check()) {
      this.pushStack(op);
      return body();
    } else {
      return exitVoid;
    }
  }
  [OP_ITERATOR](op) {
    return contOpSuccess[OP_ITERATOR](this, op, undefined);
  }
  [OP_COMMIT](op) {
    return internalCall(() => op.commit());
  }
  runLoop(effect0) {
    let cur = effect0;
    this.currentOpCount = 0;
    while (true) {
      if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
        this.currentSupervisor.onEffect(this, cur);
      }
      if (this._queue.length > 0) {
        cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
      }
      if (!this._isYielding) {
        this.currentOpCount += 1;
        const shouldYield = this.currentScheduler.shouldYield(this);
        if (shouldYield !== false) {
          this._isYielding = true;
          this.currentOpCount = 0;
          const oldCur = cur;
          cur = flatMap7(yieldNow({
            priority: shouldYield
          }), () => oldCur);
        }
      }
      try {
        cur = this.currentTracer.context(() => {
          if (_version !== cur[EffectTypeId2]._V) {
            const level = this.getFiberRef(currentVersionMismatchErrorLogLevel);
            if (level._tag === "Some") {
              const effectVersion = cur[EffectTypeId2]._V;
              this.log(`Executing an Effect versioned ${effectVersion} with a Runtime of version ${getCurrentVersion()}, you may want to dedupe the effect dependencies, you can use the language service plugin to detect this at compile time: https://github.com/Effect-TS/language-service`, empty20, level);
            }
          }
          return this[cur._op](cur);
        }, this);
        if (cur === YieldedOp) {
          const op = yieldedOpChannel.currentOp;
          if (op._op === OP_YIELD || op._op === OP_ASYNC) {
            return YieldedOp;
          }
          yieldedOpChannel.currentOp = null;
          return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause(die(op));
        }
      } catch (e) {
        if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
          cur = dieMessage(`Not a valid effect: ${toStringUnknown(cur)}`);
        } else if (isInterruptedException(e)) {
          cur = exitFailCause(sequential(die(e), interrupt(none4)));
        } else {
          cur = die2(e);
        }
      }
    }
  }
  run = () => {
    this.drainQueueOnCurrentThread();
  };
}
var currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
var loggerWithConsoleLog = (self2) => makeLogger((opts) => {
  const services = getOrDefault2(opts.context, currentServices);
  get3(services, consoleTag).unsafe.log(self2.log(opts));
});
var defaultLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
var tracerLogger = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
  annotations: annotations2,
  cause: cause2,
  context: context2,
  fiberId: fiberId2,
  logLevel,
  message
}) => {
  const span2 = getOption2(getOrDefault(context2, currentContext), spanTag);
  if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
    return;
  }
  const clockService = unsafeGet3(getOrDefault(context2, currentServices), clockTag);
  const attributes = {};
  for (const [key, value] of annotations2) {
    attributes[key] = value;
  }
  attributes["effect.fiberId"] = threadName2(fiberId2);
  attributes["effect.logLevel"] = logLevel.label;
  if (cause2 !== null && cause2._tag !== "Empty") {
    attributes["effect.cause"] = pretty(cause2, {
      renderErrorCause: true
    });
  }
  span2.value.event(toStringUnknown(Array.isArray(message) && message.length === 1 ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
}));
var currentLoggers = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make11(defaultLogger, tracerLogger)));
var annotateLogsScoped = function() {
  if (typeof arguments[0] === "string") {
    return fiberRefLocallyScopedWith(currentLogAnnotations, set4(arguments[0], arguments[1]));
  }
  const entries2 = Object.entries(arguments[0]);
  return fiberRefLocallyScopedWith(currentLogAnnotations, mutate3((annotations2) => {
    for (let i = 0;i < entries2.length; i++) {
      const [key, value] = entries2[i];
      set4(annotations2, key, value);
    }
    return annotations2;
  }));
};
var whenLogLevel = /* @__PURE__ */ dual(2, (effect, level) => {
  const requiredLogLevel = typeof level === "string" ? fromLiteral(level) : level;
  return withFiberRuntime((fiberState) => {
    const minimumLogLevel = fiberState.getFiberRef(currentMinimumLogLevel);
    if (greaterThan4(minimumLogLevel, requiredLogLevel)) {
      return succeed(none2());
    }
    return map9(effect, some2);
  });
});
var acquireRelease = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => uninterruptible(tap(acquire, (a) => addFinalizer((exit2) => release(a, exit2)))));
var acquireReleaseInterruptible = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (acquire, release) => ensuring(acquire, addFinalizer((exit2) => release(exit2))));
var addFinalizer = (finalizer) => withFiberRuntime((runtime3) => {
  const acquireRefs = runtime3.getFiberRefs();
  const acquireFlags = disable2(runtime3.currentRuntimeFlags, Interruption);
  return flatMap7(scope, (scope) => scopeAddFinalizerExit(scope, (exit2) => withFiberRuntime((runtimeFinalizer) => {
    const preRefs = runtimeFinalizer.getFiberRefs();
    const preFlags = runtimeFinalizer.currentRuntimeFlags;
    const patchRefs = diff9(preRefs, acquireRefs);
    const patchFlags = diff7(preFlags, acquireFlags);
    const inverseRefs = diff9(acquireRefs, preRefs);
    runtimeFinalizer.setFiberRefs(patch10(patchRefs, runtimeFinalizer.id(), acquireRefs));
    return ensuring(withRuntimeFlags(finalizer(exit2), patchFlags), sync(() => {
      runtimeFinalizer.setFiberRefs(patch10(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
    }));
  })));
});
var daemonChildren = (self2) => {
  const forkScope = fiberRefLocally(currentForkScopeOverride, some2(globalScope));
  return forkScope(self2);
};
var _existsParFound = /* @__PURE__ */ Symbol.for("effect/Effect/existsPar/found");
var exists2 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => matchSimple(options?.concurrency, () => suspend(() => existsLoop(elements[Symbol.iterator](), 0, predicate)), () => matchEffect(forEach7(elements, (a, i) => if_(predicate(a, i), {
  onTrue: () => fail2(_existsParFound),
  onFalse: () => void_
}), options), {
  onFailure: (e) => e === _existsParFound ? succeed(true) : fail2(e),
  onSuccess: () => succeed(false)
})));
var existsLoop = (iterator, index, f) => {
  const next = iterator.next();
  if (next.done) {
    return succeed(false);
  }
  return flatMap7(f(next.value, index), (b) => b ? succeed(b) : existsLoop(iterator, index + 1, f));
};
var filter5 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, predicate, options) => {
  const predicate_ = options?.negate ? (a, i) => map9(predicate(a, i), not) : predicate;
  return matchSimple(options?.concurrency, () => suspend(() => fromIterable(elements).reduceRight((effect, a, i) => zipWith2(effect, suspend(() => predicate_(a, i)), (list, b) => b ? [a, ...list] : list), sync(() => new Array))), () => map9(forEach7(elements, (a, i) => map9(predicate_(a, i), (b) => b ? some2(a) : none2()), options), getSomes));
});
var allResolveInput = (input) => {
  if (Array.isArray(input) || isIterable(input)) {
    return [input, none2()];
  }
  const keys5 = Object.keys(input);
  const size8 = keys5.length;
  return [keys5.map((k) => input[k]), some2((values4) => {
    const res = {};
    for (let i = 0;i < size8; i++) {
      res[keys5[i]] = values4[i];
    }
    return res;
  })];
};
var allValidate = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  return flatMap7(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => {
    const none9 = none2();
    const size8 = eithers.length;
    const errors = new Array(size8);
    const successes = new Array(size8);
    let errored = false;
    for (let i = 0;i < size8; i++) {
      const either3 = eithers[i];
      if (either3._tag === "Left") {
        errors[i] = some2(either3.left);
        errored = true;
      } else {
        successes[i] = either3.right;
        errors[i] = none9;
      }
    }
    if (errored) {
      return reconcile._tag === "Some" ? fail2(reconcile.value(errors)) : fail2(errors);
    } else if (options?.discard) {
      return void_;
    }
    return reconcile._tag === "Some" ? succeed(reconcile.value(successes)) : succeed(successes);
  });
};
var allEither = (effects, reconcile, options) => {
  const eitherEffects = [];
  for (const effect of effects) {
    eitherEffects.push(either2(effect));
  }
  if (options?.discard) {
    return forEach7(eitherEffects, identity, {
      concurrency: options?.concurrency,
      batching: options?.batching,
      discard: true,
      concurrentFinalizers: options?.concurrentFinalizers
    });
  }
  return map9(forEach7(eitherEffects, identity, {
    concurrency: options?.concurrency,
    batching: options?.batching,
    concurrentFinalizers: options?.concurrentFinalizers
  }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
};
var all2 = (arg, options) => {
  const [effects, reconcile] = allResolveInput(arg);
  if (options?.mode === "validate") {
    return allValidate(effects, reconcile, options);
  } else if (options?.mode === "either") {
    return allEither(effects, reconcile, options);
  }
  return options?.discard !== true && reconcile._tag === "Some" ? map9(forEach7(effects, identity, options), reconcile.value) : forEach7(effects, identity, options);
};
var allWith = (options) => (arg) => all2(arg, options);
var allSuccesses = (elements, options) => map9(all2(fromIterable(elements).map(exit), options), filterMap2((exit2) => exitIsSuccess(exit2) ? some2(exit2.effect_instruction_i0) : none2()));
var replicate = /* @__PURE__ */ dual(2, (self2, n) => Array.from({
  length: n
}, () => self2));
var replicateEffect = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, n, options) => all2(replicate(self2, n), options));
var forEach7 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options) => withFiberRuntime((r) => {
  const isRequestBatchingEnabled = options?.batching === true || options?.batching === "inherit" && r.getFiberRef(currentRequestBatching);
  if (options?.discard) {
    return match9(options.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
  }
  return match9(options?.concurrency, () => finalizersMaskInternal(sequential3, options?.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel3, options?.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN2(n), options?.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
}));
var forEachParUnbounded = (self2, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array5 = new Array(as2.length);
  const fn = (a, i) => flatMap7(f(a, i), (b) => sync(() => array5[i] = b));
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false), succeed(array5));
});
var forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask((restore) => transplant((graft) => withFiberRuntime((parent) => {
  let todos = Array.from(self2).reverse();
  let target = todos.length;
  if (target === 0) {
    return void_;
  }
  let counter6 = 0;
  let interrupted = false;
  const fibersCount = n ? Math.min(todos.length, n) : todos.length;
  const fibers = new Set;
  const results = new Array;
  const interruptAll = () => fibers.forEach((fiber) => {
    fiber.currentScheduler.scheduleTask(() => {
      fiber.unsafeInterruptAsFork(parent.id());
    }, 0);
  });
  const startOrder = new Array;
  const joinOrder = new Array;
  const residual = new Array;
  const collectExits = () => {
    const exits = results.filter(({
      exit: exit2
    }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
      exit: exit2
    }) => exit2);
    if (exits.length === 0) {
      exits.push(exitVoid);
    }
    return exits;
  };
  const runFiber = (eff, interruptImmediately = false) => {
    const runnable = uninterruptible(graft(eff));
    const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
    parent.currentScheduler.scheduleTask(() => {
      if (interruptImmediately) {
        fiber.unsafeInterruptAsFork(parent.id());
      }
      fiber.resume(runnable);
    }, 0);
    return fiber;
  };
  const onInterruptSignal = () => {
    if (!processAll) {
      target -= todos.length;
      todos = [];
    }
    interrupted = true;
    interruptAll();
  };
  const stepOrExit = batching ? step2 : exit;
  const processingFiber = runFiber(async_((resume2) => {
    const pushResult = (res, index) => {
      if (res._op === "Blocked") {
        residual.push(res);
      } else {
        results.push({
          index,
          exit: res
        });
        if (res._op === "Failure" && !interrupted) {
          onInterruptSignal();
        }
      }
    };
    const next = () => {
      if (todos.length > 0) {
        const a = todos.pop();
        let index = counter6++;
        const returnNextElement = () => {
          const a2 = todos.pop();
          index = counter6++;
          return flatMap7(yieldNow(), () => flatMap7(stepOrExit(restore(f(a2, index))), onRes));
        };
        const onRes = (res) => {
          if (todos.length > 0) {
            pushResult(res, index);
            if (todos.length > 0) {
              return returnNextElement();
            }
          }
          return succeed(res);
        };
        const todo = flatMap7(stepOrExit(restore(f(a, index))), onRes);
        const fiber = runFiber(todo);
        startOrder.push(fiber);
        fibers.add(fiber);
        if (interrupted) {
          fiber.currentScheduler.scheduleTask(() => {
            fiber.unsafeInterruptAsFork(parent.id());
          }, 0);
        }
        fiber.addObserver((wrapped) => {
          let exit2;
          if (wrapped._op === "Failure") {
            exit2 = wrapped;
          } else {
            exit2 = wrapped.effect_instruction_i0;
          }
          joinOrder.push(fiber);
          fibers.delete(fiber);
          pushResult(exit2, index);
          if (results.length === target) {
            resume2(succeed(getOrElse(exitCollectAll(collectExits(), {
              parallel: true
            }), () => exitVoid)));
          } else if (residual.length + results.length === target) {
            const exits = collectExits();
            const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
            resume2(succeed(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
              parallel: true
            }), () => exitVoid), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
          } else {
            next();
          }
        });
      }
    };
    for (let i = 0;i < fibersCount; i++) {
      next();
    }
  }));
  return asVoid(onExit(flatten5(restore(join2(processingFiber))), exitMatch({
    onFailure: (cause2) => {
      onInterruptSignal();
      const target2 = residual.length + 1;
      const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
      const toPop = Array.from(residual);
      return async_((cb) => {
        const exits = [];
        let count = 0;
        let index = 0;
        const check = (index2, hitNext) => (exit2) => {
          exits[index2] = exit2;
          count++;
          if (count === target2) {
            cb(exitSucceed(exitFailCause(cause2)));
          }
          if (toPop.length > 0 && hitNext) {
            next();
          }
        };
        const next = () => {
          runFiber(toPop.pop(), true).addObserver(check(index, true));
          index++;
        };
        processingFiber.addObserver(check(index, false));
        index++;
        for (let i = 0;i < concurrency; i++) {
          next();
        }
      });
    },
    onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
  })));
})));
var forEachParN = (self2, n, f, batching) => suspend(() => {
  const as2 = fromIterable(self2);
  const array5 = new Array(as2.length);
  const fn = (a, i) => map9(f(a, i), (b) => array5[i] = b);
  return zipRight(forEachConcurrentDiscard(as2, fn, batching, false, n), succeed(array5));
});
var fork = (self2) => withFiberRuntime((state, status) => succeed(unsafeFork(self2, state, status.runtimeFlags)));
var forkDaemon = (self2) => forkWithScopeOverride(self2, globalScope);
var forkWithErrorHandler = /* @__PURE__ */ dual(2, (self2, handler) => fork(onError(self2, (cause2) => {
  const either3 = failureOrCause(cause2);
  switch (either3._tag) {
    case "Left":
      return handler(either3.left);
    case "Right":
      return failCause(either3.right);
  }
})));
var unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  childFiber.resume(effect);
  return childFiber;
};
var unsafeForkUnstarted = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);
  return childFiber;
};
var unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {
  const childId = unsafeMake3();
  const parentFiberRefs = parentFiber.getFiberRefs();
  const childFiberRefs = forkAs(parentFiberRefs, childId);
  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
  const childContext = getOrDefault(childFiberRefs, currentContext);
  const supervisor = childFiber.currentSupervisor;
  supervisor.onStart(childContext, effect, some2(parentFiber), childFiber);
  childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
  const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
  parentScope.add(parentRuntimeFlags, childFiber);
  return childFiber;
};
var forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime((parentFiber, parentStatus) => succeed(unsafeFork(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
var mergeAll3 = /* @__PURE__ */ dual((args2) => isFunction2(args2[2]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i)), succeed(zero3)), () => flatMap7(make28(zero3), (acc) => flatMap7(forEach7(elements, (effect, i) => flatMap7(effect, (a) => update3(acc, (b) => f(b, a, i))), options), () => get12(acc)))));
var partition3 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => pipe(forEach7(elements, (a, i) => either2(f(a, i)), options), map9((chunk2) => partitionMap2(chunk2, identity))));
var validateAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flatMap7(partition3(elements, f, {
  concurrency: options?.concurrency,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([es, bs]) => isNonEmptyArray2(es) ? fail2(es) : options?.discard ? void_ : succeed(bs)));
var raceAll = (all3) => withFiberRuntime((state, status) => async_((resume2) => {
  const fibers = new Set;
  let winner;
  let failures2 = empty20;
  const interruptAll = () => {
    for (const fiber of fibers) {
      fiber.unsafeInterruptAsFork(state.id());
    }
  };
  let latch = false;
  let empty30 = true;
  for (const self2 of all3) {
    empty30 = false;
    const fiber = unsafeFork(interruptible2(self2), state, status.runtimeFlags);
    fibers.add(fiber);
    fiber.addObserver((exit2) => {
      fibers.delete(fiber);
      if (!winner) {
        if (exit2._tag === "Success") {
          latch = true;
          winner = fiber;
          failures2 = empty20;
          interruptAll();
        } else {
          failures2 = parallel(exit2.cause, failures2);
        }
      }
      if (latch && fibers.size === 0) {
        resume2(winner ? zipRight(inheritAll(winner), winner.unsafePoll()) : failCause(failures2));
      }
    });
    if (winner)
      break;
  }
  if (empty30) {
    return resume2(dieSync(() => new IllegalArgumentException(`Received an empty collection of effects`)));
  }
  latch = true;
  return interruptAllAs(fibers, state.id());
}));
var reduceEffect = /* @__PURE__ */ dual((args2) => isIterable(args2[0]) && !isEffect(args2[0]), (elements, zero3, f, options) => matchSimple(options?.concurrency, () => fromIterable(elements).reduce((acc, a, i) => zipWith2(acc, a, (acc2, a2) => f(acc2, a2, i)), zero3), () => suspend(() => pipe(mergeAll3([zero3, ...elements], none2(), (acc, elem, i) => {
  switch (acc._tag) {
    case "None": {
      return some2(elem);
    }
    case "Some": {
      return some2(f(acc.value, elem, i));
    }
  }
}, options), map9((option2) => {
  switch (option2._tag) {
    case "None": {
      throw new Error("BUG: Effect.reduceEffect - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    case "Some": {
      return option2.value;
    }
  }
})))));
var parallelFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Parallel":
        return self2;
      case "Sequential":
      case "ParallelN":
        return flatMap7(scopeFork(scope, parallel3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    if (scope.strategy._tag === "ParallelN" && scope.strategy.parallelism === parallelism) {
      return self2;
    }
    return flatMap7(scopeFork(scope, parallelN2(parallelism)), (inner) => scopeExtend(self2, inner));
  }
}));
var finalizersMask = (strategy) => (self2) => finalizersMaskInternal(strategy, true)(self2);
var finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2(identity),
  onSome: (scope) => {
    if (concurrentFinalizers === true) {
      const patch12 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
      switch (scope.strategy._tag) {
        case "Parallel":
          return patch12(self2(parallelFinalizers));
        case "Sequential":
          return patch12(self2(sequentialFinalizers));
        case "ParallelN":
          return patch12(self2(parallelNFinalizers(scope.strategy.parallelism)));
      }
    } else {
      return self2(identity);
    }
  }
}));
var scopeWith = (f) => flatMap7(scopeTag, f);
var scopedWith = (f) => flatMap7(scopeMake(), (scope) => onExit(f(scope), (exit2) => scope.close(exit2)));
var scopedEffect = (effect) => flatMap7(scopeMake(), (scope) => scopeUse(effect, scope));
var sequentialFinalizers = (self2) => contextWithEffect((context2) => match2(getOption2(context2, scopeTag), {
  onNone: () => self2,
  onSome: (scope) => {
    switch (scope.strategy._tag) {
      case "Sequential":
        return self2;
      case "Parallel":
      case "ParallelN":
        return flatMap7(scopeFork(scope, sequential3), (inner) => scopeExtend(self2, inner));
    }
  }
}));
var tagMetricsScoped = (key, value) => labelMetricsScoped([make29(key, value)]);
var labelMetricsScoped = (labels) => fiberRefLocallyScopedWith(currentMetricLabels, (old) => union(old, labels));
var using = /* @__PURE__ */ dual(2, (self2, use) => scopedWith((scope) => flatMap7(scopeExtend(self2, scope), use)));
var validate = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => validateWith(self2, that, (a, b) => [a, b], options));
var validateWith = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => flatten5(zipWithOptions(exit(self2), exit(that), (ea, eb) => exitZipWith(ea, eb, {
  onSuccess: f,
  onFailure: (ca, cb) => options?.concurrent ? parallel(ca, cb) : sequential(ca, cb)
}), options)));
var validateFirst = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (elements, f, options) => flip(forEach7(elements, (a, i) => flip(f(a, i)), options)));
var withClockScoped = (c) => fiberRefLocallyScopedWith(currentServices, add2(clockTag, c));
var withRandomScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(randomTag, value));
var withConfigProviderScoped = (provider) => fiberRefLocallyScopedWith(currentServices, add2(configProviderTag, provider));
var withEarlyRelease = (self2) => scopeWith((parent) => flatMap7(scopeFork(parent, sequential2), (child) => pipe(self2, scopeExtend(child), map9((value) => [fiberIdWith((fiberId2) => scopeClose(child, exitInterrupt(fiberId2))), value]))));
var zipOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => zipWithOptions(self2, that, (a, b) => [a, b], options));
var zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipLeft(self2, that);
  }
  return zipWithOptions(self2, that, (a, _) => a, options);
});
var zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, options) => {
  if (options?.concurrent !== true && (options?.batching === undefined || options.batching === false)) {
    return zipRight(self2, that);
  }
  return zipWithOptions(self2, that, (_, b) => b, options);
});
var zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect(args2[1]), (self2, that, f, options) => map9(all2([self2, that], {
  concurrency: options?.concurrent ? 2 : 1,
  batching: options?.batching,
  concurrentFinalizers: options?.concurrentFinalizers
}), ([a, a2]) => f(a, a2)));
var withRuntimeFlagsScoped = (update5) => {
  if (update5 === empty18) {
    return void_;
  }
  return pipe(runtimeFlags, flatMap7((runtimeFlags2) => {
    const updatedRuntimeFlags = patch7(runtimeFlags2, update5);
    const revertRuntimeFlags = diff7(updatedRuntimeFlags, runtimeFlags2);
    return pipe(updateRuntimeFlags(update5), zipRight(addFinalizer(() => updateRuntimeFlags(revertRuntimeFlags))), asVoid);
  }), uninterruptible);
};
var scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
var scope = scopeTag;
var scopeUnsafeAddFinalizer = (scope2, fin) => {
  if (scope2.state._tag === "Open") {
    scope2.state.finalizers.set({}, fin);
  }
};
var ScopeImplProto = {
  [ScopeTypeId]: ScopeTypeId,
  [CloseableScopeTypeId]: CloseableScopeTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  fork(strategy) {
    return sync(() => {
      const newScope = scopeUnsafeMake(strategy);
      if (this.state._tag === "Closed") {
        newScope.state = this.state;
        return newScope;
      }
      const key = {};
      const fin = (exit2) => newScope.close(exit2);
      this.state.finalizers.set(key, fin);
      scopeUnsafeAddFinalizer(newScope, (_) => sync(() => {
        if (this.state._tag === "Open") {
          this.state.finalizers.delete(key);
        }
      }));
      return newScope;
    });
  },
  close(exit2) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return void_;
      }
      const finalizers = Array.from(this.state.finalizers.values()).reverse();
      this.state = {
        _tag: "Closed",
        exit: exit2
      };
      if (finalizers.length === 0) {
        return void_;
      }
      return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit(fin(exit2))), flatMap7((results) => pipe(exitCollectAll(results), map2(exitAsVoid), getOrElse(() => exitVoid)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit(fin(exit2)), false), flatMap7((results) => pipe(exitCollectAll(results, {
        parallel: true
      }), map2(exitAsVoid), getOrElse(() => exitVoid))));
    });
  },
  addFinalizer(fin) {
    return suspend(() => {
      if (this.state._tag === "Closed") {
        return fin(this.state.exit);
      }
      this.state.finalizers.set({}, fin);
      return void_;
    });
  }
};
var scopeUnsafeMake = (strategy = sequential2) => {
  const scope2 = Object.create(ScopeImplProto);
  scope2.strategy = strategy;
  scope2.state = {
    _tag: "Open",
    finalizers: new Map
  };
  return scope2;
};
var scopeMake = (strategy = sequential2) => sync(() => scopeUnsafeMake(strategy));
var scopeExtend = /* @__PURE__ */ dual(2, (effect, scope2) => mapInputContext(effect, merge3(make6(scopeTag, scope2))));
var scopeUse = /* @__PURE__ */ dual(2, (effect, scope2) => pipe(effect, scopeExtend(scope2), onExit((exit2) => scope2.close(exit2))));
var fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
  differ: differ2,
  fork: empty29
});
var fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value) => asVoid(acquireRelease(flatMap7(fiberRefGet(self2), (oldValue) => as(fiberRefSet(self2, value), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
var fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
var currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none5);
var currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none8);
var fiberAwaitAll = (fibers) => forEach7(fibers, _await2);
var fiberAll = (fibers) => {
  const _fiberAll = {
    ...CommitPrototype2,
    commit() {
      return join2(this);
    },
    [FiberTypeId]: fiberVariance2,
    id: () => fromIterable(fibers).reduce((id, fiber) => combine3(id, fiber.id()), none4),
    await: exit(forEachParUnbounded(fibers, (fiber) => flatten5(fiber.await), false)),
    children: map9(forEachParUnbounded(fibers, (fiber) => fiber.children, false), flatten),
    inheritAll: forEachSequentialDiscard(fibers, (fiber) => fiber.inheritAll),
    poll: map9(forEachSequential(fibers, (fiber) => fiber.poll), reduceRight(some2(exitSucceed(new Array)), (optionB, optionA) => {
      switch (optionA._tag) {
        case "None": {
          return none2();
        }
        case "Some": {
          switch (optionB._tag) {
            case "None": {
              return none2();
            }
            case "Some": {
              return some2(exitZipWith(optionA.value, optionB.value, {
                onSuccess: (a, chunk2) => [a, ...chunk2],
                onFailure: parallel
              }));
            }
          }
        }
      }
    })),
    interruptAsFork: (fiberId2) => forEachSequentialDiscard(fibers, (fiber) => fiber.interruptAsFork(fiberId2))
  };
  return _fiberAll;
};
var raceWith = /* @__PURE__ */ dual(3, (self2, other, options) => raceFibersWith(self2, other, {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onSelfDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onSelfDone(exit2, loser);
      }
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    switch (exit2._tag) {
      case OP_SUCCESS: {
        return flatMap7(winner.inheritAll, () => options.onOtherDone(exit2, loser));
      }
      case OP_FAILURE: {
        return options.onOtherDone(exit2, loser);
      }
    }
  })
}));
var disconnect = (self2) => uninterruptibleMask((restore) => fiberIdWith((fiberId2) => flatMap7(forkDaemon(restore(self2)), (fiber) => pipe(restore(join2(fiber)), onInterrupt(() => pipe(fiber, interruptAsFork(fiberId2)))))));
var race = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith((parentFiberId) => raceWith(self2, that, {
  onSelfDone: (exit2, right3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(right3), mapErrorCause((cause22) => parallel(cause2, cause22))),
    onSuccess: (value) => pipe(right3, interruptAsFiber(parentFiberId), as(value))
  }),
  onOtherDone: (exit2, left3) => exitMatchEffect(exit2, {
    onFailure: (cause2) => pipe(join2(left3), mapErrorCause((cause22) => parallel(cause22, cause2))),
    onSuccess: (value) => pipe(left3, interruptAsFiber(parentFiberId), as(value))
  })
})));
var raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options) => withFiberRuntime((parentFiber, parentStatus) => {
  const parentRuntimeFlags = parentStatus.runtimeFlags;
  const raceIndicator = make12(true);
  const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options.selfScope);
  const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options.otherScope);
  return async_((cb) => {
    leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options.onSelfWin, raceIndicator, cb));
    rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options.onOtherWin, raceIndicator, cb));
    leftFiber.startFork(self2);
    rightFiber.startFork(other);
  }, combine3(leftFiber.id(), rightFiber.id()));
}));
var completeRace = (winner, loser, cont, ab, cb) => {
  if (compareAndSet(true, false)(ab)) {
    cb(cont(winner, loser));
  }
};
var ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask((restore) => matchCauseEffect(restore(self2), {
  onFailure: (cause1) => matchCauseEffect(finalizer, {
    onFailure: (cause2) => failCause(sequential(cause1, cause2)),
    onSuccess: () => failCause(cause1)
  }),
  onSuccess: (a) => as(finalizer, a)
})));
var invokeWithInterrupt = (self2, entries2, onInterrupt2) => fiberIdWith((id) => flatMap7(flatMap7(forkDaemon(interruptible2(self2)), (processing) => async_((cb) => {
  const counts = entries2.map((_) => _.listeners.count);
  const checkDone = () => {
    if (counts.every((count) => count === 0)) {
      if (entries2.every((_) => {
        if (_.result.state.current._tag === "Pending") {
          return true;
        } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted(_.result.state.current.effect.cause)) {
          return true;
        } else {
          return false;
        }
      })) {
        cleanup.forEach((f) => f());
        onInterrupt2?.();
        cb(interruptFiber(processing));
      }
    }
  };
  processing.addObserver((exit2) => {
    cleanup.forEach((f) => f());
    cb(exit2);
  });
  const cleanup = entries2.map((r, i) => {
    const observer = (count) => {
      counts[i] = count;
      checkDone();
    };
    r.listeners.addObserver(observer);
    return () => r.listeners.removeObserver(observer);
  });
  checkDone();
  return sync(() => {
    cleanup.forEach((f) => f());
  });
})), () => suspend(() => {
  const residual = entries2.flatMap((entry) => {
    if (!entry.state.completed) {
      return [entry];
    }
    return [];
  });
  return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt(id)));
})));
var makeSpanScoped = (name, options) => {
  options = addSpanStackTrace(options);
  return uninterruptible(withFiberRuntime((fiber) => {
    const scope2 = unsafeGet3(fiber.getFiberRef(currentContext), scopeTag);
    const span2 = unsafeMakeSpan(fiber, name, options);
    const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled);
    const clock_ = get3(fiber.getFiberRef(currentServices), clockTag);
    return as(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
  }));
};
var withTracerScoped = (value) => fiberRefLocallyScopedWith(currentServices, add2(tracerTag, value));
var withSpanScoped = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return flatMap7(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
  }
  return (self2) => flatMap7(makeSpanScoped(name, addSpanStackTrace(options)), (span2) => provideService(self2, spanTag, span2));
};

// node_modules/effect/dist/esm/internal/cache.js
var complete2 = (key, exit2, entryStats, timeToLiveMillis) => struct({
  _tag: "Complete",
  key,
  exit: exit2,
  entryStats,
  timeToLiveMillis
});
var pending2 = (key, deferred) => struct({
  _tag: "Pending",
  key,
  deferred
});
var refreshing = (deferred, complete3) => struct({
  _tag: "Refreshing",
  deferred,
  complete: complete3
});
var MapKeyTypeId = /* @__PURE__ */ Symbol.for("effect/Cache/MapKey");

class MapKeyImpl {
  current;
  [MapKeyTypeId] = MapKeyTypeId;
  previous = undefined;
  next = undefined;
  constructor(current) {
    this.current = current;
  }
  [symbol]() {
    return pipe(hash(this.current), combine(hash(this.previous)), combine(hash(this.next)), cached(this));
  }
  [symbol2](that) {
    if (this === that) {
      return true;
    }
    return isMapKey(that) && equals(this.current, that.current) && equals(this.previous, that.previous) && equals(this.next, that.next);
  }
}
var makeMapKey = (current) => new MapKeyImpl(current);
var isMapKey = (u) => hasProperty(u, MapKeyTypeId);

class KeySetImpl {
  head = undefined;
  tail = undefined;
  add(key) {
    if (key !== this.tail) {
      if (this.tail === undefined) {
        this.head = key;
        this.tail = key;
      } else {
        const previous = key.previous;
        const next = key.next;
        if (next !== undefined) {
          key.next = undefined;
          if (previous !== undefined) {
            previous.next = next;
            next.previous = previous;
          } else {
            this.head = next;
            this.head.previous = undefined;
          }
        }
        this.tail.next = key;
        key.previous = this.tail;
        this.tail = key;
      }
    }
  }
  remove() {
    const key = this.head;
    if (key !== undefined) {
      const next = key.next;
      if (next !== undefined) {
        key.next = undefined;
        this.head = next;
        this.head.previous = undefined;
      } else {
        this.head = undefined;
        this.tail = undefined;
      }
    }
    return key;
  }
}
var makeKeySet = () => new KeySetImpl;
var makeCacheState = (map10, keys5, accesses, updating, hits, misses) => ({
  map: map10,
  keys: keys5,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty21(), makeKeySet(), unbounded(), make12(false), 0, 0);
var CacheSymbolKey = "effect/Cache";
var CacheTypeId = /* @__PURE__ */ Symbol.for(CacheSymbolKey);
var cacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var ConsumerCacheSymbolKey = "effect/ConsumerCache";
var ConsumerCacheTypeId = /* @__PURE__ */ Symbol.for(ConsumerCacheSymbolKey);
var consumerCacheVariance = {
  _Key: (_) => _,
  _Error: (_) => _,
  _Value: (_) => _
};
var makeCacheStats = (options) => options;
var makeEntryStats = (loadedMillis) => ({
  loadedMillis
});

class CacheImpl {
  capacity;
  context;
  fiberId;
  lookup;
  timeToLive;
  [CacheTypeId] = cacheVariance;
  [ConsumerCacheTypeId] = consumerCacheVariance;
  cacheState;
  constructor(capacity, context2, fiberId2, lookup, timeToLive) {
    this.capacity = capacity;
    this.context = context2;
    this.fiberId = fiberId2;
    this.lookup = lookup;
    this.timeToLive = timeToLive;
    this.cacheState = initialCacheState();
  }
  get(key) {
    return map9(this.getEither(key), merge);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size4(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value)
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get8(this.cacheState.map, key), {
      onNone: () => {
        const mapKey = makeMapKey(key);
        this.trackAccess(mapKey);
        this.trackMiss();
        return succeed(none2());
      },
      onSome: (value) => this.resolveMapValue(value, true)
    }));
  }
  contains(key) {
    return sync(() => has4(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const option2 = get8(this.cacheState.map, key);
      if (isSome2(option2)) {
        switch (option2.value._tag) {
          case "Complete": {
            const loaded = option2.value.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
          case "Pending": {
            return none2();
          }
          case "Refreshing": {
            const loaded = option2.value.complete.entryStats.loadedMillis;
            return some2(makeEntryStats(loaded));
          }
        }
      }
      return none2();
    });
  }
  getEither(key) {
    return suspend(() => {
      const k = key;
      let mapKey = undefined;
      let deferred = undefined;
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === undefined) {
        deferred = unsafeMake4(this.fiberId);
        mapKey = makeMapKey(k);
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(mapKey, deferred));
        }
      }
      if (value === undefined) {
        this.trackAccess(mapKey);
        this.trackMiss();
        return map9(this.lookupValueOf(key, deferred), right2);
      } else {
        return flatMap7(this.resolveMapValue(value), match2({
          onNone: () => this.getEither(key),
          onSome: (value2) => succeed(left2(value2))
        }));
      }
    });
  }
  invalidate(key) {
    return sync(() => {
      remove6(this.cacheState.map, key);
    });
  }
  invalidateWhen(key, when2) {
    return sync(() => {
      const value = get8(this.cacheState.map, key);
      if (isSome2(value) && value.value._tag === "Complete") {
        if (value.value.exit._tag === "Success") {
          if (when2(value.value.exit.value)) {
            remove6(this.cacheState.map, key);
          }
        }
      }
    });
  }
  get invalidateAll() {
    return sync(() => {
      this.cacheState.map = empty21();
    });
  }
  refresh(key) {
    return clockWith3((clock2) => suspend(() => {
      const k = key;
      const deferred = unsafeMake4(this.fiberId);
      let value = getOrUndefined(get8(this.cacheState.map, k));
      if (value === undefined) {
        if (has4(this.cacheState.map, k)) {
          value = getOrUndefined(get8(this.cacheState.map, k));
        } else {
          set5(this.cacheState.map, k, pending2(makeMapKey(k), deferred));
        }
      }
      if (value === undefined) {
        return asVoid(this.lookupValueOf(key, deferred));
      } else {
        switch (value._tag) {
          case "Complete": {
            if (this.hasExpired(clock2, value.timeToLiveMillis)) {
              const found = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(found, value)) {
                remove6(this.cacheState.map, k);
              }
              return asVoid(this.get(key));
            }
            return pipe(this.lookupValueOf(key, deferred), when(() => {
              const current = getOrUndefined(get8(this.cacheState.map, k));
              if (equals(current, value)) {
                const mapValue = refreshing(deferred, value);
                set5(this.cacheState.map, k, mapValue);
                return true;
              }
              return false;
            }), asVoid);
          }
          case "Pending": {
            return _await(value.deferred);
          }
          case "Refreshing": {
            return _await(value.deferred);
          }
        }
      }
    }));
  }
  set(key, value) {
    return clockWith3((clock2) => sync(() => {
      const now = clock2.unsafeCurrentTimeMillis();
      const k = key;
      const lookupResult = succeed2(value);
      const mapValue = complete2(makeMapKey(k), lookupResult, makeEntryStats(now), now + toMillis(decode(this.timeToLive(lookupResult))));
      set5(this.cacheState.map, k, mapValue);
    }));
  }
  get size() {
    return sync(() => {
      return size4(this.cacheState.map);
    });
  }
  get values() {
    return sync(() => {
      const values4 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values4.push(entry[1].exit.value);
        }
      }
      return values4;
    });
  }
  get entries() {
    return sync(() => {
      const values4 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          values4.push([entry[0], entry[1].exit.value]);
        }
      }
      return values4;
    });
  }
  get keys() {
    return sync(() => {
      const keys5 = [];
      for (const entry of this.cacheState.map) {
        if (entry[1]._tag === "Complete" && entry[1].exit._tag === "Success") {
          keys5.push(entry[0]);
        }
      }
      return keys5;
    });
  }
  resolveMapValue(value, ignorePending = false) {
    return clockWith3((clock2) => {
      switch (value._tag) {
        case "Complete": {
          this.trackAccess(value.key);
          if (this.hasExpired(clock2, value.timeToLiveMillis)) {
            remove6(this.cacheState.map, value.key.current);
            return succeed(none2());
          }
          this.trackHit();
          return map9(value.exit, some2);
        }
        case "Pending": {
          this.trackAccess(value.key);
          this.trackHit();
          if (ignorePending) {
            return succeed(none2());
          }
          return map9(_await(value.deferred), some2);
        }
        case "Refreshing": {
          this.trackAccess(value.complete.key);
          this.trackHit();
          if (this.hasExpired(clock2, value.complete.timeToLiveMillis)) {
            if (ignorePending) {
              return succeed(none2());
            }
            return map9(_await(value.deferred), some2);
          }
          return map9(value.complete.exit, some2);
        }
      }
    });
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop2 = true;
      while (loop2) {
        const key2 = poll(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop2 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size8 = size4(this.cacheState.map);
      loop2 = size8 > this.capacity;
      while (loop2) {
        const key2 = this.cacheState.keys.remove();
        if (key2 !== undefined) {
          if (has4(this.cacheState.map, key2.current)) {
            remove6(this.cacheState.map, key2.current);
            size8 = size8 - 1;
            loop2 = size8 > this.capacity;
          }
        } else {
          loop2 = false;
        }
      }
      set3(this.cacheState.updating, false);
    }
  }
  hasExpired(clock2, timeToLiveMillis) {
    return clock2.unsafeCurrentTimeMillis() > timeToLiveMillis;
  }
  lookupValueOf(input, deferred) {
    return clockWith3((clock2) => suspend(() => {
      const key = input;
      return pipe(this.lookup(input), provideContext(this.context), exit, flatMap7((exit2) => {
        const now = clock2.unsafeCurrentTimeMillis();
        const stats = makeEntryStats(now);
        const value = complete2(makeMapKey(key), exit2, stats, now + toMillis(decode(this.timeToLive(exit2))));
        set5(this.cacheState.map, key, value);
        return zipRight(done2(deferred, exit2), exit2);
      }), onInterrupt(() => zipRight(interrupt3(deferred), sync(() => {
        remove6(this.cacheState.map, key);
      }))));
    }));
  }
}
var unsafeMakeWith = (capacity, lookup, timeToLive) => new CacheImpl(capacity, empty4(), none3, lookup, (exit2) => decode(timeToLive(exit2)));
// node_modules/effect/dist/esm/Cause.js
var empty30 = empty20;
var fail4 = fail;
var die4 = die;
var interrupt5 = interrupt;
var parallel4 = parallel;
var sequential4 = sequential;
var isCause2 = isCause;
var isFailType2 = isFailType;
var failureOrCause2 = failureOrCause;
var NoSuchElementException2 = NoSuchElementException;
var pretty2 = pretty;
// node_modules/effect/dist/esm/Effect.js
var exports_Effect = {};
__export(exports_Effect, {
  zipWith: () => zipWith6,
  zipRight: () => zipRight2,
  zipLeft: () => zipLeft2,
  zip: () => zip4,
  yieldNow: () => yieldNow4,
  withUnhandledErrorLogLevel: () => withUnhandledErrorLogLevel2,
  withTracerTiming: () => withTracerTiming2,
  withTracerScoped: () => withTracerScoped2,
  withTracerEnabled: () => withTracerEnabled2,
  withTracer: () => withTracer2,
  withSpanScoped: () => withSpanScoped2,
  withSpan: () => withSpan3,
  withSchedulingPriority: () => withSchedulingPriority2,
  withScheduler: () => withScheduler2,
  withRuntimeFlagsPatchScoped: () => withRuntimeFlagsPatchScoped,
  withRuntimeFlagsPatch: () => withRuntimeFlagsPatch,
  withRequestCaching: () => withRequestCaching2,
  withRequestCache: () => withRequestCache2,
  withRequestBatching: () => withRequestBatching2,
  withRandomScoped: () => withRandomScoped2,
  withRandomFixed: () => withRandomFixed,
  withRandom: () => withRandom2,
  withParentSpan: () => withParentSpan3,
  withMetric: () => withMetric2,
  withMaxOpsBeforeYield: () => withMaxOpsBeforeYield2,
  withLogSpan: () => withLogSpan2,
  withFiberRuntime: () => withFiberRuntime2,
  withExecutionPlan: () => withExecutionPlan2,
  withEarlyRelease: () => withEarlyRelease2,
  withConsoleScoped: () => withConsoleScoped2,
  withConsole: () => withConsole2,
  withConfigProviderScoped: () => withConfigProviderScoped2,
  withConfigProvider: () => withConfigProvider2,
  withConcurrency: () => withConcurrency2,
  withClockScoped: () => withClockScoped2,
  withClock: () => withClock2,
  whileLoop: () => whileLoop2,
  whenRef: () => whenRef2,
  whenLogLevel: () => whenLogLevel2,
  whenFiberRef: () => whenFiberRef2,
  whenEffect: () => whenEffect2,
  when: () => when2,
  void: () => _void,
  validateWith: () => validateWith2,
  validateFirst: () => validateFirst2,
  validateAll: () => validateAll2,
  validate: () => validate2,
  using: () => using2,
  useSpan: () => useSpan2,
  updateService: () => updateService2,
  updateFiberRefs: () => updateFiberRefs2,
  unsandbox: () => unsandbox2,
  unsafeMakeSemaphore: () => unsafeMakeSemaphore2,
  unsafeMakeLatch: () => unsafeMakeLatch2,
  unlessEffect: () => unlessEffect2,
  unless: () => unless2,
  uninterruptibleMask: () => uninterruptibleMask3,
  uninterruptible: () => uninterruptible2,
  tryPromise: () => tryPromise2,
  tryMapPromise: () => tryMapPromise2,
  tryMap: () => tryMap2,
  try: () => try_3,
  transposeOption: () => transposeOption,
  transposeMapOption: () => transposeMapOption,
  transplant: () => transplant2,
  tracerWith: () => tracerWith4,
  tracer: () => tracer2,
  timeoutTo: () => timeoutTo2,
  timeoutOption: () => timeoutOption2,
  timeoutFailCause: () => timeoutFailCause2,
  timeoutFail: () => timeoutFail2,
  timeout: () => timeout2,
  timedWith: () => timedWith2,
  timed: () => timed2,
  tapErrorTag: () => tapErrorTag2,
  tapErrorCause: () => tapErrorCause3,
  tapError: () => tapError3,
  tapDefect: () => tapDefect2,
  tapBoth: () => tapBoth2,
  tap: () => tap3,
  takeWhile: () => takeWhile2,
  takeUntil: () => takeUntil2,
  tagMetricsScoped: () => tagMetricsScoped2,
  tagMetrics: () => tagMetrics2,
  sync: () => sync3,
  suspend: () => suspend3,
  supervised: () => supervised2,
  summarized: () => summarized2,
  succeedSome: () => succeedSome2,
  succeedNone: () => succeedNone2,
  succeed: () => succeed7,
  step: () => step3,
  spanLinks: () => spanLinks2,
  spanAnnotations: () => spanAnnotations2,
  sleep: () => sleep4,
  setFiberRefs: () => setFiberRefs2,
  serviceOptional: () => serviceOptional2,
  serviceOption: () => serviceOption2,
  serviceMembers: () => serviceMembers2,
  serviceFunctions: () => serviceFunctions2,
  serviceFunctionEffect: () => serviceFunctionEffect2,
  serviceFunction: () => serviceFunction2,
  serviceConstants: () => serviceConstants2,
  sequentialFinalizers: () => sequentialFinalizers2,
  scopedWith: () => scopedWith2,
  scoped: () => scoped2,
  scopeWith: () => scopeWith2,
  scope: () => scope3,
  scheduleFrom: () => scheduleFrom,
  scheduleForked: () => scheduleForked2,
  schedule: () => schedule,
  sandbox: () => sandbox2,
  runtime: () => runtime4,
  runSyncExit: () => runSyncExit,
  runSync: () => runSync,
  runRequestBlock: () => runRequestBlock2,
  runPromiseExit: () => runPromiseExit,
  runPromise: () => runPromise,
  runFork: () => runFork2,
  runCallback: () => runCallback,
  retryOrElse: () => retryOrElse,
  retry: () => retry2,
  request: () => request,
  replicateEffect: () => replicateEffect2,
  replicate: () => replicate2,
  repeatOrElse: () => repeatOrElse,
  repeatN: () => repeatN2,
  repeat: () => repeat,
  reduceWhile: () => reduceWhile2,
  reduceRight: () => reduceRight3,
  reduceEffect: () => reduceEffect2,
  reduce: () => reduce12,
  randomWith: () => randomWith2,
  random: () => random3,
  raceWith: () => raceWith2,
  raceFirst: () => raceFirst2,
  raceAll: () => raceAll2,
  race: () => race2,
  provideServiceEffect: () => provideServiceEffect2,
  provideService: () => provideService2,
  provide: () => provide2,
  promise: () => promise2,
  patchRuntimeFlags: () => patchRuntimeFlags,
  patchFiberRefs: () => patchFiberRefs2,
  partition: () => partition4,
  parallelFinalizers: () => parallelFinalizers2,
  parallelErrors: () => parallelErrors2,
  orElseSucceed: () => orElseSucceed2,
  orElseFail: () => orElseFail2,
  orElse: () => orElse5,
  orDieWith: () => orDieWith2,
  orDie: () => orDie3,
  optionFromOptional: () => optionFromOptional2,
  option: () => option2,
  once: () => once3,
  onInterrupt: () => onInterrupt2,
  onExit: () => onExit3,
  onError: () => onError2,
  none: () => none9,
  never: () => never3,
  negate: () => negate2,
  metricLabels: () => metricLabels2,
  mergeAll: () => mergeAll5,
  merge: () => merge7,
  matchEffect: () => matchEffect2,
  matchCauseEffect: () => matchCauseEffect3,
  matchCause: () => matchCause3,
  match: () => match13,
  mapInputContext: () => mapInputContext2,
  mapErrorCause: () => mapErrorCause2,
  mapError: () => mapError3,
  mapBoth: () => mapBoth2,
  mapAccum: () => mapAccum3,
  map: () => map13,
  makeSpanScoped: () => makeSpanScoped2,
  makeSpan: () => makeSpan2,
  makeSemaphore: () => makeSemaphore2,
  makeLatch: () => makeLatch2,
  loop: () => loop2,
  logWithLevel: () => logWithLevel2,
  logWarning: () => logWarning2,
  logTrace: () => logTrace2,
  logInfo: () => logInfo2,
  logFatal: () => logFatal2,
  logError: () => logError2,
  logDebug: () => logDebug2,
  logAnnotations: () => logAnnotations2,
  log: () => log2,
  locallyWith: () => locallyWith,
  locallyScopedWith: () => locallyScopedWith,
  locallyScoped: () => locallyScoped,
  locally: () => locally,
  linkSpans: () => linkSpans2,
  linkSpanCurrent: () => linkSpanCurrent2,
  liftPredicate: () => liftPredicate2,
  let: () => let_3,
  labelMetricsScoped: () => labelMetricsScoped2,
  labelMetrics: () => labelMetrics2,
  iterate: () => iterate2,
  isSuccess: () => isSuccess3,
  isFailure: () => isFailure3,
  isEffect: () => isEffect2,
  intoDeferred: () => intoDeferred2,
  interruptibleMask: () => interruptibleMask2,
  interruptible: () => interruptible4,
  interruptWith: () => interruptWith2,
  interrupt: () => interrupt6,
  inheritFiberRefs: () => inheritFiberRefs2,
  ignoreLogged: () => ignoreLogged2,
  ignore: () => ignore2,
  if: () => if_2,
  head: () => head4,
  getRuntimeFlags: () => getRuntimeFlags,
  getFiberRefs: () => getFiberRefs,
  gen: () => gen2,
  functionWithSpan: () => functionWithSpan2,
  fromNullable: () => fromNullable3,
  fromFiberEffect: () => fromFiberEffect2,
  fromFiber: () => fromFiber2,
  forkWithErrorHandler: () => forkWithErrorHandler2,
  forkScoped: () => forkScoped2,
  forkIn: () => forkIn2,
  forkDaemon: () => forkDaemon2,
  forkAll: () => forkAll2,
  fork: () => fork3,
  forever: () => forever3,
  forEach: () => forEach8,
  fnUntraced: () => fnUntraced2,
  fn: () => fn,
  flipWith: () => flipWith2,
  flip: () => flip2,
  flatten: () => flatten8,
  flatMap: () => flatMap10,
  firstSuccessOf: () => firstSuccessOf2,
  findFirst: () => findFirst6,
  finalizersMask: () => finalizersMask2,
  filterOrFail: () => filterOrFail2,
  filterOrElse: () => filterOrElse2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrDie: () => filterOrDie2,
  filterMap: () => filterMap5,
  filterEffectOrFail: () => filterEffectOrFail2,
  filterEffectOrElse: () => filterEffectOrElse2,
  filter: () => filter7,
  fiberIdWith: () => fiberIdWith2,
  fiberId: () => fiberId2,
  failSync: () => failSync3,
  failCauseSync: () => failCauseSync3,
  failCause: () => failCause7,
  fail: () => fail8,
  exit: () => exit2,
  exists: () => exists3,
  every: () => every7,
  eventually: () => eventually2,
  ensuringChildren: () => ensuringChildren2,
  ensuringChild: () => ensuringChild2,
  ensuring: () => ensuring2,
  ensureSuccessType: () => ensureSuccessType,
  ensureRequirementsType: () => ensureRequirementsType,
  ensureErrorType: () => ensureErrorType,
  either: () => either3,
  dropWhile: () => dropWhile2,
  dropUntil: () => dropUntil2,
  disconnect: () => disconnect2,
  diffFiberRefs: () => diffFiberRefs2,
  dieSync: () => dieSync3,
  dieMessage: () => dieMessage2,
  die: () => die6,
  descriptorWith: () => descriptorWith2,
  descriptor: () => descriptor2,
  delay: () => delay2,
  daemonChildren: () => daemonChildren2,
  custom: () => custom2,
  currentSpan: () => currentSpan2,
  currentParentSpan: () => currentParentSpan2,
  contextWithEffect: () => contextWithEffect2,
  contextWith: () => contextWith2,
  context: () => context3,
  consoleWith: () => consoleWith2,
  console: () => console3,
  configProviderWith: () => configProviderWith2,
  clockWith: () => clockWith4,
  clock: () => clock2,
  checkInterruptible: () => checkInterruptible2,
  cause: () => cause2,
  catchTags: () => catchTags2,
  catchTag: () => catchTag2,
  catchSomeDefect: () => catchSomeDefect2,
  catchSomeCause: () => catchSomeCause2,
  catchSome: () => catchSome2,
  catchIf: () => catchIf2,
  catchAllDefect: () => catchAllDefect2,
  catchAllCause: () => catchAllCause3,
  catchAll: () => catchAll3,
  catch: () => _catch2,
  cachedWithTTL: () => cachedWithTTL,
  cachedInvalidateWithTTL: () => cachedInvalidateWithTTL2,
  cachedFunction: () => cachedFunction2,
  cached: () => cached3,
  cacheRequestResult: () => cacheRequestResult,
  blocked: () => blocked2,
  bindTo: () => bindTo3,
  bindAll: () => bindAll2,
  bind: () => bind3,
  awaitAllChildren: () => awaitAllChildren2,
  asyncEffect: () => asyncEffect2,
  async: () => async,
  asVoid: () => asVoid3,
  asSomeError: () => asSomeError2,
  asSome: () => asSome2,
  as: () => as3,
  ap: () => ap,
  annotateSpans: () => annotateSpans3,
  annotateLogsScoped: () => annotateLogsScoped2,
  annotateLogs: () => annotateLogs3,
  annotateCurrentSpan: () => annotateCurrentSpan2,
  andThen: () => andThen4,
  allowInterrupt: () => allowInterrupt2,
  allWith: () => allWith2,
  allSuccesses: () => allSuccesses2,
  all: () => all4,
  addFinalizer: () => addFinalizer2,
  acquireUseRelease: () => acquireUseRelease2,
  acquireReleaseInterruptible: () => acquireReleaseInterruptible2,
  acquireRelease: () => acquireRelease2,
  Tag: () => Tag3,
  Service: () => Service,
  EffectTypeId: () => EffectTypeId3,
  Do: () => Do2
});

// node_modules/effect/dist/esm/internal/schedule/interval.js
var IntervalSymbolKey = "effect/ScheduleInterval";
var IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
var empty31 = {
  [IntervalTypeId]: IntervalTypeId,
  startMillis: 0,
  endMillis: 0
};
var make36 = (startMillis, endMillis) => {
  if (startMillis > endMillis) {
    return empty31;
  }
  return {
    [IntervalTypeId]: IntervalTypeId,
    startMillis,
    endMillis
  };
};
var lessThan4 = /* @__PURE__ */ dual(2, (self2, that) => min2(self2, that) === self2);
var min2 = /* @__PURE__ */ dual(2, (self2, that) => {
  if (self2.endMillis <= that.startMillis)
    return self2;
  if (that.endMillis <= self2.startMillis)
    return that;
  if (self2.startMillis < that.startMillis)
    return self2;
  if (that.startMillis < self2.startMillis)
    return that;
  if (self2.endMillis <= that.endMillis)
    return self2;
  return that;
});
var isEmpty7 = (self2) => {
  return self2.startMillis >= self2.endMillis;
};
var intersect = /* @__PURE__ */ dual(2, (self2, that) => {
  const start = Math.max(self2.startMillis, that.startMillis);
  const end = Math.min(self2.endMillis, that.endMillis);
  return make36(start, end);
});
var after = (startMilliseconds) => {
  return make36(startMilliseconds, Number.POSITIVE_INFINITY);
};

// node_modules/effect/dist/esm/ScheduleInterval.js
var empty32 = empty31;
var lessThan5 = lessThan4;
var isEmpty8 = isEmpty7;
var intersect2 = intersect;
var after2 = after;

// node_modules/effect/dist/esm/internal/schedule/intervals.js
var IntervalsSymbolKey = "effect/ScheduleIntervals";
var IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
var make38 = (intervals) => {
  return {
    [IntervalsTypeId]: IntervalsTypeId,
    intervals
  };
};
var intersect3 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty5()));
var intersectLoop = (_left, _right, _acc) => {
  let left3 = _left;
  let right3 = _right;
  let acc = _acc;
  while (isNonEmpty2(left3) && isNonEmpty2(right3)) {
    const interval = pipe(headNonEmpty2(left3), intersect2(headNonEmpty2(right3)));
    const intervals = isEmpty8(interval) ? acc : pipe(acc, prepend2(interval));
    if (pipe(headNonEmpty2(left3), lessThan5(headNonEmpty2(right3)))) {
      left3 = tailNonEmpty2(left3);
    } else {
      right3 = tailNonEmpty2(right3);
    }
    acc = intervals;
  }
  return make38(reverse2(acc));
};
var start = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).startMillis;
};
var end = (self2) => {
  return pipe(self2.intervals, head2, getOrElse(() => empty32)).endMillis;
};
var lessThan6 = /* @__PURE__ */ dual(2, (self2, that) => start(self2) < start(that));
var isNonEmpty4 = (self2) => {
  return isNonEmpty2(self2.intervals);
};

// node_modules/effect/dist/esm/ScheduleIntervals.js
var make39 = make38;
var intersect4 = intersect3;
var start2 = start;
var end2 = end;
var lessThan7 = lessThan6;
var isNonEmpty5 = isNonEmpty4;

// node_modules/effect/dist/esm/internal/schedule/decision.js
var OP_CONTINUE = "Continue";
var OP_DONE2 = "Done";
var _continue = (intervals) => {
  return {
    _tag: OP_CONTINUE,
    intervals
  };
};
var continueWith = (interval) => {
  return {
    _tag: OP_CONTINUE,
    intervals: make39(of2(interval))
  };
};
var done5 = {
  _tag: OP_DONE2
};
var isContinue = (self2) => {
  return self2._tag === OP_CONTINUE;
};
var isDone3 = (self2) => {
  return self2._tag === OP_DONE2;
};

// node_modules/effect/dist/esm/ScheduleDecision.js
var _continue2 = _continue;
var continueWith2 = continueWith;
var done6 = done5;
var isContinue2 = isContinue;
var isDone4 = isDone3;

// node_modules/effect/dist/esm/Scope.js
var Scope = scopeTag;
var close = scopeClose;
var fork2 = scopeFork;

// node_modules/effect/dist/esm/internal/effect/circular.js
class Semaphore {
  permits;
  waiters = /* @__PURE__ */ new Set;
  taken = 0;
  constructor(permits) {
    this.permits = permits;
  }
  get free() {
    return this.permits - this.taken;
  }
  take = (n) => asyncInterrupt((resume2) => {
    if (this.free < n) {
      const observer = () => {
        if (this.free < n) {
          return;
        }
        this.waiters.delete(observer);
        this.taken += n;
        resume2(succeed(n));
      };
      this.waiters.add(observer);
      return sync(() => {
        this.waiters.delete(observer);
      });
    }
    this.taken += n;
    return resume2(succeed(n));
  });
  updateTaken = (f) => withFiberRuntime((fiber) => {
    this.taken = f(this.taken);
    if (this.waiters.size > 0) {
      fiber.getFiberRef(currentScheduler).scheduleTask(() => {
        const iter = this.waiters.values();
        let item = iter.next();
        while (item.done === false && this.free > 0) {
          item.value();
          item = iter.next();
        }
      }, fiber.getFiberRef(currentSchedulingPriority));
    }
    return succeed(this.free);
  });
  release = (n) => this.updateTaken((taken) => taken - n);
  releaseAll = /* @__PURE__ */ this.updateTaken((_) => 0);
  withPermits = (n) => (self2) => uninterruptibleMask((restore) => flatMap7(restore(this.take(n)), (permits) => ensuring(restore(self2), this.release(permits))));
  withPermitsIfAvailable = (n) => (self2) => uninterruptibleMask((restore) => suspend(() => {
    if (this.free < n) {
      return succeedNone;
    }
    this.taken += n;
    return ensuring(restore(asSome(self2)), this.release(n));
  }));
}
var unsafeMakeSemaphore = (permits) => new Semaphore(permits);
var makeSemaphore = (permits) => sync(() => unsafeMakeSemaphore(permits));

class Latch extends Class {
  isOpen;
  waiters = [];
  scheduled = false;
  constructor(isOpen) {
    super();
    this.isOpen = isOpen;
  }
  commit() {
    return this.await;
  }
  unsafeSchedule(fiber) {
    if (this.scheduled || this.waiters.length === 0) {
      return void_;
    }
    this.scheduled = true;
    fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority));
    return void_;
  }
  flushWaiters = () => {
    this.scheduled = false;
    const waiters = this.waiters;
    this.waiters = [];
    for (let i = 0;i < waiters.length; i++) {
      waiters[i](exitVoid);
    }
  };
  open = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    this.isOpen = true;
    return this.unsafeSchedule(fiber);
  });
  unsafeOpen() {
    if (this.isOpen)
      return;
    this.isOpen = true;
    this.flushWaiters();
  }
  release = /* @__PURE__ */ withFiberRuntime((fiber) => {
    if (this.isOpen) {
      return void_;
    }
    return this.unsafeSchedule(fiber);
  });
  await = /* @__PURE__ */ asyncInterrupt((resume2) => {
    if (this.isOpen) {
      return resume2(void_);
    }
    this.waiters.push(resume2);
    return sync(() => {
      const index = this.waiters.indexOf(resume2);
      if (index !== -1) {
        this.waiters.splice(index, 1);
      }
    });
  });
  unsafeClose() {
    this.isOpen = false;
  }
  close = /* @__PURE__ */ sync(() => {
    this.isOpen = false;
  });
  whenOpen = (self2) => {
    return zipRight(this.await, self2);
  };
}
var unsafeMakeLatch = (open) => new Latch(open ?? false);
var makeLatch = (open) => sync(() => unsafeMakeLatch(open));
var awaitAllChildren = (self2) => ensuringChildren(self2, fiberAwaitAll);
var cached2 = /* @__PURE__ */ dual(2, (self2, timeToLive) => map9(cachedInvalidateWithTTL(self2, timeToLive), (tuple3) => tuple3[0]));
var cachedInvalidateWithTTL = /* @__PURE__ */ dual(2, (self2, timeToLive) => {
  const duration = decode(timeToLive);
  return flatMap7(context(), (env) => map9(makeSynchronized(none2()), (cache) => [provideContext(getCachedValue(self2, duration, cache), env), invalidateCache(cache)]));
});
var computeCachedValue = (self2, timeToLive, start3) => {
  const timeToLiveMillis = toMillis(decode(timeToLive));
  return pipe(deferredMake(), tap((deferred) => intoDeferred(self2, deferred)), map9((deferred) => some2([start3 + timeToLiveMillis, deferred])));
};
var getCachedValue = (self2, timeToLive, cache) => uninterruptibleMask((restore) => pipe(clockWith3((clock2) => clock2.currentTimeMillis), flatMap7((time) => updateSomeAndGetEffectSynchronized(cache, (option2) => {
  switch (option2._tag) {
    case "None": {
      return some2(computeCachedValue(self2, timeToLive, time));
    }
    case "Some": {
      const [end3] = option2.value;
      return end3 - time <= 0 ? some2(computeCachedValue(self2, timeToLive, time)) : none2();
    }
  }
})), flatMap7((option2) => isNone2(option2) ? dieMessage("BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/effect/issues") : restore(deferredAwait(option2.value[1])))));
var invalidateCache = (cache) => set6(cache, none2());
var ensuringChild = /* @__PURE__ */ dual(2, (self2, f) => ensuringChildren(self2, (children) => f(fiberAll(children))));
var ensuringChildren = /* @__PURE__ */ dual(2, (self2, children) => flatMap7(track, (supervisor) => pipe(supervised(self2, supervisor), ensuring(flatMap7(supervisor.value, children)))));
var forkAll = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (effects, options) => options?.discard ? forEachSequentialDiscard(effects, fork) : map9(forEachSequential(effects, fork), fiberAll));
var forkIn = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime((parent, parentStatus) => {
  const scopeImpl = scope2;
  const fiber = unsafeFork(self2, parent, parentStatus.runtimeFlags, globalScope);
  if (scopeImpl.state._tag === "Open") {
    const finalizer = () => fiberIdWith((fiberId2) => equals(fiberId2, fiber.id()) ? void_ : asVoid(interruptFiber(fiber)));
    const key = {};
    scopeImpl.state.finalizers.set(key, finalizer);
    fiber.addObserver(() => {
      if (scopeImpl.state._tag === "Closed")
        return;
      scopeImpl.state.finalizers.delete(key);
    });
  } else {
    fiber.unsafeInterruptAsFork(parent.id());
  }
  return succeed(fiber);
}));
var forkScoped = (self2) => scopeWith((scope2) => forkIn(self2, scope2));
var fromFiber = (fiber) => join2(fiber);
var fromFiberEffect = (fiber) => suspend(() => flatMap7(fiber, join2));
var memoKeySymbol = /* @__PURE__ */ Symbol.for("effect/Effect/memoizeFunction.key");

class Key {
  a;
  eq;
  [memoKeySymbol] = memoKeySymbol;
  constructor(a, eq) {
    this.a = a;
    this.eq = eq;
  }
  [symbol2](that) {
    if (hasProperty(that, memoKeySymbol)) {
      if (this.eq) {
        return this.eq(this.a, that.a);
      } else {
        return equals(this.a, that.a);
      }
    }
    return false;
  }
  [symbol]() {
    return this.eq ? 0 : cached(this, hash(this.a));
  }
}
var cachedFunction = (f, eq) => {
  return pipe(sync(() => empty21()), flatMap7(makeSynchronized), map9((ref) => (a) => pipe(ref.modifyEffect((map10) => {
    const result = pipe(map10, get8(new Key(a, eq)));
    if (isNone2(result)) {
      return pipe(deferredMake(), tap((deferred) => pipe(diffFiberRefs(f(a)), intoDeferred(deferred), fork)), map9((deferred) => [deferred, pipe(map10, set5(new Key(a, eq), deferred))]));
    }
    return succeed([result.value, map10]);
  }), flatMap7(deferredAwait), flatMap7(([patch12, b]) => pipe(patchFiberRefs(patch12), as(b))))));
};
var raceFirst = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit(self2), race(exit(that)), (effect) => flatten5(effect)));
var supervised = /* @__PURE__ */ dual(2, (self2, supervisor) => {
  const supervise = fiberRefLocallyWith(currentSupervisor, (s) => s.zip(supervisor));
  return supervise(self2);
});
var timeout = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
  onTimeout: () => timeoutExceptionFromDuration(duration),
  duration
}));
var timeoutFail = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutFailCause = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onTimeout
}) => flatten5(timeoutTo(self2, {
  onTimeout: () => failCauseSync(onTimeout),
  onSuccess: succeed,
  duration
})));
var timeoutOption = /* @__PURE__ */ dual(2, (self2, duration) => timeoutTo(self2, {
  duration,
  onSuccess: some2,
  onTimeout: none2
}));
var timeoutTo = /* @__PURE__ */ dual(2, (self2, {
  duration,
  onSuccess,
  onTimeout
}) => fiberIdWith((parentFiberId) => uninterruptibleMask((restore) => raceFibersWith(restore(self2), interruptible2(sleep3(duration)), {
  onSelfWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  onOtherWin: (winner, loser) => flatMap7(winner.await, (exit2) => {
    if (exit2._tag === "Success") {
      return flatMap7(winner.inheritAll, () => as(interruptAsFiber(loser, parentFiberId), onTimeout()));
    } else {
      return flatMap7(interruptAsFiber(loser, parentFiberId), () => exitFailCause(exit2.cause));
    }
  }),
  otherScope: globalScope
}))));
var SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
var SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
var synchronizedVariance = {
  _A: (_) => _
};

class SynchronizedImpl extends Class {
  ref;
  withLock;
  [SynchronizedTypeId] = synchronizedVariance;
  [RefTypeId] = refVariance;
  [TypeId13] = TypeId13;
  constructor(ref, withLock) {
    super();
    this.ref = ref;
    this.withLock = withLock;
    this.get = get11(this.ref);
  }
  get;
  commit() {
    return this.get;
  }
  modify(f) {
    return this.modifyEffect((a) => succeed(f(a)));
  }
  modifyEffect(f) {
    return this.withLock(pipe(flatMap7(get11(this.ref), f), flatMap7(([b, a]) => as(set6(this.ref, a), b))));
  }
}
var makeSynchronized = (value) => sync(() => unsafeMakeSynchronized(value));
var unsafeMakeSynchronized = (value) => {
  const ref = unsafeMake6(value);
  const sem = unsafeMakeSemaphore(1);
  return new SynchronizedImpl(ref, sem.withPermits(1));
};
var updateSomeAndGetEffectSynchronized = /* @__PURE__ */ dual(2, (self2, pf) => self2.modifyEffect((value) => {
  const result = pf(value);
  switch (result._tag) {
    case "None": {
      return succeed([value, value]);
    }
    case "Some": {
      return map9(result.value, (a) => [a, a]);
    }
  }
}));
var bindAll = /* @__PURE__ */ dual((args2) => isEffect(args2[0]), (self2, f, options) => flatMap7(self2, (a) => all2(f(a), options).pipe(map9((record) => Object.assign({}, a, record)))));

// node_modules/effect/dist/esm/internal/managedRuntime/circular.js
var TypeId16 = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");

// node_modules/effect/dist/esm/internal/opCodes/layer.js
var OP_EXTEND_SCOPE = "ExtendScope";
var OP_FOLD = "Fold";
var OP_FRESH = "Fresh";
var OP_FROM_EFFECT = "FromEffect";
var OP_SCOPED = "Scoped";
var OP_SUSPEND = "Suspend";
var OP_PROVIDE = "Provide";
var OP_PROVIDE_MERGE = "ProvideMerge";
var OP_ZIP_WITH2 = "ZipWith";

// node_modules/effect/dist/esm/Fiber.js
var interruptAs = interruptAsFiber;

// node_modules/effect/dist/esm/internal/runtime.js
var makeDual = (f) => function() {
  if (arguments.length === 1) {
    const runtime3 = arguments[0];
    return (effect, ...args2) => f(runtime3, effect, ...args2);
  }
  return f.apply(this, arguments);
};
var unsafeFork2 = /* @__PURE__ */ makeDual((runtime3, self2, options) => {
  const fiberId2 = unsafeMake3();
  const fiberRefUpdates = [[currentContext, [[fiberId2, runtime3.context]]]];
  if (options?.scheduler) {
    fiberRefUpdates.push([currentScheduler, [[fiberId2, options.scheduler]]]);
  }
  let fiberRefs3 = updateManyAs2(runtime3.fiberRefs, {
    entries: fiberRefUpdates,
    forkAs: fiberId2
  });
  if (options?.updateRefs) {
    fiberRefs3 = options.updateRefs(fiberRefs3, fiberId2);
  }
  const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs3, runtime3.runtimeFlags);
  let effect = self2;
  if (options?.scope) {
    effect = flatMap7(fork2(options.scope, sequential2), (closeableScope) => zipRight(scopeAddFinalizer(closeableScope, fiberIdWith((id2) => equals(id2, fiberRuntime.id()) ? void_ : interruptAsFiber(fiberRuntime, id2))), onExit(self2, (exit2) => close(closeableScope, exit2))));
  }
  const supervisor = fiberRuntime.currentSupervisor;
  if (supervisor !== none8) {
    supervisor.onStart(runtime3.context, effect, none2(), fiberRuntime);
    fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
  }
  globalScope.add(runtime3.runtimeFlags, fiberRuntime);
  if (options?.immediate === false) {
    fiberRuntime.resume(effect);
  } else {
    fiberRuntime.start(effect);
  }
  return fiberRuntime;
});
var unsafeRunCallback = /* @__PURE__ */ makeDual((runtime3, effect, options = {}) => {
  const fiberRuntime = unsafeFork2(runtime3, effect, options);
  if (options.onExit) {
    fiberRuntime.addObserver((exit2) => {
      options.onExit(exit2);
    });
  }
  return (id2, cancelOptions) => unsafeRunCallback(runtime3)(pipe(fiberRuntime, interruptAs(id2 ?? none4)), {
    ...cancelOptions,
    onExit: cancelOptions?.onExit ? (exit2) => cancelOptions.onExit(flatten6(exit2)) : undefined
  });
});
var unsafeRunSync = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const result = unsafeRunSyncExit(runtime3)(effect);
  if (result._tag === "Failure") {
    throw fiberFailure(result.effect_instruction_i0);
  }
  return result.effect_instruction_i0;
});

class AsyncFiberExceptionImpl extends Error {
  fiber;
  _tag = "AsyncFiberException";
  constructor(fiber) {
    super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
    this.fiber = fiber;
    this.name = this._tag;
    this.stack = this.message;
  }
}
var asyncFiberException = (fiber) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new AsyncFiberExceptionImpl(fiber);
  Error.stackTraceLimit = limit;
  return error;
};
var FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
var FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");

class FiberFailureImpl extends Error {
  [FiberFailureId];
  [FiberFailureCauseId];
  constructor(cause2) {
    const head4 = prettyErrors(cause2)[0];
    super(head4?.message || "An error has occurred");
    this[FiberFailureId] = FiberFailureId;
    this[FiberFailureCauseId] = cause2;
    this.name = head4 ? `(FiberFailure) ${head4.name}` : "FiberFailure";
    if (head4?.stack) {
      this.stack = head4.stack;
    }
  }
  toJSON() {
    return {
      _id: "FiberFailure",
      cause: this[FiberFailureCauseId].toJSON()
    };
  }
  toString() {
    return "(FiberFailure) " + pretty(this[FiberFailureCauseId], {
      renderErrorCause: true
    });
  }
  [NodeInspectSymbol]() {
    return this.toString();
  }
}
var fiberFailure = (cause2) => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 0;
  const error = new FiberFailureImpl(cause2);
  Error.stackTraceLimit = limit;
  return error;
};
var fastPath = (effect) => {
  const op = effect;
  switch (op._op) {
    case "Failure":
    case "Success": {
      return op;
    }
    case "Left": {
      return exitFail(op.left);
    }
    case "Right": {
      return exitSucceed(op.right);
    }
    case "Some": {
      return exitSucceed(op.value);
    }
    case "None": {
      return exitFail(NoSuchElementException());
    }
  }
};
var unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime3, effect) => {
  const op = fastPath(effect);
  if (op) {
    return op;
  }
  const scheduler = new SyncScheduler;
  const fiberRuntime = unsafeFork2(runtime3)(effect, {
    scheduler
  });
  scheduler.flush();
  const result = fiberRuntime.unsafePoll();
  if (result) {
    return result;
  }
  return exitDie(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
});
var unsafeRunPromise = /* @__PURE__ */ makeDual((runtime3, effect, options) => unsafeRunPromiseExit(runtime3, effect, options).then((result) => {
  switch (result._tag) {
    case OP_SUCCESS: {
      return result.effect_instruction_i0;
    }
    case OP_FAILURE: {
      throw fiberFailure(result.effect_instruction_i0);
    }
  }
}));
var unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime3, effect, options) => new Promise((resolve) => {
  const op = fastPath(effect);
  if (op) {
    resolve(op);
  }
  const fiber = unsafeFork2(runtime3)(effect);
  fiber.addObserver((exit2) => {
    resolve(exit2);
  });
  if (options?.signal !== undefined) {
    if (options.signal.aborted) {
      fiber.unsafeInterruptAsFork(fiber.id());
    } else {
      options.signal.addEventListener("abort", () => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, {
        once: true
      });
    }
  }
}));

class RuntimeImpl {
  context;
  runtimeFlags;
  fiberRefs;
  constructor(context2, runtimeFlags2, fiberRefs3) {
    this.context = context2;
    this.runtimeFlags = runtimeFlags2;
    this.fiberRefs = fiberRefs3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var make40 = (options) => new RuntimeImpl(options.context, options.runtimeFlags, options.fiberRefs);
var runtime3 = () => withFiberRuntime((state, status2) => succeed(new RuntimeImpl(state.getFiberRef(currentContext), status2.runtimeFlags, state.getFiberRefs())));
var defaultRuntimeFlags = /* @__PURE__ */ make17(Interruption, CooperativeYielding, RuntimeMetrics);
var defaultRuntime = /* @__PURE__ */ make40({
  context: /* @__PURE__ */ empty4(),
  runtimeFlags: defaultRuntimeFlags,
  fiberRefs: /* @__PURE__ */ empty25()
});
var unsafeRunEffect = /* @__PURE__ */ unsafeRunCallback(defaultRuntime);
var unsafeForkEffect = /* @__PURE__ */ unsafeFork2(defaultRuntime);
var unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
var unsafeRunPromiseExitEffect = /* @__PURE__ */ unsafeRunPromiseExit(defaultRuntime);
var unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
var unsafeRunSyncExitEffect = /* @__PURE__ */ unsafeRunSyncExit(defaultRuntime);
var asyncEffect = (register) => suspend(() => {
  let cleanup = undefined;
  return flatMap7(deferredMake(), (deferred) => flatMap7(runtime3(), (runtime4) => uninterruptibleMask((restore) => zipRight(fork(restore(matchCauseEffect(register((cb) => unsafeRunCallback(runtime4)(intoDeferred(cb, deferred))), {
    onFailure: (cause2) => deferredFailCause(deferred, cause2),
    onSuccess: (cleanup_) => {
      cleanup = cleanup_;
      return void_;
    }
  }))), restore(onInterrupt(deferredAwait(deferred), () => cleanup ?? void_))))));
});

// node_modules/effect/dist/esm/internal/synchronizedRef.js
var modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));

// node_modules/effect/dist/esm/internal/layer.js
function fromEffectContext(effect) {
  const fromEffect3 = Object.create(proto3);
  fromEffect3._op_layer = OP_FROM_EFFECT;
  fromEffect3.effect = effect;
  return fromEffect3;
}
var LayerSymbolKey = "effect/Layer";
var LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
var layerVariance = {
  _RIn: (_) => _,
  _E: (_) => _,
  _ROut: (_) => _
};
var proto3 = {
  [LayerTypeId]: layerVariance,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var MemoMapTypeIdKey = "effect/Layer/MemoMap";
var MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
var CurrentMemoMap = /* @__PURE__ */ Reference2()("effect/Layer/CurrentMemoMap", {
  defaultValue: () => unsafeMakeMemoMap()
});
var isLayer = (u) => hasProperty(u, LayerTypeId);
var isFresh = (self2) => {
  return self2._op_layer === OP_FRESH;
};

class MemoMapImpl {
  ref;
  [MemoMapTypeId];
  constructor(ref) {
    this.ref = ref;
    this[MemoMapTypeId] = MemoMapTypeId;
  }
  getOrElseMemoize(layer, scope2) {
    return pipe(modifyEffect(this.ref, (map11) => {
      const inMap = map11.get(layer);
      if (inMap !== undefined) {
        const [acquire, release] = inMap;
        const cached3 = pipe(acquire, flatMap7(([patch12, b]) => pipe(patchFiberRefs(patch12), as(b))), onExit(exitMatch({
          onFailure: () => void_,
          onSuccess: () => scopeAddFinalizerExit(scope2, release)
        })));
        return succeed([cached3, map11]);
      }
      return pipe(make27(0), flatMap7((observers) => pipe(deferredMake(), flatMap7((deferred) => pipe(make27(() => void_), map9((finalizerRef) => {
        const resource = uninterruptibleMask((restore) => pipe(scopeMake(), flatMap7((innerScope) => pipe(restore(flatMap7(makeBuilder(layer, innerScope, true), (f) => diffFiberRefs(f(this)))), exit, flatMap7((exit2) => {
          switch (exit2._tag) {
            case OP_FAILURE: {
              return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight(scopeClose(innerScope, exit2)), zipRight(failCause(exit2.effect_instruction_i0)));
            }
            case OP_SUCCESS: {
              return pipe(set6(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify3(observers, (n) => [n === 1, n - 1])), asVoid)), zipRight(update2(observers, (n) => n + 1)), zipRight(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync(() => map11.delete(layer)), zipRight(get11(finalizerRef)), flatMap7((finalizer) => finalizer(exit3))))), zipRight(deferredSucceed(deferred, exit2.effect_instruction_i0)), as(exit2.effect_instruction_i0[1]));
            }
          }
        })))));
        const memoized = [pipe(deferredAwait(deferred), onExit(exitMatchEffect({
          onFailure: () => void_,
          onSuccess: () => update2(observers, (n) => n + 1)
        }))), (exit2) => pipe(get11(finalizerRef), flatMap7((finalizer) => finalizer(exit2)))];
        return [resource, isFresh(layer) ? map11 : map11.set(layer, memoized)];
      }))))));
    }), flatten5);
  }
}
var makeMemoMap = /* @__PURE__ */ suspend(() => map9(makeSynchronized(new Map), (ref) => new MemoMapImpl(ref)));
var unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(new Map));
var build = (self2) => scopeWith((scope2) => buildWithScope(self2, scope2));
var buildWithScope = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap7(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
var buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap7(makeBuilder(self2, scope2), (run) => provideService(run(memoMap), CurrentMemoMap, memoMap)));
var makeBuilder = (self2, scope2, inMemoMap = false) => {
  const op = self2;
  switch (op._op_layer) {
    case "Locally": {
      return sync(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
    }
    case "ExtendScope": {
      return sync(() => (memoMap) => scopeWith((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
    }
    case "Fold": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect({
        onFailure: (cause2) => memoMap.getOrElseMemoize(op.failureK(cause2), scope2),
        onSuccess: (value) => memoMap.getOrElseMemoize(op.successK(value), scope2)
      })));
    }
    case "Fresh": {
      return sync(() => (_) => pipe(op.layer, buildWithScope(scope2)));
    }
    case "FromEffect": {
      return inMemoMap ? sync(() => (_) => op.effect) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Provide": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap7((env) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext(env)))));
    }
    case "Scoped": {
      return inMemoMap ? sync(() => (_) => scopeExtend(op.effect, scope2)) : sync(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
    }
    case "Suspend": {
      return sync(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
    }
    case "ProvideMerge": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith2(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
    }
    case "ZipWith": {
      return sync(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
        concurrent: true
      })));
    }
  }
};
var catchAll2 = /* @__PURE__ */ dual(2, (self2, onFailure) => match11(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var catchAllCause2 = /* @__PURE__ */ dual(2, (self2, onFailure) => matchCause2(self2, {
  onFailure,
  onSuccess: succeedContext
}));
var die5 = (defect) => failCause5(die4(defect));
var dieSync2 = (evaluate2) => failCauseSync2(() => die4(evaluate2()));
var discard = (self2) => map11(self2, () => empty4());
var context2 = () => fromEffectContext(context());
var extendScope = (self2) => {
  const extendScope2 = Object.create(proto3);
  extendScope2._op_layer = OP_EXTEND_SCOPE;
  extendScope2.layer = self2;
  return extendScope2;
};
var fail6 = (error) => failCause5(fail4(error));
var failSync2 = (evaluate2) => failCauseSync2(() => fail4(evaluate2()));
var failCause5 = (cause2) => fromEffectContext(failCause(cause2));
var failCauseSync2 = (evaluate2) => fromEffectContext(failCauseSync(evaluate2));
var flatMap9 = /* @__PURE__ */ dual(2, (self2, f) => match11(self2, {
  onFailure: fail6,
  onSuccess: f
}));
var flatten7 = /* @__PURE__ */ dual(2, (self2, tag) => flatMap9(self2, get3(tag)));
var fresh = (self2) => {
  const fresh2 = Object.create(proto3);
  fresh2._op_layer = OP_FRESH;
  fresh2.layer = self2;
  return fresh2;
};
var fromEffect3 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return fromEffectContext(map9(effect, (service) => make6(tag, service)));
});
var fromEffectDiscard = (effect) => fromEffectContext(map9(effect, () => empty4()));
var fiberRefLocally2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocally(ref, value)));
var locallyEffect = /* @__PURE__ */ dual(2, (self2, f) => {
  const locally = Object.create(proto3);
  locally._op_layer = "Locally";
  locally.self = self2;
  locally.f = f;
  return locally;
});
var fiberRefLocallyWith2 = /* @__PURE__ */ dual(3, (self2, ref, value) => locallyEffect(self2, fiberRefLocallyWith(ref, value)));
var fiberRefLocallyScoped2 = (self2, value) => scopedDiscard(fiberRefLocallyScoped(self2, value));
var fiberRefLocallyScopedWith2 = (self2, value) => scopedDiscard(fiberRefLocallyScopedWith(self2, value));
var fromFunction = (tagA, tagB, f) => fromEffectContext(map9(tagA, (a) => make6(tagB, f(a))));
var launch = (self2) => scopedEffect(zipRight(scopeWith((scope2) => pipe(self2, buildWithScope(scope2))), never));
var mock = function() {
  if (arguments.length === 1) {
    return (service) => mockImpl(arguments[0], service);
  }
  return mockImpl(arguments[0], arguments[1]);
};
var mockImpl = (tag, service) => succeed5(tag, new Proxy({
  ...service
}, {
  get(target, prop, _receiver) {
    if (prop in target) {
      return target[prop];
    }
    const prevLimit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const error = new Error(`${tag.key}: Unimplemented method "${prop.toString()}"`);
    Error.stackTraceLimit = prevLimit;
    error.name = "UnimplementedError";
    return makeUnimplemented(error);
  },
  has: constTrue
}));
var makeUnimplemented = (error) => {
  const dead = die2(error);
  function unimplemented() {
    return dead;
  }
  Object.assign(unimplemented, dead);
  Object.setPrototypeOf(unimplemented, Object.getPrototypeOf(dead));
  return unimplemented;
};
var map11 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (context3) => succeedContext(f(context3))));
var mapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (error) => failSync2(() => f(error))));
var matchCause2 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => {
  const fold = Object.create(proto3);
  fold._op_layer = OP_FOLD;
  fold.layer = self2;
  fold.failureK = onFailure;
  fold.successK = onSuccess;
  return fold;
});
var match11 = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => matchCause2(self2, {
  onFailure: (cause2) => {
    const failureOrCause3 = failureOrCause2(cause2);
    switch (failureOrCause3._tag) {
      case "Left": {
        return onFailure(failureOrCause3.left);
      }
      case "Right": {
        return failCause5(failureOrCause3.right);
      }
    }
  },
  onSuccess
}));
var memoize2 = (self2) => scopeWith((scope2) => map9(memoize(buildWithScope(self2, scope2)), fromEffectContext));
var merge6 = /* @__PURE__ */ dual(2, (self2, that) => zipWith5(self2, that, (a, b) => merge3(a, b)));
var mergeAll4 = (...layers) => {
  let final = layers[0];
  for (let i = 1;i < layers.length; i++) {
    final = merge6(final, layers[i]);
  }
  return final;
};
var orDie2 = (self2) => catchAll2(self2, (defect) => die5(defect));
var orElse4 = /* @__PURE__ */ dual(2, (self2, that) => catchAll2(self2, that));
var passthrough = (self2) => merge6(context2(), self2);
var project = /* @__PURE__ */ dual(4, (self2, tagA, tagB, f) => map11(self2, (context3) => make6(tagB, f(unsafeGet3(context3, tagA)))));
var retry = /* @__PURE__ */ dual(2, (self2, schedule) => suspend2(() => {
  const stateTag = GenericTag("effect/Layer/retry/{ state: unknown }");
  return pipe(succeed5(stateTag, {
    state: schedule.initial
  }), flatMap9((env) => retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state)));
}));
var retryLoop = (self2, schedule, stateTag, state) => {
  return pipe(self2, catchAll2((error) => pipe(retryUpdate(schedule, stateTag, error, state), flatMap9((env) => fresh(retryLoop(self2, schedule, stateTag, pipe(env, get3(stateTag)).state))))));
};
var retryUpdate = (schedule, stateTag, error, state) => {
  return fromEffect3(stateTag, pipe(currentTimeMillis2, flatMap7((now) => pipe(schedule.step(now, error, state), flatMap7(([state2, _, decision]) => isDone4(decision) ? fail2(error) : pipe(sleep2(millis(start2(decision.intervals) - now)), as({
    state: state2
  })))))));
};
var scoped = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const effect = tagFirst ? b : a;
  return scopedContext(map9(effect, (service) => make6(tag, service)));
});
var scopedDiscard = (effect) => scopedContext(pipe(effect, as(empty4())));
var scopedContext = (effect) => {
  const scoped2 = Object.create(proto3);
  scoped2._op_layer = OP_SCOPED;
  scoped2.effect = effect;
  return scoped2;
};
var scope2 = /* @__PURE__ */ scopedContext(/* @__PURE__ */ map9(/* @__PURE__ */ acquireRelease(/* @__PURE__ */ scopeMake(), (scope3, exit2) => scope3.close(exit2)), (scope3) => make6(Scope, scope3)));
var service = (tag) => fromEffect3(tag, tag);
var succeed5 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const resource = tagFirst ? b : a;
  return fromEffectContext(succeed(make6(tag, resource)));
});
var succeedContext = (context3) => {
  return fromEffectContext(succeed(context3));
};
var empty34 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty4());
var suspend2 = (evaluate2) => {
  const suspend3 = Object.create(proto3);
  suspend3._op_layer = OP_SUSPEND;
  suspend3.evaluate = evaluate2;
  return suspend3;
};
var sync2 = /* @__PURE__ */ dual(2, (a, b) => {
  const tagFirst = isTag2(a);
  const tag = tagFirst ? a : b;
  const evaluate2 = tagFirst ? b : a;
  return fromEffectContext(sync(() => make6(tag, evaluate2())));
});
var syncContext = (evaluate2) => {
  return fromEffectContext(sync(evaluate2));
};
var tap2 = /* @__PURE__ */ dual(2, (self2, f) => flatMap9(self2, (context3) => fromEffectContext(as(f(context3), context3))));
var tapError2 = /* @__PURE__ */ dual(2, (self2, f) => catchAll2(self2, (e) => fromEffectContext(flatMap7(f(e), () => fail2(e)))));
var tapErrorCause2 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause2(self2, (cause2) => fromEffectContext(flatMap7(f(cause2), () => failCause(cause2)))));
var toRuntime = (self2) => pipe(scopeWith((scope3) => buildWithScope(self2, scope3)), flatMap7((context3) => pipe(runtime3(), provideContext(context3))));
var toRuntimeWithMemoMap = /* @__PURE__ */ dual(2, (self2, memoMap) => flatMap7(scopeWith((scope3) => buildWithMemoMap(self2, memoMap, scope3)), (context3) => pipe(runtime3(), provideContext(context3))));
var provide = /* @__PURE__ */ dual(2, (self2, that) => suspend2(() => {
  const provideTo = Object.create(proto3);
  provideTo._op_layer = OP_PROVIDE;
  provideTo.first = Object.create(proto3, {
    _op_layer: {
      value: OP_PROVIDE_MERGE,
      enumerable: true
    },
    first: {
      value: context2(),
      enumerable: true
    },
    second: {
      value: Array.isArray(that) ? mergeAll4(...that) : that
    },
    zipK: {
      value: (a, b) => pipe(a, merge3(b))
    }
  });
  provideTo.second = self2;
  return provideTo;
}));
var provideMerge = /* @__PURE__ */ dual(2, (that, self2) => {
  const zipWith5 = Object.create(proto3);
  zipWith5._op_layer = OP_PROVIDE_MERGE;
  zipWith5.first = self2;
  zipWith5.second = provide(that, self2);
  zipWith5.zipK = (a, b) => {
    return pipe(a, merge3(b));
  };
  return zipWith5;
});
var zipWith5 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend2(() => {
  const zipWith6 = Object.create(proto3);
  zipWith6._op_layer = OP_ZIP_WITH2;
  zipWith6.first = self2;
  zipWith6.second = that;
  zipWith6.zipK = f;
  return zipWith6;
}));
var unwrapEffect = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
  return flatMap9(fromEffect3(tag, self2), (context3) => get3(context3, tag));
};
var unwrapScoped = (self2) => {
  const tag = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
  return flatMap9(scoped(tag, self2), (context3) => get3(context3, tag));
};
var annotateLogs2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations2));
});
var annotateSpans2 = /* @__PURE__ */ dual((args2) => isLayer(args2[0]), function() {
  const args2 = arguments;
  return fiberRefLocallyWith2(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set4(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value]) => set4(acc, key, value), annotations2));
});
var withSpan2 = function() {
  const dataFirst = typeof arguments[0] !== "string";
  const name = dataFirst ? arguments[1] : arguments[0];
  const options = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
  if (dataFirst) {
    const self2 = arguments[0];
    return unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
  }
  return (self2) => unwrapScoped(map9(options?.onEnd ? tap(makeSpanScoped(name, options), (span2) => addFinalizer((exit2) => options.onEnd(span2, exit2))) : makeSpanScoped(name, options), (span2) => withParentSpan2(self2, span2)));
};
var withParentSpan2 = /* @__PURE__ */ dual(2, (self2, span2) => provide(self2, succeedContext(make6(spanTag, span2))));
var provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer) => scopedWith((scope3) => flatMap7(buildWithScope(layer, scope3), (context3) => provideSomeContext(self2, context3))));
var provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
  const patchRefs = diff9(defaultRuntime.fiberRefs, rt.fiberRefs);
  const patchFlags = diff7(defaultRuntime.runtimeFlags, rt.runtimeFlags);
  return uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    const oldContext = fiber.getFiberRef(currentContext);
    const oldRefs = fiber.getFiberRefs();
    const newRefs = patch10(fiber.id(), oldRefs)(patchRefs);
    const oldFlags = fiber.currentRuntimeFlags;
    const newFlags = patch7(patchFlags)(oldFlags);
    const rollbackRefs = diff9(newRefs, oldRefs);
    const rollbackFlags = diff7(newFlags, oldFlags);
    fiber.setFiberRefs(newRefs);
    fiber.currentRuntimeFlags = newFlags;
    return ensuring(provideSomeContext(restore(self2), merge3(oldContext, rt.context)), withFiberRuntime((fiber2) => {
      fiber2.setFiberRefs(patch10(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
      fiber2.currentRuntimeFlags = patch7(rollbackFlags)(fiber2.currentRuntimeFlags);
      return void_;
    }));
  }));
});
var effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
  if (Array.isArray(source)) {
    return provideSomeLayer(self2, mergeAll4(...source));
  } else if (isLayer(source)) {
    return provideSomeLayer(self2, source);
  } else if (isContext2(source)) {
    return provideSomeContext(self2, source);
  } else if (TypeId16 in source) {
    return flatMap7(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
  } else {
    return provideSomeRuntime(self2, source);
  }
});

// node_modules/effect/dist/esm/internal/console.js
var console2 = /* @__PURE__ */ map9(/* @__PURE__ */ fiberRefGet(currentServices), /* @__PURE__ */ get3(consoleTag));
var consoleWith = (f) => fiberRefGetWith(currentServices, (services) => f(get3(services, consoleTag)));
var withConsole = /* @__PURE__ */ dual(2, (effect, value) => fiberRefLocallyWith(effect, currentServices, add2(consoleTag, value)));
var withConsoleScoped = (console3) => fiberRefLocallyScopedWith(currentServices, add2(consoleTag, console3));

// node_modules/effect/dist/esm/Data.js
var struct2 = struct;
var array5 = (as3) => unsafeArray(as3.slice(0));
var unsafeArray = (as3) => Object.setPrototypeOf(as3, ArrayProto);
var Class3 = Structural;
var Error3 = /* @__PURE__ */ function() {
  const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
  const O = {
    BaseEffectError: class extends YieldableError {
      constructor(args2) {
        super(args2?.message, args2?.cause ? {
          cause: args2.cause
        } : undefined);
        if (args2) {
          Object.assign(this, args2);
          Object.defineProperty(this, plainArgsSymbol, {
            value: args2,
            enumerable: false
          });
        }
      }
      toJSON() {
        return {
          ...this[plainArgsSymbol],
          ...this
        };
      }
    }
  };
  return O.BaseEffectError;
}();
var TaggedError = (tag) => {
  const O = {
    BaseEffectError: class extends Error3 {
      _tag = tag;
    }
  };
  O.BaseEffectError.prototype.name = tag;
  return O.BaseEffectError;
};

// node_modules/effect/dist/esm/internal/dateTime.js
var TypeId17 = /* @__PURE__ */ Symbol.for("effect/DateTime");
var TimeZoneTypeId = /* @__PURE__ */ Symbol.for("effect/DateTime/TimeZone");
var Proto2 = {
  [TypeId17]: TypeId17,
  pipe() {
    return pipeArguments(this, arguments);
  },
  [NodeInspectSymbol]() {
    return this.toString();
  },
  toJSON() {
    return toDateUtc(this).toJSON();
  }
};
var ProtoUtc = {
  ...Proto2,
  _tag: "Utc",
  [symbol]() {
    return cached(this, number2(this.epochMillis));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Utc" && this.epochMillis === that.epochMillis;
  },
  toString() {
    return `DateTime.Utc(${toDateUtc(this).toJSON()})`;
  }
};
var ProtoZoned = {
  ...Proto2,
  _tag: "Zoned",
  [symbol]() {
    return pipe(number2(this.epochMillis), combine(hash(this.zone)), cached(this));
  },
  [symbol2](that) {
    return isDateTime(that) && that._tag === "Zoned" && this.epochMillis === that.epochMillis && equals(this.zone, that.zone);
  },
  toString() {
    return `DateTime.Zoned(${formatIsoZoned(this)})`;
  }
};
var ProtoTimeZone = {
  [TimeZoneTypeId]: TimeZoneTypeId,
  [NodeInspectSymbol]() {
    return this.toString();
  }
};
var ProtoTimeZoneNamed = {
  ...ProtoTimeZone,
  _tag: "Named",
  [symbol]() {
    return cached(this, string(`Named:${this.id}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Named" && this.id === that.id;
  },
  toString() {
    return `TimeZone.Named(${this.id})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Named",
      id: this.id
    };
  }
};
var ProtoTimeZoneOffset = {
  ...ProtoTimeZone,
  _tag: "Offset",
  [symbol]() {
    return cached(this, string(`Offset:${this.offset}`));
  },
  [symbol2](that) {
    return isTimeZone(that) && that._tag === "Offset" && this.offset === that.offset;
  },
  toString() {
    return `TimeZone.Offset(${offsetToString(this.offset)})`;
  },
  toJSON() {
    return {
      _id: "TimeZone",
      _tag: "Offset",
      offset: this.offset
    };
  }
};
var isDateTime = (u) => hasProperty(u, TypeId17);
var isTimeZone = (u) => hasProperty(u, TimeZoneTypeId);
var minEpochMillis = -8640000000000000 + 12 * 60 * 60 * 1000;
var maxEpochMillis = 8640000000000000 - 14 * 60 * 60 * 1000;
var toDateUtc = (self2) => new Date(self2.epochMillis);
var toDate = (self2) => {
  if (self2._tag === "Utc") {
    return new Date(self2.epochMillis);
  } else if (self2.zone._tag === "Offset") {
    return new Date(self2.epochMillis + self2.zone.offset);
  } else if (self2.adjustedEpochMillis !== undefined) {
    return new Date(self2.adjustedEpochMillis);
  }
  const parts2 = self2.zone.format.formatToParts(self2.epochMillis).filter((_) => _.type !== "literal");
  const date = new Date(0);
  date.setUTCFullYear(Number(parts2[2].value), Number(parts2[0].value) - 1, Number(parts2[1].value));
  date.setUTCHours(Number(parts2[3].value), Number(parts2[4].value), Number(parts2[5].value), Number(parts2[6].value));
  self2.adjustedEpochMillis = date.getTime();
  return date;
};
var zonedOffset = (self2) => {
  const date = toDate(self2);
  return date.getTime() - toEpochMillis(self2);
};
var offsetToString = (offset) => {
  const abs2 = Math.abs(offset);
  let hours2 = Math.floor(abs2 / (60 * 60 * 1000));
  let minutes2 = Math.round(abs2 % (60 * 60 * 1000) / (60 * 1000));
  if (minutes2 === 60) {
    hours2 += 1;
    minutes2 = 0;
  }
  return `${offset < 0 ? "-" : "+"}${String(hours2).padStart(2, "0")}:${String(minutes2).padStart(2, "0")}`;
};
var zonedOffsetIso = (self2) => offsetToString(zonedOffset(self2));
var toEpochMillis = (self2) => self2.epochMillis;
var constDayMillis = 24 * 60 * 60 * 1000;
var formatIsoOffset = (self2) => {
  const date = toDate(self2);
  return self2._tag === "Utc" ? date.toISOString() : `${date.toISOString().slice(0, -1)}${zonedOffsetIso(self2)}`;
};
var formatIsoZoned = (self2) => self2.zone._tag === "Offset" ? formatIsoOffset(self2) : `${formatIsoOffset(self2)}[${self2.zone.id}]`;

// node_modules/effect/dist/esm/String.js
var toUpperCase = (self2) => self2.toUpperCase();
var toLowerCase = (self2) => self2.toLowerCase();
var capitalize = (self2) => {
  if (self2.length === 0)
    return self2;
  return toUpperCase(self2[0]) + self2.slice(1);
};
var uncapitalize = (self2) => {
  if (self2.length === 0)
    return self2;
  return toLowerCase(self2[0]) + self2.slice(1);
};
var split = /* @__PURE__ */ dual(2, (self2, separator) => {
  const out = self2.split(separator);
  return isNonEmptyArray(out) ? out : [self2];
});

// node_modules/effect/dist/esm/Cron.js
var TypeId18 = /* @__PURE__ */ Symbol.for("effect/Cron");
var CronProto = {
  [TypeId18]: TypeId18,
  [symbol2](that) {
    return isCron(that) && equals4(this, that);
  },
  [symbol]() {
    return pipe(hash(this.tz), combine(array2(fromIterable(this.seconds))), combine(array2(fromIterable(this.minutes))), combine(array2(fromIterable(this.hours))), combine(array2(fromIterable(this.days))), combine(array2(fromIterable(this.months))), combine(array2(fromIterable(this.weekdays))), cached(this));
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Cron",
      tz: this.tz,
      seconds: fromIterable(this.seconds),
      minutes: fromIterable(this.minutes),
      hours: fromIterable(this.hours),
      days: fromIterable(this.days),
      months: fromIterable(this.months),
      weekdays: fromIterable(this.weekdays)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isCron = (u) => hasProperty(u, TypeId18);
var Equivalence3 = /* @__PURE__ */ make((self2, that) => restrictionsEquals(self2.seconds, that.seconds) && restrictionsEquals(self2.minutes, that.minutes) && restrictionsEquals(self2.hours, that.hours) && restrictionsEquals(self2.days, that.days) && restrictionsEquals(self2.months, that.months) && restrictionsEquals(self2.weekdays, that.weekdays));
var restrictionsArrayEquals = /* @__PURE__ */ array(number);
var restrictionsEquals = (self2, that) => restrictionsArrayEquals(fromIterable(self2), fromIterable(that));
var equals4 = /* @__PURE__ */ dual(2, (self2, that) => Equivalence3(self2, that));

// node_modules/effect/dist/esm/Random.js
var fixed2 = fixed;

// node_modules/effect/dist/esm/internal/schedule.js
var ScheduleSymbolKey = "effect/Schedule";
var ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
var isSchedule = (u) => hasProperty(u, ScheduleTypeId);
var ScheduleDriverSymbolKey = "effect/ScheduleDriver";
var ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
var defaultIterationMetadata = {
  start: 0,
  now: 0,
  input: undefined,
  output: undefined,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  recurrence: 0
};
var CurrentIterationMetadata = /* @__PURE__ */ Reference2()("effect/Schedule/CurrentIterationMetadata", {
  defaultValue: () => defaultIterationMetadata
});
var scheduleVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};
var scheduleDriverVariance = {
  _Out: (_) => _,
  _In: (_) => _,
  _R: (_) => _
};

class ScheduleImpl {
  initial;
  step;
  [ScheduleTypeId] = scheduleVariance;
  constructor(initial, step3) {
    this.initial = initial;
    this.step = step3;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var updateInfo = (iterationMetaRef, now, input, output) => update2(iterationMetaRef, (prev) => prev.recurrence === 0 ? {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: zero2,
  elapsedSincePrevious: zero2,
  start: now
} : {
  now,
  input,
  output,
  recurrence: prev.recurrence + 1,
  elapsed: millis(now - prev.start),
  elapsedSincePrevious: millis(now - prev.now),
  start: prev.start
});

class ScheduleDriverImpl {
  schedule;
  ref;
  [ScheduleDriverTypeId] = scheduleDriverVariance;
  constructor(schedule, ref) {
    this.schedule = schedule;
    this.ref = ref;
  }
  get state() {
    return map9(get11(this.ref), (tuple3) => tuple3[1]);
  }
  get last() {
    return flatMap7(get11(this.ref), ([element, _]) => {
      switch (element._tag) {
        case "None": {
          return failSync(() => new NoSuchElementException);
        }
        case "Some": {
          return succeed(element.value);
        }
      }
    });
  }
  iterationMeta = /* @__PURE__ */ unsafeMake6(defaultIterationMetadata);
  get reset() {
    return set6(this.ref, [none2(), this.schedule.initial]).pipe(zipLeft(set6(this.iterationMeta, defaultIterationMetadata)));
  }
  next(input) {
    return pipe(map9(get11(this.ref), (tuple3) => tuple3[1]), flatMap7((state) => pipe(currentTimeMillis2, flatMap7((now) => pipe(suspend(() => this.schedule.step(now, input, state)), flatMap7(([state2, out, decision]) => {
      const setState = set6(this.ref, [some2(out), state2]);
      if (isDone4(decision)) {
        return setState.pipe(zipRight(fail2(none2())));
      }
      const millis2 = start2(decision.intervals) - now;
      if (millis2 <= 0) {
        return setState.pipe(zipRight(updateInfo(this.iterationMeta, now, input, out)), as(out));
      }
      const duration = millis(millis2);
      return pipe(setState, zipRight(updateInfo(this.iterationMeta, now, input, out)), zipRight(sleep3(duration)), as(out));
    }))))));
  }
}
var makeWithState = (initial, step3) => new ScheduleImpl(initial, step3);
var asVoid2 = (self2) => map12(self2, constVoid);
var check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync(() => test(input, out))));
var checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state) => flatMap7(self2.step(now, input, state), ([state2, out, decision]) => {
  if (isDone4(decision)) {
    return succeed([state2, out, done6]);
  }
  return map9(test(input, out), (cont) => cont ? [state2, out, decision] : [state2, out, done6]);
})));
var driver = (self2) => pipe(make27([none2(), self2.initial]), map9((ref) => new ScheduleDriverImpl(self2, ref)));
var intersect5 = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect4));
var intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state) => pipe(zipWith2(self2.step(now, input, state[0]), that.step(now, input, state[1]), (a, b) => [a, b]), flatMap7(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
  if (isContinue2(lDecision) && isContinue2(rDecision)) {
    return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
  }
  return succeed([[lState, rState], [out, out2], done6]);
}))));
var intersectWithLoop = (self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
  const combined = f(lInterval, rInterval);
  if (isNonEmpty5(combined)) {
    return succeed([[lState, rState], [out, out2], _continue2(combined)]);
  }
  if (pipe(lInterval, lessThan7(rInterval))) {
    return flatMap7(self2.step(end2(lInterval), input, lState), ([lState2, out3, decision]) => {
      if (isDone4(decision)) {
        return succeed([[lState2, rState], [out3, out2], done6]);
      }
      return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
    });
  }
  return flatMap7(that.step(end2(rInterval), input, rState), ([rState2, out22, decision]) => {
    if (isDone4(decision)) {
      return succeed([[lState, rState2], [out, out22], done6]);
    }
    return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
  });
};
var map12 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect2(self2, (out) => sync(() => f(out))));
var mapEffect2 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state) => flatMap7(self2.step(now, input, state), ([state2, out, decision]) => map9(f(out), (out2) => [state2, out2, decision]))));
var passthrough2 = (self2) => makeWithState(self2.initial, (now, input, state) => pipe(self2.step(now, input, state), map9(([state2, _, decision]) => [state2, input, decision])));
var recurs = (n) => whileOutput(forever2, (out) => out < n);
var unfold2 = (initial, f) => makeWithState(initial, (now, _, state) => sync(() => [f(state), state, continueWith2(after2(now))]));
var untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
var whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
var whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
var ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");

class ScheduleDefect {
  error;
  [ScheduleDefectTypeId];
  constructor(error) {
    this.error = error;
    this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
  }
}
var isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
var scheduleDefectWrap = (self2) => catchAll(self2, (e) => die2(new ScheduleDefect(e)));
var scheduleDefectRefailCause = (cause2) => match2(find(cause2, (_) => isDieType(_) && isScheduleDefect(_.defect) ? some2(_.defect) : none2()), {
  onNone: () => cause2,
  onSome: (error) => fail(error.error)
});
var scheduleDefectRefail = (effect) => catchAllCause(effect, (cause2) => failCause(scheduleDefectRefailCause(cause2)));
var repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _) => fail2(e)));
var repeat_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return repeat_Effect(self2, options);
  }
  const base = options.schedule ?? passthrough2(forever2);
  const withWhile = options.while ? whileInputEffect(base, (a) => {
    const applied = options.while(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (a) => {
    const applied = options.until(a);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  const withTimes = options.times ? intersect5(withUntil, recurs(options.times)).pipe(map12((intersectionPair) => intersectionPair[0])) : withUntil;
  return scheduleDefectRefail(repeat_Effect(self2, withTimes));
});
var repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse5) => flatMap7(driver(schedule), (driver2) => matchEffect(self2, {
  onFailure: (error) => orElse5(error, none2()),
  onSuccess: (value) => repeatOrElseEffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (error, option2) => provideServiceEffect(orElse5(error, option2), CurrentIterationMetadata, get11(driver2.iterationMeta)), value)
})));
var repeatOrElseEffectLoop = (self2, driver2, orElse5, value) => matchEffect(driver2.next(value), {
  onFailure: () => orDie(driver2.last),
  onSuccess: (b) => matchEffect(self2, {
    onFailure: (error) => orElse5(error, some2(b)),
    onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse5, value2)
  })
});
var retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail2(e)));
var retry_combined = /* @__PURE__ */ dual(2, (self2, options) => {
  if (isSchedule(options)) {
    return retry_Effect(self2, options);
  }
  return scheduleDefectRefail(retry_Effect(self2, fromRetryOptions(options)));
});
var fromRetryOptions = (options) => {
  const base = options.schedule ?? forever2;
  const withWhile = options.while ? whileInputEffect(base, (e) => {
    const applied = options.while(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : base;
  const withUntil = options.until ? untilInputEffect(withWhile, (e) => {
    const applied = options.until(e);
    if (typeof applied === "boolean") {
      return succeed(applied);
    }
    return scheduleDefectWrap(applied);
  }) : withWhile;
  return options.times ? intersect5(withUntil, recurs(options.times)) : withUntil;
};
var retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse5) => flatMap7(driver(policy), (driver2) => retryOrElse_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), driver2, (e, out) => provideServiceEffect(orElse5(e, out), CurrentIterationMetadata, get11(driver2.iterationMeta)))));
var retryOrElse_EffectLoop = (self2, driver2, orElse5) => {
  return catchAll(self2, (e) => matchEffect(driver2.next(e), {
    onFailure: () => pipe(driver2.last, orDie, flatMap7((out) => orElse5(e, out))),
    onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse5)
  }));
};
var schedule_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => scheduleFrom_Effect(self2, undefined, schedule));
var scheduleFrom_Effect = /* @__PURE__ */ dual(3, (self2, initial, schedule) => flatMap7(driver(schedule), (driver2) => scheduleFrom_EffectLoop(provideServiceEffect(self2, CurrentIterationMetadata, get11(driver2.iterationMeta)), initial, driver2)));
var scheduleFrom_EffectLoop = (self2, initial, driver2) => matchEffect(driver2.next(initial), {
  onFailure: () => orDie(driver2.last),
  onSuccess: () => flatMap7(self2, (a) => scheduleFrom_EffectLoop(self2, a, driver2))
});
var forever2 = /* @__PURE__ */ unfold2(0, (n) => n + 1);
var once2 = /* @__PURE__ */ asVoid2(/* @__PURE__ */ recurs(1));
var scheduleForked = /* @__PURE__ */ dual(2, (self2, schedule) => forkScoped(schedule_Effect(self2, schedule)));

// node_modules/effect/dist/esm/internal/executionPlan.js
var TypeId19 = /* @__PURE__ */ Symbol.for("effect/ExecutionPlan");
var withExecutionPlan = /* @__PURE__ */ dual(2, (effect, plan) => suspend(() => {
  let i = 0;
  let result;
  return flatMap7(whileLoop({
    while: () => i < plan.steps.length && (result === undefined || isLeft2(result)),
    body: () => {
      const step3 = plan.steps[i];
      let nextEffect = effect_provide(effect, step3.provide);
      if (result) {
        let attempted = false;
        const wrapped = nextEffect;
        nextEffect = suspend(() => {
          if (attempted)
            return wrapped;
          attempted = true;
          return result;
        });
        nextEffect = scheduleDefectRefail(retry_Effect(nextEffect, scheduleFromStep(step3, false)));
      } else {
        const schedule = scheduleFromStep(step3, true);
        nextEffect = schedule ? scheduleDefectRefail(retry_Effect(nextEffect, schedule)) : nextEffect;
      }
      return either2(nextEffect);
    },
    step: (either3) => {
      result = either3;
      i++;
    }
  }), () => result);
}));
var scheduleFromStep = (step3, first2) => {
  if (!first2) {
    return fromRetryOptions({
      schedule: step3.schedule ? step3.schedule : step3.attempts ? undefined : once2,
      times: step3.attempts,
      while: step3.while
    });
  } else if (step3.attempts === 1 || !(step3.schedule || step3.attempts)) {
    return;
  }
  return fromRetryOptions({
    schedule: step3.schedule,
    while: step3.while,
    times: step3.attempts ? step3.attempts - 1 : undefined
  });
};

// node_modules/effect/dist/esm/internal/query.js
var currentCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCache"), () => fiberRefUnsafeMake(unsafeMakeWith(65536, () => map9(deferredMake(), (handle) => ({
  listeners: new Listeners,
  handle
})), () => seconds(60))));
var currentCacheEnabled = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentCacheEnabled"), () => fiberRefUnsafeMake(false));
var fromRequest = (request, dataSource) => flatMap7(isEffect(dataSource) ? dataSource : succeed(dataSource), (ds) => fiberIdWith((id2) => {
  const proxy = new Proxy(request, {});
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      const cached3 = fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(proxy), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            if (orNew.left.listeners.interrupted) {
              return flatMap7(cache.invalidateWhen(proxy, (entry) => entry.handle === orNew.left.handle), () => cached3);
            }
            orNew.left.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(empty19, restore(deferredAwait(orNew.left.handle)))), (exit2) => {
              orNew.left.listeners.decrement();
              return exit2;
            }));
          }
          case "Right": {
            orNew.right.listeners.increment();
            return uninterruptibleMask((restore) => flatMap7(exit(blocked(single(ds, makeEntry({
              request: proxy,
              result: orNew.right.handle,
              listeners: orNew.right.listeners,
              ownerId: id2,
              state: {
                completed: false
              }
            })), restore(deferredAwait(orNew.right.handle)))), () => {
              orNew.right.listeners.decrement();
              return deferredAwait(orNew.right.handle);
            }));
          }
        }
      }));
      return cached3;
    }
    const listeners = new Listeners;
    listeners.increment();
    return flatMap7(deferredMake(), (ref) => ensuring(blocked(single(ds, makeEntry({
      request: proxy,
      result: ref,
      listeners,
      ownerId: id2,
      state: {
        completed: false
      }
    })), deferredAwait(ref)), sync(() => listeners.decrement())));
  });
}));
var cacheRequest = (request, result) => {
  return fiberRefGetWith(currentCacheEnabled, (cacheEnabled) => {
    if (cacheEnabled) {
      return fiberRefGetWith(currentCache, (cache) => flatMap7(cache.getEither(request), (orNew) => {
        switch (orNew._tag) {
          case "Left": {
            return void_;
          }
          case "Right": {
            return deferredComplete(orNew.right.handle, result);
          }
        }
      }));
    }
    return void_;
  });
};
var withRequestCaching = /* @__PURE__ */ dual(2, (self2, strategy) => fiberRefLocally(self2, currentCacheEnabled, strategy));
var withRequestCache = /* @__PURE__ */ dual(2, (self2, cache) => fiberRefLocally(self2, currentCache, cache));

// node_modules/effect/dist/esm/Request.js
var isRequest2 = isRequest;
var Class4 = Class2;

// node_modules/effect/dist/esm/Effect.js
function defineLength(length2, fn) {
  return Object.defineProperty(fn, "length", {
    value: length2,
    configurable: true
  });
}
function fnApply(options) {
  let effect;
  let fnError = undefined;
  if (isGeneratorFunction(options.body)) {
    effect = fromIterator(() => options.body.apply(options.self, options.args));
  } else {
    try {
      effect = options.body.apply(options.self, options.args);
    } catch (error) {
      fnError = error;
      effect = die6(error);
    }
  }
  if (options.pipeables.length > 0) {
    try {
      for (const x of options.pipeables) {
        effect = x(effect, ...options.args);
      }
    } catch (error) {
      effect = fnError ? failCause7(sequential(die(fnError), die(error))) : die6(error);
    }
  }
  let cache = false;
  const captureStackTrace = () => {
    if (cache !== false) {
      return cache;
    }
    if (options.errorCall.stack) {
      const stackDef = options.errorDef.stack.trim().split("\n");
      const stackCall = options.errorCall.stack.trim().split("\n");
      let endStackDef = stackDef.slice(2).join("\n").trim();
      if (!endStackDef.includes(`(`)) {
        endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
      }
      let endStackCall = stackCall.slice(2).join("\n").trim();
      if (!endStackCall.includes(`(`)) {
        endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
      }
      cache = `${endStackDef}\n${endStackCall}`;
      return cache;
    }
  };
  const opts = options.spanOptions && "captureStackTrace" in options.spanOptions ? options.spanOptions : {
    captureStackTrace,
    ...options.spanOptions
  };
  return withSpan3(effect, options.spanName, opts);
}
var EffectTypeId3 = EffectTypeId2;
var isEffect2 = isEffect;
var cachedWithTTL = cached2;
var cachedInvalidateWithTTL2 = cachedInvalidateWithTTL;
var cached3 = memoize;
var cachedFunction2 = cachedFunction;
var once3 = once;
var all4 = all2;
var allWith2 = allWith;
var allSuccesses2 = allSuccesses;
var dropUntil2 = dropUntil;
var dropWhile2 = dropWhile;
var takeUntil2 = takeUntil;
var takeWhile2 = takeWhile;
var every7 = every5;
var exists3 = exists2;
var filter7 = filter5;
var filterMap5 = filterMap4;
var findFirst6 = findFirst4;
var forEach8 = forEach7;
var head4 = head3;
var mergeAll5 = mergeAll3;
var partition4 = partition3;
var reduce12 = reduce10;
var reduceWhile2 = reduceWhile;
var reduceRight3 = reduceRight2;
var reduceEffect2 = reduceEffect;
var replicate2 = replicate;
var replicateEffect2 = replicateEffect;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var async = async_;
var asyncEffect2 = asyncEffect;
var custom2 = custom;
var withFiberRuntime2 = withFiberRuntime;
var fail8 = fail2;
var failSync3 = failSync;
var failCause7 = failCause;
var failCauseSync3 = failCauseSync;
var die6 = die2;
var dieMessage2 = dieMessage;
var dieSync3 = dieSync;
var gen2 = gen;
var never3 = never;
var none9 = none6;
var promise2 = promise;
var succeed7 = succeed;
var succeedNone2 = succeedNone;
var succeedSome2 = succeedSome;
var suspend3 = suspend;
var sync3 = sync;
var _void = void_;
var yieldNow4 = yieldNow;
var _catch2 = _catch;
var catchAll3 = catchAll;
var catchAllCause3 = catchAllCause;
var catchAllDefect2 = catchAllDefect;
var catchIf2 = catchIf;
var catchSome2 = catchSome;
var catchSomeCause2 = catchSomeCause;
var catchSomeDefect2 = catchSomeDefect;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var cause2 = cause;
var eventually2 = eventually;
var ignore2 = ignore;
var ignoreLogged2 = ignoreLogged;
var parallelErrors2 = parallelErrors;
var sandbox2 = sandbox;
var retry2 = retry_combined;
var withExecutionPlan2 = withExecutionPlan;
var retryOrElse = retryOrElse_Effect;
var try_3 = try_2;
var tryMap2 = tryMap;
var tryMapPromise2 = tryMapPromise;
var tryPromise2 = tryPromise;
var unsandbox2 = unsandbox;
var allowInterrupt2 = allowInterrupt;
var checkInterruptible2 = checkInterruptible;
var disconnect2 = disconnect;
var interrupt6 = interrupt2;
var interruptWith2 = interruptWith;
var interruptible4 = interruptible2;
var interruptibleMask2 = interruptibleMask;
var onInterrupt2 = onInterrupt;
var uninterruptible2 = uninterruptible;
var uninterruptibleMask3 = uninterruptibleMask;
var liftPredicate2 = liftPredicate;
var as3 = as;
var asSome2 = asSome;
var asSomeError2 = asSomeError;
var asVoid3 = asVoid;
var flip2 = flip;
var flipWith2 = flipWith;
var map13 = map9;
var mapAccum3 = mapAccum2;
var mapBoth2 = mapBoth;
var mapError3 = mapError;
var mapErrorCause2 = mapErrorCause;
var merge7 = merge5;
var negate2 = negate;
var acquireRelease2 = acquireRelease;
var acquireReleaseInterruptible2 = acquireReleaseInterruptible;
var acquireUseRelease2 = acquireUseRelease;
var addFinalizer2 = addFinalizer;
var ensuring2 = ensuring;
var onError2 = onError;
var onExit3 = onExit;
var parallelFinalizers2 = parallelFinalizers;
var sequentialFinalizers2 = sequentialFinalizers;
var finalizersMask2 = finalizersMask;
var scope3 = scope;
var scopeWith2 = scopeWith;
var scopedWith2 = scopedWith;
var scoped2 = scopedEffect;
var using2 = using;
var withEarlyRelease2 = withEarlyRelease;
var awaitAllChildren2 = awaitAllChildren;
var daemonChildren2 = daemonChildren;
var descriptor2 = descriptor;
var descriptorWith2 = descriptorWith;
var diffFiberRefs2 = diffFiberRefs;
var ensuringChild2 = ensuringChild;
var ensuringChildren2 = ensuringChildren;
var fiberId2 = fiberId;
var fiberIdWith2 = fiberIdWith;
var fork3 = fork;
var forkDaemon2 = forkDaemon;
var forkAll2 = forkAll;
var forkIn2 = forkIn;
var forkScoped2 = forkScoped;
var forkWithErrorHandler2 = forkWithErrorHandler;
var fromFiber2 = fromFiber;
var fromFiberEffect2 = fromFiberEffect;
var supervised2 = supervised;
var transplant2 = transplant;
var withConcurrency2 = withConcurrency;
var withScheduler2 = withScheduler;
var withSchedulingPriority2 = withSchedulingPriority;
var withMaxOpsBeforeYield2 = withMaxOpsBeforeYield;
var clock2 = clock;
var clockWith4 = clockWith3;
var withClockScoped2 = withClockScoped;
var withClock2 = withClock;
var console3 = console2;
var consoleWith2 = consoleWith;
var withConsoleScoped2 = withConsoleScoped;
var withConsole2 = withConsole;
var delay2 = delay;
var sleep4 = sleep3;
var timed2 = timed;
var timedWith2 = timedWith;
var timeout2 = timeout;
var timeoutOption2 = timeoutOption;
var timeoutFail2 = timeoutFail;
var timeoutFailCause2 = timeoutFailCause;
var timeoutTo2 = timeoutTo;
var configProviderWith2 = configProviderWith;
var withConfigProvider2 = withConfigProvider;
var withConfigProviderScoped2 = withConfigProviderScoped;
var context3 = context;
var contextWith2 = contextWith;
var contextWithEffect2 = contextWithEffect;
var mapInputContext2 = mapInputContext;
var provide2 = effect_provide;
var provideService2 = provideService;
var provideServiceEffect2 = provideServiceEffect;
var serviceFunction2 = serviceFunction;
var serviceFunctionEffect2 = serviceFunctionEffect;
var serviceFunctions2 = serviceFunctions;
var serviceConstants2 = serviceConstants;
var serviceMembers2 = serviceMembers;
var serviceOption2 = serviceOption;
var serviceOptional2 = serviceOptional;
var updateService2 = updateService;
var Do2 = Do;
var bind3 = bind2;
var bindAll2 = bindAll;
var bindTo3 = bindTo2;
var let_3 = let_2;
var option2 = option;
var either3 = either2;
var exit2 = exit;
var intoDeferred2 = intoDeferred;
var if_2 = if_;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail2 = filterOrFail;
var filterEffectOrElse2 = filterEffectOrElse;
var filterEffectOrFail2 = filterEffectOrFail;
var unless2 = unless;
var unlessEffect2 = unlessEffect;
var when2 = when;
var whenEffect2 = whenEffect;
var whenFiberRef2 = whenFiberRef;
var whenRef2 = whenRef;
var flatMap10 = flatMap7;
var andThen4 = andThen2;
var flatten8 = flatten5;
var race2 = race;
var raceAll2 = raceAll;
var raceFirst2 = raceFirst;
var raceWith2 = raceWith;
var summarized2 = summarized;
var tap3 = tap;
var tapBoth2 = tapBoth;
var tapDefect2 = tapDefect;
var tapError3 = tapError;
var tapErrorTag2 = tapErrorTag;
var tapErrorCause3 = tapErrorCause;
var forever3 = forever;
var iterate2 = iterate;
var loop2 = loop;
var repeat = repeat_combined;
var repeatN2 = repeatN;
var repeatOrElse = repeatOrElse_Effect;
var schedule = schedule_Effect;
var scheduleForked2 = scheduleForked;
var scheduleFrom = scheduleFrom_Effect;
var whileLoop2 = whileLoop;
var getFiberRefs = fiberRefs2;
var inheritFiberRefs2 = inheritFiberRefs;
var locally = fiberRefLocally;
var locallyWith = fiberRefLocallyWith;
var locallyScoped = fiberRefLocallyScoped;
var locallyScopedWith = fiberRefLocallyScopedWith;
var patchFiberRefs2 = patchFiberRefs;
var setFiberRefs2 = setFiberRefs;
var updateFiberRefs2 = updateFiberRefs;
var isFailure3 = isFailure;
var isSuccess3 = isSuccess2;
var match13 = match7;
var matchCause3 = matchCause;
var matchCauseEffect3 = matchCauseEffect;
var matchEffect2 = matchEffect;
var log2 = log;
var logWithLevel2 = (level, ...message) => logWithLevel(level)(...message);
var logTrace2 = logTrace;
var logDebug2 = logDebug;
var logInfo2 = logInfo;
var logWarning2 = logWarning;
var logError2 = logError;
var logFatal2 = logFatal;
var withLogSpan2 = withLogSpan;
var annotateLogs3 = annotateLogs;
var annotateLogsScoped2 = annotateLogsScoped;
var logAnnotations2 = logAnnotations;
var withUnhandledErrorLogLevel2 = withUnhandledErrorLogLevel;
var whenLogLevel2 = whenLogLevel;
var orDie3 = orDie;
var orDieWith2 = orDieWith;
var orElse5 = orElse2;
var orElseFail2 = orElseFail;
var orElseSucceed2 = orElseSucceed;
var firstSuccessOf2 = firstSuccessOf;
var random3 = random2;
var randomWith2 = randomWith;
var withRandom2 = withRandom;
var withRandomFixed = /* @__PURE__ */ dual(2, (effect, values4) => withRandom2(effect, fixed2(values4)));
var withRandomScoped2 = withRandomScoped;
var runtime4 = runtime3;
var getRuntimeFlags = runtimeFlags;
var patchRuntimeFlags = updateRuntimeFlags;
var withRuntimeFlagsPatch = withRuntimeFlags;
var withRuntimeFlagsPatchScoped = withRuntimeFlagsScoped;
var tagMetrics2 = tagMetrics;
var labelMetrics2 = labelMetrics;
var tagMetricsScoped2 = tagMetricsScoped;
var labelMetricsScoped2 = labelMetricsScoped;
var metricLabels2 = metricLabels;
var withMetric2 = withMetric;
var unsafeMakeSemaphore2 = unsafeMakeSemaphore;
var makeSemaphore2 = makeSemaphore;
var unsafeMakeLatch2 = unsafeMakeLatch;
var makeLatch2 = makeLatch;
var runFork2 = unsafeForkEffect;
var runCallback = unsafeRunEffect;
var runPromise = unsafeRunPromiseEffect;
var runPromiseExit = unsafeRunPromiseExitEffect;
var runSync = unsafeRunSyncEffect;
var runSyncExit = unsafeRunSyncExitEffect;
var validate2 = validate;
var validateWith2 = validateWith;
var zip4 = zipOptions;
var zipLeft2 = zipLeftOptions;
var zipRight2 = zipRightOptions;
var zipWith6 = zipWithOptions;
var ap = /* @__PURE__ */ dual(2, (self2, that) => zipWith6(self2, that, (f, a) => f(a)));
var blocked2 = blocked;
var runRequestBlock2 = runRequestBlock;
var step3 = step2;
var request = /* @__PURE__ */ dual((args2) => isRequest2(args2[0]), fromRequest);
var cacheRequestResult = cacheRequest;
var withRequestBatching2 = withRequestBatching;
var withRequestCaching2 = withRequestCaching;
var withRequestCache2 = withRequestCache;
var tracer2 = tracer;
var tracerWith4 = tracerWith;
var withTracer2 = withTracer;
var withTracerScoped2 = withTracerScoped;
var withTracerEnabled2 = withTracerEnabled;
var withTracerTiming2 = withTracerTiming;
var annotateSpans3 = annotateSpans;
var annotateCurrentSpan2 = annotateCurrentSpan;
var currentSpan2 = currentSpan;
var currentParentSpan2 = currentParentSpan;
var spanAnnotations2 = spanAnnotations;
var spanLinks2 = spanLinks;
var linkSpans2 = linkSpans;
var linkSpanCurrent2 = linkSpanCurrent;
var makeSpan2 = makeSpan;
var makeSpanScoped2 = makeSpanScoped;
var useSpan2 = useSpan;
var withSpan3 = withSpan;
var functionWithSpan2 = functionWithSpan;
var withSpanScoped2 = withSpanScoped;
var withParentSpan3 = withParentSpan;
var fromNullable3 = fromNullable2;
var optionFromOptional2 = optionFromOptional;
var transposeOption = (self2) => {
  return isNone(self2) ? succeedNone2 : map13(self2.value, some);
};
var transposeMapOption = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? succeedNone2 : map13(f(self2.value), some));
var makeTagProxy = (TagClass) => {
  const cache = new Map;
  return new Proxy(TagClass, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      }
      if (cache.has(prop)) {
        return cache.get(prop);
      }
      const fn = (...args2) => andThen2(target, (s) => {
        if (typeof s[prop] === "function") {
          cache.set(prop, (...args3) => andThen2(target, (s2) => s2[prop](...args3)));
          return s[prop](...args2);
        }
        cache.set(prop, andThen2(target, (s2) => s2[prop]));
        return s[prop];
      });
      const cn = andThen2(target, (s) => s[prop]);
      Object.assign(fn, cn);
      const apply = fn.apply;
      const bind4 = fn.bind;
      const call = fn.call;
      const proto4 = Object.setPrototypeOf({}, Object.getPrototypeOf(cn));
      proto4.apply = apply;
      proto4.bind = bind4;
      proto4.call = call;
      Object.setPrototypeOf(fn, proto4);
      cache.set(prop, fn);
      return fn;
    }
  });
};
var Tag3 = (id2) => () => {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const creationError = new Error;
  Error.stackTraceLimit = limit;
  function TagClass() {
  }
  Object.setPrototypeOf(TagClass, TagProto);
  TagClass.key = id2;
  Object.defineProperty(TagClass, "use", {
    get() {
      return (body) => andThen2(this, body);
    }
  });
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  return makeTagProxy(TagClass);
};
var Service = function() {
  return function() {
    const [id2, maker] = arguments;
    const proxy = "accessors" in maker ? maker["accessors"] : false;
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error;
    Error.stackTraceLimit = limit;
    let patchState = "unchecked";
    const TagClass = function(service2) {
      if (patchState === "unchecked") {
        const proto4 = Object.getPrototypeOf(service2);
        if (proto4 === Object.prototype || proto4 === null) {
          patchState = "plain";
        } else {
          const selfProto = Object.getPrototypeOf(this);
          Object.setPrototypeOf(selfProto, proto4);
          patchState = "patched";
        }
      }
      if (patchState === "plain") {
        Object.assign(this, service2);
      } else if (patchState === "patched") {
        Object.setPrototypeOf(service2, Object.getPrototypeOf(this));
        return service2;
      }
    };
    TagClass.prototype._tag = id2;
    Object.defineProperty(TagClass, "make", {
      get() {
        return (service2) => new this(service2);
      }
    });
    Object.defineProperty(TagClass, "use", {
      get() {
        return (body) => andThen2(this, body);
      }
    });
    TagClass.key = id2;
    Object.assign(TagClass, TagProto);
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    const hasDeps = "dependencies" in maker && maker.dependencies.length > 0;
    const layerName = hasDeps ? "DefaultWithoutDependencies" : "Default";
    let layerCache;
    let isFunction3 = false;
    if ("effect" in maker) {
      isFunction3 = typeof maker.effect === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return fromEffect3(TagClass, map13(maker.effect.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= fromEffect3(TagClass, map13(maker.effect, (_) => new this(_)));
        }
      });
    } else if ("scoped" in maker) {
      isFunction3 = typeof maker.scoped === "function";
      Object.defineProperty(TagClass, layerName, {
        get() {
          if (isFunction3) {
            return function() {
              return scoped(TagClass, map13(maker.scoped.apply(null, arguments), (_) => new this(_)));
            }.bind(this);
          }
          return layerCache ??= scoped(TagClass, map13(maker.scoped, (_) => new this(_)));
        }
      });
    } else if ("sync" in maker) {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= sync2(TagClass, () => new this(maker.sync()));
        }
      });
    } else {
      Object.defineProperty(TagClass, layerName, {
        get() {
          return layerCache ??= succeed5(TagClass, new this(maker.succeed));
        }
      });
    }
    if (hasDeps) {
      let layerWithDepsCache;
      Object.defineProperty(TagClass, "Default", {
        get() {
          if (isFunction3) {
            return function() {
              return provide(this.DefaultWithoutDependencies.apply(null, arguments), maker.dependencies);
            };
          }
          return layerWithDepsCache ??= provide(this.DefaultWithoutDependencies, maker.dependencies);
        }
      });
    }
    return proxy === true ? makeTagProxy(TagClass) : TagClass;
  };
};
var fn = function(nameOrBody, ...pipeables) {
  const limit = Error.stackTraceLimit;
  Error.stackTraceLimit = 2;
  const errorDef = new Error;
  Error.stackTraceLimit = limit;
  if (typeof nameOrBody !== "string") {
    return defineLength(nameOrBody.length, function(...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body: nameOrBody,
        args: args2,
        pipeables,
        spanName: "<anonymous>",
        spanOptions: {
          context: DisablePropagation.context(true)
        },
        errorDef,
        errorCall
      });
    });
  }
  const name = nameOrBody;
  const options = pipeables[0];
  return (body, ...pipeables2) => defineLength(body.length, {
    [name](...args2) {
      const limit2 = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      const errorCall = new Error;
      Error.stackTraceLimit = limit2;
      return fnApply({
        self: this,
        body,
        args: args2,
        pipeables: pipeables2,
        spanName: name,
        spanOptions: options,
        errorDef,
        errorCall
      });
    }
  }[name]);
};
var fnUntraced2 = fnUntraced;
var ensureSuccessType = () => (effect) => effect;
var ensureErrorType = () => (effect) => effect;
var ensureRequirementsType = () => (effect) => effect;

// node_modules/effect/dist/esm/FiberRef.js
var currentContext2 = currentContext;
var currentSchedulingPriority2 = currentSchedulingPriority;
var currentScheduler2 = currentScheduler;

// node_modules/effect/dist/esm/Layer.js
var exports_Layer = {};
__export(exports_Layer, {
  zipWith: () => zipWith7,
  withSpan: () => withSpan4,
  withParentSpan: () => withParentSpan4,
  updateService: () => updateService3,
  unwrapScoped: () => unwrapScoped2,
  unwrapEffect: () => unwrapEffect2,
  toRuntimeWithMemoMap: () => toRuntimeWithMemoMap2,
  toRuntime: () => toRuntime2,
  tapErrorCause: () => tapErrorCause4,
  tapError: () => tapError4,
  tap: () => tap4,
  syncContext: () => syncContext2,
  sync: () => sync4,
  suspend: () => suspend4,
  succeedContext: () => succeedContext2,
  succeed: () => succeed8,
  span: () => span3,
  setVersionMismatchErrorLogLevel: () => setVersionMismatchErrorLogLevel,
  setUnhandledErrorLogLevel: () => setUnhandledErrorLogLevel,
  setTracerTiming: () => setTracerTiming,
  setTracerEnabled: () => setTracerEnabled,
  setTracer: () => setTracer2,
  setScheduler: () => setScheduler,
  setRequestCaching: () => setRequestCaching,
  setRequestCache: () => setRequestCache,
  setRequestBatching: () => setRequestBatching,
  setRandom: () => setRandom,
  setConfigProvider: () => setConfigProvider2,
  setClock: () => setClock,
  service: () => service2,
  scopedDiscard: () => scopedDiscard2,
  scopedContext: () => scopedContext2,
  scoped: () => scoped3,
  scope: () => scope4,
  retry: () => retry3,
  provideMerge: () => provideMerge2,
  provide: () => provide3,
  project: () => project2,
  passthrough: () => passthrough3,
  parentSpan: () => parentSpan2,
  orElse: () => orElse6,
  orDie: () => orDie4,
  mock: () => mock2,
  mergeAll: () => mergeAll6,
  merge: () => merge8,
  memoize: () => memoize3,
  matchCause: () => matchCause4,
  match: () => match14,
  mapError: () => mapError4,
  map: () => map14,
  makeMemoMap: () => makeMemoMap2,
  locallyWith: () => locallyWith2,
  locallyScoped: () => locallyScoped2,
  locallyEffect: () => locallyEffect2,
  locally: () => locally2,
  launch: () => launch2,
  isLayer: () => isLayer2,
  isFresh: () => isFresh2,
  function: () => fromFunction2,
  fresh: () => fresh2,
  flatten: () => flatten9,
  flatMap: () => flatMap11,
  fiberRefLocallyScopedWith: () => fiberRefLocallyScopedWith3,
  failSync: () => failSync4,
  failCauseSync: () => failCauseSync4,
  failCause: () => failCause8,
  fail: () => fail9,
  extendScope: () => extendScope2,
  empty: () => empty35,
  effectDiscard: () => effectDiscard,
  effectContext: () => effectContext,
  effect: () => effect,
  discard: () => discard2,
  dieSync: () => dieSync4,
  die: () => die7,
  context: () => context4,
  catchAllCause: () => catchAllCause4,
  catchAll: () => catchAll4,
  buildWithScope: () => buildWithScope2,
  buildWithMemoMap: () => buildWithMemoMap2,
  build: () => build2,
  annotateSpans: () => annotateSpans4,
  annotateLogs: () => annotateLogs4,
  MemoMapTypeId: () => MemoMapTypeId2,
  LayerTypeId: () => LayerTypeId2,
  CurrentMemoMap: () => CurrentMemoMap2
});

// node_modules/effect/dist/esm/internal/layer/circular.js
var setConfigProvider = (configProvider) => scopedDiscard(withConfigProviderScoped(configProvider));
var parentSpan = (span2) => succeedContext(make6(spanTag, span2));
var span2 = (name, options) => {
  options = addSpanStackTrace(options);
  return scoped(spanTag, options?.onEnd ? tap(makeSpanScoped(name, options), (span3) => addFinalizer((exit3) => options.onEnd(span3, exit3))) : makeSpanScoped(name, options));
};
var setTracer = (tracer3) => scopedDiscard(withTracerScoped(tracer3));

// node_modules/effect/dist/esm/Layer.js
var LayerTypeId2 = LayerTypeId;
var MemoMapTypeId2 = MemoMapTypeId;
var CurrentMemoMap2 = CurrentMemoMap;
var isLayer2 = isLayer;
var isFresh2 = isFresh;
var annotateLogs4 = annotateLogs2;
var annotateSpans4 = annotateSpans2;
var build2 = build;
var buildWithScope2 = buildWithScope;
var catchAll4 = catchAll2;
var catchAllCause4 = catchAllCause2;
var context4 = context2;
var die7 = die5;
var dieSync4 = dieSync2;
var discard2 = discard;
var effect = fromEffect3;
var effectDiscard = fromEffectDiscard;
var effectContext = fromEffectContext;
var empty35 = empty34;
var extendScope2 = extendScope;
var fail9 = fail6;
var failSync4 = failSync2;
var failCause8 = failCause5;
var failCauseSync4 = failCauseSync2;
var flatMap11 = flatMap9;
var flatten9 = flatten7;
var fresh2 = fresh;
var mock2 = mock;
var fromFunction2 = fromFunction;
var launch2 = launch;
var map14 = map11;
var mapError4 = mapError2;
var match14 = match11;
var matchCause4 = matchCause2;
var memoize3 = memoize2;
var merge8 = merge6;
var mergeAll6 = mergeAll4;
var orDie4 = orDie2;
var orElse6 = orElse4;
var passthrough3 = passthrough;
var project2 = project;
var locallyEffect2 = locallyEffect;
var locally2 = fiberRefLocally2;
var locallyWith2 = fiberRefLocallyWith2;
var locallyScoped2 = fiberRefLocallyScoped2;
var fiberRefLocallyScopedWith3 = fiberRefLocallyScopedWith2;
var retry3 = retry;
var scope4 = scope2;
var scoped3 = scoped;
var scopedDiscard2 = scopedDiscard;
var scopedContext2 = scopedContext;
var service2 = service;
var succeed8 = succeed5;
var succeedContext2 = succeedContext;
var suspend4 = suspend2;
var sync4 = sync2;
var syncContext2 = syncContext;
var tap4 = tap2;
var tapError4 = tapError2;
var tapErrorCause4 = tapErrorCause2;
var toRuntime2 = toRuntime;
var toRuntimeWithMemoMap2 = toRuntimeWithMemoMap;
var provide3 = provide;
var provideMerge2 = provideMerge;
var zipWith7 = zipWith5;
var unwrapEffect2 = unwrapEffect;
var unwrapScoped2 = unwrapScoped;
var setClock = (clock3) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(clockTag, clock3)));
var setConfigProvider2 = setConfigProvider;
var parentSpan2 = parentSpan;
var setRandom = (random4) => scopedDiscard2(fiberRefLocallyScopedWith(currentServices, add2(randomTag, random4)));
var setRequestBatching = (requestBatching) => scopedDiscard2(fiberRefLocallyScoped(currentRequestBatching, requestBatching));
var setRequestCaching = (requestCaching) => scopedDiscard2(fiberRefLocallyScoped(currentCacheEnabled, requestCaching));
var setRequestCache = (cache) => scopedDiscard2(isEffect(cache) ? flatMap7(cache, (x) => fiberRefLocallyScoped(currentCache, x)) : fiberRefLocallyScoped(currentCache, cache));
var setScheduler = (scheduler) => scopedDiscard2(fiberRefLocallyScoped(currentScheduler, scheduler));
var span3 = span2;
var setTracer2 = setTracer;
var setTracerEnabled = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerEnabled, enabled2));
var setTracerTiming = (enabled2) => scopedDiscard2(fiberRefLocallyScoped(currentTracerTimingEnabled, enabled2));
var setUnhandledErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentUnhandledErrorLogLevel, level));
var setVersionMismatchErrorLogLevel = (level) => scopedDiscard2(fiberRefLocallyScoped(currentVersionMismatchErrorLogLevel, level));
var withSpan4 = withSpan2;
var withParentSpan4 = withParentSpan2;
var makeMemoMap2 = makeMemoMap;
var buildWithMemoMap2 = buildWithMemoMap;
var updateService3 = /* @__PURE__ */ dual(3, (layer, tag, f) => provide3(layer, map14(context4(), (c) => add2(c, tag, f(unsafeGet3(c, tag))))));

// node_modules/effect/dist/esm/internal/pubsub.js
var AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
class UnboundedPubSub {
  replayBuffer;
  publisherHead = {
    value: AbsentValue,
    subscribers: 0,
    next: null
  };
  publisherTail = this.publisherHead;
  publisherIndex = 0;
  subscribersIndex = 0;
  capacity = Number.MAX_SAFE_INTEGER;
  constructor(replayBuffer) {
    this.replayBuffer = replayBuffer;
  }
  replayWindow() {
    return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
  }
  isEmpty() {
    return this.publisherHead === this.publisherTail;
  }
  isFull() {
    return false;
  }
  size() {
    return this.publisherIndex - this.subscribersIndex;
  }
  publish(value) {
    const subscribers = this.publisherTail.subscribers;
    if (subscribers !== 0) {
      this.publisherTail.next = {
        value,
        subscribers,
        next: null
      };
      this.publisherTail = this.publisherTail.next;
      this.publisherIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.offer(value);
    }
    return true;
  }
  publishAll(elements) {
    if (this.publisherTail.subscribers !== 0) {
      for (const a of elements) {
        this.publish(a);
      }
    } else if (this.replayBuffer) {
      this.replayBuffer.offerAll(elements);
    }
    return empty5();
  }
  slide() {
    if (this.publisherHead !== this.publisherTail) {
      this.publisherHead = this.publisherHead.next;
      this.publisherHead.value = AbsentValue;
      this.subscribersIndex += 1;
    }
    if (this.replayBuffer) {
      this.replayBuffer.slide();
    }
  }
  subscribe() {
    this.publisherTail.subscribers += 1;
    return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
  }
}

class UnboundedPubSubSubscription {
  self;
  subscriberHead;
  subscriberIndex;
  unsubscribed;
  constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
    this.self = self2;
    this.subscriberHead = subscriberHead;
    this.subscriberIndex = subscriberIndex;
    this.unsubscribed = unsubscribed;
  }
  isEmpty() {
    if (this.unsubscribed) {
      return true;
    }
    let empty36 = true;
    let loop3 = true;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        if (this.subscriberHead.next.value !== AbsentValue) {
          empty36 = false;
          loop3 = false;
        } else {
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
    }
    return empty36;
  }
  size() {
    if (this.unsubscribed) {
      return 0;
    }
    return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
  }
  poll(default_) {
    if (this.unsubscribed) {
      return default_;
    }
    let loop3 = true;
    let polled = default_;
    while (loop3) {
      if (this.subscriberHead === this.self.publisherTail) {
        loop3 = false;
      } else {
        const elem = this.subscriberHead.next.value;
        if (elem !== AbsentValue) {
          polled = elem;
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
          loop3 = false;
        }
        this.subscriberHead = this.subscriberHead.next;
        this.subscriberIndex += 1;
      }
    }
    return polled;
  }
  pollUpTo(n) {
    const builder = [];
    const default_ = AbsentValue;
    let i = 0;
    while (i !== n) {
      const a = this.poll(default_);
      if (a === default_) {
        i = n;
      } else {
        builder.push(a);
        i += 1;
      }
    }
    return fromIterable2(builder);
  }
  unsubscribe() {
    if (!this.unsubscribed) {
      this.unsubscribed = true;
      this.self.publisherTail.subscribers -= 1;
      while (this.subscriberHead !== this.self.publisherTail) {
        if (this.subscriberHead.next.value !== AbsentValue) {
          this.subscriberHead.subscribers -= 1;
          if (this.subscriberHead.subscribers === 0) {
            this.self.publisherHead = this.self.publisherHead.next;
            this.self.publisherHead.value = AbsentValue;
            this.self.subscribersIndex += 1;
          }
        }
        this.subscriberHead = this.subscriberHead.next;
      }
    }
  }
}
class ReplayBuffer {
  capacity;
  constructor(capacity2) {
    this.capacity = capacity2;
  }
  head = {
    value: AbsentValue,
    next: null
  };
  tail = this.head;
  size = 0;
  index = 0;
  slide() {
    this.index++;
  }
  offer(a) {
    this.tail.value = a;
    this.tail.next = {
      value: AbsentValue,
      next: null
    };
    this.tail = this.tail.next;
    if (this.size === this.capacity) {
      this.head = this.head.next;
    } else {
      this.size += 1;
    }
  }
  offerAll(as4) {
    for (const a of as4) {
      this.offer(a);
    }
  }
}

class ReplayWindowImpl {
  buffer;
  head;
  index;
  remaining;
  constructor(buffer) {
    this.buffer = buffer;
    this.index = buffer.index;
    this.remaining = buffer.size;
    this.head = buffer.head;
  }
  fastForward() {
    while (this.index < this.buffer.index) {
      this.head = this.head.next;
      this.index++;
    }
  }
  take() {
    if (this.remaining === 0) {
      return;
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    this.remaining--;
    const value = this.head.value;
    this.head = this.head.next;
    return value;
  }
  takeN(n) {
    if (this.remaining === 0) {
      return empty5();
    } else if (this.index < this.buffer.index) {
      this.fastForward();
    }
    const len = Math.min(n, this.remaining);
    const items = new Array(len);
    for (let i = 0;i < len; i++) {
      const value = this.head.value;
      this.head = this.head.next;
      items[i] = value;
    }
    this.remaining -= len;
    return unsafeFromArray(items);
  }
  takeAll() {
    return this.takeN(this.remaining);
  }
}
var emptyReplayWindow = {
  remaining: 0,
  take: () => {
    return;
  },
  takeN: () => empty5(),
  takeAll: () => empty5()
};

// node_modules/effect/dist/esm/internal/channel/childExecutorDecision.js
var ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
var ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
var proto4 = {
  [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
};

// node_modules/effect/dist/esm/internal/channel/upstreamPullStrategy.js
var UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
var UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
var upstreamPullStrategyVariance = {
  _A: (_) => _
};
var proto5 = {
  [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
};

// node_modules/effect/dist/esm/internal/core-stream.js
var ChannelSymbolKey = "effect/Channel";
var ChannelTypeId2 = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
var channelVariance2 = {
  _Env: (_) => _,
  _InErr: (_) => _,
  _InElem: (_) => _,
  _InDone: (_) => _,
  _OutErr: (_) => _,
  _OutElem: (_) => _,
  _OutDone: (_) => _
};
var proto6 = {
  [ChannelTypeId2]: channelVariance2,
  pipe() {
    return pipeArguments(this, arguments);
  }
};

// node_modules/effect/dist/esm/internal/channel/channelState.js
var ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
var channelStateVariance = {
  _E: (_) => _,
  _R: (_) => _
};
var proto7 = {
  [ChannelStateTypeId]: channelStateVariance
};

// node_modules/effect/dist/esm/internal/channel/upstreamPullRequest.js
var UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
var UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
var upstreamPullRequestVariance = {
  _A: (_) => _
};
var proto8 = {
  [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
};

// node_modules/effect/dist/esm/internal/channel/mergeDecision.js
var MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
var MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
var proto9 = {
  [MergeDecisionTypeId]: {
    _R: (_) => _,
    _E0: (_) => _,
    _Z0: (_) => _,
    _E: (_) => _,
    _Z: (_) => _
  }
};

// node_modules/effect/dist/esm/internal/channel/mergeState.js
var MergeStateSymbolKey = "effect/ChannelMergeState";
var MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
var proto10 = {
  [MergeStateTypeId]: MergeStateTypeId
};

// node_modules/effect/dist/esm/internal/channel/mergeStrategy.js
var MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
var MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
var proto11 = {
  [MergeStrategyTypeId]: MergeStrategyTypeId
};

// node_modules/effect/dist/esm/internal/sink.js
var SinkTypeId2 = /* @__PURE__ */ Symbol.for("effect/Sink");

// node_modules/effect/dist/esm/internal/stm/versioned.js
class Versioned {
  value;
  constructor(value) {
    this.value = value;
  }
}

// node_modules/effect/dist/esm/internal/stm/entry.js
var make46 = (ref, isNew) => ({
  ref,
  isNew,
  isChanged: false,
  expected: ref.versioned,
  newValue: ref.versioned.value
});
var unsafeGet7 = (self2) => {
  return self2.newValue;
};
var unsafeSet = (self2, value) => {
  self2.isChanged = true;
  self2.newValue = value;
};
var commit = (self2) => {
  self2.ref.versioned = new Versioned(self2.newValue);
};
var isInvalid = (self2) => {
  return self2.ref.versioned !== self2.expected;
};
var isChanged = (self2) => {
  return self2.isChanged;
};

// node_modules/effect/dist/esm/internal/stm/journal.js
var JournalAnalysisInvalid = "Invalid";
var JournalAnalysisReadWrite = "ReadWrite";
var JournalAnalysisReadOnly = "ReadOnly";
var commitJournal = (journal) => {
  for (const entry of journal) {
    commit(entry[1]);
  }
};
var analyzeJournal = (journal) => {
  let val = JournalAnalysisReadOnly;
  for (const [, entry] of journal) {
    val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
    if (val === JournalAnalysisInvalid) {
      return val;
    }
  }
  return val;
};
var collectTodos = (journal) => {
  const allTodos = new Map;
  for (const [, entry] of journal) {
    for (const todo of entry.ref.todos) {
      allTodos.set(todo[0], todo[1]);
    }
    entry.ref.todos = new Map;
  }
  return allTodos;
};
var execTodos = (todos) => {
  const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
  for (const [_, todo] of todosSorted) {
    todo();
  }
};
var addTodo = (txnId, journal, todoEffect) => {
  let added = false;
  for (const [, entry] of journal) {
    if (!entry.ref.todos.has(txnId)) {
      entry.ref.todos.set(txnId, todoEffect);
      added = true;
    }
  }
  return added;
};

// node_modules/effect/dist/esm/internal/stm/opCodes/stm.js
var OP_WITH_STM_RUNTIME = "WithSTMRuntime";
var OP_ON_FAILURE2 = "OnFailure";
var OP_ON_RETRY = "OnRetry";
var OP_ON_SUCCESS2 = "OnSuccess";
var OP_PROVIDE3 = "Provide";
var OP_SYNC2 = "Sync";
var OP_SUCCEED2 = "Succeed";
var OP_RETRY = "Retry";
var OP_FAIL4 = "Fail";
var OP_DIE2 = "Die";
var OP_INTERRUPT2 = "Interrupt";

// node_modules/effect/dist/esm/internal/stm/opCodes/tExit.js
var OP_FAIL5 = "Fail";
var OP_DIE3 = "Die";
var OP_INTERRUPT3 = "Interrupt";
var OP_SUCCEED3 = "Succeed";
var OP_RETRY2 = "Retry";

// node_modules/effect/dist/esm/internal/stm/opCodes/tryCommit.js
var OP_DONE5 = "Done";
var OP_SUSPEND3 = "Suspend";

// node_modules/effect/dist/esm/internal/stm/opCodes/stmState.js
var OP_DONE6 = "Done";
var OP_INTERRUPTED = "Interrupted";
var OP_RUNNING2 = "Running";

// node_modules/effect/dist/esm/internal/stm/stmState.js
var STMStateSymbolKey = "effect/STM/State";
var STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
var isSTMState = (u) => hasProperty(u, STMStateTypeId);
var isRunning3 = (self2) => {
  return self2._tag === OP_RUNNING2;
};
var isDone6 = (self2) => {
  return self2._tag === OP_DONE6;
};
var done8 = (exit3) => {
  return {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_DONE6,
    exit: exit3,
    [symbol]() {
      return pipe(hash(STMStateSymbolKey), combine(hash(OP_DONE6)), combine(hash(exit3)), cached(this));
    },
    [symbol2](that) {
      return isSTMState(that) && that._tag === OP_DONE6 && equals(exit3, that.exit);
    }
  };
};
var interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_INTERRUPTED)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("interrupted")));
var interrupted2 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_INTERRUPTED,
  [symbol]() {
    return interruptedHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_INTERRUPTED;
  }
};
var runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(STMStateSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RUNNING2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("running")));
var running3 = {
  [STMStateTypeId]: STMStateTypeId,
  _tag: OP_RUNNING2,
  [symbol]() {
    return runningHash;
  },
  [symbol2](that) {
    return isSTMState(that) && that._tag === OP_RUNNING2;
  }
};
var fromTExit = (tExit) => {
  switch (tExit._tag) {
    case OP_FAIL5: {
      return done8(fail3(tExit.error));
    }
    case OP_DIE3: {
      return done8(die3(tExit.defect));
    }
    case OP_INTERRUPT3: {
      return done8(interrupt4(tExit.fiberId));
    }
    case OP_SUCCEED3: {
      return done8(succeed2(tExit.value));
    }
    case OP_RETRY2: {
      throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
  }
};

// node_modules/effect/dist/esm/internal/stm/tExit.js
var TExitSymbolKey = "effect/TExit";
var TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
var variance8 = {
  _A: (_) => _,
  _E: (_) => _
};
var isExit2 = (u) => hasProperty(u, TExitTypeId);
var isSuccess4 = (self2) => {
  return self2._tag === OP_SUCCEED3;
};
var isRetry = (self2) => {
  return self2._tag === OP_RETRY2;
};
var fail11 = (error) => ({
  [TExitTypeId]: variance8,
  _tag: OP_FAIL5,
  error,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_FAIL5)), combine(hash(error)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_FAIL5 && equals(error, that.error);
  }
});
var die8 = (defect) => ({
  [TExitTypeId]: variance8,
  _tag: OP_DIE3,
  defect,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_DIE3)), combine(hash(defect)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_DIE3 && equals(defect, that.defect);
  }
});
var interrupt8 = (fiberId3) => ({
  [TExitTypeId]: variance8,
  _tag: OP_INTERRUPT3,
  fiberId: fiberId3,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_INTERRUPT3)), combine(hash(fiberId3)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_INTERRUPT3 && equals(fiberId3, that.fiberId);
  }
});
var succeed12 = (value) => ({
  [TExitTypeId]: variance8,
  _tag: OP_SUCCEED3,
  value,
  [symbol]() {
    return pipe(hash(TExitSymbolKey), combine(hash(OP_SUCCEED3)), combine(hash(value)), cached(this));
  },
  [symbol2](that) {
    return isExit2(that) && that._tag === OP_SUCCEED3 && equals(value, that.value);
  }
});
var retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash(TExitSymbolKey), /* @__PURE__ */ combine(/* @__PURE__ */ hash(OP_RETRY2)), /* @__PURE__ */ combine(/* @__PURE__ */ hash("retry")));
var retry4 = {
  [TExitTypeId]: variance8,
  _tag: OP_RETRY2,
  [symbol]() {
    return retryHash;
  },
  [symbol2](that) {
    return isExit2(that) && isRetry(that);
  }
};

// node_modules/effect/dist/esm/internal/stm/tryCommit.js
var done9 = (exit3) => {
  return {
    _tag: OP_DONE5,
    exit: exit3
  };
};
var suspend6 = (journal) => {
  return {
    _tag: OP_SUSPEND3,
    journal
  };
};

// node_modules/effect/dist/esm/internal/stm/txnId.js
var txnCounter = {
  ref: 0
};
var make47 = () => {
  const newId = txnCounter.ref + 1;
  txnCounter.ref = newId;
  return newId;
};

// node_modules/effect/dist/esm/internal/stm/core.js
var STMSymbolKey2 = "effect/STM";
var STMTypeId2 = /* @__PURE__ */ Symbol.for(STMSymbolKey2);
var stmVariance = {
  _R: (_) => _,
  _E: (_) => _,
  _A: (_) => _
};

class STMPrimitive {
  effect_instruction_i0;
  _op = OP_COMMIT;
  effect_instruction_i1 = undefined;
  effect_instruction_i2 = undefined;
  [EffectTypeId3];
  [StreamTypeId];
  [SinkTypeId2];
  [ChannelTypeId2];
  get [STMTypeId2]() {
    return stmVariance;
  }
  constructor(effect_instruction_i0) {
    this.effect_instruction_i0 = effect_instruction_i0;
    this[EffectTypeId3] = effectVariance;
    this[StreamTypeId] = stmVariance;
    this[SinkTypeId2] = stmVariance;
    this[ChannelTypeId2] = stmVariance;
  }
  [symbol2](that) {
    return this === that;
  }
  [symbol]() {
    return cached(this, random(this));
  }
  [Symbol.iterator]() {
    return new SingleShotGen2(new YieldWrap(this));
  }
  commit() {
    return unsafeAtomically(this, constVoid, constVoid);
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var unsafeAtomically = (self2, onDone, onInterrupt3) => withFiberRuntime((state) => {
  const fiberId3 = state.id();
  const env = state.getFiberRef(currentContext2);
  const scheduler = state.getFiberRef(currentScheduler2);
  const priority = state.getFiberRef(currentSchedulingPriority2);
  const commitResult = tryCommitSync(fiberId3, self2, env, scheduler, priority);
  switch (commitResult._tag) {
    case OP_DONE5: {
      onDone(commitResult.exit);
      return commitResult.exit;
    }
    case OP_SUSPEND3: {
      const txnId = make47();
      const state2 = {
        value: running3
      };
      const effect3 = async((k) => tryCommitAsync(fiberId3, self2, txnId, state2, env, scheduler, priority, k));
      return uninterruptibleMask3((restore) => pipe(restore(effect3), catchAllCause3((cause3) => {
        let currentState = state2.value;
        if (isRunning3(currentState)) {
          state2.value = interrupted2;
        }
        currentState = state2.value;
        if (isDone6(currentState)) {
          onDone(currentState.exit);
          return currentState.exit;
        }
        onInterrupt3();
        return failCause7(cause3);
      })));
    }
  }
});
var tryCommit = (fiberId3, stm, state, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      state.value = fromTExit(tExit);
      return completeTodos(succeed2(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      state.value = fromTExit(tExit);
      const cause3 = fail4(tExit.error);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      state.value = fromTExit(tExit);
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      state.value = fromTExit(tExit);
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitSync = (fiberId3, stm, env, scheduler, priority) => {
  const journal = new Map;
  const tExit = new STMDriver(stm, journal, fiberId3, env).run();
  const analysis = analyzeJournal(journal);
  if (analysis === JournalAnalysisReadWrite && isSuccess4(tExit)) {
    commitJournal(journal);
  } else if (analysis === JournalAnalysisInvalid) {
    throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  switch (tExit._tag) {
    case OP_SUCCEED3: {
      return completeTodos(succeed2(tExit.value), journal, scheduler, priority);
    }
    case OP_FAIL5: {
      const cause3 = fail4(tExit.error);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_DIE3: {
      const cause3 = die4(tExit.defect);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_INTERRUPT3: {
      const cause3 = interrupt5(fiberId3);
      return completeTodos(failCause2(cause3), journal, scheduler, priority);
    }
    case OP_RETRY2: {
      return suspend6(journal);
    }
  }
};
var tryCommitAsync = (fiberId3, self2, txnId, state, context5, scheduler, priority, k) => {
  if (isRunning3(state.value)) {
    const result = tryCommit(fiberId3, self2, state, context5, scheduler, priority);
    switch (result._tag) {
      case OP_DONE5: {
        completeTryCommit(result.exit, k);
        break;
      }
      case OP_SUSPEND3: {
        addTodo(txnId, result.journal, () => tryCommitAsync(fiberId3, self2, txnId, state, context5, scheduler, priority, k));
        break;
      }
    }
  }
};
var completeTodos = (exit3, journal, scheduler, priority) => {
  const todos = collectTodos(journal);
  if (todos.size > 0) {
    scheduler.scheduleTask(() => execTodos(todos), priority);
  }
  return done9(exit3);
};
var completeTryCommit = (exit3, k) => {
  k(exit3);
};
class STMDriver {
  self;
  journal;
  fiberId;
  contStack = [];
  env;
  constructor(self2, journal, fiberId3, r0) {
    this.self = self2;
    this.journal = journal;
    this.fiberId = fiberId3;
    this.env = r0;
  }
  getEnv() {
    return this.env;
  }
  pushStack(cont) {
    this.contStack.push(cont);
  }
  popStack() {
    return this.contStack.pop();
  }
  nextSuccess() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_SUCCESS2) {
      current = this.popStack();
    }
    return current;
  }
  nextFailure() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_FAILURE2) {
      current = this.popStack();
    }
    return current;
  }
  nextRetry() {
    let current = this.popStack();
    while (current !== undefined && current.effect_instruction_i0 !== OP_ON_RETRY) {
      current = this.popStack();
    }
    return current;
  }
  run() {
    let curr = this.self;
    let exit3 = undefined;
    while (exit3 === undefined && curr !== undefined) {
      try {
        const current = curr;
        if (current) {
          switch (current._op) {
            case "Tag": {
              curr = effect3((_, __, env) => unsafeGet3(env, current));
              break;
            }
            case "Left": {
              curr = fail12(current.left);
              break;
            }
            case "None": {
              curr = fail12(new NoSuchElementException2);
              break;
            }
            case "Right": {
              curr = succeed13(current.right);
              break;
            }
            case "Some": {
              curr = succeed13(current.value);
              break;
            }
            case "Commit": {
              switch (current.effect_instruction_i0) {
                case OP_DIE2: {
                  exit3 = die8(internalCall(() => current.effect_instruction_i1()));
                  break;
                }
                case OP_FAIL4: {
                  const cont = this.nextFailure();
                  if (cont === undefined) {
                    exit3 = fail11(internalCall(() => current.effect_instruction_i1()));
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                  }
                  break;
                }
                case OP_RETRY: {
                  const cont = this.nextRetry();
                  if (cont === undefined) {
                    exit3 = retry4;
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2());
                  }
                  break;
                }
                case OP_INTERRUPT2: {
                  exit3 = interrupt8(this.fiberId);
                  break;
                }
                case OP_WITH_STM_RUNTIME: {
                  curr = internalCall(() => current.effect_instruction_i1(this));
                  break;
                }
                case OP_ON_SUCCESS2:
                case OP_ON_FAILURE2:
                case OP_ON_RETRY: {
                  this.pushStack(current);
                  curr = current.effect_instruction_i1;
                  break;
                }
                case OP_PROVIDE3: {
                  const env = this.env;
                  this.env = internalCall(() => current.effect_instruction_i2(env));
                  curr = pipe(current.effect_instruction_i1, ensuring5(sync7(() => this.env = env)));
                  break;
                }
                case OP_SUCCEED2: {
                  const value = current.effect_instruction_i1;
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
                case OP_SYNC2: {
                  const value = internalCall(() => current.effect_instruction_i1());
                  const cont = this.nextSuccess();
                  if (cont === undefined) {
                    exit3 = succeed12(value);
                  } else {
                    curr = internalCall(() => cont.effect_instruction_i2(value));
                  }
                  break;
                }
              }
              break;
            }
          }
        }
      } catch (e) {
        curr = die9(e);
      }
    }
    return exit3;
  }
}
var catchAll6 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_FAILURE2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var die9 = (defect) => dieSync5(() => defect);
var dieSync5 = (evaluate2) => {
  const stm = new STMPrimitive(OP_DIE2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var effect3 = (f) => withSTMRuntime((_) => succeed13(f(_.journal, _.fiberId, _.getEnv())));
var ensuring5 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
  onFailure: (e) => zipRight6(finalizer, fail12(e)),
  onSuccess: (a) => zipRight6(finalizer, succeed13(a))
}));
var fail12 = (error) => failSync6(() => error);
var failSync6 = (evaluate2) => {
  const stm = new STMPrimitive(OP_FAIL4);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var flatMap13 = /* @__PURE__ */ dual(2, (self2, f) => {
  const stm = new STMPrimitive(OP_ON_SUCCESS2);
  stm.effect_instruction_i1 = self2;
  stm.effect_instruction_i2 = f;
  return stm;
});
var matchSTM = /* @__PURE__ */ dual(2, (self2, {
  onFailure,
  onSuccess
}) => pipe(self2, map19(right2), catchAll6((e) => pipe(onFailure(e), map19(left2))), flatMap13((either5) => {
  switch (either5._tag) {
    case "Left": {
      return succeed13(either5.left);
    }
    case "Right": {
      return onSuccess(either5.right);
    }
  }
})));
var withSTMRuntime = (f) => {
  const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
  stm.effect_instruction_i1 = f;
  return stm;
};
var interruptAs2 = (fiberId3) => {
  const stm = new STMPrimitive(OP_INTERRUPT2);
  stm.effect_instruction_i1 = fiberId3;
  return stm;
};
var map19 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap13((a) => sync7(() => f(a)))));
var retry5 = /* @__PURE__ */ new STMPrimitive(OP_RETRY);
var succeed13 = (value) => {
  const stm = new STMPrimitive(OP_SUCCEED2);
  stm.effect_instruction_i1 = value;
  return stm;
};
var sync7 = (evaluate2) => {
  const stm = new STMPrimitive(OP_SYNC2);
  stm.effect_instruction_i1 = evaluate2;
  return stm;
};
var zipRight6 = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap13(() => that)));
var zipWith9 = /* @__PURE__ */ dual(3, (self2, that, f) => pipe(self2, flatMap13((a) => pipe(that, map19((b) => f(a, b))))));

// node_modules/effect/dist/esm/internal/stm/opCodes/strategy.js
var OP_BACKPRESSURE_STRATEGY = "BackPressure";
var OP_DROPPING_STRATEGY = "Dropping";
var OP_SLIDING_STRATEGY = "Sliding";

// node_modules/effect/dist/esm/internal/stm/stm.js
var flatten11 = (self2) => flatMap13(self2, identity);
var forEach9 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (iterable, f, options) => {
  if (options?.discard) {
    return pipe(sync7(() => iterable[Symbol.iterator]()), flatMap13((iterator) => {
      const loop3 = suspend7(() => {
        const next4 = iterator.next();
        if (next4.done) {
          return void_6;
        }
        return pipe(f(next4.value), flatMap13(() => loop3));
      });
      return loop3;
    }));
  }
  return suspend7(() => fromIterable(iterable).reduce((acc, curr) => zipWith9(acc, f(curr), (array6, elem) => {
    array6.push(elem);
    return array6;
  }), succeed13([])));
});
var suspend7 = (evaluate2) => flatten11(sync7(evaluate2));
var void_6 = /* @__PURE__ */ succeed13(undefined);

// node_modules/effect/dist/esm/internal/stm/tRef.js
var TRefSymbolKey = "effect/TRef";
var TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
var tRefVariance = {
  _A: (_) => _
};

class TRefImpl {
  [TRefTypeId] = tRefVariance;
  todos;
  versioned;
  constructor(value) {
    this.versioned = new Versioned(value);
    this.todos = new Map;
  }
  modify(f) {
    return effect3((journal) => {
      const entry = getOrMakeEntry(this, journal);
      const [retValue, newValue] = f(unsafeGet7(entry));
      unsafeSet(entry, newValue);
      return retValue;
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var getOrMakeEntry = (self2, journal) => {
  if (journal.has(self2)) {
    return journal.get(self2);
  }
  const entry = make46(self2, false);
  journal.set(self2, entry);
  return entry;
};
var unsafeGet8 = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet7(getOrMakeEntry(self2, journal)));
var unsafeSet2 = /* @__PURE__ */ dual(3, (self2, value, journal) => {
  const entry = getOrMakeEntry(self2, journal);
  unsafeSet(entry, value);
  return;
});

// node_modules/effect/dist/esm/internal/stm/tQueue.js
var TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
var TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
var TDequeueSymbolKey = "effect/TQueue/TDequeue";
var TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
var tDequeueVariance = {
  _Out: (_) => _
};
var tEnqueueVariance = {
  _In: (_) => _
};

class TQueueImpl {
  ref;
  requestedCapacity;
  strategy;
  [TDequeueTypeId] = tDequeueVariance;
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(ref, requestedCapacity, strategy) {
    this.ref = ref;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
  }
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(queue.length);
  });
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.requestedCapacity);
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  shutdown = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    unsafeSet2(this.ref, undefined, runtime5.journal);
    return void_6;
  });
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const queue = unsafeGet8(this.ref, journal);
    return queue === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const queue = pipe(this.ref, unsafeGet8(runtime5.journal));
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length < this.requestedCapacity) {
        queue.push(value);
        unsafeSet2(this.ref, queue, runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (queue.length === 0) {
            return succeed13(true);
          }
          queue.shift();
          queue.push(value);
          unsafeSet2(this.ref, queue, runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return withSTMRuntime((runtime5) => {
      const as6 = Array.from(iterable);
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      if (queue.length + as6.length <= this.requestedCapacity) {
        unsafeSet2(this.ref, [...queue, ...as6], runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          unsafeSet2(this.ref, [...queue, ...forQueue], runtime5.journal);
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          const forQueue = as6.slice(0, this.requestedCapacity - queue.length);
          const toDrop = queue.length + forQueue.length - this.requestedCapacity;
          const newQueue = queue.slice(toDrop);
          unsafeSet2(this.ref, [...newQueue, ...forQueue], runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    return succeed13(queue[0]);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(fromNullable(queue[0]));
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    if (queue.length === 0) {
      return retry5;
    }
    const dequeued = queue.shift();
    unsafeSet2(this.ref, queue, runtime5.journal);
    return succeed13(dequeued);
  });
  takeAll = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const queue = unsafeGet8(this.ref, runtime5.journal);
    if (queue === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    unsafeSet2(this.ref, [], runtime5.journal);
    return succeed13(queue);
  });
  takeUpTo(max5) {
    return withSTMRuntime((runtime5) => {
      const queue = unsafeGet8(this.ref, runtime5.journal);
      if (queue === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const [toTake, remaining] = splitAt2(unsafeFromArray(queue), max5);
      unsafeSet2(this.ref, Array.from(remaining), runtime5.journal);
      return succeed13(Array.from(toTake));
    });
  }
}

// node_modules/effect/dist/esm/internal/stm/tPubSub.js
var TPubSubSymbolKey = "effect/TPubSub";
var TPubSubTypeId = /* @__PURE__ */ Symbol.for(TPubSubSymbolKey);
var AbsentValue2 = /* @__PURE__ */ Symbol.for("effect/TPubSub/AbsentValue");
var makeNode2 = (head5, subscribers, tail) => ({
  head: head5,
  subscribers,
  tail
});

class TPubSubImpl {
  pubsubSize;
  publisherHead;
  publisherTail;
  requestedCapacity;
  strategy;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = {
    _A: (_) => _
  };
  [TEnqueueTypeId] = tEnqueueVariance;
  constructor(pubsubSize, publisherHead, publisherTail, requestedCapacity, strategy, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.publisherTail = publisherTail;
    this.requestedCapacity = requestedCapacity;
    this.strategy = strategy;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    return currentPublisherTail === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
    if (currentPublisherTail === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    return succeed13(unsafeGet8(this.pubsubSize, runtime5.journal));
  });
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.capacity());
  offer(value) {
    return withSTMRuntime((runtime5) => {
      const currentPublisherTail = unsafeGet8(this.publisherTail, runtime5.journal);
      if (currentPublisherTail === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, runtime5.journal);
      if (currentSubscriberCount === 0) {
        return succeed13(true);
      }
      const currentPubSubSize = unsafeGet8(this.pubsubSize, runtime5.journal);
      if (currentPubSubSize < this.requestedCapacity) {
        const updatedPublisherTail = new TRefImpl(undefined);
        const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
        unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
        unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
        unsafeSet2(this.pubsubSize, currentPubSubSize + 1, runtime5.journal);
        return succeed13(true);
      }
      switch (this.strategy._tag) {
        case OP_BACKPRESSURE_STRATEGY: {
          return retry5;
        }
        case OP_DROPPING_STRATEGY: {
          return succeed13(false);
        }
        case OP_SLIDING_STRATEGY: {
          if (this.requestedCapacity > 0) {
            let currentPublisherHead = unsafeGet8(this.publisherHead, runtime5.journal);
            let loop3 = true;
            while (loop3) {
              const node = unsafeGet8(currentPublisherHead, runtime5.journal);
              if (node === undefined) {
                return retry5;
              }
              const head5 = node.head;
              const tail = node.tail;
              if (head5 !== AbsentValue2) {
                const updatedNode2 = makeNode2(AbsentValue2, node.subscribers, node.tail);
                unsafeSet2(currentPublisherHead, updatedNode2, runtime5.journal);
                unsafeSet2(this.publisherHead, tail, runtime5.journal);
                loop3 = false;
              } else {
                currentPublisherHead = tail;
              }
            }
          }
          const updatedPublisherTail = new TRefImpl(undefined);
          const updatedNode = makeNode2(value, currentSubscriberCount, updatedPublisherTail);
          unsafeSet2(currentPublisherTail, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherTail, updatedPublisherTail, runtime5.journal);
          return succeed13(true);
        }
      }
    });
  }
  offerAll(iterable) {
    return map19(forEach9(iterable, (a) => this.offer(a)), every(identity));
  }
  shutdown = /* @__PURE__ */ effect3((journal) => {
    const currentPublisherTail = unsafeGet8(this.publisherTail, journal);
    if (currentPublisherTail !== undefined) {
      unsafeSet2(this.publisherTail, undefined, journal);
      const currentSubscribers = unsafeGet8(this.subscribers, journal);
      forEach3(currentSubscribers, (subscriber) => {
        unsafeSet2(subscriber, undefined, journal);
      });
      unsafeSet2(this.subscribers, empty8(), journal);
    }
  });
}

class TPubSubSubscriptionImpl {
  pubsubSize;
  publisherHead;
  requestedCapacity;
  subscriberHead;
  subscriberCount;
  subscribers;
  [TPubSubTypeId] = TPubSubTypeId;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(pubsubSize, publisherHead, requestedCapacity, subscriberHead, subscriberCount, subscribers) {
    this.pubsubSize = pubsubSize;
    this.publisherHead = publisherHead;
    this.requestedCapacity = requestedCapacity;
    this.subscriberHead = subscriberHead;
    this.subscriberCount = subscriberCount;
    this.subscribers = subscribers;
  }
  isShutdown = /* @__PURE__ */ effect3((journal) => {
    const currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    return currentSubscriberHead === undefined;
  });
  awaitShutdown = /* @__PURE__ */ flatMap13(this.isShutdown, (isShutdown3) => isShutdown3 ? void_6 : retry5);
  capacity() {
    return this.requestedCapacity;
  }
  size = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let loop3 = true;
    let size14 = 0;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        loop3 = false;
      } else {
        const head5 = node.head;
        const tail = node.tail;
        if (head5 !== AbsentValue2) {
          size14 = size14 + 1;
          if (size14 >= Number.MAX_SAFE_INTEGER) {
            loop3 = false;
          }
        }
        currentSubscriberHead = tail;
      }
    }
    return succeed13(size14);
  });
  isEmpty = /* @__PURE__ */ map19(this.size, (size14) => size14 === 0);
  isFull = /* @__PURE__ */ map19(this.size, (size14) => size14 === this.capacity());
  peek = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry5;
      }
      const head5 = node.head;
      const tail = node.tail;
      if (head5 !== AbsentValue2) {
        value = head5;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  peekOption = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = none2();
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        value = none2();
        loop3 = false;
      } else {
        const head5 = node.head;
        const tail = node.tail;
        if (head5 !== AbsentValue2) {
          value = some2(head5);
          loop3 = false;
        } else {
          currentSubscriberHead = tail;
        }
      }
    }
    return succeed13(value);
  });
  shutdown = /* @__PURE__ */ effect3((journal) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, journal);
    if (currentSubscriberHead !== undefined) {
      unsafeSet2(this.subscriberHead, undefined, journal);
      let loop3 = true;
      while (loop3) {
        const node = unsafeGet8(currentSubscriberHead, journal);
        if (node === undefined) {
          loop3 = false;
        } else {
          const head5 = node.head;
          const tail = node.tail;
          if (head5 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
              unsafeSet2(this.publisherHead, tail, journal);
              unsafeSet2(this.pubsubSize, size14 - 1, journal);
            } else {
              const updatedNode = makeNode2(head5, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, journal);
            }
          }
          currentSubscriberHead = tail;
        }
      }
      const currentSubscriberCount = unsafeGet8(this.subscriberCount, journal);
      unsafeSet2(this.subscriberCount, currentSubscriberCount - 1, journal);
      unsafeSet2(this.subscribers, remove4(unsafeGet8(this.subscribers, journal), this.subscriberHead), journal);
    }
  });
  take = /* @__PURE__ */ withSTMRuntime((runtime5) => {
    let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
    if (currentSubscriberHead === undefined) {
      return interruptAs2(runtime5.fiberId);
    }
    let value = AbsentValue2;
    let loop3 = true;
    while (loop3) {
      const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
      if (node === undefined) {
        return retry5;
      }
      const head5 = node.head;
      const tail = node.tail;
      if (head5 !== AbsentValue2) {
        const subscribers = node.subscribers;
        if (subscribers === 1) {
          const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
          const updatedNode = makeNode2(AbsentValue2, 0, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
          unsafeSet2(this.publisherHead, tail, runtime5.journal);
          unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
        } else {
          const updatedNode = makeNode2(head5, subscribers - 1, tail);
          unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
        }
        unsafeSet2(this.subscriberHead, tail, runtime5.journal);
        value = head5;
        loop3 = false;
      } else {
        currentSubscriberHead = tail;
      }
    }
    return succeed13(value);
  });
  takeAll = /* @__PURE__ */ this.takeUpTo(Number.POSITIVE_INFINITY);
  takeUpTo(max5) {
    return withSTMRuntime((runtime5) => {
      let currentSubscriberHead = unsafeGet8(this.subscriberHead, runtime5.journal);
      if (currentSubscriberHead === undefined) {
        return interruptAs2(runtime5.fiberId);
      }
      const builder = [];
      let n = 0;
      while (n !== max5) {
        const node = unsafeGet8(currentSubscriberHead, runtime5.journal);
        if (node === undefined) {
          n = max5;
        } else {
          const head5 = node.head;
          const tail = node.tail;
          if (head5 !== AbsentValue2) {
            const subscribers = node.subscribers;
            if (subscribers === 1) {
              const size14 = unsafeGet8(this.pubsubSize, runtime5.journal);
              const updatedNode = makeNode2(AbsentValue2, 0, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
              unsafeSet2(this.publisherHead, tail, runtime5.journal);
              unsafeSet2(this.pubsubSize, size14 - 1, runtime5.journal);
            } else {
              const updatedNode = makeNode2(head5, subscribers - 1, tail);
              unsafeSet2(currentSubscriberHead, updatedNode, runtime5.journal);
            }
            builder.push(head5);
            n = n + 1;
          }
          currentSubscriberHead = tail;
        }
      }
      unsafeSet2(this.subscriberHead, currentSubscriberHead, runtime5.journal);
      return succeed13(builder);
    });
  }
}
// node_modules/effect/dist/esm/ConfigError.js
var InvalidData2 = InvalidData;

// node_modules/effect/dist/esm/internal/redacted.js
var RedactedSymbolKey = "effect/Redacted";
var redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => new WeakMap);
var RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
var proto12 = {
  [RedactedTypeId]: {
    _A: (_) => _
  },
  pipe() {
    return pipeArguments(this, arguments);
  },
  toString() {
    return "<redacted>";
  },
  toJSON() {
    return "<redacted>";
  },
  [NodeInspectSymbol]() {
    return "<redacted>";
  },
  [symbol]() {
    return pipe(hash(RedactedSymbolKey), combine(hash(redactedRegistry.get(this))), cached(this));
  },
  [symbol2](that) {
    return isRedacted(that) && equals(redactedRegistry.get(this), redactedRegistry.get(that));
  }
};
var isRedacted = (u) => hasProperty(u, RedactedTypeId);
var make52 = (value) => {
  const redacted = Object.create(proto12);
  redactedRegistry.set(redacted, value);
  return redacted;
};
var value = (self2) => {
  if (redactedRegistry.has(self2)) {
    return redactedRegistry.get(self2);
  } else {
    throw new Error("Unable to get redacted value");
  }
};

// node_modules/effect/dist/esm/internal/secret.js
var SecretSymbolKey = "effect/Secret";
var SecretTypeId = /* @__PURE__ */ Symbol.for(SecretSymbolKey);
var SecretProto = {
  ...proto12,
  [SecretTypeId]: SecretTypeId
};

// node_modules/effect/dist/esm/internal/config.js
var ConfigSymbolKey = "effect/Config";
var ConfigTypeId = /* @__PURE__ */ Symbol.for(ConfigSymbolKey);
var configVariance = {
  _A: (_) => _
};
var proto13 = {
  ...CommitPrototype,
  [ConfigTypeId]: configVariance,
  commit() {
    return config(this);
  }
};
var mapOrFail = /* @__PURE__ */ dual(2, (self2, f) => {
  const mapOrFail2 = Object.create(proto13);
  mapOrFail2._tag = OP_MAP_OR_FAIL;
  mapOrFail2.original = self2;
  mapOrFail2.mapOrFail = f;
  return mapOrFail2;
});
var nested2 = /* @__PURE__ */ dual(2, (self2, name) => {
  const nested3 = Object.create(proto13);
  nested3._tag = OP_NESTED;
  nested3.name = name;
  nested3.config = self2;
  return nested3;
});
var primitive = (description, parse3) => {
  const primitive2 = Object.create(proto13);
  primitive2._tag = OP_PRIMITIVE;
  primitive2.description = description;
  primitive2.parse = parse3;
  return primitive2;
};
var string4 = (name) => {
  const config2 = primitive("a text property", right2);
  return name === undefined ? config2 : nested2(config2, name);
};

// node_modules/effect/dist/esm/Config.js
var mapOrFail2 = mapOrFail;
var string5 = string4;
// node_modules/effect/dist/esm/internal/encoding/common.js
var DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
var DecodeException = (input, message) => {
  const out = {
    _tag: "DecodeException",
    [DecodeExceptionTypeId]: DecodeExceptionTypeId,
    input
  };
  if (isString(message)) {
    out.message = message;
  }
  return out;
};
var encoder = /* @__PURE__ */ new TextEncoder;

// node_modules/effect/dist/esm/internal/encoding/base64.js
function getBase64Code(charCode) {
  if (charCode >= base64codes.length) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  const code = base64codes[charCode];
  if (code === 255) {
    throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
  }
  return code;
}
var encode = (bytes) => {
  const length3 = bytes.length;
  let result = "";
  let i;
  for (i = 2;i < length3; i += 3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += base64abc[bytes[i] & 63];
  }
  if (i === length3 + 1) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === length3) {
    result += base64abc[bytes[i - 2] >> 2];
    result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += base64abc[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
};
var decode2 = (str) => {
  const stripped = stripCrlf(str);
  const length3 = stripped.length;
  if (length3 % 4 !== 0) {
    return left2(DecodeException(stripped, `Length must be a multiple of 4, but is ${length3}`));
  }
  const index = stripped.indexOf("=");
  if (index !== -1 && (index < length3 - 2 || index === length3 - 2 && stripped[length3 - 1] !== "=")) {
    return left2(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
  }
  try {
    const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
    const result = new Uint8Array(3 * (length3 / 4) - missingOctets);
    for (let i = 0, j = 0;i < length3; i += 4, j += 3) {
      const buffer2 = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
      result[j] = buffer2 >> 16;
      result[j + 1] = buffer2 >> 8 & 255;
      result[j + 2] = buffer2 & 255;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
  }
};
var stripCrlf = (str) => str.replace(/[\n\r]/g, "");
var base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
var base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];

// node_modules/effect/dist/esm/internal/encoding/base64Url.js
var encode2 = (data) => encode(data).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
var decode3 = (str) => {
  const stripped = stripCrlf(str);
  const length3 = stripped.length;
  if (length3 % 4 === 1) {
    return left2(DecodeException(stripped, `Length should be a multiple of 4, but is ${length3}`));
  }
  if (!/^[-_A-Z0-9]*?={0,2}$/i.test(stripped)) {
    return left2(DecodeException(stripped, "Invalid input"));
  }
  let sanitized = length3 % 4 === 2 ? `${stripped}==` : length3 % 4 === 3 ? `${stripped}=` : stripped;
  sanitized = sanitized.replace(/-/g, "+").replace(/_/g, "/");
  return decode2(sanitized);
};

// node_modules/effect/dist/esm/internal/encoding/hex.js
var encode3 = (bytes) => {
  let result = "";
  for (let i = 0;i < bytes.length; ++i) {
    result += bytesToHex[bytes[i]];
  }
  return result;
};
var decode4 = (str) => {
  const bytes = new TextEncoder().encode(str);
  if (bytes.length % 2 !== 0) {
    return left2(DecodeException(str, `Length must be a multiple of 2, but is ${bytes.length}`));
  }
  try {
    const length3 = bytes.length / 2;
    const result = new Uint8Array(length3);
    for (let i = 0;i < length3; i++) {
      const a = fromHexChar(bytes[i * 2]);
      const b = fromHexChar(bytes[i * 2 + 1]);
      result[i] = a << 4 | b;
    }
    return right2(result);
  } catch (e) {
    return left2(DecodeException(str, e instanceof Error ? e.message : "Invalid input"));
  }
};
var bytesToHex = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var fromHexChar = (byte) => {
  if (48 <= byte && byte <= 57) {
    return byte - 48;
  }
  if (97 <= byte && byte <= 102) {
    return byte - 97 + 10;
  }
  if (65 <= byte && byte <= 70) {
    return byte - 65 + 10;
  }
  throw new TypeError("Invalid input");
};

// node_modules/effect/dist/esm/Encoding.js
var encodeBase64 = (input) => typeof input === "string" ? encode(encoder.encode(input)) : encode(input);
var decodeBase64 = (str) => decode2(str);
var encodeBase64Url = (input) => typeof input === "string" ? encode2(encoder.encode(input)) : encode2(input);
var decodeBase64Url = (str) => decode3(str);
var encodeHex = (input) => typeof input === "string" ? encode3(encoder.encode(input)) : encode3(input);
var decodeHex = (str) => decode4(str);
// node_modules/effect/dist/esm/ExecutionPlan.js
var TypeId21 = TypeId19;
var Proto3 = {
  [TypeId21]: TypeId21,
  get withRequirements() {
    const self2 = this;
    return contextWith2((context6) => makeProto(self2.steps.map((step4) => ({
      ...step4,
      provide: isLayer2(step4.provide) ? provide3(step4.provide, succeedContext2(context6)) : step4.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self2 = Object.create(Proto3);
  self2.steps = steps;
  return self2;
};
// node_modules/effect/dist/esm/FiberHandle.js
var TypeId22 = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
var Proto4 = {
  [TypeId22]: TypeId22,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/FiberMap.js
var TypeId23 = /* @__PURE__ */ Symbol.for("effect/FiberMap");
var Proto5 = {
  [TypeId23]: TypeId23,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/FiberSet.js
var TypeId24 = /* @__PURE__ */ Symbol.for("effect/FiberSet");
var Proto6 = {
  [TypeId24]: TypeId24,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/ParseResult.js
function sortByIndex(es) {
  return es.sort(compare).map((t) => t[1]);
}
function getRefinementExpected(ast) {
  return getDescriptionAnnotation(ast).pipe(orElse(() => getTitleAnnotation(ast)), orElse(() => getAutoTitleAnnotation(ast)), orElse(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
}
function getDefaultTypeMessage(issue) {
  if (issue.message !== undefined) {
    return issue.message;
  }
  const expected = isRefinement(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
  return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
}

class Pointer {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite2 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}

class Refinement2 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type2 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
class ParseError extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId] = ParseErrorTypeId;
  get message() {
    return this.toString();
  }
  toString() {
    return TreeFormatter.formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError = (issue) => new ParseError({
  issue
});
var succeed15 = right2;
var fail16 = left2;
var isEither4 = isEither2;
var flatMap16 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: left2,
    onRight: f
  }) : flatMap10(self2, f);
});
var map23 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? map(self2, f) : map13(self2, f);
});
var mapError6 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? mapLeft(self2, f) : mapError3(self2, f);
});
var orElse10 = /* @__PURE__ */ dual(2, (self2, f) => {
  return isEither4(self2) ? match(self2, {
    onLeft: f,
    onRight: right2
  }) : catchAll3(self2, f);
});
var mergeInternalOptions = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither = (ast, isDecoding, options) => {
  const parser = goMemo(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions(options, overrideOptions));
};
var getSync = (ast, isDecoding, options) => {
  const parser = getEither(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
};
var validateSync = (schema, options) => getSync(typeAST(schema.ast), true, options);
var decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => new WeakMap);
var goMemo = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
  const parserWithOptions = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions(options, parseOptionsAnnotation.value)) : raw;
  const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
  const parser = isDecoding && isSome2(decodingFallbackAnnotation) ? (i, options) => handleForbidden(orElse10(parserWithOptions(i, options), decodingFallbackAnnotation.value), ast, i, options) : parserWithOptions;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
var getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
var go = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo(ast.from, true);
        return (i, options) => {
          options = options ?? defaultParseOption;
          const allErrors = options?.errors === "all";
          const result = flatMap16(orElse10(from(i, options), (ef) => {
            const issue = new Refinement2(ast, i, "From", ef);
            if (allErrors && hasStableFilter(ast) && isComposite2(ef)) {
              return match2(ast.filter(i, options, ast), {
                onNone: () => left2(issue),
                onSome: (ep) => left2(new Composite2(ast, i, [issue, new Refinement2(ast, i, "Predicate", ep)]))
              });
            }
            return left2(issue);
          }), (a) => match2(ast.filter(a, options, ast), {
            onNone: () => right2(a),
            onSome: (ep) => left2(new Refinement2(ast, i, "Predicate", ep))
          }));
          return handleForbidden(result, ast, i, options);
        };
      } else {
        const from = goMemo(typeAST(ast), true);
        const to = goMemo(dropRightRefinement(ast.from), false);
        return (i, options) => handleForbidden(flatMap16(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform2 = getFinalTransformation(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
      const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
      return (i, options) => handleForbidden(flatMap16(mapError6(from(i, options), (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap16(mapError6(transform2(a, options ?? defaultParseOption, ast, i), (e) => new Transformation(ast, i, "Transformation", e)), (i2) => mapError6(to(i2, options), (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options);
    }
    case "Declaration": {
      const parse3 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden(parse3(i, options ?? defaultParseOption, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
    case "VoidKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement(ast, isString);
    case "NumberKeyword":
      return fromRefinement(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement(ast, isObject);
    case "Enums":
      return fromRefinement(ast, (u) => ast.enums.some(([_, value2]) => value2 === u));
    case "TemplateLiteral": {
      const regex = getTemplateLiteralRegExp(ast);
      return fromRefinement(ast, (u) => isString(u) && regex.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite2(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite2(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              }
              output.push([stepKey++, te.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                }
                output2.push([nk, t.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head6, ...tail] = rest;
          for (;i < len - tail.length; i++) {
            const te = head6(input[i], options);
            if (isEither4(te)) {
              if (isLeft2(te)) {
                const e = new Pointer(i, input, te.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, sortByIndex(output)));
                }
              } else {
                output.push([stepKey++, te.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t) => {
                if (isLeft2(t)) {
                  const e = new Pointer(index, input, t.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                  }
                } else {
                  output2.push([nk, t.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options);
              if (isEither4(te)) {
                if (isLeft2(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(te), (t) => {
                  if (isLeft2(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite2(ast, input, sortByIndex(es2), sortByIndex(output2))) : right2(sortByIndex(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is) => [goMemo(is.parameter, isDecoding), goMemo(is.type, isDecoding), is.parameter]);
      const expectedAST = Union.make(ast.indexSignatures.map((is) => is.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal(key))));
      const expected = goMemo(expectedAST, isDecoding);
      const concurrency = getConcurrency(ast);
      const batching = getBatching(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type2(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = Reflect.ownKeys(input);
          for (const key of inputKeys) {
            const te = expected(key, options);
            if (isEither4(te) && isLeft2(te)) {
              if (onExcessPropertyError) {
                const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite2(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer(name, input, new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          if (isEither4(te)) {
            if (isLeft2(te)) {
              const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite2(ast, input, e, output));
              }
            }
            output[name] = te.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap10(either3(te), (t) => {
              if (isLeft2(t)) {
                const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite2(ast, input, e, output2));
                }
              }
              output2[index] = t.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type = indexSignature[1];
          const keys5 = getKeysForIndexSignature(input, indexSignature[2]);
          for (const key of keys5) {
            const keu = parameter(key, options);
            if (isEither4(keu) && isRight2(keu)) {
              const vpr = type(input[key], options);
              if (isEither4(vpr)) {
                if (isLeft2(vpr)) {
                  const e = new Pointer(key, input, vpr.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite2(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = vpr.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite2(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite2(ast, input, sortByIndex(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys5 = inputKeys || Reflect.ownKeys(input);
            for (const name of expectedKeys) {
              if (keys5.indexOf(name) === -1) {
                keys5.push(name);
              }
            }
            const out = {};
            for (const key of keys5) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree(ast.types, isDecoding);
      const ownKeys = Reflect.ownKeys(searchTree.keys);
      const ownKeysLen = ownKeys.length;
      const astTypesLen = ast.types.length;
      const map24 = new Map;
      for (let i = 0;i < astTypesLen; i++) {
        map24.set(ast.types[i], goMemo(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency(ast) ?? 1;
      const batching = getBatching(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (ownKeysLen > 0) {
          if (isRecordOrArray(input)) {
            for (let i = 0;i < ownKeysLen; i++) {
              const name = ownKeys[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const literalsUnion = Union.make(literals);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union.make(candidates2);
                  es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Type2(literalsUnion, input[name])))]);
                }
              } else {
                const {
                  candidates: candidates2,
                  literals
                } = searchTree.keys[name];
                const fakePropertySignature = new PropertySignature(name, Union.make(literals), false, true);
                const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union.make(candidates2);
                es.push([stepKey++, new Composite2(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
              }
            }
          } else {
            const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union.make(searchTree.candidates);
            es.push([stepKey++, new Type2(errorAst, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map24.get(candidate)(input, options);
          if (isEither4(pr) && (!queue || queue.length === 0)) {
            if (isRight2(pr)) {
              return pr;
            } else {
              es.push([stepKey++, pr.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap10(either3(pr), (t) => {
                  if (isRight2(t)) {
                    state.finalResult = t;
                  } else {
                    state.es.push([nk, t.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite2(ast, input, sortByIndex(es2))) : left2(new Type2(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get17 = memoizeThunk(() => goMemo(ast.f(), isDecoding));
      return (a, options) => get17()(a, options);
    }
  }
};
var fromRefinement = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type2(ast, u));
var getLiterals = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation(ast);
      if (isSome2(annotation)) {
        return getLiterals(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type = isDecoding ? encodedAST(propertySignature.type) : typeAST(propertySignature.type);
        if (isLiteral(type) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type]);
        }
      }
      return out;
    }
    case "TupleType": {
      const out = [];
      for (let i = 0;i < ast.elements.length; i++) {
        const element = ast.elements[i];
        const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
        if (isLiteral(type) && !element.isOptional) {
          out.push([i, type]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals(ast.from, isDecoding);
    case "Suspend":
      return getLiterals(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree = (members, isDecoding) => {
  const keys5 = {};
  const otherwise = [];
  const candidates = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags = getLiterals(member, isDecoding);
    if (tags.length > 0) {
      candidates.push(member);
      for (let j = 0;j < tags.length; j++) {
        const [key, literal2] = tags[j];
        const hash2 = String(literal2.literal);
        keys5[key] = keys5[key] || {
          buckets: {},
          literals: [],
          candidates: []
        };
        const buckets = keys5[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
          if (j < tags.length - 1) {
            continue;
          }
          buckets[hash2].push(member);
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
        } else {
          buckets[hash2] = [member];
          keys5[key].literals.push(literal2);
          keys5[key].candidates.push(member);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys5,
    otherwise,
    candidates
  };
};
var dropRightRefinement = (ast) => isRefinement(ast) ? dropRightRefinement(ast.from) : ast;
var handleForbidden = (effect4, ast, actual, options) => {
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  if (isEither4(effect4)) {
    return effect4;
  }
  const scheduler = new SyncScheduler;
  const fiber = runFork2(effect4, {
    scheduler
  });
  scheduler.flush();
  const exit3 = fiber.unsafePoll();
  if (exit3) {
    if (isSuccess(exit3)) {
      return right2(exit3.value);
    }
    const cause3 = exit3.cause;
    if (isFailType2(cause3)) {
      return left2(cause3.error);
    }
    return left2(new Forbidden(ast, actual, pretty2(cause3)));
  }
  return left2(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
};
var compare = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
var getFinalTransformation = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map23(out, f);
        }
        return out;
      };
  }
};
var makeTree = (value2, forest = []) => ({
  value: value2,
  forest
});
var TreeFormatter = {
  formatIssue: (issue) => map23(formatTree(issue), drawTree),
  formatIssueSync: (issue) => {
    const e = TreeFormatter.formatIssue(issue);
    return isEither4(e) ? getOrThrow(e) : runSync(e);
  },
  formatError: (error2) => TreeFormatter.formatIssue(error2.issue),
  formatErrorSync: (error2) => TreeFormatter.formatIssueSync(error2.issue)
};
var drawTree = (tree) => tree.value + draw("\n", tree.forest);
var draw = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var Either_void = /* @__PURE__ */ right2(undefined);
var getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap(getMessageAnnotation), match2({
  onNone: () => Either_void,
  onSome: (messageAnnotation) => {
    const union9 = messageAnnotation(issue);
    if (isString(union9)) {
      return right2({
        message: union9,
        override: false
      });
    }
    if (isEffect2(union9)) {
      return map13(union9, (message) => ({
        message,
        override: false
      }));
    }
    if (isString(union9.message)) {
      return right2({
        message: union9.message,
        override: union9.override
      });
    }
    return map13(union9.message, (message) => ({
      message,
      override: union9.override
    }));
  }
}));
var createParseIssueGuard = (tag) => (issue) => issue._tag === tag;
var isComposite2 = /* @__PURE__ */ createParseIssueGuard("Composite");
var isRefinement2 = /* @__PURE__ */ createParseIssueGuard("Refinement");
var isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
var getMessage = (issue) => flatMap16(getCurrentMessage(issue), (currentMessage) => {
  if (currentMessage !== undefined) {
    const useInnerMessage = !currentMessage.override && (isComposite2(issue) || isRefinement2(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
    return useInnerMessage ? isTransformation(issue) || isRefinement2(issue) ? getMessage(issue.issue) : Either_void : right2(currentMessage.message);
  }
  return Either_void;
});
var getParseIssueTitleAnnotation2 = (issue) => getAnnotated(issue).pipe(flatMap(getParseIssueTitleAnnotation), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
var formatTypeMessage = (issue) => map23(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation2(issue) ?? getDefaultTypeMessage(issue));
var getParseIssueTitle = (issue) => getParseIssueTitleAnnotation2(issue) ?? String(issue.ast);
var formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
var formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
var formatMissingMessage = (issue) => {
  const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
  if (isSome2(missingMessageAnnotation)) {
    const annotation = missingMessageAnnotation.value();
    return isString(annotation) ? right2(annotation) : annotation;
  }
  return right2(issue.message ?? "is missing");
};
var formatTree = (issue) => {
  switch (issue._tag) {
    case "Type":
      return map23(formatTypeMessage(issue), makeTree);
    case "Forbidden":
      return right2(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
    case "Unexpected":
      return right2(makeTree(formatUnexpectedMessage(issue)));
    case "Missing":
      return map23(formatMissingMessage(issue), makeTree);
    case "Transformation":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
      });
    case "Refinement":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        return map23(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
      });
    case "Pointer":
      return map23(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
    case "Composite":
      return flatMap16(getMessage(issue), (message) => {
        if (message !== undefined) {
          return right2(makeTree(message));
        }
        const parseIssueTitle = getParseIssueTitle(issue);
        return isNonEmpty(issue.issues) ? map23(forEach8(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map23(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
      });
  }
};
// node_modules/effect/dist/esm/internal/pool.js
var PoolTypeId = /* @__PURE__ */ Symbol.for("effect/Pool");
var poolVariance = {
  _E: (_) => _,
  _A: (_) => _
};
class PoolImpl extends Class {
  scope;
  acquire;
  concurrency;
  minSize;
  maxSize;
  strategy;
  targetUtilization;
  [PoolTypeId];
  isShuttingDown = false;
  semaphore;
  items = /* @__PURE__ */ new Set;
  available = /* @__PURE__ */ new Set;
  availableLatch = /* @__PURE__ */ unsafeMakeLatch(false);
  invalidated = /* @__PURE__ */ new Set;
  waiters = 0;
  constructor(scope5, acquire, concurrency, minSize, maxSize, strategy, targetUtilization) {
    super();
    this.scope = scope5;
    this.acquire = acquire;
    this.concurrency = concurrency;
    this.minSize = minSize;
    this.maxSize = maxSize;
    this.strategy = strategy;
    this.targetUtilization = targetUtilization;
    this[PoolTypeId] = poolVariance;
    this.semaphore = unsafeMakeSemaphore(concurrency * maxSize);
  }
  allocate = /* @__PURE__ */ acquireUseRelease(/* @__PURE__ */ scopeMake(), (scope5) => this.acquire.pipe(scopeExtend(scope5), exit, flatMap7((exit3) => {
    const item = {
      exit: exit3,
      finalizer: catchAllCause(scope5.close(exit3), reportUnhandledError),
      refCount: 0,
      disableReclaim: false
    };
    this.items.add(item);
    this.available.add(item);
    return as(exit3._tag === "Success" ? this.strategy.onAcquire(item) : zipRight(item.finalizer, this.strategy.onAcquire(item)), item);
  })), (scope5, exit3) => exit3._tag === "Failure" ? scope5.close(exit3) : void_);
  get currentUsage() {
    let count4 = this.waiters;
    for (const item of this.items) {
      count4 += item.refCount;
    }
    return count4;
  }
  get targetSize() {
    if (this.isShuttingDown)
      return 0;
    const utilization = this.currentUsage / this.targetUtilization;
    const target = Math.ceil(utilization / this.concurrency);
    return Math.min(Math.max(this.minSize, target), this.maxSize);
  }
  get activeSize() {
    return this.items.size - this.invalidated.size;
  }
  resizeLoop = /* @__PURE__ */ suspend(() => {
    if (this.activeSize >= this.targetSize) {
      return void_;
    }
    const toAcquire = this.targetSize - this.activeSize;
    return this.strategy.reclaim(this).pipe(flatMap7(match2({
      onNone: () => this.allocate,
      onSome: succeed
    })), replicateEffect(toAcquire, {
      concurrency: toAcquire
    }), zipLeft(this.availableLatch.open), flatMap7((items) => items.some((_) => _.exit._tag === "Failure") ? void_ : this.resizeLoop));
  });
  resizeSemaphore = /* @__PURE__ */ unsafeMakeSemaphore(1);
  resize = /* @__PURE__ */ this.resizeSemaphore.withPermits(1)(this.resizeLoop);
  getPoolItem = /* @__PURE__ */ uninterruptibleMask((restore) => restore(this.semaphore.take(1)).pipe(zipRight(scopeTag), flatMap7((scope5) => suspend(() => {
    this.waiters++;
    if (this.isShuttingDown) {
      return interrupt2;
    } else if (this.targetSize > this.activeSize) {
      const self2 = this;
      return flatMap7(this.resizeSemaphore.withPermitsIfAvailable(1)(forkIn(interruptible2(this.resize), this.scope)), function loop() {
        if (self2.isShuttingDown) {
          return interrupt2;
        } else if (self2.available.size > 0) {
          return succeed(unsafeHead(self2.available));
        }
        self2.availableLatch.unsafeClose();
        return flatMap7(self2.availableLatch.await, loop);
      });
    }
    return succeed(unsafeHead(this.available));
  }).pipe(ensuring(sync(() => this.waiters--)), tap((item) => {
    if (item.exit._tag === "Failure") {
      this.items.delete(item);
      this.invalidated.delete(item);
      this.available.delete(item);
      return this.semaphore.release(1);
    }
    item.refCount++;
    this.available.delete(item);
    if (item.refCount < this.concurrency) {
      this.available.add(item);
    }
    return scope5.addFinalizer(() => zipRight(suspend(() => {
      item.refCount--;
      if (this.invalidated.has(item)) {
        return this.invalidatePoolItem(item);
      }
      this.available.add(item);
      return exitVoid;
    }), this.semaphore.release(1)));
  }), onInterrupt(() => this.semaphore.release(1))))));
  commit() {
    return this.get;
  }
  get = /* @__PURE__ */ flatMap7(/* @__PURE__ */ suspend(() => this.isShuttingDown ? interrupt2 : this.getPoolItem), (_) => _.exit);
  invalidate(item) {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      for (const poolItem of this.items) {
        if (poolItem.exit._tag === "Success" && poolItem.exit.value === item) {
          poolItem.disableReclaim = true;
          return uninterruptible(this.invalidatePoolItem(poolItem));
        }
      }
      return void_;
    });
  }
  invalidatePoolItem(poolItem) {
    return suspend(() => {
      if (!this.items.has(poolItem)) {
        return void_;
      } else if (poolItem.refCount === 0) {
        this.items.delete(poolItem);
        this.available.delete(poolItem);
        this.invalidated.delete(poolItem);
        return zipRight(poolItem.finalizer, forkIn(interruptible2(this.resize), this.scope));
      }
      this.invalidated.add(poolItem);
      this.available.delete(poolItem);
      return void_;
    });
  }
  get shutdown() {
    return suspend(() => {
      if (this.isShuttingDown)
        return void_;
      this.isShuttingDown = true;
      const size16 = this.items.size;
      const semaphore = unsafeMakeSemaphore(size16);
      return forEachSequentialDiscard(this.items, (item) => {
        if (item.refCount > 0) {
          item.finalizer = zipLeft(item.finalizer, semaphore.release(1));
          this.invalidated.add(item);
          return semaphore.take(1);
        }
        this.items.delete(item);
        this.available.delete(item);
        this.invalidated.delete(item);
        return item.finalizer;
      }).pipe(zipRight(this.semaphore.releaseAll), zipRight(this.availableLatch.open), zipRight(semaphore.take(size16)));
    });
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
}
var reportUnhandledError = (cause3) => withFiberRuntime((fiber) => {
  const unhandledLogLevel = fiber.getFiberRef(currentUnhandledErrorLogLevel);
  if (unhandledLogLevel._tag === "Some") {
    fiber.log("Unhandled error in pool finalizer", cause3, unhandledLogLevel);
  }
  return void_;
});
// node_modules/effect/dist/esm/internal/managedRuntime.js
var ManagedRuntimeProto = {
  ...CommitPrototype2,
  [TypeId16]: TypeId16,
  pipe() {
    return pipeArguments(this, arguments);
  },
  commit() {
    return this.runtimeEffect;
  }
};
// node_modules/effect/dist/esm/internal/matcher.js
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
function makeValueMatcher(provided, value2) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value2;
  return matcher;
}
var TypeId27 = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId27]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var ValueMatcherProto = {
  [TypeId27]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right2(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/MutableHashSet.js
var TypeId28 = /* @__PURE__ */ Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId28]: TypeId28,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/Redacted.js
var isRedacted2 = isRedacted;
var make66 = make52;
var value4 = value;
var getEquivalence7 = (isEquivalent) => make((x, y) => isEquivalent(value4(x), value4(y)));
// node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = /* @__PURE__ */ Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  _A: (_) => _
};
var proto14 = {
  ...CommitPrototype,
  commit() {
    return get21(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var get21 = (self2) => map9(get11(self2.ref), (tuple3) => tuple3[1]);
// node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = /* @__PURE__ */ Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  _E: (_) => _,
  _A: (_) => _
};
var proto15 = {
  ...CommitPrototype,
  commit() {
    return get23(this);
  },
  [ResourceTypeId]: resourceVariance
};
var get23 = (self2) => flatMap7(get21(self2.scopedRef), identity);
// node_modules/effect/dist/esm/Struct.js
var pick3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys7) => {
  const out = {};
  for (const k of keys7) {
    if (k in s) {
      out[k] = s[k];
    }
  }
  return out;
});
var omit3 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys7) => {
  const out = {
    ...s
  };
  for (const k of keys7) {
    delete out[k];
  }
  return out;
});

// node_modules/effect/dist/esm/Schema.js
function make68(ast) {
  return class SchemaClass {
    [TypeId29] = variance9;
    static ast = ast;
    static annotations(annotations2) {
      return make68(mergeSchemaAnnotations(this.ast, annotations2));
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static toString() {
      return String(ast);
    }
    static Type;
    static Encoded;
    static Context;
    static [TypeId29] = variance9;
  };
}
function makeDeclareClass(typeParameters, ast) {
  return class DeclareClass extends make68(ast) {
    static annotations(annotations2) {
      return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static typeParameters = [...typeParameters];
  };
}
function makeRefineClass(from, filter12, ast) {
  return class RefineClass extends make68(ast) {
    static annotations(annotations2) {
      return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
    }
    static [RefineSchemaId] = from;
    static from = from;
    static filter = filter12;
    static make = (a, options) => {
      return getDisableValidationMakeOption(options) ? a : validateSync(this)(a);
    };
  };
}
function filter12(predicate, annotations2) {
  return (self2) => {
    function filter13(input, options, ast2) {
      return toFilterParseIssue(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement(self2.ast, filter13, toASTAnnotations(annotations2));
    return makeRefineClass(self2, filter13, ast);
  };
}
function getDisableValidationMakeOption(options) {
  return isBoolean(options) ? options : options?.disableValidation ?? false;
}
var TypeId29 = /* @__PURE__ */ Symbol.for("effect/Schema");
var variance9 = {
  _A: (_) => _,
  _I: (_) => _,
  _R: (_) => _
};
var builtInAnnotations = {
  schemaId: SchemaIdAnnotationId,
  message: MessageAnnotationId,
  missingMessage: MissingMessageAnnotationId,
  identifier: IdentifierAnnotationId,
  title: TitleAnnotationId,
  description: DescriptionAnnotationId,
  examples: ExamplesAnnotationId,
  default: DefaultAnnotationId,
  documentation: DocumentationAnnotationId,
  jsonSchema: JSONSchemaAnnotationId,
  arbitrary: ArbitraryAnnotationId,
  pretty: PrettyAnnotationId,
  equivalence: EquivalenceAnnotationId,
  concurrency: ConcurrencyAnnotationId,
  batching: BatchingAnnotationId,
  parseIssueTitle: ParseIssueTitleAnnotationId,
  parseOptions: ParseOptionsAnnotationId,
  decodingFallback: DecodingFallbackAnnotationId
};
var toASTAnnotations = (annotations2) => {
  if (!annotations2) {
    return {};
  }
  const out = {
    ...annotations2
  };
  for (const key in builtInAnnotations) {
    if (key in annotations2) {
      const id2 = builtInAnnotations[key];
      out[id2] = annotations2[key];
      delete out[key];
    }
  }
  return out;
};
var mergeSchemaAnnotations = (ast, annotations2) => annotations(ast, toASTAnnotations(annotations2));
var declareConstructor = (typeParameters, options, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make68)), (...typeParameters2) => options.encode(...typeParameters2.map(make68)), toASTAnnotations(annotations2)));
var declarePrimitive = (is3, annotations2) => {
  const decodeUnknown3 = () => (input, _, ast) => is3(input) ? succeed15(input) : fail16(new Type2(ast, input));
  const encodeUnknown2 = decodeUnknown3;
  return makeDeclareClass([], new Declaration([], decodeUnknown3, encodeUnknown2, toASTAnnotations(annotations2)));
};
var declare = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations3 = arguments[2];
    return declareConstructor(typeParameters, options, annotations3);
  }
  const is3 = arguments[0];
  const annotations2 = arguments[1];
  return declarePrimitive(is3, annotations2);
};
class String$ extends (/* @__PURE__ */ make68(stringKeyword)) {
}
var RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
var fromFilterPredicateReturnTypeItem = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type2(ast, input));
  }
  if (isString(item)) {
    return some2(new Type2(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type2(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue = (out, ast, input) => {
  if (isSingle(out)) {
    return fromFilterPredicateReturnTypeItem(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite2(ast, input, issues));
    }
  }
  return none2();
};
var PatternSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Pattern");
var pattern = (regex, annotations2) => (self2) => {
  const source = regex.source;
  return self2.pipe(filter12((a) => {
    regex.lastIndex = 0;
    return regex.test(a);
  }, {
    schemaId: PatternSchemaId,
    [PatternSchemaId]: {
      regex
    },
    description: `a string matching the pattern ${source}`,
    jsonSchema: {
      pattern: source
    },
    ...annotations2
  }));
};
var UUIDSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/UUID");
var uuidRegexp = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID extends (/* @__PURE__ */ String$.pipe(/* @__PURE__ */ pattern(uuidRegexp, {
  schemaId: UUIDSchemaId,
  identifier: "UUID",
  jsonSchema: {
    format: "uuid",
    pattern: uuidRegexp.source
  },
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var DateFromSelfSchemaId2 = DateFromSelfSchemaId;

class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
  identifier: "DateFromSelf",
  schemaId: DateFromSelfSchemaId2,
  [DateFromSelfSchemaId2]: {
    noInvalidDate: false
  },
  description: "a potentially invalid Date instance",
  pretty: () => (date2) => `new Date(${JSON.stringify(date2)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}
// node_modules/effect/dist/esm/SortedMap.js
var TypeId30 = /* @__PURE__ */ Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId30]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol]() {
    return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
  },
  [symbol2](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var isSortedMap = (u) => hasProperty(u, TypeId30);
// node_modules/effect/dist/esm/Subscribable.js
var TypeId31 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
var Proto7 = {
  [TypeId13]: TypeId13,
  [TypeId31]: TypeId31,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
// node_modules/effect/dist/esm/TestClock.js
var warning = "Warning: A test is using time, but is not advancing " + "the test clock, which may result in the test hanging. Use TestClock.adjust to " + "manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, " + "but a fiber is not suspending, which may result in the test hanging. Use " + "TestAspect.diagnose to identity the fiber that is not suspending.";
// node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = /* @__PURE__ */ Symbol.for(TrieSymbolKey);
var trieVariance = {
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol]() {
    let hash2 = hash(TrieSymbolKey);
    for (const item of this) {
      hash2 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash2);
  },
  [symbol2](that) {
    if (isTrie(that)) {
      const entries2 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries2[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
class TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter15) {
    this.trie = trie;
    this.f = f;
    this.filter = filter15;
    const root = trie._root !== undefined ? trie._root : undefined;
    if (root !== undefined) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value6 = node.value;
        if (value6 !== undefined) {
          const key = keyString + node.key;
          if (this.filter(key, value6)) {
            return {
              done: false,
              value: this.f(key, value6)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: undefined
    };
  }
  addToStack(node, keyString) {
    if (node.right !== undefined) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== undefined) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== undefined) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new TrieIterator(this.trie, this.f, this.filter);
  }
}
var isTrie = (u) => hasProperty(u, TrieTypeId);
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined,
  IsUint8Array: () => IsUint8Array,
  IsSymbol: () => IsSymbol,
  IsString: () => IsString,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject,
  IsNumber: () => IsNumber,
  IsNull: () => IsNull,
  IsIterator: () => IsIterator,
  IsFunction: () => IsFunction,
  IsDate: () => IsDate,
  IsBoolean: () => IsBoolean,
  IsBigInt: () => IsBigInt,
  IsAsyncIterator: () => IsAsyncIterator,
  IsArray: () => IsArray,
  HasPropertyKey: () => HasPropertyKey
});
function HasPropertyKey(value6, key) {
  return key in value6;
}
function IsAsyncIterator(value6) {
  return IsObject(value6) && !IsArray(value6) && !IsUint8Array(value6) && Symbol.asyncIterator in value6;
}
function IsArray(value6) {
  return Array.isArray(value6);
}
function IsBigInt(value6) {
  return typeof value6 === "bigint";
}
function IsBoolean(value6) {
  return typeof value6 === "boolean";
}
function IsDate(value6) {
  return value6 instanceof globalThis.Date;
}
function IsFunction(value6) {
  return typeof value6 === "function";
}
function IsIterator(value6) {
  return IsObject(value6) && !IsArray(value6) && !IsUint8Array(value6) && Symbol.iterator in value6;
}
function IsNull(value6) {
  return value6 === null;
}
function IsNumber(value6) {
  return typeof value6 === "number";
}
function IsObject(value6) {
  return typeof value6 === "object" && value6 !== null;
}
function IsRegExp(value6) {
  return value6 instanceof globalThis.RegExp;
}
function IsString(value6) {
  return typeof value6 === "string";
}
function IsSymbol(value6) {
  return typeof value6 === "symbol";
}
function IsUint8Array(value6) {
  return value6 instanceof globalThis.Uint8Array;
}
function IsUndefined(value6) {
  return value6 === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value6) {
  return value6.map((value7) => Visit(value7));
}
function DateType(value6) {
  return new Date(value6.getTime());
}
function Uint8ArrayType(value6) {
  return new Uint8Array(value6);
}
function RegExpType(value6) {
  return new RegExp(value6.source, value6.flags);
}
function ObjectType(value6) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value6)) {
    result[key] = Visit(value6[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value6)) {
    result[key] = Visit(value6[key]);
  }
  return result;
}
function Visit(value6) {
  return IsArray(value6) ? ArrayType(value6) : IsDate(value6) ? DateType(value6) : IsUint8Array(value6) ? Uint8ArrayType(value6) : IsRegExp(value6) ? RegExpType(value6) : IsObject(value6) ? ObjectType(value6) : value6;
}
function Clone(value6) {
  return Visit(value6);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneType(schema, options) {
  return options === undefined ? Clone(schema) : Clone({ ...options, ...schema });
}

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator2(value6) {
  return IsObject2(value6) && globalThis.Symbol.asyncIterator in value6;
}
function IsIterator2(value6) {
  return IsObject2(value6) && globalThis.Symbol.iterator in value6;
}
function IsStandardObject(value6) {
  return IsObject2(value6) && (globalThis.Object.getPrototypeOf(value6) === Object.prototype || globalThis.Object.getPrototypeOf(value6) === null);
}
function IsPromise(value6) {
  return value6 instanceof globalThis.Promise;
}
function IsDate2(value6) {
  return value6 instanceof Date && globalThis.Number.isFinite(value6.getTime());
}
function IsMap(value6) {
  return value6 instanceof globalThis.Map;
}
function IsSet(value6) {
  return value6 instanceof globalThis.Set;
}
function IsTypedArray(value6) {
  return globalThis.ArrayBuffer.isView(value6);
}
function IsUint8Array2(value6) {
  return value6 instanceof globalThis.Uint8Array;
}
function HasPropertyKey2(value6, key) {
  return key in value6;
}
function IsObject2(value6) {
  return value6 !== null && typeof value6 === "object";
}
function IsArray2(value6) {
  return globalThis.Array.isArray(value6) && !globalThis.ArrayBuffer.isView(value6);
}
function IsUndefined2(value6) {
  return value6 === undefined;
}
function IsNull2(value6) {
  return value6 === null;
}
function IsBoolean2(value6) {
  return typeof value6 === "boolean";
}
function IsNumber2(value6) {
  return typeof value6 === "number";
}
function IsInteger(value6) {
  return globalThis.Number.isInteger(value6);
}
function IsBigInt2(value6) {
  return typeof value6 === "bigint";
}
function IsString2(value6) {
  return typeof value6 === "string";
}
function IsFunction2(value6) {
  return typeof value6 === "function";
}
function IsSymbol2(value6) {
  return typeof value6 === "symbol";
}
function IsValueType(value6) {
  return IsBigInt2(value6) || IsBoolean2(value6) || IsNull2(value6) || IsNumber2(value6) || IsString2(value6) || IsSymbol2(value6) || IsUndefined2(value6);
}

// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.InstanceMode = "default";
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value6, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value6 : value6[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value6) {
    const isObject2 = IsObject2(value6);
    return TypeSystemPolicy2.AllowArrayObject ? isObject2 : isObject2 && !IsArray2(value6);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value6) {
    return IsObjectLike(value6) && !(value6 instanceof Date) && !(value6 instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value6) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber2(value6) : Number.isFinite(value6);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value6) {
    const isUndefined2 = IsUndefined2(value6);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined2 || value6 === null : isUndefined2;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));

// node_modules/@sinclair/typebox/build/esm/type/create/immutable.mjs
function ImmutableArray(value6) {
  return globalThis.Object.freeze(value6).map((value7) => Immutable(value7));
}
function ImmutableDate(value6) {
  return value6;
}
function ImmutableUint8Array(value6) {
  return value6;
}
function ImmutableRegExp(value6) {
  return value6;
}
function ImmutableObject(value6) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value6)) {
    result[key] = Immutable(value6[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value6)) {
    result[key] = Immutable(value6[key]);
  }
  return globalThis.Object.freeze(result);
}
function Immutable(value6) {
  return IsArray(value6) ? ImmutableArray(value6) : IsDate(value6) ? ImmutableDate(value6) : IsUint8Array(value6) ? ImmutableUint8Array(value6) : IsRegExp(value6) ? ImmutableRegExp(value6) : IsObject(value6) ? ImmutableObject(value6) : value6;
}

// node_modules/@sinclair/typebox/build/esm/type/create/type.mjs
function CreateType(schema, options) {
  const result = options !== undefined ? { ...options, ...schema } : schema;
  switch (TypeSystemPolicy.InstanceMode) {
    case "freeze":
      return Immutable(result);
    case "clone":
      return Clone(result);
    default:
      return result;
  }
}

// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");

// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value6) {
  return IsObject(value6) && value6[ReadonlyKind] === "Readonly";
}
function IsOptional(value6) {
  return IsObject(value6) && value6[OptionalKind] === "Optional";
}
function IsAny(value6) {
  return IsKindOf(value6, "Any");
}
function IsArgument(value6) {
  return IsKindOf(value6, "Argument");
}
function IsArray3(value6) {
  return IsKindOf(value6, "Array");
}
function IsAsyncIterator3(value6) {
  return IsKindOf(value6, "AsyncIterator");
}
function IsBigInt3(value6) {
  return IsKindOf(value6, "BigInt");
}
function IsBoolean3(value6) {
  return IsKindOf(value6, "Boolean");
}
function IsComputed(value6) {
  return IsKindOf(value6, "Computed");
}
function IsConstructor(value6) {
  return IsKindOf(value6, "Constructor");
}
function IsDate3(value6) {
  return IsKindOf(value6, "Date");
}
function IsFunction3(value6) {
  return IsKindOf(value6, "Function");
}
function IsInteger2(value6) {
  return IsKindOf(value6, "Integer");
}
function IsIntersect(value6) {
  return IsKindOf(value6, "Intersect");
}
function IsIterator3(value6) {
  return IsKindOf(value6, "Iterator");
}
function IsKindOf(value6, kind) {
  return IsObject(value6) && Kind in value6 && value6[Kind] === kind;
}
function IsLiteralValue(value6) {
  return IsBoolean(value6) || IsNumber(value6) || IsString(value6);
}
function IsLiteral(value6) {
  return IsKindOf(value6, "Literal");
}
function IsMappedKey(value6) {
  return IsKindOf(value6, "MappedKey");
}
function IsMappedResult(value6) {
  return IsKindOf(value6, "MappedResult");
}
function IsNever(value6) {
  return IsKindOf(value6, "Never");
}
function IsNot(value6) {
  return IsKindOf(value6, "Not");
}
function IsNull3(value6) {
  return IsKindOf(value6, "Null");
}
function IsNumber3(value6) {
  return IsKindOf(value6, "Number");
}
function IsObject3(value6) {
  return IsKindOf(value6, "Object");
}
function IsPromise2(value6) {
  return IsKindOf(value6, "Promise");
}
function IsRecord(value6) {
  return IsKindOf(value6, "Record");
}
function IsRef(value6) {
  return IsKindOf(value6, "Ref");
}
function IsRegExp2(value6) {
  return IsKindOf(value6, "RegExp");
}
function IsString3(value6) {
  return IsKindOf(value6, "String");
}
function IsSymbol3(value6) {
  return IsKindOf(value6, "Symbol");
}
function IsTemplateLiteral(value6) {
  return IsKindOf(value6, "TemplateLiteral");
}
function IsThis(value6) {
  return IsKindOf(value6, "This");
}
function IsTransform(value6) {
  return IsObject(value6) && TransformKind in value6;
}
function IsTuple(value6) {
  return IsKindOf(value6, "Tuple");
}
function IsUndefined3(value6) {
  return IsKindOf(value6, "Undefined");
}
function IsUnion(value6) {
  return IsKindOf(value6, "Union");
}
function IsUint8Array3(value6) {
  return IsKindOf(value6, "Uint8Array");
}
function IsUnknown(value6) {
  return IsKindOf(value6, "Unknown");
}
function IsUnsafe(value6) {
  return IsKindOf(value6, "Unsafe");
}
function IsVoid(value6) {
  return IsKindOf(value6, "Void");
}
function IsKind(value6) {
  return IsObject(value6) && Kind in value6 && IsString(value6[Kind]);
}
function IsSchema(value6) {
  return IsAny(value6) || IsArgument(value6) || IsArray3(value6) || IsBoolean3(value6) || IsBigInt3(value6) || IsAsyncIterator3(value6) || IsComputed(value6) || IsConstructor(value6) || IsDate3(value6) || IsFunction3(value6) || IsInteger2(value6) || IsIntersect(value6) || IsIterator3(value6) || IsLiteral(value6) || IsMappedKey(value6) || IsMappedResult(value6) || IsNever(value6) || IsNot(value6) || IsNull3(value6) || IsNumber3(value6) || IsObject3(value6) || IsPromise2(value6) || IsRecord(value6) || IsRef(value6) || IsRegExp2(value6) || IsString3(value6) || IsSymbol3(value6) || IsTemplateLiteral(value6) || IsThis(value6) || IsTuple(value6) || IsUndefined3(value6) || IsUnion(value6) || IsUint8Array3(value6) || IsUnknown(value6) || IsUnsafe(value6) || IsVoid(value6) || IsKind(value6);
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type = {};
__export(exports_type, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue2,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsImport: () => IsImport,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsComputed: () => IsComputed2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsArgument: () => IsArgument2,
  IsAny: () => IsAny2
});
function IsPattern(value6) {
  try {
    new RegExp(value6);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value6) {
  if (!IsString(value6))
    return false;
  for (let i = 0;i < value6.length; i++) {
    const code = value6.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value6) {
  return IsOptionalBoolean(value6) || IsSchema2(value6);
}
function IsOptionalBigInt(value6) {
  return IsUndefined(value6) || IsBigInt(value6);
}
function IsOptionalNumber(value6) {
  return IsUndefined(value6) || IsNumber(value6);
}
function IsOptionalBoolean(value6) {
  return IsUndefined(value6) || IsBoolean(value6);
}
function IsOptionalString(value6) {
  return IsUndefined(value6) || IsString(value6);
}
function IsOptionalPattern(value6) {
  return IsUndefined(value6) || IsString(value6) && IsControlCharacterFree(value6) && IsPattern(value6);
}
function IsOptionalFormat(value6) {
  return IsUndefined(value6) || IsString(value6) && IsControlCharacterFree(value6);
}
function IsOptionalSchema(value6) {
  return IsUndefined(value6) || IsSchema2(value6);
}
function IsReadonly2(value6) {
  return IsObject(value6) && value6[ReadonlyKind] === "Readonly";
}
function IsOptional2(value6) {
  return IsObject(value6) && value6[OptionalKind] === "Optional";
}
function IsAny2(value6) {
  return IsKindOf2(value6, "Any") && IsOptionalString(value6.$id);
}
function IsArgument2(value6) {
  return IsKindOf2(value6, "Argument") && IsNumber(value6.index);
}
function IsArray4(value6) {
  return IsKindOf2(value6, "Array") && value6.type === "array" && IsOptionalString(value6.$id) && IsSchema2(value6.items) && IsOptionalNumber(value6.minItems) && IsOptionalNumber(value6.maxItems) && IsOptionalBoolean(value6.uniqueItems) && IsOptionalSchema(value6.contains) && IsOptionalNumber(value6.minContains) && IsOptionalNumber(value6.maxContains);
}
function IsAsyncIterator4(value6) {
  return IsKindOf2(value6, "AsyncIterator") && value6.type === "AsyncIterator" && IsOptionalString(value6.$id) && IsSchema2(value6.items);
}
function IsBigInt4(value6) {
  return IsKindOf2(value6, "BigInt") && value6.type === "bigint" && IsOptionalString(value6.$id) && IsOptionalBigInt(value6.exclusiveMaximum) && IsOptionalBigInt(value6.exclusiveMinimum) && IsOptionalBigInt(value6.maximum) && IsOptionalBigInt(value6.minimum) && IsOptionalBigInt(value6.multipleOf);
}
function IsBoolean4(value6) {
  return IsKindOf2(value6, "Boolean") && value6.type === "boolean" && IsOptionalString(value6.$id);
}
function IsComputed2(value6) {
  return IsKindOf2(value6, "Computed") && IsString(value6.target) && IsArray(value6.parameters) && value6.parameters.every((schema) => IsSchema2(schema));
}
function IsConstructor2(value6) {
  return IsKindOf2(value6, "Constructor") && value6.type === "Constructor" && IsOptionalString(value6.$id) && IsArray(value6.parameters) && value6.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value6.returns);
}
function IsDate4(value6) {
  return IsKindOf2(value6, "Date") && value6.type === "Date" && IsOptionalString(value6.$id) && IsOptionalNumber(value6.exclusiveMaximumTimestamp) && IsOptionalNumber(value6.exclusiveMinimumTimestamp) && IsOptionalNumber(value6.maximumTimestamp) && IsOptionalNumber(value6.minimumTimestamp) && IsOptionalNumber(value6.multipleOfTimestamp);
}
function IsFunction4(value6) {
  return IsKindOf2(value6, "Function") && value6.type === "Function" && IsOptionalString(value6.$id) && IsArray(value6.parameters) && value6.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value6.returns);
}
function IsImport(value6) {
  return IsKindOf2(value6, "Import") && HasPropertyKey(value6, "$defs") && IsObject(value6.$defs) && IsProperties(value6.$defs) && HasPropertyKey(value6, "$ref") && IsString(value6.$ref) && value6.$ref in value6.$defs;
}
function IsInteger3(value6) {
  return IsKindOf2(value6, "Integer") && value6.type === "integer" && IsOptionalString(value6.$id) && IsOptionalNumber(value6.exclusiveMaximum) && IsOptionalNumber(value6.exclusiveMinimum) && IsOptionalNumber(value6.maximum) && IsOptionalNumber(value6.minimum) && IsOptionalNumber(value6.multipleOf);
}
function IsProperties(value6) {
  return IsObject(value6) && Object.entries(value6).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value6) {
  return IsKindOf2(value6, "Intersect") && (IsString(value6.type) && value6.type !== "object" ? false : true) && IsArray(value6.allOf) && value6.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value6.type) && (IsOptionalBoolean(value6.unevaluatedProperties) || IsOptionalSchema(value6.unevaluatedProperties)) && IsOptionalString(value6.$id);
}
function IsIterator4(value6) {
  return IsKindOf2(value6, "Iterator") && value6.type === "Iterator" && IsOptionalString(value6.$id) && IsSchema2(value6.items);
}
function IsKindOf2(value6, kind) {
  return IsObject(value6) && Kind in value6 && value6[Kind] === kind;
}
function IsLiteralString(value6) {
  return IsLiteral2(value6) && IsString(value6.const);
}
function IsLiteralNumber(value6) {
  return IsLiteral2(value6) && IsNumber(value6.const);
}
function IsLiteralBoolean(value6) {
  return IsLiteral2(value6) && IsBoolean(value6.const);
}
function IsLiteral2(value6) {
  return IsKindOf2(value6, "Literal") && IsOptionalString(value6.$id) && IsLiteralValue2(value6.const);
}
function IsLiteralValue2(value6) {
  return IsBoolean(value6) || IsNumber(value6) || IsString(value6);
}
function IsMappedKey2(value6) {
  return IsKindOf2(value6, "MappedKey") && IsArray(value6.keys) && value6.keys.every((key) => IsNumber(key) || IsString(key));
}
function IsMappedResult2(value6) {
  return IsKindOf2(value6, "MappedResult") && IsProperties(value6.properties);
}
function IsNever2(value6) {
  return IsKindOf2(value6, "Never") && IsObject(value6.not) && Object.getOwnPropertyNames(value6.not).length === 0;
}
function IsNot2(value6) {
  return IsKindOf2(value6, "Not") && IsSchema2(value6.not);
}
function IsNull4(value6) {
  return IsKindOf2(value6, "Null") && value6.type === "null" && IsOptionalString(value6.$id);
}
function IsNumber4(value6) {
  return IsKindOf2(value6, "Number") && value6.type === "number" && IsOptionalString(value6.$id) && IsOptionalNumber(value6.exclusiveMaximum) && IsOptionalNumber(value6.exclusiveMinimum) && IsOptionalNumber(value6.maximum) && IsOptionalNumber(value6.minimum) && IsOptionalNumber(value6.multipleOf);
}
function IsObject4(value6) {
  return IsKindOf2(value6, "Object") && value6.type === "object" && IsOptionalString(value6.$id) && IsProperties(value6.properties) && IsAdditionalProperties(value6.additionalProperties) && IsOptionalNumber(value6.minProperties) && IsOptionalNumber(value6.maxProperties);
}
function IsPromise3(value6) {
  return IsKindOf2(value6, "Promise") && value6.type === "Promise" && IsOptionalString(value6.$id) && IsSchema2(value6.item);
}
function IsRecord2(value6) {
  return IsKindOf2(value6, "Record") && value6.type === "object" && IsOptionalString(value6.$id) && IsAdditionalProperties(value6.additionalProperties) && IsObject(value6.patternProperties) && ((schema) => {
    const keys9 = Object.getOwnPropertyNames(schema.patternProperties);
    return keys9.length === 1 && IsPattern(keys9[0]) && IsObject(schema.patternProperties) && IsSchema2(schema.patternProperties[keys9[0]]);
  })(value6);
}
function IsRecursive(value6) {
  return IsObject(value6) && Hint in value6 && value6[Hint] === "Recursive";
}
function IsRef2(value6) {
  return IsKindOf2(value6, "Ref") && IsOptionalString(value6.$id) && IsString(value6.$ref);
}
function IsRegExp3(value6) {
  return IsKindOf2(value6, "RegExp") && IsOptionalString(value6.$id) && IsString(value6.source) && IsString(value6.flags) && IsOptionalNumber(value6.maxLength) && IsOptionalNumber(value6.minLength);
}
function IsString4(value6) {
  return IsKindOf2(value6, "String") && value6.type === "string" && IsOptionalString(value6.$id) && IsOptionalNumber(value6.minLength) && IsOptionalNumber(value6.maxLength) && IsOptionalPattern(value6.pattern) && IsOptionalFormat(value6.format);
}
function IsSymbol4(value6) {
  return IsKindOf2(value6, "Symbol") && value6.type === "symbol" && IsOptionalString(value6.$id);
}
function IsTemplateLiteral2(value6) {
  return IsKindOf2(value6, "TemplateLiteral") && value6.type === "string" && IsString(value6.pattern) && value6.pattern[0] === "^" && value6.pattern[value6.pattern.length - 1] === "$";
}
function IsThis2(value6) {
  return IsKindOf2(value6, "This") && IsOptionalString(value6.$id) && IsString(value6.$ref);
}
function IsTransform2(value6) {
  return IsObject(value6) && TransformKind in value6;
}
function IsTuple2(value6) {
  return IsKindOf2(value6, "Tuple") && value6.type === "array" && IsOptionalString(value6.$id) && IsNumber(value6.minItems) && IsNumber(value6.maxItems) && value6.minItems === value6.maxItems && (IsUndefined(value6.items) && IsUndefined(value6.additionalItems) && value6.minItems === 0 || IsArray(value6.items) && value6.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value6) {
  return IsKindOf2(value6, "Undefined") && value6.type === "undefined" && IsOptionalString(value6.$id);
}
function IsUnionLiteral(value6) {
  return IsUnion2(value6) && value6.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value6) {
  return IsKindOf2(value6, "Union") && IsOptionalString(value6.$id) && IsObject(value6) && IsArray(value6.anyOf) && value6.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value6) {
  return IsKindOf2(value6, "Uint8Array") && value6.type === "Uint8Array" && IsOptionalString(value6.$id) && IsOptionalNumber(value6.minByteLength) && IsOptionalNumber(value6.maxByteLength);
}
function IsUnknown2(value6) {
  return IsKindOf2(value6, "Unknown") && IsOptionalString(value6.$id);
}
function IsUnsafe2(value6) {
  return IsKindOf2(value6, "Unsafe");
}
function IsVoid2(value6) {
  return IsKindOf2(value6, "Void") && value6.type === "void" && IsOptionalString(value6.$id);
}
function IsKind2(value6) {
  return IsObject(value6) && Kind in value6 && IsString(value6[Kind]) && !KnownTypes.includes(value6[Kind]);
}
function IsSchema2(value6) {
  return IsObject(value6) && (IsAny2(value6) || IsArgument2(value6) || IsArray4(value6) || IsBoolean4(value6) || IsBigInt4(value6) || IsAsyncIterator4(value6) || IsComputed2(value6) || IsConstructor2(value6) || IsDate4(value6) || IsFunction4(value6) || IsInteger3(value6) || IsIntersect2(value6) || IsIterator4(value6) || IsLiteral2(value6) || IsMappedKey2(value6) || IsMappedResult2(value6) || IsNever2(value6) || IsNot2(value6) || IsNull4(value6) || IsNumber4(value6) || IsObject4(value6) || IsPromise3(value6) || IsRecord2(value6) || IsRef2(value6) || IsRegExp3(value6) || IsString4(value6) || IsSymbol4(value6) || IsTemplateLiteral2(value6) || IsThis2(value6) || IsTuple2(value6) || IsUndefined4(value6) || IsUnion2(value6) || IsUint8Array4(value6) || IsUnknown2(value6) || IsUnsafe2(value6) || IsVoid2(value6) || IsKind2(value6));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Argument",
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Computed",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
var PatternNeverExact = `^${PatternNever}\$`;

// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
function Entries() {
  return new Map(map31);
}
function Clear() {
  return map31.clear();
}
function Delete(format6) {
  return map31.delete(format6);
}
function Has(format6) {
  return map31.has(format6);
}
function Set2(format6, func) {
  map31.set(format6, func);
}
function Get(format6) {
  return map31.get(format6);
}
var map31 = new Map;
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
function Entries2() {
  return new Map(map32);
}
function Clear2() {
  return map32.clear();
}
function Delete2(kind) {
  return map32.delete(kind);
}
function Has2(kind) {
  return map32.has(kind);
}
function Set3(kind, func) {
  map32.set(kind, func);
}
function Get2(kind) {
  return map32.get(kind);
}
var map32 = new Map;
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}

// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options) {
  return CreateType({ [Kind]: "Any" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(items, options) {
  return CreateType({ [Kind]: "Array", type: "array", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/argument/argument.mjs
function Argument(index) {
  return CreateType({ [Kind]: "Argument", index });
}

// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options) {
  return CreateType({ [Kind]: "AsyncIterator", type: "AsyncIterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/computed/computed.mjs
function Computed(target, parameters, options) {
  return CreateType({ [Kind]: "Computed", target, parameters }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value6, key) {
  const { [key]: _, ...rest } = value6;
  return rest;
}
function Discard(value6, keys9) {
  return keys9.reduce((acc, key) => DiscardKey(acc, key), value6);
}

// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options) {
  return CreateType({ [Kind]: "Never", not: {} }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return CreateType({
    [Kind]: "MappedResult",
    properties
  });
}

// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return CreateType({ [Kind]: "Constructor", type: "Constructor", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return CreateType({ [Kind]: "Function", type: "Function", parameters, returns }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return CreateType({ [Kind]: "Union", anyOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(types) {
  return types.some((type2) => IsOptional(type2));
}
function RemoveOptionalFromRest(types) {
  return types.map((left3) => IsOptional(left3) ? RemoveOptionalFromType(left3) : left3);
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(types, options) {
  const isOptional = IsUnionOptional(types);
  return isOptional ? Optional(UnionCreate(RemoveOptionalFromRest(types), options)) : UnionCreate(RemoveOptionalFromRest(types), options);
}
function UnionEvaluated(T, options) {
  return T.length === 1 ? CreateType(T[0], options) : T.length === 0 ? Never(options) : ResolveUnion(T, options);
}

// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union2(types, options) {
  return types.length === 0 ? Never(options) : types.length === 1 ? CreateType(types[0], options) : UnionCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
function Unescape(pattern2) {
  return pattern2.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern2, index, char) {
  return pattern2[index] === char && pattern2.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern2, index) {
  return IsNonEscaped(pattern2, index, "(");
}
function IsCloseParen(pattern2, index) {
  return IsNonEscaped(pattern2, index, ")");
}
function IsSeparator(pattern2, index) {
  return IsNonEscaped(pattern2, index, "|");
}
function IsGroup(pattern2) {
  if (!(IsOpenParen(pattern2, 0) && IsCloseParen(pattern2, pattern2.length - 1)))
    return false;
  let count5 = 0;
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen(pattern2, index))
      count5 += 1;
    if (IsCloseParen(pattern2, index))
      count5 -= 1;
    if (count5 === 0 && index !== pattern2.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern2) {
  return pattern2.slice(1, pattern2.length - 1);
}
function IsPrecedenceOr(pattern2) {
  let count5 = 0;
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen(pattern2, index))
      count5 += 1;
    if (IsCloseParen(pattern2, index))
      count5 -= 1;
    if (IsSeparator(pattern2, index) && count5 === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern2) {
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen(pattern2, index))
      return true;
  }
  return false;
}
function Or2(pattern2) {
  let [count5, start5] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen(pattern2, index))
      count5 += 1;
    if (IsCloseParen(pattern2, index))
      count5 -= 1;
    if (IsSeparator(pattern2, index) && count5 === 0) {
      const range4 = pattern2.slice(start5, index);
      if (range4.length > 0)
        expressions.push(TemplateLiteralParse(range4));
      start5 = index + 1;
    }
  }
  const range3 = pattern2.slice(start5);
  if (range3.length > 0)
    expressions.push(TemplateLiteralParse(range3));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern2) {
  function Group(value6, index) {
    if (!IsOpenParen(value6, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count5 = 0;
    for (let scan2 = index;scan2 < value6.length; scan2++) {
      if (IsOpenParen(value6, scan2))
        count5 += 1;
      if (IsCloseParen(value6, scan2))
        count5 -= 1;
      if (count5 === 0)
        return [index, scan2];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern3, index) {
    for (let scan2 = index;scan2 < pattern3.length; scan2++) {
      if (IsOpenParen(pattern3, scan2))
        return [index, scan2];
    }
    return [index, pattern3.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen(pattern2, index)) {
      const [start5, end6] = Group(pattern2, index);
      const range3 = pattern2.slice(start5, end6 + 1);
      expressions.push(TemplateLiteralParse(range3));
      index = end6;
    } else {
      const [start5, end6] = Range(pattern2, index);
      const range3 = pattern2.slice(start5, end6);
      if (range3.length > 0)
        expressions.push(TemplateLiteralParse(range3));
      index = end6 - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern2) {
  return IsGroup(pattern2) ? TemplateLiteralParse(InGroup(pattern2)) : IsPrecedenceOr(pattern2) ? Or2(pattern2) : IsPrecedenceAnd(pattern2) ? And2(pattern2) : { type: "const", const: Unescape(pattern2) };
}
function TemplateLiteralParseExact(pattern2) {
  return TemplateLiteralParse(pattern2.slice(1, pattern2.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
function* GenerateReduce(buffer3) {
  if (buffer3.length === 1)
    return yield* buffer3[0];
  for (const left3 of buffer3[0]) {
    for (const right3 of GenerateReduce(buffer3.slice(1))) {
      yield `${left3}${right3}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal2(value6, options) {
  return CreateType({
    [Kind]: "Literal",
    const: value6,
    type: typeof value6
  }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options) {
  return CreateType({ [Kind]: "Boolean", type: "boolean" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options) {
  return CreateType({ [Kind]: "BigInt", type: "bigint" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options) {
  return CreateType({ [Kind]: "Number", type: "number" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options) {
  return CreateType({ [Kind]: "String", type: "string" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal2(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal2("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal2(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal2(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal2(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
function Escape(value6) {
  return value6.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal2(S));
  return UnionEvaluated(L);
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral2(unresolved, options) {
  const pattern2 = IsString(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return CreateType({ [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(templateLiteral) {
  const keys9 = TemplateLiteralGenerate(templateLiteral);
  return keys9.map((key) => key.toString());
}
function FromUnion2(types) {
  const result = [];
  for (const type2 of types)
    result.push(...IndexPropertyKeys(type2));
  return result;
}
function FromLiteral(literalValue) {
  return [literalValue.toString()];
}
function IndexPropertyKeys(type2) {
  return [...new Set(IsTemplateLiteral(type2) ? FromTemplateLiteral(type2) : IsUnion(type2) ? FromUnion2(type2.anyOf) : IsLiteral(type2) ? FromLiteral(type2.const) : IsNumber3(type2) ? ["[number]"] : IsInteger2(type2) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties(type2, properties, options) {
  const result = {};
  for (const K2 of Object.getOwnPropertyNames(properties)) {
    result[K2] = Index(type2, IndexPropertyKeys(properties[K2]), options);
  }
  return result;
}
function FromMappedResult(type2, mappedResult, options) {
  return FromProperties(type2, mappedResult.properties, options);
}
function IndexFromMappedResult(type2, mappedResult, options) {
  const properties = FromMappedResult(type2, mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(types, key) {
  return types.map((type2) => IndexFromPropertyKey(type2, key));
}
function FromIntersectRest(types) {
  return types.filter((type2) => !IsNever(type2));
}
function FromIntersect(types, key) {
  return IntersectEvaluated(FromIntersectRest(FromRest(types, key)));
}
function FromUnionRest(types) {
  return types.some((L) => IsNever(L)) ? [] : types;
}
function FromUnion3(types, key) {
  return UnionEvaluated(FromUnionRest(FromRest(types, key)));
}
function FromTuple(types, key) {
  return key in types ? types[key] : key === "[number]" ? UnionEvaluated(types) : Never();
}
function FromArray(type2, key) {
  return key === "[number]" ? type2 : Never();
}
function FromProperty(properties, propertyKey) {
  return propertyKey in properties ? properties[propertyKey] : Never();
}
function IndexFromPropertyKey(type2, propertyKey) {
  return IsIntersect(type2) ? FromIntersect(type2.allOf, propertyKey) : IsUnion(type2) ? FromUnion3(type2.anyOf, propertyKey) : IsTuple(type2) ? FromTuple(type2.items ?? [], propertyKey) : IsArray3(type2) ? FromArray(type2.items, propertyKey) : IsObject3(type2) ? FromProperty(type2.properties, propertyKey) : Never();
}
function IndexFromPropertyKeys(type2, propertyKeys) {
  return propertyKeys.map((propertyKey) => IndexFromPropertyKey(type2, propertyKey));
}
function FromSchema(type2, propertyKeys) {
  return UnionEvaluated(IndexFromPropertyKeys(type2, propertyKeys));
}
function Index(type2, key, options) {
  if (IsRef(type2) || IsRef(key)) {
    const error2 = `Index types using Ref parameters require both Type and Key to be of TSchema`;
    if (!IsSchema(type2) || !IsSchema(key))
      throw new TypeBoxError(error2);
    return Computed("Index", [type2, key]);
  }
  if (IsMappedResult(key))
    return IndexFromMappedResult(type2, key, options);
  if (IsMappedKey(key))
    return IndexFromMappedKey(type2, key, options);
  return CreateType(IsSchema(key) ? FromSchema(type2, IndexPropertyKeys(key)) : FromSchema(type2, key), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(type2, key, options) {
  return { [key]: Index(type2, [key], Clone(options)) };
}
function MappedIndexPropertyKeys(type2, propertyKeys, options) {
  return propertyKeys.reduce((result, left3) => {
    return { ...result, ...MappedIndexPropertyKey(type2, left3, options) };
  }, {});
}
function MappedIndexProperties(type2, mappedKey, options) {
  return MappedIndexPropertyKeys(type2, mappedKey.keys, options);
}
function IndexFromMappedKey(type2, mappedKey, options) {
  const properties = MappedIndexProperties(type2, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options) {
  return CreateType({ [Kind]: "Iterator", type: "Iterator", items }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function RequiredKeys(properties) {
  const keys9 = [];
  for (let key in properties) {
    if (!IsOptional(properties[key]))
      keys9.push(key);
  }
  return keys9;
}
function _Object(properties, options) {
  const required2 = RequiredKeys(properties);
  const schematic = required2.length > 0 ? { [Kind]: "Object", type: "object", properties, required: required2 } : { [Kind]: "Object", type: "object", properties };
  return CreateType(schematic, options);
}
var Object2 = _Object;

// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options) {
  return CreateType({ [Kind]: "Promise", type: "Promise", item }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return CreateType(Discard(schema, [ReadonlyKind]));
}
function AddReadonly(schema) {
  return CreateType({ ...schema, [ReadonlyKind]: "Readonly" });
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable4) {
  const F = enable4 ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties2(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult2(R, F) {
  return FromProperties2(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult2(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(types, options) {
  return CreateType(types.length > 0 ? { [Kind]: "Tuple", type: "array", items: types, additionalItems: false, minItems: types.length, maxItems: types.length } : { [Kind]: "Tuple", type: "array", minItems: types.length, maxItems: types.length }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult3(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal2(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult3(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties3(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  const options = { ...T };
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult3(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns), options) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items), options) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items), options) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf), options) : IsUnion(T) ? Union2(FromRest2(K, T.anyOf), options) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? []), options) : IsObject3(T) ? Object2(FromProperties3(K, T.properties), options) : IsArray3(T) ? Array2(FromSchemaType(K, T.items), options) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item), options) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map33, options) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map33({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return Object2(R, options);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return CreateType(Discard(schema, [OptionalKind]));
}
function AddOptional(schema) {
  return CreateType({ ...schema, [OptionalKind]: "Optional" });
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable4) {
  const F = enable4 ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties4(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult4(R, F) {
  return FromProperties4(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult4(R, F);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options = {}) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: options.unevaluatedProperties } : {};
  return CreateType(options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: T } : { ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: T }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(types) {
  return types.every((left3) => IsOptional(left3));
}
function RemoveOptionalFromType2(type2) {
  return Discard(type2, [OptionalKind]);
}
function RemoveOptionalFromRest2(types) {
  return types.map((left3) => IsOptional(left3) ? RemoveOptionalFromType2(left3) : left3);
}
function ResolveIntersect(types, options) {
  return IsIntersectOptional(types) ? Optional(IntersectCreate(RemoveOptionalFromRest2(types), options)) : IntersectCreate(RemoveOptionalFromRest2(types), options);
}
function IntersectEvaluated(types, options = {}) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(types, options) {
  if (types.length === 1)
    return CreateType(types[0], options);
  if (types.length === 0)
    return Never(options);
  if (types.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(types, options);
}

// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(...args2) {
  const [$ref, options] = typeof args2[0] === "string" ? [args2[0], args2[1]] : [args2[0].$id, args2[1]];
  if (typeof $ref !== "string")
    throw new TypeBoxError("Ref: $ref must be a string");
  return CreateType({ [Kind]: "Ref", $ref }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromComputed(target, parameters) {
  return Computed("Awaited", [Computed(target, parameters)]);
}
function FromRef($ref) {
  return Computed("Awaited", [Ref($ref)]);
}
function FromIntersect2(types) {
  return Intersect(FromRest3(types));
}
function FromUnion4(types) {
  return Union2(FromRest3(types));
}
function FromPromise(type2) {
  return Awaited(type2);
}
function FromRest3(types) {
  return types.map((type2) => Awaited(type2));
}
function Awaited(type2, options) {
  return CreateType(IsComputed(type2) ? FromComputed(type2.target, type2.parameters) : IsIntersect(type2) ? FromIntersect2(type2.allOf) : IsUnion(type2) ? FromUnion4(type2.anyOf) : IsPromise2(type2) ? FromPromise(type2.item) : IsRef(type2) ? FromRef(type2.$ref) : type2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest4(types) {
  const result = [];
  for (const L of types)
    result.push(KeyOfPropertyKeys(L));
  return result;
}
function FromIntersect3(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetUnionMany(propertyKeysArray);
  return propertyKeys;
}
function FromUnion5(types) {
  const propertyKeysArray = FromRest4(types);
  const propertyKeys = SetIntersectMany(propertyKeysArray);
  return propertyKeys;
}
function FromTuple2(types) {
  return types.map((_, indexer) => indexer.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(type2) {
  return IsIntersect(type2) ? FromIntersect3(type2.allOf) : IsUnion(type2) ? FromUnion5(type2.anyOf) : IsTuple(type2) ? FromTuple2(type2.items ?? []) : IsArray3(type2) ? FromArray2(type2.items) : IsObject3(type2) ? FromProperties5(type2.properties) : IsRecord(type2) ? FromPatternProperties(type2.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys9 = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys9.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function FromComputed2(target, parameters) {
  return Computed("KeyOf", [Computed(target, parameters)]);
}
function FromRef2($ref) {
  return Computed("KeyOf", [Ref($ref)]);
}
function KeyOfFromType(type2, options) {
  const propertyKeys = KeyOfPropertyKeys(type2);
  const propertyKeyTypes = KeyOfPropertyKeysToRest(propertyKeys);
  const result = UnionEvaluated(propertyKeyTypes);
  return CreateType(result, options);
}
function KeyOfPropertyKeysToRest(propertyKeys) {
  return propertyKeys.map((L) => L === "[number]" ? Number2() : Literal2(L));
}
function KeyOf(type2, options) {
  return IsComputed(type2) ? FromComputed2(type2.target, type2.parameters) : IsRef(type2) ? FromRef2(type2.$ref) : IsMappedResult(type2) ? KeyOfFromMappedResult(type2, options) : KeyOfFromType(type2, options);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(properties, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = KeyOf(properties[K2], Clone(options));
  return result;
}
function FromMappedResult5(mappedResult, options) {
  return FromProperties6(mappedResult.properties, options);
}
function KeyOfFromMappedResult(mappedResult, options) {
  const properties = FromMappedResult5(mappedResult, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys9 = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys9);
  return keys9.map((_, index) => [keys9[index], schemas[index]]);
}

// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite3(T, options) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}

// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date3(options) {
  return CreateType({ [Kind]: "Date", type: "Date" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options) {
  return CreateType({ [Kind]: "Null", type: "null" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return CreateType({ [Kind]: "Symbol", type: "symbol" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options) {
  return CreateType({ [Kind]: "Undefined", type: "undefined" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options) {
  return CreateType({ [Kind]: "Uint8Array", type: "Uint8Array" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options) {
  return CreateType({ [Kind]: "Unknown" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray3(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties7(value6) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value6))
    Acc[K] = Readonly(FromValue(value6[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value6, root) {
  return IsAsyncIterator(value6) ? ConditionalReadonly(Any(), root) : IsIterator(value6) ? ConditionalReadonly(Any(), root) : IsArray(value6) ? Readonly(Tuple(FromArray3(value6))) : IsUint8Array(value6) ? Uint8Array2() : IsDate(value6) ? Date3() : IsObject(value6) ? ConditionalReadonly(Object2(FromProperties7(value6)), root) : IsFunction(value6) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined(value6) ? Undefined() : IsNull(value6) ? Null() : IsSymbol(value6) ? Symbol2() : IsBigInt(value6) ? BigInt2() : IsNumber(value6) ? Literal2(value6) : IsBoolean(value6) ? Literal2(value6) : IsString(value6) ? Literal2(value6) : Object2({});
}
function Const2(T, options) {
  return CreateType(FromValue(T, true), options);
}

// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options) {
  return IsConstructor(schema) ? Tuple(schema.parameters, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options) {
  if (IsUndefined(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values22 = [...new Set(values1)];
  const anyOf = values22.map((value6) => Literal2(value6));
  return Union2(anyOf, { ...options, [Hint]: "Enum" });
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right3) {
  return exports_type.IsNever(right3) || exports_type.IsIntersect(right3) || exports_type.IsUnion(right3) || exports_type.IsUnknown(right3) || exports_type.IsAny(right3);
}
function StructuralRight(left3, right3) {
  return exports_type.IsNever(right3) ? FromNeverRight(left3, right3) : exports_type.IsIntersect(right3) ? FromIntersectRight(left3, right3) : exports_type.IsUnion(right3) ? FromUnionRight(left3, right3) : exports_type.IsUnknown(right3) ? FromUnknownRight(left3, right3) : exports_type.IsAny(right3) ? FromAnyRight(left3, right3) : Throw("StructuralRight");
}
function FromAnyRight(left3, right3) {
  return ExtendsResult.True;
}
function FromAny(left3, right3) {
  return exports_type.IsIntersect(right3) ? FromIntersectRight(left3, right3) : exports_type.IsUnion(right3) && right3.anyOf.some((schema) => exports_type.IsAny(schema) || exports_type.IsUnknown(schema)) ? ExtendsResult.True : exports_type.IsUnion(right3) ? ExtendsResult.Union : exports_type.IsUnknown(right3) ? ExtendsResult.True : exports_type.IsAny(right3) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left3, right3) {
  return exports_type.IsUnknown(left3) ? ExtendsResult.False : exports_type.IsAny(left3) ? ExtendsResult.Union : exports_type.IsNever(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left3, right3) {
  return exports_type.IsObject(right3) && IsObjectArrayLike(right3) ? ExtendsResult.True : IsStructuralRight(right3) ? StructuralRight(left3, right3) : !exports_type.IsArray(right3) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.items, right3.items));
}
function FromAsyncIterator(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : !exports_type.IsAsyncIterator(right3) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.items, right3.items));
}
function FromBigInt(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsBigInt(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left3, right3) {
  return exports_type.IsLiteralBoolean(left3) ? ExtendsResult.True : exports_type.IsBoolean(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsBoolean(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : !exports_type.IsConstructor(right3) ? ExtendsResult.False : left3.parameters.length > right3.parameters.length ? ExtendsResult.False : !left3.parameters.every((schema, index) => IntoBooleanResult(Visit3(right3.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.returns, right3.returns));
}
function FromDate(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsDate(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : !exports_type.IsFunction(right3) ? ExtendsResult.False : left3.parameters.length > right3.parameters.length ? ExtendsResult.False : !left3.parameters.every((schema, index) => IntoBooleanResult(Visit3(right3.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.returns, right3.returns));
}
function FromIntegerRight(left3, right3) {
  return exports_type.IsLiteral(left3) && exports_value.IsNumber(left3.const) ? ExtendsResult.True : exports_type.IsNumber(left3) || exports_type.IsInteger(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger(left3, right3) {
  return exports_type.IsInteger(right3) || exports_type.IsNumber(right3) ? ExtendsResult.True : IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : ExtendsResult.False;
}
function FromIntersectRight(left3, right3) {
  return right3.allOf.every((schema) => Visit3(left3, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left3, right3) {
  return left3.allOf.some((schema) => Visit3(schema, right3) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : !exports_type.IsIterator(right3) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.items, right3.items));
}
function FromLiteral2(left3, right3) {
  return exports_type.IsLiteral(right3) && right3.const === left3.const ? ExtendsResult.True : IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsString(right3) ? FromStringRight(left3, right3) : exports_type.IsNumber(right3) ? FromNumberRight(left3, right3) : exports_type.IsInteger(right3) ? FromIntegerRight(left3, right3) : exports_type.IsBoolean(right3) ? FromBooleanRight(left3, right3) : ExtendsResult.False;
}
function FromNeverRight(left3, right3) {
  return ExtendsResult.False;
}
function FromNever(left3, right3) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current2, depth] = [schema, 0];
  while (true) {
    if (!exports_type.IsNot(current2))
      break;
    current2 = current2.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current2 : Unknown();
}
function FromNot(left3, right3) {
  return exports_type.IsNot(left3) ? Visit3(UnwrapTNot(left3), right3) : exports_type.IsNot(right3) ? Visit3(left3, UnwrapTNot(right3)) : Throw("Invalid fallthrough for Not");
}
function FromNull(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsNull(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left3, right3) {
  return exports_type.IsLiteralNumber(left3) ? ExtendsResult.True : exports_type.IsNumber(left3) || exports_type.IsInteger(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsInteger(right3) || exports_type.IsNumber(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count5) {
  return Object.getOwnPropertyNames(schema.properties).length === count5;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type.IsString(schema.properties.description.anyOf[0]) && exports_type.IsUndefined(schema.properties.description.anyOf[1]) || exports_type.IsString(schema.properties.description.anyOf[1]) && exports_type.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length3 = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length3)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length3 = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit3(schema.properties["length"], length3)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit3(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left3, right3) {
  return Visit3(left3, right3) === ExtendsResult.False ? ExtendsResult.False : exports_type.IsOptional(left3) && !exports_type.IsOptional(right3) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left3, right3) {
  return exports_type.IsUnknown(left3) ? ExtendsResult.False : exports_type.IsAny(left3) ? ExtendsResult.Union : exports_type.IsNever(left3) || exports_type.IsLiteralString(left3) && IsObjectStringLike(right3) || exports_type.IsLiteralNumber(left3) && IsObjectNumberLike(right3) || exports_type.IsLiteralBoolean(left3) && IsObjectBooleanLike(right3) || exports_type.IsSymbol(left3) && IsObjectSymbolLike(right3) || exports_type.IsBigInt(left3) && IsObjectBigIntLike(right3) || exports_type.IsString(left3) && IsObjectStringLike(right3) || exports_type.IsSymbol(left3) && IsObjectSymbolLike(right3) || exports_type.IsNumber(left3) && IsObjectNumberLike(right3) || exports_type.IsInteger(left3) && IsObjectNumberLike(right3) || exports_type.IsBoolean(left3) && IsObjectBooleanLike(right3) || exports_type.IsUint8Array(left3) && IsObjectUint8ArrayLike(right3) || exports_type.IsDate(left3) && IsObjectDateLike(right3) || exports_type.IsConstructor(left3) && IsObjectConstructorLike(right3) || exports_type.IsFunction(left3) && IsObjectFunctionLike(right3) ? ExtendsResult.True : exports_type.IsRecord(left3) && exports_type.IsString(RecordKey(left3)) ? (() => {
    return right3[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type.IsRecord(left3) && exports_type.IsNumber(RecordKey(left3)) ? (() => {
    return IsObjectPropertyCount(right3, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : !exports_type.IsObject(right3) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right3.properties)) {
      if (!(key in left3.properties) && !exports_type.IsOptional(right3.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type.IsOptional(right3.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left3.properties[key], right3.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) && IsObjectPromiseLike(right3) ? ExtendsResult.True : !exports_type.IsPromise(right3) ? ExtendsResult.False : IntoBooleanResult(Visit3(left3.item, right3.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left3, right3) {
  const [Key2, Value2] = [RecordKey(right3), RecordValue(right3)];
  return exports_type.IsLiteralString(left3) && exports_type.IsNumber(Key2) && IntoBooleanResult(Visit3(left3, Value2)) === ExtendsResult.True ? ExtendsResult.True : exports_type.IsUint8Array(left3) && exports_type.IsNumber(Key2) ? Visit3(left3, Value2) : exports_type.IsString(left3) && exports_type.IsNumber(Key2) ? Visit3(left3, Value2) : exports_type.IsArray(left3) && exports_type.IsNumber(Key2) ? Visit3(left3, Value2) : exports_type.IsObject(left3) ? (() => {
    for (const key of Object.getOwnPropertyNames(left3.properties)) {
      if (Property(Value2, left3.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : !exports_type.IsRecord(right3) ? ExtendsResult.False : Visit3(RecordValue(left3), RecordValue(right3));
}
function FromRegExp(left3, right3) {
  const L = exports_type.IsRegExp(left3) ? String2() : left3;
  const R = exports_type.IsRegExp(right3) ? String2() : right3;
  return Visit3(L, R);
}
function FromStringRight(left3, right3) {
  return exports_type.IsLiteral(left3) && exports_value.IsString(left3.const) ? ExtendsResult.True : exports_type.IsString(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsString(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsSymbol(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral2(left3, right3) {
  return exports_type.IsTemplateLiteral(left3) ? Visit3(TemplateLiteralToUnion(left3), right3) : exports_type.IsTemplateLiteral(right3) ? Visit3(left3, TemplateLiteralToUnion(right3)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left3, right3) {
  return exports_type.IsArray(right3) && left3.items !== undefined && left3.items.every((schema) => Visit3(schema, right3.items) === ExtendsResult.True);
}
function FromTupleRight(left3, right3) {
  return exports_type.IsNever(left3) ? ExtendsResult.True : exports_type.IsUnknown(left3) ? ExtendsResult.False : exports_type.IsAny(left3) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple3(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) && IsObjectArrayLike(right3) ? ExtendsResult.True : exports_type.IsArray(right3) && IsArrayOfTuple(left3, right3) ? ExtendsResult.True : !exports_type.IsTuple(right3) ? ExtendsResult.False : exports_value.IsUndefined(left3.items) && !exports_value.IsUndefined(right3.items) || !exports_value.IsUndefined(left3.items) && exports_value.IsUndefined(right3.items) ? ExtendsResult.False : exports_value.IsUndefined(left3.items) && !exports_value.IsUndefined(right3.items) ? ExtendsResult.True : left3.items.every((schema, index) => Visit3(schema, right3.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsUint8Array(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined(left3, right3) {
  return IsStructuralRight(right3) ? StructuralRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsRecord(right3) ? FromRecordRight(left3, right3) : exports_type.IsVoid(right3) ? FromVoidRight(left3, right3) : exports_type.IsUndefined(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left3, right3) {
  return right3.anyOf.some((schema) => Visit3(left3, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left3, right3) {
  return left3.anyOf.every((schema) => Visit3(schema, right3) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left3, right3) {
  return ExtendsResult.True;
}
function FromUnknown(left3, right3) {
  return exports_type.IsNever(right3) ? FromNeverRight(left3, right3) : exports_type.IsIntersect(right3) ? FromIntersectRight(left3, right3) : exports_type.IsUnion(right3) ? FromUnionRight(left3, right3) : exports_type.IsAny(right3) ? FromAnyRight(left3, right3) : exports_type.IsString(right3) ? FromStringRight(left3, right3) : exports_type.IsNumber(right3) ? FromNumberRight(left3, right3) : exports_type.IsInteger(right3) ? FromIntegerRight(left3, right3) : exports_type.IsBoolean(right3) ? FromBooleanRight(left3, right3) : exports_type.IsArray(right3) ? FromArrayRight(left3, right3) : exports_type.IsTuple(right3) ? FromTupleRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsUnknown(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left3, right3) {
  return exports_type.IsUndefined(left3) ? ExtendsResult.True : exports_type.IsUndefined(left3) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid(left3, right3) {
  return exports_type.IsIntersect(right3) ? FromIntersectRight(left3, right3) : exports_type.IsUnion(right3) ? FromUnionRight(left3, right3) : exports_type.IsUnknown(right3) ? FromUnknownRight(left3, right3) : exports_type.IsAny(right3) ? FromAnyRight(left3, right3) : exports_type.IsObject(right3) ? FromObjectRight(left3, right3) : exports_type.IsVoid(right3) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit3(left3, right3) {
  return exports_type.IsTemplateLiteral(left3) || exports_type.IsTemplateLiteral(right3) ? FromTemplateLiteral2(left3, right3) : exports_type.IsRegExp(left3) || exports_type.IsRegExp(right3) ? FromRegExp(left3, right3) : exports_type.IsNot(left3) || exports_type.IsNot(right3) ? FromNot(left3, right3) : exports_type.IsAny(left3) ? FromAny(left3, right3) : exports_type.IsArray(left3) ? FromArray4(left3, right3) : exports_type.IsBigInt(left3) ? FromBigInt(left3, right3) : exports_type.IsBoolean(left3) ? FromBoolean(left3, right3) : exports_type.IsAsyncIterator(left3) ? FromAsyncIterator(left3, right3) : exports_type.IsConstructor(left3) ? FromConstructor(left3, right3) : exports_type.IsDate(left3) ? FromDate(left3, right3) : exports_type.IsFunction(left3) ? FromFunction(left3, right3) : exports_type.IsInteger(left3) ? FromInteger(left3, right3) : exports_type.IsIntersect(left3) ? FromIntersect4(left3, right3) : exports_type.IsIterator(left3) ? FromIterator(left3, right3) : exports_type.IsLiteral(left3) ? FromLiteral2(left3, right3) : exports_type.IsNever(left3) ? FromNever(left3, right3) : exports_type.IsNull(left3) ? FromNull(left3, right3) : exports_type.IsNumber(left3) ? FromNumber(left3, right3) : exports_type.IsObject(left3) ? FromObject(left3, right3) : exports_type.IsRecord(left3) ? FromRecord(left3, right3) : exports_type.IsString(left3) ? FromString(left3, right3) : exports_type.IsSymbol(left3) ? FromSymbol(left3, right3) : exports_type.IsTuple(left3) ? FromTuple3(left3, right3) : exports_type.IsPromise(left3) ? FromPromise2(left3, right3) : exports_type.IsUint8Array(left3) ? FromUint8Array(left3, right3) : exports_type.IsUndefined(left3) ? FromUndefined(left3, right3) : exports_type.IsUnion(left3) ? FromUnion6(left3, right3) : exports_type.IsUnknown(left3) ? FromUnknown(left3, right3) : exports_type.IsVoid(left3) ? FromVoid(left3, right3) : Throw(`Unknown left type operand '${left3[Kind]}'`);
}
function ExtendsCheck(left3, right3) {
  return Visit3(left3, right3);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties8(P, Right2, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right2, True, False, Clone(options));
  return Acc;
}
function FromMappedResult6(Left2, Right2, True, False, options) {
  return FromProperties8(Left2.properties, Right2, True, False, options);
}
function ExtendsFromMappedResult(Left2, Right2, True, False, options) {
  const P = FromMappedResult6(Left2, Right2, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left3, right3, trueType, falseType) {
  const R = ExtendsCheck(left3, right3);
  return R === ExtendsResult.Union ? Union2([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CreateType(ExtendsFromMappedKey(L, R, T, F, options)) : CreateType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal2(K), U, L, R, Clone(options))
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union3(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union3(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union2(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CreateType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExcludeFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties9(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties9(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union2(extracted);
}
function Extract(L, R, options) {
  if (IsTemplateLiteral(L))
    return CreateType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CreateType(ExtractFromMappedResult(L, R), options);
  return CreateType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties10(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties10(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options) {
  return IsConstructor(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}

// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return CreateType({ [Kind]: "Record", type: "object", patternProperties: { [pattern2]: T } }, options);
}
function RecordCreateFromKeys(K, T, options) {
  const result = {};
  for (const K2 of K)
    result[K2] = T;
  return Object2(result, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(key, type2, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union2(key)), type2, options);
}
function FromLiteralKey(key, type2, options) {
  return RecordCreateFromKeys([key.toString()], type2, options);
}
function FromRegExpKey(key, type2, options) {
  return RecordCreateFromPattern(key.source, type2, options);
}
function FromStringKey(key, type2, options) {
  const pattern2 = IsUndefined(key.pattern) ? PatternStringExact : key.pattern;
  return RecordCreateFromPattern(pattern2, type2, options);
}
function FromAnyKey(_, type2, options) {
  return RecordCreateFromPattern(PatternStringExact, type2, options);
}
function FromNeverKey(_key, type2, options) {
  return RecordCreateFromPattern(PatternNeverExact, type2, options);
}
function FromBooleanKey(_key, type2, options) {
  return Object2({ true: type2, false: type2 }, options);
}
function FromIntegerKey(_key, type2, options) {
  return RecordCreateFromPattern(PatternNumberExact, type2, options);
}
function FromNumberKey(_, type2, options) {
  return RecordCreateFromPattern(PatternNumberExact, type2, options);
}
function Record(key, type2, options = {}) {
  return IsUnion(key) ? FromUnionKey(key.anyOf, type2, options) : IsTemplateLiteral(key) ? FromTemplateLiteralKey(key, type2, options) : IsLiteral(key) ? FromLiteralKey(key.const, type2, options) : IsBoolean3(key) ? FromBooleanKey(key, type2, options) : IsInteger2(key) ? FromIntegerKey(key, type2, options) : IsNumber3(key) ? FromNumberKey(key, type2, options) : IsRegExp2(key) ? FromRegExpKey(key, type2, options) : IsString3(key) ? FromStringKey(key, type2, options) : IsAny(key) ? FromAnyKey(key, type2, options) : IsNever(key) ? FromNeverKey(key, type2, options) : Never(options);
}
function RecordPattern(record2) {
  return globalThis.Object.getOwnPropertyNames(record2.patternProperties)[0];
}
function RecordKey2(type2) {
  const pattern2 = RecordPattern(type2);
  return pattern2 === PatternStringExact ? String2() : pattern2 === PatternNumberExact ? Number2() : String2({ pattern: pattern2 });
}
function RecordValue2(type2) {
  return type2.patternProperties[RecordPattern(type2)];
}

// node_modules/@sinclair/typebox/build/esm/type/instantiate/instantiate.mjs
function FromConstructor2(args2, type2) {
  type2.parameters = FromTypes(args2, type2.parameters);
  type2.returns = FromType(args2, type2.returns);
  return type2;
}
function FromFunction2(args2, type2) {
  type2.parameters = FromTypes(args2, type2.parameters);
  type2.returns = FromType(args2, type2.returns);
  return type2;
}
function FromIntersect5(args2, type2) {
  type2.allOf = FromTypes(args2, type2.allOf);
  return type2;
}
function FromUnion7(args2, type2) {
  type2.anyOf = FromTypes(args2, type2.anyOf);
  return type2;
}
function FromTuple4(args2, type2) {
  if (IsUndefined(type2.items))
    return type2;
  type2.items = FromTypes(args2, type2.items);
  return type2;
}
function FromArray5(args2, type2) {
  type2.items = FromType(args2, type2.items);
  return type2;
}
function FromAsyncIterator2(args2, type2) {
  type2.items = FromType(args2, type2.items);
  return type2;
}
function FromIterator2(args2, type2) {
  type2.items = FromType(args2, type2.items);
  return type2;
}
function FromPromise3(args2, type2) {
  type2.item = FromType(args2, type2.item);
  return type2;
}
function FromObject2(args2, type2) {
  const mappedProperties = FromProperties11(args2, type2.properties);
  return { ...type2, ...Object2(mappedProperties) };
}
function FromRecord2(args2, type2) {
  const mappedKey = FromType(args2, RecordKey2(type2));
  const mappedValue = FromType(args2, RecordValue2(type2));
  const result = Record(mappedKey, mappedValue);
  return { ...type2, ...result };
}
function FromArgument(args2, argument) {
  return argument.index in args2 ? args2[argument.index] : Unknown();
}
function FromProperty2(args2, type2) {
  const isReadonly = IsReadonly(type2);
  const isOptional = IsOptional(type2);
  const mapped = FromType(args2, type2);
  return isReadonly && isOptional ? ReadonlyOptional(mapped) : isReadonly && !isOptional ? Readonly(mapped) : !isReadonly && isOptional ? Optional(mapped) : mapped;
}
function FromProperties11(args2, properties) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((result, key) => {
    return { ...result, [key]: FromProperty2(args2, properties[key]) };
  }, {});
}
function FromTypes(args2, types) {
  return types.map((type2) => FromType(args2, type2));
}
function FromType(args2, type2) {
  return IsConstructor(type2) ? FromConstructor2(args2, type2) : IsFunction3(type2) ? FromFunction2(args2, type2) : IsIntersect(type2) ? FromIntersect5(args2, type2) : IsUnion(type2) ? FromUnion7(args2, type2) : IsTuple(type2) ? FromTuple4(args2, type2) : IsArray3(type2) ? FromArray5(args2, type2) : IsAsyncIterator3(type2) ? FromAsyncIterator2(args2, type2) : IsIterator3(type2) ? FromIterator2(args2, type2) : IsPromise2(type2) ? FromPromise3(args2, type2) : IsObject3(type2) ? FromObject2(args2, type2) : IsRecord(type2) ? FromRecord2(args2, type2) : IsArgument(type2) ? FromArgument(args2, type2) : type2;
}
function Instantiate(type2, args2) {
  return FromType(args2, CloneType(type2));
}

// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options) {
  return CreateType({ [Kind]: "Integer", type: "integer" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal2(K), M, Clone(options))
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  const result = K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
  return result;
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value6) {
  const [first4, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first4.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value6) {
  const [first4, rest] = [value6.slice(0, 1), value6.slice(1)];
  return [first4.toUpperCase(), rest].join("");
}
function ApplyUppercase(value6) {
  return value6.toUpperCase();
}
function ApplyLowercase(value6) {
  return value6.toLowerCase();
}
function FromTemplateLiteral3(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite = IsTemplateLiteralExpressionFinite(expression);
  if (!finite)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value6) => Literal2(value6));
  const mapped = FromRest5(literals, mode);
  const union11 = Union2(mapped);
  return TemplateLiteral2([union11], options);
}
function FromLiteralValue(value6, mode) {
  return typeof value6 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value6) : mode === "Capitalize" ? ApplyCapitalize(value6) : mode === "Uppercase" ? ApplyUppercase(value6) : mode === "Lowercase" ? ApplyLowercase(value6) : value6 : value6.toString();
}
function FromRest5(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral3(schema, mode, options) : IsUnion(schema) ? Union2(FromRest5(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal2(FromLiteralValue(schema.const, mode), options) : CreateType(schema, options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Omit(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult9(mappedResult, propertyKeys, options) {
  return FromProperties12(mappedResult.properties, propertyKeys, options);
}
function OmitFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult9(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect6(types, propertyKeys) {
  return types.map((type2) => OmitResolve(type2, propertyKeys));
}
function FromUnion8(types, propertyKeys) {
  return types.map((type2) => OmitResolve(type2, propertyKeys));
}
function FromProperty3(properties, key) {
  const { [key]: _, ...R } = properties;
  return R;
}
function FromProperties13(properties, propertyKeys) {
  return propertyKeys.reduce((T, K2) => FromProperty3(T, K2), properties);
}
function FromObject3(properties, propertyKeys) {
  const options = Discard(properties, [TransformKind, "$id", "required", "properties"]);
  const omittedProperties = FromProperties13(properties["properties"], propertyKeys);
  return Object2(omittedProperties, options);
}
function UnionFromPropertyKeys(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal2(key)] : result2, []);
  return Union2(result);
}
function OmitResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect6(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union2(FromUnion8(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject3(properties, propertyKeys) : Object2({});
}
function Omit(type2, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type2);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type2) ? OmitFromMappedResult(type2, propertyKeys, options) : IsMappedKey(key) ? OmitFromMappedKey(type2, key, options) : isTypeRef && isKeyRef ? Computed("Omit", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Omit", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Omit", [type2, typeKey], options) : CreateType({ ...OmitResolve(type2, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(type2, key, options) {
  return { [key]: Omit(type2, [key], Clone(options)) };
}
function FromPropertyKeys2(type2, propertyKeys, options) {
  return propertyKeys.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(type2, LK, options) };
  }, {});
}
function FromMappedKey3(type2, mappedKey, options) {
  return FromPropertyKeys2(type2, mappedKey.keys, options);
}
function OmitFromMappedKey(type2, mappedKey, options) {
  const properties = FromMappedKey3(type2, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties14(properties, propertyKeys, options) {
  const result = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(properties))
    result[K2] = Pick(properties[K2], propertyKeys, Clone(options));
  return result;
}
function FromMappedResult10(mappedResult, propertyKeys, options) {
  return FromProperties14(mappedResult.properties, propertyKeys, options);
}
function PickFromMappedResult(mappedResult, propertyKeys, options) {
  const properties = FromMappedResult10(mappedResult, propertyKeys, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect7(types, propertyKeys) {
  return types.map((type2) => PickResolve(type2, propertyKeys));
}
function FromUnion9(types, propertyKeys) {
  return types.map((type2) => PickResolve(type2, propertyKeys));
}
function FromProperties15(properties, propertyKeys) {
  const result = {};
  for (const K2 of propertyKeys)
    if (K2 in properties)
      result[K2] = properties[K2];
  return result;
}
function FromObject4(T, K) {
  const options = Discard(T, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties15(T["properties"], K);
  return Object2(properties, options);
}
function UnionFromPropertyKeys2(propertyKeys) {
  const result = propertyKeys.reduce((result2, key) => IsLiteralValue(key) ? [...result2, Literal2(key)] : result2, []);
  return Union2(result);
}
function PickResolve(properties, propertyKeys) {
  return IsIntersect(properties) ? Intersect(FromIntersect7(properties.allOf, propertyKeys)) : IsUnion(properties) ? Union2(FromUnion9(properties.anyOf, propertyKeys)) : IsObject3(properties) ? FromObject4(properties, propertyKeys) : Object2({});
}
function Pick(type2, key, options) {
  const typeKey = IsArray(key) ? UnionFromPropertyKeys2(key) : key;
  const propertyKeys = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const isTypeRef = IsRef(type2);
  const isKeyRef = IsRef(key);
  return IsMappedResult(type2) ? PickFromMappedResult(type2, propertyKeys, options) : IsMappedKey(key) ? PickFromMappedKey(type2, key, options) : isTypeRef && isKeyRef ? Computed("Pick", [type2, typeKey], options) : !isTypeRef && isKeyRef ? Computed("Pick", [type2, typeKey], options) : isTypeRef && !isKeyRef ? Computed("Pick", [type2, typeKey], options) : CreateType({ ...PickResolve(type2, propertyKeys), ...options });
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(type2, key, options) {
  return {
    [key]: Pick(type2, [key], Clone(options))
  };
}
function FromPropertyKeys3(type2, propertyKeys, options) {
  return propertyKeys.reduce((result, leftKey) => {
    return { ...result, ...FromPropertyKey3(type2, leftKey, options) };
  }, {});
}
function FromMappedKey4(type2, mappedKey, options) {
  return FromPropertyKeys3(type2, mappedKey.keys, options);
}
function PickFromMappedKey(type2, mappedKey, options) {
  const properties = FromMappedKey4(type2, mappedKey, options);
  return MappedResult(properties);
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromComputed3(target, parameters) {
  return Computed("Partial", [Computed(target, parameters)]);
}
function FromRef3($ref) {
  return Computed("Partial", [Ref($ref)]);
}
function FromProperties16(properties) {
  const partialProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    partialProperties[K] = Optional(properties[K]);
  return partialProperties;
}
function FromObject5(type2) {
  const options = Discard(type2, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties16(type2["properties"]);
  return Object2(properties, options);
}
function FromRest6(types) {
  return types.map((type2) => PartialResolve(type2));
}
function PartialResolve(type2) {
  return IsComputed(type2) ? FromComputed3(type2.target, type2.parameters) : IsRef(type2) ? FromRef3(type2.$ref) : IsIntersect(type2) ? Intersect(FromRest6(type2.allOf)) : IsUnion(type2) ? Union2(FromRest6(type2.anyOf)) : IsObject3(type2) ? FromObject5(type2) : IsBigInt3(type2) ? type2 : IsBoolean3(type2) ? type2 : IsInteger2(type2) ? type2 : IsLiteral(type2) ? type2 : IsNull3(type2) ? type2 : IsNumber3(type2) ? type2 : IsString3(type2) ? type2 : IsSymbol3(type2) ? type2 : IsUndefined3(type2) ? type2 : Object2({});
}
function Partial(type2, options) {
  if (IsMappedResult(type2)) {
    return PartialFromMappedResult(type2, options);
  } else {
    return CreateType({ ...PartialResolve(type2), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties17(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], Clone(options));
  return Acc;
}
function FromMappedResult11(R, options) {
  return FromProperties17(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult11(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromComputed4(target, parameters) {
  return Computed("Required", [Computed(target, parameters)]);
}
function FromRef4($ref) {
  return Computed("Required", [Ref($ref)]);
}
function FromProperties18(properties) {
  const requiredProperties = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties))
    requiredProperties[K] = Discard(properties[K], [OptionalKind]);
  return requiredProperties;
}
function FromObject6(type2) {
  const options = Discard(type2, [TransformKind, "$id", "required", "properties"]);
  const properties = FromProperties18(type2["properties"]);
  return Object2(properties, options);
}
function FromRest7(types) {
  return types.map((type2) => RequiredResolve(type2));
}
function RequiredResolve(type2) {
  return IsComputed(type2) ? FromComputed4(type2.target, type2.parameters) : IsRef(type2) ? FromRef4(type2.$ref) : IsIntersect(type2) ? Intersect(FromRest7(type2.allOf)) : IsUnion(type2) ? Union2(FromRest7(type2.anyOf)) : IsObject3(type2) ? FromObject6(type2) : IsBigInt3(type2) ? type2 : IsBoolean3(type2) ? type2 : IsInteger2(type2) ? type2 : IsLiteral(type2) ? type2 : IsNull3(type2) ? type2 : IsNumber3(type2) ? type2 : IsString3(type2) ? type2 : IsSymbol3(type2) ? type2 : IsUndefined3(type2) ? type2 : Object2({});
}
function Required(type2, options) {
  if (IsMappedResult(type2)) {
    return RequiredFromMappedResult(type2, options);
  } else {
    return CreateType({ ...RequiredResolve(type2), ...options });
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/module/compute.mjs
function DereferenceParameters(moduleProperties, types) {
  return types.map((type2) => {
    return IsRef(type2) ? Dereference(moduleProperties, type2.$ref) : FromType2(moduleProperties, type2);
  });
}
function Dereference(moduleProperties, ref) {
  return ref in moduleProperties ? IsRef(moduleProperties[ref]) ? Dereference(moduleProperties, moduleProperties[ref].$ref) : FromType2(moduleProperties, moduleProperties[ref]) : Never();
}
function FromAwaited(parameters) {
  return Awaited(parameters[0]);
}
function FromIndex(parameters) {
  return Index(parameters[0], parameters[1]);
}
function FromKeyOf(parameters) {
  return KeyOf(parameters[0]);
}
function FromPartial(parameters) {
  return Partial(parameters[0]);
}
function FromOmit(parameters) {
  return Omit(parameters[0], parameters[1]);
}
function FromPick(parameters) {
  return Pick(parameters[0], parameters[1]);
}
function FromRequired(parameters) {
  return Required(parameters[0]);
}
function FromComputed5(moduleProperties, target, parameters) {
  const dereferenced = DereferenceParameters(moduleProperties, parameters);
  return target === "Awaited" ? FromAwaited(dereferenced) : target === "Index" ? FromIndex(dereferenced) : target === "KeyOf" ? FromKeyOf(dereferenced) : target === "Partial" ? FromPartial(dereferenced) : target === "Omit" ? FromOmit(dereferenced) : target === "Pick" ? FromPick(dereferenced) : target === "Required" ? FromRequired(dereferenced) : Never();
}
function FromArray6(moduleProperties, type2) {
  return Array2(FromType2(moduleProperties, type2));
}
function FromAsyncIterator3(moduleProperties, type2) {
  return AsyncIterator(FromType2(moduleProperties, type2));
}
function FromConstructor3(moduleProperties, parameters, instanceType) {
  return Constructor(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, instanceType));
}
function FromFunction3(moduleProperties, parameters, returnType) {
  return Function2(FromTypes2(moduleProperties, parameters), FromType2(moduleProperties, returnType));
}
function FromIntersect8(moduleProperties, types) {
  return Intersect(FromTypes2(moduleProperties, types));
}
function FromIterator3(moduleProperties, type2) {
  return Iterator(FromType2(moduleProperties, type2));
}
function FromObject7(moduleProperties, properties) {
  return Object2(globalThis.Object.keys(properties).reduce((result, key) => {
    return { ...result, [key]: FromType2(moduleProperties, properties[key]) };
  }, {}));
}
function FromRecord3(moduleProperties, type2) {
  const [value6, pattern2] = [FromType2(moduleProperties, RecordValue2(type2)), RecordPattern(type2)];
  const result = CloneType(type2);
  result.patternProperties[pattern2] = value6;
  return result;
}
function FromTransform(moduleProperties, transform5) {
  return IsRef(transform5) ? { ...Dereference(moduleProperties, transform5.$ref), [TransformKind]: transform5[TransformKind] } : transform5;
}
function FromTuple5(moduleProperties, types) {
  return Tuple(FromTypes2(moduleProperties, types));
}
function FromUnion10(moduleProperties, types) {
  return Union2(FromTypes2(moduleProperties, types));
}
function FromTypes2(moduleProperties, types) {
  return types.map((type2) => FromType2(moduleProperties, type2));
}
function FromType2(moduleProperties, type2) {
  return IsOptional(type2) ? CreateType(FromType2(moduleProperties, Discard(type2, [OptionalKind])), type2) : IsReadonly(type2) ? CreateType(FromType2(moduleProperties, Discard(type2, [ReadonlyKind])), type2) : IsTransform(type2) ? CreateType(FromTransform(moduleProperties, type2), type2) : IsArray3(type2) ? CreateType(FromArray6(moduleProperties, type2.items), type2) : IsAsyncIterator3(type2) ? CreateType(FromAsyncIterator3(moduleProperties, type2.items), type2) : IsComputed(type2) ? CreateType(FromComputed5(moduleProperties, type2.target, type2.parameters)) : IsConstructor(type2) ? CreateType(FromConstructor3(moduleProperties, type2.parameters, type2.returns), type2) : IsFunction3(type2) ? CreateType(FromFunction3(moduleProperties, type2.parameters, type2.returns), type2) : IsIntersect(type2) ? CreateType(FromIntersect8(moduleProperties, type2.allOf), type2) : IsIterator3(type2) ? CreateType(FromIterator3(moduleProperties, type2.items), type2) : IsObject3(type2) ? CreateType(FromObject7(moduleProperties, type2.properties), type2) : IsRecord(type2) ? CreateType(FromRecord3(moduleProperties, type2)) : IsTuple(type2) ? CreateType(FromTuple5(moduleProperties, type2.items || []), type2) : IsUnion(type2) ? CreateType(FromUnion10(moduleProperties, type2.anyOf), type2) : type2;
}
function ComputeType(moduleProperties, key) {
  return key in moduleProperties ? FromType2(moduleProperties, moduleProperties[key]) : Never();
}
function ComputeModuleProperties(moduleProperties) {
  return globalThis.Object.getOwnPropertyNames(moduleProperties).reduce((result, key) => {
    return { ...result, [key]: ComputeType(moduleProperties, key) };
  }, {});
}

// node_modules/@sinclair/typebox/build/esm/type/module/module.mjs
function Module(properties) {
  return new TModule(properties);
}

class TModule {
  constructor($defs) {
    const computed = ComputeModuleProperties($defs);
    const identified = this.WithIdentifiers(computed);
    this.$defs = identified;
  }
  Import(key, options) {
    const $defs = { ...this.$defs, [key]: CreateType(this.$defs[key], options) };
    return CreateType({ [Kind]: "Import", $defs, $ref: key });
  }
  WithIdentifiers($defs) {
    return globalThis.Object.getOwnPropertyNames($defs).reduce((result, key) => {
      return { ...result, [key]: { ...$defs[key], $id: key } };
    }, {});
  }
}

// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(type2, options) {
  return CreateType({ [Kind]: "Not", not: type2 }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options) {
  return IsFunction3(schema) ? Tuple(schema.parameters, options) : Never();
}

// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = CloneType(callback({ [Kind]: "This", $ref: `${options.$id}` }));
  thisType.$id = options.$id;
  return CreateType({ [Hint]: "Recursive", ...thisType }, options);
}
var Ordinal = 0;

// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options) {
  const expr = IsString(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return CreateType({ [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? T.allOf : IsUnion(T) ? T.anyOf : IsTuple(T) ? T.items ?? [] : [];
}
function Rest(T) {
  return RestResolve(T);
}

// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options) {
  return IsFunction3(schema) ? CreateType(schema.returns, options) : Never(options);
}

// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
function Transform(schema) {
  return new TransformDecodeBuilder(schema);
}

class TransformDecodeBuilder {
  constructor(schema) {
    this.schema = schema;
  }
  Decode(decode5) {
    return new TransformEncodeBuilder(this.schema, decode5);
  }
}

class TransformEncodeBuilder {
  constructor(schema, decode5) {
    this.schema = schema;
    this.decode = decode5;
  }
  EncodeTransform(encode4, schema) {
    const Encode = (value6) => schema[TransformKind].Encode(encode4(value6));
    const Decode = (value6) => this.decode(schema[TransformKind].Decode(value6));
    const Codec = { Encode, Decode };
    return { ...schema, [TransformKind]: Codec };
  }
  EncodeSchema(encode4, schema) {
    const Codec = { Decode: this.decode, Encode: encode4 };
    return { ...schema, [TransformKind]: Codec };
  }
  Encode(encode4) {
    return IsTransform(this.schema) ? this.EncodeTransform(encode4, this.schema) : this.EncodeSchema(encode4, this.schema);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return CreateType({ [Kind]: options[Kind] ?? "Unsafe" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options) {
  return CreateType({ [Kind]: "Void", type: "void" }, options);
}

// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union2,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral2,
  Symbol: () => Symbol2,
  String: () => String2,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Module: () => Module,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal2,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  Instantiate: () => Instantiate,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Date: () => Date3,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const2,
  Composite: () => Composite3,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Argument: () => Argument,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type3 = exports_type3;

// node_modules/elysia/dist/bun/index.js
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function date2(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function getTime(strictTimeZone) {
  return function(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min4 = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min4 <= 59 && sec < 60)
      return true;
    let utcMin = min4 - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
function getDateTime(strictTimeZone) {
  let time2 = getTime(strictTimeZone);
  return function(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date2(dateTime[0]) && time2(dateTime[1]);
  };
}
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
function validateInt32(value6) {
  return Number.isInteger(value6) && value6 <= MAX_INT32 && value6 >= MIN_INT32;
}
function validateInt64(value6) {
  return Number.isInteger(value6);
}
function validateNumber() {
  return true;
}
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Pushref(schema, references) {
  if (!IsString2(schema.$id) || references.some((target) => target.$id === schema.$id))
    return references;
  references.push(schema);
  return references;
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}

class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$ref}'`);
    this.schema = schema;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
function* NumberToBytes(value6) {
  const byteCount = value6 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value6) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value6 >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value6) {
  FNV1A64(ByteMarker.Array);
  for (const item of value6) {
    Visit4(item);
  }
}
function BooleanType(value6) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value6 ? 1 : 0);
}
function BigIntType(value6) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value6);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value6) {
  FNV1A64(ByteMarker.Date);
  Visit4(value6.getTime());
}
function NullType(value6) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value6) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value6);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value6) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value6).sort()) {
    Visit4(key);
    Visit4(value6[key]);
  }
}
function StringType(value6) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value6.length; i++) {
    for (const byte of NumberToBytes(value6.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value6) {
  FNV1A64(ByteMarker.Symbol);
  Visit4(value6.description);
}
function Uint8ArrayType2(value6) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value6.length; i++) {
    FNV1A64(value6[i]);
  }
}
function UndefinedType(value6) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit4(value6) {
  if (IsArray2(value6))
    return ArrayType2(value6);
  if (IsBoolean2(value6))
    return BooleanType(value6);
  if (IsBigInt2(value6))
    return BigIntType(value6);
  if (IsDate2(value6))
    return DateType2(value6);
  if (IsNull2(value6))
    return NullType(value6);
  if (IsNumber2(value6))
    return NumberType(value6);
  if (IsObject2(value6))
    return ObjectType2(value6);
  if (IsString2(value6))
    return StringType(value6);
  if (IsSymbol2(value6))
    return SymbolType(value6);
  if (IsUint8Array2(value6))
    return Uint8ArrayType2(value6);
  if (IsUndefined2(value6))
    return UndefinedType(value6);
  throw new ValueHashError(value6);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value6) {
  Accumulator = BigInt("14695981039346656037");
  Visit4(value6);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  constructor(value6) {
    super(`Unable to hash value`);
    this.value = value6;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("18446744073709551616")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);

// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined(value6) {
  return value6 !== undefined;
}
function FromAny2(schema, references, value6) {
  return true;
}
function FromArgument2(schema, references, value6) {
  return true;
}
function FromArray7(schema, references, value6) {
  if (!IsArray2(value6))
    return false;
  if (IsDefined(schema.minItems) && !(value6.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined(schema.maxItems) && !(value6.length <= schema.maxItems)) {
    return false;
  }
  if (!value6.every((value7) => Visit5(schema.items, references, value7))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set16 = new Set;
    for (const element of value6) {
      const hashed = Hash(element);
      if (set16.has(hashed)) {
        return false;
      } else {
        set16.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value6.reduce((acc, value7) => Visit5(containsSchema, references, value7) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator4(schema, references, value6) {
  return IsAsyncIterator2(value6);
}
function FromBigInt2(schema, references, value6) {
  if (!IsBigInt2(value6))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value6 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value6 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value6 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean2(schema, references, value6) {
  return IsBoolean2(value6);
}
function FromConstructor4(schema, references, value6) {
  return Visit5(schema.returns, references, value6.prototype);
}
function FromDate2(schema, references, value6) {
  if (!IsDate2(value6))
    return false;
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value6.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value6.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.maximumTimestamp) && !(value6.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.minimumTimestamp) && !(value6.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value6.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction4(schema, references, value6) {
  return IsFunction2(value6);
}
function FromImport(schema, references, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit5(target, [...references, ...definitions], value6);
}
function FromInteger2(schema, references, value6) {
  if (!IsInteger(value6)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value6 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value6 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value6 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect9(schema, references, value6) {
  const check1 = schema.allOf.every((schema2) => Visit5(schema2, references, value6));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check22 = Object.getOwnPropertyNames(value6).every((key) => keyPattern.test(key));
    return check1 && check22;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check22 = Object.getOwnPropertyNames(value6).every((key) => keyCheck.test(key) || Visit5(schema.unevaluatedProperties, references, value6[key]));
    return check1 && check22;
  } else {
    return check1;
  }
}
function FromIterator4(schema, references, value6) {
  return IsIterator2(value6);
}
function FromLiteral3(schema, references, value6) {
  return value6 === schema.const;
}
function FromNever2(schema, references, value6) {
  return false;
}
function FromNot2(schema, references, value6) {
  return !Visit5(schema.not, references, value6);
}
function FromNull2(schema, references, value6) {
  return IsNull2(value6);
}
function FromNumber2(schema, references, value6) {
  if (!TypeSystemPolicy.IsNumberLike(value6))
    return false;
  if (IsDefined(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined(schema.minimum) && !(value6 >= schema.minimum)) {
    return false;
  }
  if (IsDefined(schema.maximum) && !(value6 <= schema.maximum)) {
    return false;
  }
  if (IsDefined(schema.multipleOf) && !(value6 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject8(schema, references, value6) {
  if (!TypeSystemPolicy.IsObjectLike(value6))
    return false;
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value6).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value6).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit5(property, references, value6[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value6)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value6, knownKey) && !Visit5(property, references, value6[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value6);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value6);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit5(schema.additionalProperties, references, value6[key]));
  } else {
    return true;
  }
}
function FromPromise4(schema, references, value6) {
  return IsPromise(value6);
}
function FromRecord4(schema, references, value6) {
  if (!TypeSystemPolicy.IsRecordLike(value6)) {
    return false;
  }
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value6).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value6).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value6).every(([key, value7]) => {
    return regex.test(key) ? Visit5(patternSchema, references, value7) : true;
  });
  const check22 = typeof schema.additionalProperties === "object" ? Object.entries(value6).every(([key, value7]) => {
    return !regex.test(key) ? Visit5(schema.additionalProperties, references, value7) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value6).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check22 && check3;
}
function FromRef5(schema, references, value6) {
  return Visit5(Deref(schema, references), references, value6);
}
function FromRegExp2(schema, references, value6) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined(schema.minLength)) {
    if (!(value6.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value6.length <= schema.maxLength))
      return false;
  }
  return regex.test(value6);
}
function FromString2(schema, references, value6) {
  if (!IsString2(value6)) {
    return false;
  }
  if (IsDefined(schema.minLength)) {
    if (!(value6.length >= schema.minLength))
      return false;
  }
  if (IsDefined(schema.maxLength)) {
    if (!(value6.length <= schema.maxLength))
      return false;
  }
  if (IsDefined(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value6))
      return false;
  }
  if (IsDefined(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value6);
  }
  return true;
}
function FromSymbol2(schema, references, value6) {
  return IsSymbol2(value6);
}
function FromTemplateLiteral4(schema, references, value6) {
  return IsString2(value6) && new RegExp(schema.pattern).test(value6);
}
function FromThis(schema, references, value6) {
  return Visit5(Deref(schema, references), references, value6);
}
function FromTuple6(schema, references, value6) {
  if (!IsArray2(value6)) {
    return false;
  }
  if (schema.items === undefined && !(value6.length === 0)) {
    return false;
  }
  if (!(value6.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit5(schema.items[i], references, value6[i]))
      return false;
  }
  return true;
}
function FromUndefined2(schema, references, value6) {
  return IsUndefined2(value6);
}
function FromUnion11(schema, references, value6) {
  return schema.anyOf.some((inner) => Visit5(inner, references, value6));
}
function FromUint8Array2(schema, references, value6) {
  if (!IsUint8Array2(value6)) {
    return false;
  }
  if (IsDefined(schema.maxByteLength) && !(value6.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined(schema.minByteLength) && !(value6.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown2(schema, references, value6) {
  return true;
}
function FromVoid2(schema, references, value6) {
  return TypeSystemPolicy.IsVoidLike(value6);
}
function FromKind(schema, references, value6) {
  if (!exports_type2.Has(schema[Kind]))
    return false;
  const func = exports_type2.Get(schema[Kind]);
  return func(schema, value6);
}
function Visit5(schema, references, value6) {
  const references_ = IsDefined(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny2(schema_, references_, value6);
    case "Argument":
      return FromArgument2(schema_, references_, value6);
    case "Array":
      return FromArray7(schema_, references_, value6);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_, value6);
    case "BigInt":
      return FromBigInt2(schema_, references_, value6);
    case "Boolean":
      return FromBoolean2(schema_, references_, value6);
    case "Constructor":
      return FromConstructor4(schema_, references_, value6);
    case "Date":
      return FromDate2(schema_, references_, value6);
    case "Function":
      return FromFunction4(schema_, references_, value6);
    case "Import":
      return FromImport(schema_, references_, value6);
    case "Integer":
      return FromInteger2(schema_, references_, value6);
    case "Intersect":
      return FromIntersect9(schema_, references_, value6);
    case "Iterator":
      return FromIterator4(schema_, references_, value6);
    case "Literal":
      return FromLiteral3(schema_, references_, value6);
    case "Never":
      return FromNever2(schema_, references_, value6);
    case "Not":
      return FromNot2(schema_, references_, value6);
    case "Null":
      return FromNull2(schema_, references_, value6);
    case "Number":
      return FromNumber2(schema_, references_, value6);
    case "Object":
      return FromObject8(schema_, references_, value6);
    case "Promise":
      return FromPromise4(schema_, references_, value6);
    case "Record":
      return FromRecord4(schema_, references_, value6);
    case "Ref":
      return FromRef5(schema_, references_, value6);
    case "RegExp":
      return FromRegExp2(schema_, references_, value6);
    case "String":
      return FromString2(schema_, references_, value6);
    case "Symbol":
      return FromSymbol2(schema_, references_, value6);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value6);
    case "This":
      return FromThis(schema_, references_, value6);
    case "Tuple":
      return FromTuple6(schema_, references_, value6);
    case "Undefined":
      return FromUndefined2(schema_, references_, value6);
    case "Union":
      return FromUnion11(schema_, references_, value6);
    case "Uint8Array":
      return FromUint8Array2(schema_, references_, value6);
    case "Unknown":
      return FromUnknown2(schema_, references_, value6);
    case "Void":
      return FromVoid2(schema_, references_, value6);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind(schema_, references_, value6);
  }
}
function Check(...args2) {
  return args2.length === 3 ? Visit5(args2[0], args2[1], args2[2]) : Visit5(args2[0], [], args2[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}

// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined2(value6) {
  return value6 !== undefined;
}
function Create(errorType, schema, path, value6, errors = []) {
  return {
    type: errorType,
    schema,
    path,
    value: value6,
    message: GetErrorFunction()({ errorType, path, schema, value: value6, errors }),
    errors
  };
}
function* FromAny3(schema, references, path, value6) {
}
function* FromArgument3(schema, references, path, value6) {
}
function* FromArray8(schema, references, path, value6) {
  if (!IsArray2(value6)) {
    return yield Create(ValueErrorType.Array, schema, path, value6);
  }
  if (IsDefined2(schema.minItems) && !(value6.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value6);
  }
  if (IsDefined2(schema.maxItems) && !(value6.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value6);
  }
  for (let i = 0;i < value6.length; i++) {
    yield* Visit6(schema.items, references, `${path}/${i}`, value6[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set16 = new Set;
    for (const element of value6) {
      const hashed = Hash(element);
      if (set16.has(hashed)) {
        return false;
      } else {
        set16.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value6);
  }
  if (!(IsDefined2(schema.contains) || IsDefined2(schema.minContains) || IsDefined2(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value6.reduce((acc, value7, index) => Visit6(containsSchema, references, `${path}${index}`, value7).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value6);
  }
  if (IsNumber2(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value6);
  }
  if (IsNumber2(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value6);
  }
}
function* FromAsyncIterator5(schema, references, path, value6) {
  if (!IsAsyncIterator2(value6))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value6);
}
function* FromBigInt3(schema, references, path, value6) {
  if (!IsBigInt2(value6))
    return yield Create(ValueErrorType.BigInt, schema, path, value6);
  if (IsDefined2(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.maximum) && !(value6 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.minimum) && !(value6 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.multipleOf) && !(value6 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value6);
  }
}
function* FromBoolean3(schema, references, path, value6) {
  if (!IsBoolean2(value6))
    yield Create(ValueErrorType.Boolean, schema, path, value6);
}
function* FromConstructor5(schema, references, path, value6) {
  yield* Visit6(schema.returns, references, path, value6.prototype);
}
function* FromDate3(schema, references, path, value6) {
  if (!IsDate2(value6))
    return yield Create(ValueErrorType.Date, schema, path, value6);
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value6.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value6);
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value6.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value6);
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value6.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value6);
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value6.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value6);
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value6.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value6);
  }
}
function* FromFunction5(schema, references, path, value6) {
  if (!IsFunction2(value6))
    yield Create(ValueErrorType.Function, schema, path, value6);
}
function* FromImport2(schema, references, path, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  yield* Visit6(target, [...references, ...definitions], path, value6);
}
function* FromInteger3(schema, references, path, value6) {
  if (!IsInteger(value6))
    return yield Create(ValueErrorType.Integer, schema, path, value6);
  if (IsDefined2(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.maximum) && !(value6 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.minimum) && !(value6 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.multipleOf) && !(value6 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value6);
  }
}
function* FromIntersect10(schema, references, path, value6) {
  let hasError = false;
  for (const inner of schema.allOf) {
    for (const error2 of Visit6(inner, references, path, value6)) {
      hasError = true;
      yield error2;
    }
  }
  if (hasError) {
    return yield Create(ValueErrorType.Intersect, schema, path, value6);
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value6)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value6);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value6)) {
      if (!keyCheck.test(valueKey)) {
        const next5 = Visit6(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value6[valueKey]).next();
        if (!next5.done)
          yield next5.value;
      }
    }
  }
}
function* FromIterator5(schema, references, path, value6) {
  if (!IsIterator2(value6))
    yield Create(ValueErrorType.Iterator, schema, path, value6);
}
function* FromLiteral4(schema, references, path, value6) {
  if (!(value6 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value6);
}
function* FromNever3(schema, references, path, value6) {
  yield Create(ValueErrorType.Never, schema, path, value6);
}
function* FromNot3(schema, references, path, value6) {
  if (Visit6(schema.not, references, path, value6).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value6);
}
function* FromNull3(schema, references, path, value6) {
  if (!IsNull2(value6))
    yield Create(ValueErrorType.Null, schema, path, value6);
}
function* FromNumber3(schema, references, path, value6) {
  if (!TypeSystemPolicy.IsNumberLike(value6))
    return yield Create(ValueErrorType.Number, schema, path, value6);
  if (IsDefined2(schema.exclusiveMaximum) && !(value6 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value6 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.maximum) && !(value6 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value6);
  }
  if (IsDefined2(schema.minimum) && !(value6 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value6);
  }
  if (IsDefined2(schema.multipleOf) && !(value6 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value6);
  }
}
function* FromObject9(schema, references, path, value6) {
  if (!TypeSystemPolicy.IsObjectLike(value6))
    return yield Create(ValueErrorType.Object, schema, path, value6);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value6).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value6);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value6).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value6);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value6);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value6[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value6[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value6[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value6)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value6, knownKey)) {
        yield* Visit6(property, references, `${path}/${EscapeKey(knownKey)}`, value6[knownKey]);
      }
    }
  }
}
function* FromPromise5(schema, references, path, value6) {
  if (!IsPromise(value6))
    yield Create(ValueErrorType.Promise, schema, path, value6);
}
function* FromRecord5(schema, references, path, value6) {
  if (!TypeSystemPolicy.IsRecordLike(value6))
    return yield Create(ValueErrorType.Object, schema, path, value6);
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value6).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value6);
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value6).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value6);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value6)) {
    if (regex.test(propertyKey))
      yield* Visit6(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value6)) {
      if (!regex.test(propertyKey))
        yield* Visit6(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value6)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef6(schema, references, path, value6) {
  yield* Visit6(Deref(schema, references), references, path, value6);
}
function* FromRegExp3(schema, references, path, value6) {
  if (!IsString2(value6))
    return yield Create(ValueErrorType.String, schema, path, value6);
  if (IsDefined2(schema.minLength) && !(value6.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value6);
  }
  if (IsDefined2(schema.maxLength) && !(value6.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value6);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value6)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value6);
  }
}
function* FromString3(schema, references, path, value6) {
  if (!IsString2(value6))
    return yield Create(ValueErrorType.String, schema, path, value6);
  if (IsDefined2(schema.minLength) && !(value6.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value6);
  }
  if (IsDefined2(schema.maxLength) && !(value6.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value6);
  }
  if (IsString2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value6)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value6);
    }
  }
  if (IsString2(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value6);
    } else {
      const format6 = exports_format.Get(schema.format);
      if (!format6(value6)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value6);
      }
    }
  }
}
function* FromSymbol3(schema, references, path, value6) {
  if (!IsSymbol2(value6))
    yield Create(ValueErrorType.Symbol, schema, path, value6);
}
function* FromTemplateLiteral5(schema, references, path, value6) {
  if (!IsString2(value6))
    return yield Create(ValueErrorType.String, schema, path, value6);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value6)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value6);
  }
}
function* FromThis2(schema, references, path, value6) {
  yield* Visit6(Deref(schema, references), references, path, value6);
}
function* FromTuple7(schema, references, path, value6) {
  if (!IsArray2(value6))
    return yield Create(ValueErrorType.Tuple, schema, path, value6);
  if (schema.items === undefined && !(value6.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value6);
  }
  if (!(value6.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value6);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit6(schema.items[i], references, `${path}/${i}`, value6[i]);
  }
}
function* FromUndefined3(schema, references, path, value6) {
  if (!IsUndefined2(value6))
    yield Create(ValueErrorType.Undefined, schema, path, value6);
}
function* FromUnion12(schema, references, path, value6) {
  if (Check(schema, references, value6))
    return;
  const errors = schema.anyOf.map((variant) => new ValueErrorIterator(Visit6(variant, references, path, value6)));
  yield Create(ValueErrorType.Union, schema, path, value6, errors);
}
function* FromUint8Array3(schema, references, path, value6) {
  if (!IsUint8Array2(value6))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value6);
  if (IsDefined2(schema.maxByteLength) && !(value6.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value6);
  }
  if (IsDefined2(schema.minByteLength) && !(value6.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value6);
  }
}
function* FromUnknown3(schema, references, path, value6) {
}
function* FromVoid3(schema, references, path, value6) {
  if (!TypeSystemPolicy.IsVoidLike(value6))
    yield Create(ValueErrorType.Void, schema, path, value6);
}
function* FromKind2(schema, references, path, value6) {
  const check3 = exports_type2.Get(schema[Kind]);
  if (!check3(schema, value6))
    yield Create(ValueErrorType.Kind, schema, path, value6);
}
function* Visit6(schema, references, path, value6) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny3(schema_, references_, path, value6);
    case "Argument":
      return yield* FromArgument3(schema_, references_, path, value6);
    case "Array":
      return yield* FromArray8(schema_, references_, path, value6);
    case "AsyncIterator":
      return yield* FromAsyncIterator5(schema_, references_, path, value6);
    case "BigInt":
      return yield* FromBigInt3(schema_, references_, path, value6);
    case "Boolean":
      return yield* FromBoolean3(schema_, references_, path, value6);
    case "Constructor":
      return yield* FromConstructor5(schema_, references_, path, value6);
    case "Date":
      return yield* FromDate3(schema_, references_, path, value6);
    case "Function":
      return yield* FromFunction5(schema_, references_, path, value6);
    case "Import":
      return yield* FromImport2(schema_, references_, path, value6);
    case "Integer":
      return yield* FromInteger3(schema_, references_, path, value6);
    case "Intersect":
      return yield* FromIntersect10(schema_, references_, path, value6);
    case "Iterator":
      return yield* FromIterator5(schema_, references_, path, value6);
    case "Literal":
      return yield* FromLiteral4(schema_, references_, path, value6);
    case "Never":
      return yield* FromNever3(schema_, references_, path, value6);
    case "Not":
      return yield* FromNot3(schema_, references_, path, value6);
    case "Null":
      return yield* FromNull3(schema_, references_, path, value6);
    case "Number":
      return yield* FromNumber3(schema_, references_, path, value6);
    case "Object":
      return yield* FromObject9(schema_, references_, path, value6);
    case "Promise":
      return yield* FromPromise5(schema_, references_, path, value6);
    case "Record":
      return yield* FromRecord5(schema_, references_, path, value6);
    case "Ref":
      return yield* FromRef6(schema_, references_, path, value6);
    case "RegExp":
      return yield* FromRegExp3(schema_, references_, path, value6);
    case "String":
      return yield* FromString3(schema_, references_, path, value6);
    case "Symbol":
      return yield* FromSymbol3(schema_, references_, path, value6);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral5(schema_, references_, path, value6);
    case "This":
      return yield* FromThis2(schema_, references_, path, value6);
    case "Tuple":
      return yield* FromTuple7(schema_, references_, path, value6);
    case "Undefined":
      return yield* FromUndefined3(schema_, references_, path, value6);
    case "Union":
      return yield* FromUnion12(schema_, references_, path, value6);
    case "Uint8Array":
      return yield* FromUint8Array3(schema_, references_, path, value6);
    case "Unknown":
      return yield* FromUnknown3(schema_, references_, path, value6);
    case "Void":
      return yield* FromVoid3(schema_, references_, path, value6);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind2(schema_, references_, path, value6);
  }
}
function Errors(...args2) {
  const iterator = args2.length === 3 ? Visit6(args2[0], args2[1], "", args2[2]) : Visit6(args2[0], [], "", args2[1]);
  return new ValueErrorIterator(iterator);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  constructor(iterator) {
    this.iterator = iterator;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next5 = this.iterator.next();
    return next5.done ? undefined : next5.value;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/assert/assert.mjs
function AssertValue(schema, references, value6) {
  if (Check(schema, references, value6))
    return;
  throw new AssertError(Errors(schema, references, value6));
}
function Assert(...args2) {
  return args2.length === 3 ? AssertValue(args2[0], args2[1], args2[2]) : AssertValue(args2[0], [], args2[1]);
}
var __classPrivateFieldSet = function(receiver, state, value6, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value6) : f ? f.value = value6 : state.set(receiver, value6), value6;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AssertError_instances;
var _AssertError_iterator;
var _AssertError_Iterator;

class AssertError extends TypeBoxError {
  constructor(iterator) {
    const error2 = iterator.First();
    super(error2 === undefined ? "Invalid Value" : error2.message);
    _AssertError_instances.add(this);
    _AssertError_iterator.set(this, undefined);
    __classPrivateFieldSet(this, _AssertError_iterator, iterator, "f");
    this.error = error2;
  }
  Errors() {
    return new ValueErrorIterator(__classPrivateFieldGet(this, _AssertError_instances, "m", _AssertError_Iterator).call(this));
  }
}
_AssertError_iterator = new WeakMap, _AssertError_instances = new WeakSet, _AssertError_Iterator = function* _AssertError_Iterator2() {
  if (this.error)
    yield this.error;
  yield* __classPrivateFieldGet(this, _AssertError_iterator, "f");
};
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function FromObject10(value6) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value6)) {
    Acc[key] = Clone2(value6[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value6)) {
    Acc[key] = Clone2(value6[key]);
  }
  return Acc;
}
function FromArray9(value6) {
  return value6.map((element) => Clone2(element));
}
function FromTypedArray(value6) {
  return value6.slice();
}
function FromMap(value6) {
  return new Map(Clone2([...value6.entries()]));
}
function FromSet(value6) {
  return new Set(Clone2([...value6.entries()]));
}
function FromDate4(value6) {
  return new Date(value6.toISOString());
}
function FromValue2(value6) {
  return value6;
}
function Clone2(value6) {
  if (IsArray2(value6))
    return FromArray9(value6);
  if (IsDate2(value6))
    return FromDate4(value6);
  if (IsTypedArray(value6))
    return FromTypedArray(value6);
  if (IsMap(value6))
    return FromMap(value6);
  if (IsSet(value6))
    return FromSet(value6);
  if (IsObject2(value6))
    return FromObject10(value6);
  if (IsValueType(value6))
    return FromValue2(value6);
  throw new Error("ValueClone: Unable to clone value");
}

// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
function FromDefault(value6) {
  return IsFunction2(value6) ? value6() : Clone2(value6);
}
function FromAny4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArgument4(schema, references) {
  return {};
}
function FromArray10(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey2(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value6 = Visit7(schema.returns, references);
    if (typeof value6 === "object" && !Array.isArray(value6)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value6)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromImport3(schema, references) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit7(target, [...references, ...definitions]);
}
function FromInteger4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value6 = schema.allOf.reduce((acc, schema2) => {
      const next5 = Visit7(schema2, references);
      return typeof next5 === "object" ? { ...acc, ...next5 } : next5;
    }, {});
    if (!Check(schema, references, value6))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value6;
  }
}
function FromIterator6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject11(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required2 = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required2.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromRef7(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey2(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey2(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral6(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple8(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion13(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey2(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Argument":
      return FromArgument4(schema_, references_);
    case "Array":
      return FromArray10(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator6(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Date":
      return FromDate5(schema_, references_);
    case "Function":
      return FromFunction6(schema_, references_);
    case "Import":
      return FromImport3(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect11(schema_, references_);
    case "Iterator":
      return FromIterator6(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise6(schema_, references_);
    case "Record":
      return FromRecord6(schema_, references_);
    case "Ref":
      return FromRef7(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral6(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple8(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion13(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type2.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
function Create2(...args2) {
  recursiveDepth = 0;
  return args2.length === 2 ? Visit7(args2[0], args2[1]) : Visit7(args2[0], []);
}

class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;

// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
function ScoreUnion(schema, references, value6) {
  if (schema[Kind] === "Object" && typeof value6 === "object" && !IsNull2(value6)) {
    const object = schema;
    const keys9 = Object.getOwnPropertyNames(value6);
    const entries3 = Object.entries(object.properties);
    return entries3.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value6[key] ? 100 : 0;
      const checks = Check(schema2, references, value6[key]) ? 10 : 0;
      const exists5 = keys9.includes(key) ? 1 : 0;
      return acc + (literal2 + checks + exists5);
    }, 0);
  } else if (schema[Kind] === "Union") {
    const schemas = schema.anyOf.map((schema2) => Deref(schema2, references));
    const scores = schemas.map((schema2) => ScoreUnion(schema2, references, value6));
    return Math.max(...scores);
  } else {
    return Check(schema, references, value6) ? 1 : 0;
  }
}
function SelectUnion(union11, references, value6) {
  const schemas = union11.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value6);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union11, references, value6) {
  if ("default" in union11) {
    return typeof value6 === "function" ? union11.default : Clone2(union11.default);
  } else {
    const schema = SelectUnion(union11, references, value6);
    return Cast(schema, references, value6);
  }
}
function DefaultClone(schema, references, value6) {
  return Check(schema, references, value6) ? Clone2(value6) : Create2(schema, references);
}
function Default(schema, references, value6) {
  return Check(schema, references, value6) ? value6 : Create2(schema, references);
}
function FromArray11(schema, references, value6) {
  if (Check(schema, references, value6))
    return Clone2(value6);
  const created = IsArray2(value6) ? Clone2(value6) : Create2(schema, references);
  const minimum = IsNumber2(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber2(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value7) => Visit8(schema.items, references, value7));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor7(schema, references, value6) {
  if (Check(schema, references, value6))
    return Create2(schema, references);
  const required2 = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required2.has(key) && value6.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value6.prototype[key]);
  }
  return result;
}
function FromImport4(schema, references, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit8(target, [...references, ...definitions], value6);
}
function IntersectAssign(correct, value6) {
  if (IsObject2(correct) && !IsObject2(value6) || !IsObject2(correct) && IsObject2(value6))
    return correct;
  if (!IsObject2(correct) || !IsObject2(value6))
    return value6;
  return globalThis.Object.getOwnPropertyNames(correct).reduce((result, key) => {
    const property = key in value6 ? IntersectAssign(correct[key], value6[key]) : correct[key];
    return { ...result, [key]: property };
  }, {});
}
function FromIntersect12(schema, references, value6) {
  if (Check(schema, references, value6))
    return value6;
  const correct = Create2(schema, references);
  const assigned = IntersectAssign(correct, value6);
  return Check(schema, references, assigned) ? assigned : correct;
}
function FromNever5(schema, references, value6) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject12(schema, references, value6) {
  if (Check(schema, references, value6))
    return value6;
  if (value6 === null || typeof value6 !== "object")
    return Create2(schema, references);
  const required2 = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required2.has(key) && value6[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value6[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value6)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value6[propertyName]);
    }
  }
  return result;
}
function FromRecord7(schema, references, value6) {
  if (Check(schema, references, value6))
    return Clone2(value6);
  if (value6 === null || typeof value6 !== "object" || Array.isArray(value6) || value6 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value6)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef8(schema, references, value6) {
  return Visit8(Deref(schema, references), references, value6);
}
function FromThis4(schema, references, value6) {
  return Visit8(Deref(schema, references), references, value6);
}
function FromTuple9(schema, references, value6) {
  if (Check(schema, references, value6))
    return Clone2(value6);
  if (!IsArray2(value6))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value6[index]));
}
function FromUnion14(schema, references, value6) {
  return Check(schema, references, value6) ? Clone2(value6) : CastUnion(schema, references, value6);
}
function Visit8(schema, references, value6) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value6);
    case "Constructor":
      return FromConstructor7(schema_, references_, value6);
    case "Import":
      return FromImport4(schema_, references_, value6);
    case "Intersect":
      return FromIntersect12(schema_, references_, value6);
    case "Never":
      return FromNever5(schema_, references_, value6);
    case "Object":
      return FromObject12(schema_, references_, value6);
    case "Record":
      return FromRecord7(schema_, references_, value6);
    case "Ref":
      return FromRef8(schema_, references_, value6);
    case "This":
      return FromThis4(schema_, references_, value6);
    case "Tuple":
      return FromTuple9(schema_, references_, value6);
    case "Union":
      return FromUnion14(schema_, references_, value6);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value6);
    default:
      return Default(schema_, references_, value6);
  }
}
function Cast(...args2) {
  return args2.length === 3 ? Visit8(args2[0], args2[1], args2[2]) : Visit8(args2[0], [], args2[1]);
}

class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsKind(schema) && schema[Kind] !== "Unsafe";
}
function FromArray12(schema, references, value6) {
  if (!IsArray2(value6))
    return value6;
  return value6.map((value7) => Visit9(schema.items, references, value7));
}
function FromImport5(schema, references, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit9(target, [...references, ...definitions], value6);
}
function FromIntersect13(schema, references, value6) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value6)));
  const composite3 = intersections.reduce((acc, value7) => IsObject2(value7) ? { ...acc, ...value7 } : value7, {});
  if (!IsObject2(value6) || !IsObject2(composite3) || !IsKind(unevaluatedProperties))
    return composite3;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value6)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value6[key])) {
      composite3[key] = Visit9(unevaluatedProperties, references, value6[key]);
    }
  }
  return composite3;
}
function FromObject13(schema, references, value6) {
  if (!IsObject2(value6) || IsArray2(value6))
    return value6;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value6)) {
    if (HasPropertyKey2(schema.properties, key)) {
      value6[key] = Visit9(schema.properties[key], references, value6[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value6[key])) {
      value6[key] = Visit9(additionalProperties, references, value6[key]);
      continue;
    }
    delete value6[key];
  }
  return value6;
}
function FromRecord8(schema, references, value6) {
  if (!IsObject2(value6))
    return value6;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value6);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value6[key] = Visit9(propertySchema, references, value6[key]);
      continue;
    }
    if (IsKind(additionalProperties) && Check(additionalProperties, references, value6[key])) {
      value6[key] = Visit9(additionalProperties, references, value6[key]);
      continue;
    }
    delete value6[key];
  }
  return value6;
}
function FromRef9(schema, references, value6) {
  return Visit9(Deref(schema, references), references, value6);
}
function FromThis5(schema, references, value6) {
  return Visit9(Deref(schema, references), references, value6);
}
function FromTuple10(schema, references, value6) {
  if (!IsArray2(value6))
    return value6;
  if (IsUndefined2(schema.items))
    return [];
  const length3 = Math.min(value6.length, schema.items.length);
  for (let i = 0;i < length3; i++) {
    value6[i] = Visit9(schema.items[i], references, value6[i]);
  }
  return value6.length > length3 ? value6.slice(0, length3) : value6;
}
function FromUnion15(schema, references, value6) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value6)) {
      return Visit9(inner, references, value6);
    }
  }
  return value6;
}
function Visit9(schema, references, value6) {
  const references_ = IsString2(schema.$id) ? Pushref(schema, references) : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value6);
    case "Import":
      return FromImport5(schema_, references_, value6);
    case "Intersect":
      return FromIntersect13(schema_, references_, value6);
    case "Object":
      return FromObject13(schema_, references_, value6);
    case "Record":
      return FromRecord8(schema_, references_, value6);
    case "Ref":
      return FromRef9(schema_, references_, value6);
    case "This":
      return FromThis5(schema_, references_, value6);
    case "Tuple":
      return FromTuple10(schema_, references_, value6);
    case "Union":
      return FromUnion15(schema_, references_, value6);
    default:
      return value6;
  }
}
function Clean(...args2) {
  return args2.length === 3 ? Visit9(args2[0], args2[1], args2[2]) : Visit9(args2[0], [], args2[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value6) {
  return IsString2(value6) && !isNaN(value6) && !isNaN(parseFloat(value6));
}
function IsValueToString(value6) {
  return IsBigInt2(value6) || IsBoolean2(value6) || IsNumber2(value6);
}
function IsValueTrue(value6) {
  return value6 === true || IsNumber2(value6) && value6 === 1 || IsBigInt2(value6) && value6 === BigInt("1") || IsString2(value6) && (value6.toLowerCase() === "true" || value6 === "1");
}
function IsValueFalse(value6) {
  return value6 === false || IsNumber2(value6) && (value6 === 0 || Object.is(value6, -0)) || IsBigInt2(value6) && value6 === BigInt("0") || IsString2(value6) && (value6.toLowerCase() === "false" || value6 === "0" || value6 === "-0");
}
function IsTimeStringWithTimeZone(value6) {
  return IsString2(value6) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value6);
}
function IsTimeStringWithoutTimeZone(value6) {
  return IsString2(value6) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value6);
}
function IsDateTimeStringWithTimeZone(value6) {
  return IsString2(value6) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value6);
}
function IsDateTimeStringWithoutTimeZone(value6) {
  return IsString2(value6) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value6);
}
function IsDateString(value6) {
  return IsString2(value6) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value6);
}
function TryConvertLiteralString(value6, target) {
  const conversion = TryConvertString(value6);
  return conversion === target ? conversion : value6;
}
function TryConvertLiteralNumber(value6, target) {
  const conversion = TryConvertNumber(value6);
  return conversion === target ? conversion : value6;
}
function TryConvertLiteralBoolean(value6, target) {
  const conversion = TryConvertBoolean(value6);
  return conversion === target ? conversion : value6;
}
function TryConvertLiteral(schema, value6) {
  return IsString2(schema.const) ? TryConvertLiteralString(value6, schema.const) : IsNumber2(schema.const) ? TryConvertLiteralNumber(value6, schema.const) : IsBoolean2(schema.const) ? TryConvertLiteralBoolean(value6, schema.const) : value6;
}
function TryConvertBoolean(value6) {
  return IsValueTrue(value6) ? true : IsValueFalse(value6) ? false : value6;
}
function TryConvertBigInt(value6) {
  const truncateInteger = (value7) => value7.split(".")[0];
  return IsStringNumeric(value6) ? BigInt(truncateInteger(value6)) : IsNumber2(value6) ? BigInt(Math.trunc(value6)) : IsValueFalse(value6) ? BigInt(0) : IsValueTrue(value6) ? BigInt(1) : value6;
}
function TryConvertString(value6) {
  return IsSymbol2(value6) && value6.description !== undefined ? value6.description.toString() : IsValueToString(value6) ? value6.toString() : value6;
}
function TryConvertNumber(value6) {
  return IsStringNumeric(value6) ? parseFloat(value6) : IsValueTrue(value6) ? 1 : IsValueFalse(value6) ? 0 : value6;
}
function TryConvertInteger(value6) {
  return IsStringNumeric(value6) ? parseInt(value6) : IsNumber2(value6) ? Math.trunc(value6) : IsValueTrue(value6) ? 1 : IsValueFalse(value6) ? 0 : value6;
}
function TryConvertNull(value6) {
  return IsString2(value6) && value6.toLowerCase() === "null" ? null : value6;
}
function TryConvertUndefined(value6) {
  return IsString2(value6) && value6 === "undefined" ? undefined : value6;
}
function TryConvertDate(value6) {
  return IsDate2(value6) ? value6 : IsNumber2(value6) ? new Date(value6) : IsValueTrue(value6) ? new Date(1) : IsValueFalse(value6) ? new Date(0) : IsStringNumeric(value6) ? new Date(parseInt(value6)) : IsTimeStringWithoutTimeZone(value6) ? new Date(`1970-01-01T${value6}.000Z`) : IsTimeStringWithTimeZone(value6) ? new Date(`1970-01-01T${value6}`) : IsDateTimeStringWithoutTimeZone(value6) ? new Date(`${value6}.000Z`) : IsDateTimeStringWithTimeZone(value6) ? new Date(value6) : IsDateString(value6) ? new Date(`${value6}T00:00:00.000Z`) : value6;
}
function Default2(value6) {
  return value6;
}
function FromArray13(schema, references, value6) {
  const elements = IsArray2(value6) ? value6 : [value6];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value6) {
  return TryConvertBigInt(value6);
}
function FromBoolean5(schema, references, value6) {
  return TryConvertBoolean(value6);
}
function FromDate6(schema, references, value6) {
  return TryConvertDate(value6);
}
function FromImport6(schema, references, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit10(target, [...references, ...definitions], value6);
}
function FromInteger5(schema, references, value6) {
  return TryConvertInteger(value6);
}
function FromIntersect14(schema, references, value6) {
  return schema.allOf.reduce((value7, schema2) => Visit10(schema2, references, value7), value6);
}
function FromLiteral6(schema, references, value6) {
  return TryConvertLiteral(schema, value6);
}
function FromNull5(schema, references, value6) {
  return TryConvertNull(value6);
}
function FromNumber5(schema, references, value6) {
  return TryConvertNumber(value6);
}
function FromObject14(schema, references, value6) {
  if (!IsObject2(value6) || IsArray2(value6))
    return value6;
  for (const propertyKey of Object.getOwnPropertyNames(schema.properties)) {
    if (!HasPropertyKey2(value6, propertyKey))
      continue;
    value6[propertyKey] = Visit10(schema.properties[propertyKey], references, value6[propertyKey]);
  }
  return value6;
}
function FromRecord9(schema, references, value6) {
  const isConvertable = IsObject2(value6) && !IsArray2(value6);
  if (!isConvertable)
    return value6;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  for (const [propKey, propValue] of Object.entries(value6)) {
    value6[propKey] = Visit10(property, references, propValue);
  }
  return value6;
}
function FromRef10(schema, references, value6) {
  return Visit10(Deref(schema, references), references, value6);
}
function FromString5(schema, references, value6) {
  return TryConvertString(value6);
}
function FromSymbol5(schema, references, value6) {
  return IsString2(value6) || IsNumber2(value6) ? Symbol(value6) : value6;
}
function FromThis6(schema, references, value6) {
  return Visit10(Deref(schema, references), references, value6);
}
function FromTuple11(schema, references, value6) {
  const isConvertable = IsArray2(value6) && !IsUndefined2(schema.items);
  if (!isConvertable)
    return value6;
  return value6.map((value7, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value7) : value7;
  });
}
function FromUndefined5(schema, references, value6) {
  return TryConvertUndefined(value6);
}
function FromUnion16(schema, references, value6) {
  for (const subschema of schema.anyOf) {
    if (Check(subschema, references, value6)) {
      return value6;
    }
  }
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, Clone2(value6));
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value6;
}
function Visit10(schema, references, value6) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_, value6);
    case "BigInt":
      return FromBigInt5(schema_, references_, value6);
    case "Boolean":
      return FromBoolean5(schema_, references_, value6);
    case "Date":
      return FromDate6(schema_, references_, value6);
    case "Import":
      return FromImport6(schema_, references_, value6);
    case "Integer":
      return FromInteger5(schema_, references_, value6);
    case "Intersect":
      return FromIntersect14(schema_, references_, value6);
    case "Literal":
      return FromLiteral6(schema_, references_, value6);
    case "Null":
      return FromNull5(schema_, references_, value6);
    case "Number":
      return FromNumber5(schema_, references_, value6);
    case "Object":
      return FromObject14(schema_, references_, value6);
    case "Record":
      return FromRecord9(schema_, references_, value6);
    case "Ref":
      return FromRef10(schema_, references_, value6);
    case "String":
      return FromString5(schema_, references_, value6);
    case "Symbol":
      return FromSymbol5(schema_, references_, value6);
    case "This":
      return FromThis6(schema_, references_, value6);
    case "Tuple":
      return FromTuple11(schema_, references_, value6);
    case "Undefined":
      return FromUndefined5(schema_, references_, value6);
    case "Union":
      return FromUnion16(schema_, references_, value6);
    default:
      return Default2(value6);
  }
}
function Convert(...args2) {
  return args2.length === 3 ? Visit10(args2[0], args2[1], args2[2]) : Visit10(args2[0], [], args2[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
function Default3(schema, path, value6) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value6) : value6;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value6, error2);
  }
}
function FromArray14(schema, references, path, value6) {
  return IsArray2(value6) ? Default3(schema, path, value6.map((value7, index) => Visit11(schema.items, references, `${path}/${index}`, value7))) : Default3(schema, path, value6);
}
function FromIntersect15(schema, references, path, value6) {
  if (!IsObject2(value6) || IsValueType(value6))
    return Default3(schema, path, value6);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value6 };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit11(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromImport7(schema, references, path, value6) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Visit11(target, [...references, ...additional], path, value6);
  return Default3(schema, path, result);
}
function FromNot5(schema, references, path, value6) {
  return Default3(schema, path, Visit11(schema.not, references, path, value6));
}
function FromObject15(schema, references, path, value6) {
  if (!IsObject2(value6))
    return Default3(schema, path, value6);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value6 };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit11(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRecord10(schema, references, path, value6) {
  if (!IsObject2(value6))
    return Default3(schema, path, value6);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value6 };
  for (const key of Object.getOwnPropertyNames(value6))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit11(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return Default3(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default3(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default3(schema, path, unknownProperties);
}
function FromRef11(schema, references, path, value6) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value6));
}
function FromThis7(schema, references, path, value6) {
  const target = Deref(schema, references);
  return Default3(schema, path, Visit11(target, references, path, value6));
}
function FromTuple12(schema, references, path, value6) {
  return IsArray2(value6) && IsArray2(schema.items) ? Default3(schema, path, schema.items.map((schema2, index) => Visit11(schema2, references, `${path}/${index}`, value6[index]))) : Default3(schema, path, value6);
}
function FromUnion17(schema, references, path, value6) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value6))
      continue;
    const decoded = Visit11(subschema, references, path, value6);
    return Default3(schema, path, decoded);
  }
  return Default3(schema, path, value6);
}
function Visit11(schema, references, path, value6) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray14(schema_, references_, path, value6);
    case "Import":
      return FromImport7(schema_, references_, path, value6);
    case "Intersect":
      return FromIntersect15(schema_, references_, path, value6);
    case "Not":
      return FromNot5(schema_, references_, path, value6);
    case "Object":
      return FromObject15(schema_, references_, path, value6);
    case "Record":
      return FromRecord10(schema_, references_, path, value6);
    case "Ref":
      return FromRef11(schema_, references_, path, value6);
    case "Symbol":
      return Default3(schema_, path, value6);
    case "This":
      return FromThis7(schema_, references_, path, value6);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value6);
    case "Union":
      return FromUnion17(schema_, references_, path, value6);
    default:
      return Default3(schema_, path, value6);
  }
}
function TransformDecode(schema, references, value6) {
  return Visit11(schema, references, "", value6);
}

class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value6, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value6;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value6, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value6;
    this.error = error2;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
function Default4(schema, path, value6) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value6) : value6;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value6, error2);
  }
}
function FromArray15(schema, references, path, value6) {
  const defaulted = Default4(schema, path, value6);
  return IsArray2(defaulted) ? defaulted.map((value7, index) => Visit12(schema.items, references, `${path}/${index}`, value7)) : defaulted;
}
function FromImport8(schema, references, path, value6) {
  const additional = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  const result = Default4(schema, path, value6);
  return Visit12(target, [...references, ...additional], path, result);
}
function FromIntersect16(schema, references, path, value6) {
  const defaulted = Default4(schema, path, value6);
  if (!IsObject2(value6) || IsValueType(value6))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit12(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform(schema.unevaluatedProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value6) {
  return Default4(schema.not, path, Default4(schema, path, value6));
}
function FromObject16(schema, references, path, value6) {
  const defaulted = Default4(schema, path, value6);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys) {
    if (!HasPropertyKey2(knownProperties, key))
      continue;
    if (IsUndefined2(knownProperties[key]) && (!IsUndefined3(schema.properties[key]) || TypeSystemPolicy.IsExactOptionalProperty(knownProperties, key)))
      continue;
    knownProperties[key] = Visit12(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
  }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord11(schema, references, path, value6) {
  const defaulted = Default4(schema, path, value6);
  if (!IsObject2(value6))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value6))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit12(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default4(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef12(schema, references, path, value6) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value6);
  return Default4(schema, path, resolved);
}
function FromThis8(schema, references, path, value6) {
  const target = Deref(schema, references);
  const resolved = Visit12(target, references, path, value6);
  return Default4(schema, path, resolved);
}
function FromTuple13(schema, references, path, value6) {
  const value1 = Default4(schema, path, value6);
  return IsArray2(schema.items) ? schema.items.map((schema2, index) => Visit12(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion18(schema, references, path, value6) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value6))
      continue;
    const value1 = Visit12(subschema, references, path, value6);
    return Default4(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit12(subschema, references, path, value6);
    if (!Check(schema, references, value1))
      continue;
    return Default4(schema, path, value1);
  }
  return Default4(schema, path, value6);
}
function Visit12(schema, references, path, value6) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray15(schema_, references_, path, value6);
    case "Import":
      return FromImport8(schema_, references_, path, value6);
    case "Intersect":
      return FromIntersect16(schema_, references_, path, value6);
    case "Not":
      return FromNot6(schema_, references_, path, value6);
    case "Object":
      return FromObject16(schema_, references_, path, value6);
    case "Record":
      return FromRecord11(schema_, references_, path, value6);
    case "Ref":
      return FromRef12(schema_, references_, path, value6);
    case "This":
      return FromThis8(schema_, references_, path, value6);
    case "Tuple":
      return FromTuple13(schema_, references_, path, value6);
    case "Union":
      return FromUnion18(schema_, references_, path, value6);
    default:
      return Default4(schema_, path, value6);
  }
}
function TransformEncode(schema, references, value6) {
  return Visit12(schema, references, "", value6);
}

class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value6, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value6;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value6, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value6;
    this.error = error2;
  }
}

// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray16(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromAsyncIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromConstructor8(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromFunction7(schema, references) {
  return IsTransform(schema) || Visit13(schema.returns, references) || schema.parameters.some((schema2) => Visit13(schema2, references));
}
function FromIntersect17(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit13(schema2, references));
}
function FromImport9(schema, references) {
  const additional = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => [...result, schema.$defs[key]], []);
  const target = schema.$defs[schema.$ref];
  return IsTransform(schema) || Visit13(target, [...additional, ...references]);
}
function FromIterator7(schema, references) {
  return IsTransform(schema) || Visit13(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform(schema) || Visit13(schema.not, references);
}
function FromObject17(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit13(schema2, references)) || IsSchema(schema.additionalProperties) && Visit13(schema.additionalProperties, references);
}
function FromPromise7(schema, references) {
  return IsTransform(schema) || Visit13(schema.item, references);
}
function FromRecord12(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform(schema) || Visit13(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
}
function FromRef13(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromThis9(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit13(Deref(schema, references), references);
}
function FromTuple14(schema, references) {
  return IsTransform(schema) || !IsUndefined2(schema.items) && schema.items.some((schema2) => Visit13(schema2, references));
}
function FromUnion19(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit13(schema2, references));
}
function Visit13(schema, references) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray16(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator7(schema_, references_);
    case "Constructor":
      return FromConstructor8(schema_, references_);
    case "Function":
      return FromFunction7(schema_, references_);
    case "Import":
      return FromImport9(schema_, references_);
    case "Intersect":
      return FromIntersect17(schema_, references_);
    case "Iterator":
      return FromIterator7(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject17(schema_, references_);
    case "Promise":
      return FromPromise7(schema_, references_);
    case "Record":
      return FromRecord12(schema_, references_);
    case "Ref":
      return FromRef13(schema_, references_);
    case "This":
      return FromThis9(schema_, references_);
    case "Tuple":
      return FromTuple14(schema_, references_);
    case "Union":
      return FromUnion19(schema_, references_);
    default:
      return IsTransform(schema);
  }
}
function HasTransform(schema, references) {
  visited.clear();
  return Visit13(schema, references);
}
var visited = new Set;

// node_modules/@sinclair/typebox/build/esm/value/decode/decode.mjs
function Decode(...args2) {
  const [schema, references, value6] = args2.length === 3 ? [args2[0], args2[1], args2[2]] : [args2[0], [], args2[1]];
  if (!Check(schema, references, value6))
    throw new TransformDecodeCheckError(schema, value6, Errors(schema, references, value6).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value6) : value6;
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value6) {
  const defaultValue = HasPropertyKey2(schema, "default") ? schema.default : undefined;
  const clone2 = IsFunction2(defaultValue) ? defaultValue() : Clone2(defaultValue);
  return IsUndefined2(value6) ? clone2 : IsObject2(value6) && IsObject2(clone2) ? Object.assign(clone2, value6) : value6;
}
function HasDefaultProperty(schema) {
  return IsKind(schema) && "default" in schema;
}
function FromArray17(schema, references, value6) {
  if (IsArray2(value6)) {
    for (let i = 0;i < value6.length; i++) {
      value6[i] = Visit14(schema.items, references, value6[i]);
    }
    return value6;
  }
  const defaulted = ValueOrDefault(schema, value6);
  if (!IsArray2(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit14(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromDate7(schema, references, value6) {
  return IsDate2(value6) ? value6 : ValueOrDefault(schema, value6);
}
function FromImport10(schema, references, value6) {
  const definitions = globalThis.Object.values(schema.$defs);
  const target = schema.$defs[schema.$ref];
  return Visit14(target, [...references, ...definitions], value6);
}
function FromIntersect18(schema, references, value6) {
  const defaulted = ValueOrDefault(schema, value6);
  return schema.allOf.reduce((acc, schema2) => {
    const next5 = Visit14(schema2, references, defaulted);
    return IsObject2(next5) ? { ...acc, ...next5 } : next5;
  }, {});
}
function FromObject18(schema, references, value6) {
  const defaulted = ValueOrDefault(schema, value6);
  if (!IsObject2(defaulted))
    return defaulted;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    const propertyValue = Visit14(schema.properties[key], references, defaulted[key]);
    if (IsUndefined2(propertyValue))
      continue;
    defaulted[key] = Visit14(schema.properties[key], references, defaulted[key]);
  }
  if (!HasDefaultProperty(schema.additionalProperties))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit14(schema.additionalProperties, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord13(schema, references, value6) {
  const defaulted = ValueOrDefault(schema, value6);
  if (!IsObject2(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && HasDefaultProperty(propertySchema)))
      continue;
    defaulted[key] = Visit14(propertySchema, references, defaulted[key]);
  }
  if (!HasDefaultProperty(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit14(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef14(schema, references, value6) {
  return Visit14(Deref(schema, references), references, ValueOrDefault(schema, value6));
}
function FromThis10(schema, references, value6) {
  return Visit14(Deref(schema, references), references, value6);
}
function FromTuple15(schema, references, value6) {
  const defaulted = ValueOrDefault(schema, value6);
  if (!IsArray2(defaulted) || IsUndefined2(schema.items))
    return defaulted;
  const [items, max6] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max6; i++) {
    if (i < items.length)
      defaulted[i] = Visit14(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion20(schema, references, value6) {
  const defaulted = ValueOrDefault(schema, value6);
  for (const inner of schema.anyOf) {
    const result = Visit14(inner, references, Clone2(defaulted));
    if (Check(inner, references, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit14(schema, references, value6) {
  const references_ = Pushref(schema, references);
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray17(schema_, references_, value6);
    case "Date":
      return FromDate7(schema_, references_, value6);
    case "Import":
      return FromImport10(schema_, references_, value6);
    case "Intersect":
      return FromIntersect18(schema_, references_, value6);
    case "Object":
      return FromObject18(schema_, references_, value6);
    case "Record":
      return FromRecord13(schema_, references_, value6);
    case "Ref":
      return FromRef14(schema_, references_, value6);
    case "This":
      return FromThis10(schema_, references_, value6);
    case "Tuple":
      return FromTuple15(schema_, references_, value6);
    case "Union":
      return FromUnion20(schema_, references_, value6);
    default:
      return ValueOrDefault(schema_, value6);
  }
}
function Default5(...args2) {
  return args2.length === 3 ? Visit14(args2[0], args2[1], args2[2]) : Visit14(args2[0], [], args2[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start5, end6] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start5 = i + 1;
      } else {
        end6 = i;
        yield Escape2(pointer.slice(start5, end6));
        start5 = i + 1;
      }
    } else {
      end6 = i;
    }
  }
  yield Escape2(pointer.slice(start5));
}
function Set4(value6, pointer, update9) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value6, pointer, update9);
  let [owner, next5, key] = [null, value6, ""];
  for (const component of Format(pointer)) {
    if (next5[component] === undefined)
      next5[component] = {};
    owner = next5;
    next5 = next5[component];
    key = component;
  }
  owner[key] = update9;
}
function Delete3(value6, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value6, pointer);
  let [owner, next5, key] = [null, value6, ""];
  for (const component of Format(pointer)) {
    if (next5[component] === undefined || next5[component] === null)
      return;
    owner = next5;
    next5 = next5[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value6, pointer) {
  if (pointer === "")
    return true;
  let [owner, next5, key] = [null, value6, ""];
  for (const component of Format(pointer)) {
    if (next5[component] === undefined)
      return false;
    owner = next5;
    next5 = next5[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value6, pointer) {
  if (pointer === "")
    return value6;
  let current2 = value6;
  for (const component of Format(pointer)) {
    if (current2[component] === undefined)
      return;
    current2 = current2[component];
  }
  return current2;
}

class ValuePointerRootSetError extends TypeBoxError {
  constructor(value6, path, update9) {
    super("Cannot set root value");
    this.value = value6;
    this.path = path;
    this.update = update9;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value6, path) {
    super("Cannot delete root value");
    this.value = value6;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType3(left3, right3) {
  if (!IsObject2(right3))
    return false;
  const leftKeys = [...Object.keys(left3), ...Object.getOwnPropertySymbols(left3)];
  const rightKeys = [...Object.keys(right3), ...Object.getOwnPropertySymbols(right3)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left3[key], right3[key]));
}
function DateType3(left3, right3) {
  return IsDate2(right3) && left3.getTime() === right3.getTime();
}
function ArrayType3(left3, right3) {
  if (!IsArray2(right3) || left3.length !== right3.length)
    return false;
  return left3.every((value6, index) => Equal(value6, right3[index]));
}
function TypedArrayType(left3, right3) {
  if (!IsTypedArray(right3) || left3.length !== right3.length || Object.getPrototypeOf(left3).constructor.name !== Object.getPrototypeOf(right3).constructor.name)
    return false;
  return left3.every((value6, index) => Equal(value6, right3[index]));
}
function ValueType(left3, right3) {
  return left3 === right3;
}
function Equal(left3, right3) {
  if (IsDate2(left3))
    return DateType3(left3, right3);
  if (IsTypedArray(left3))
    return TypedArrayType(left3, right3);
  if (IsArray2(left3))
    return ArrayType3(left3, right3);
  if (IsObject2(left3))
    return ObjectType3(left3, right3);
  if (IsValueType(left3))
    return ValueType(left3, right3);
  throw new Error("ValueEquals: Unable to compare value");
}

// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
function CreateUpdate(path, value6) {
  return { type: "update", path, value: value6 };
}
function CreateInsert(path, value6) {
  return { type: "insert", path, value: value6 };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function AssertDiffable(value6) {
  if (globalThis.Object.getOwnPropertySymbols(value6).length > 0)
    throw new ValueDiffError(value6, "Cannot diff objects with symbols");
}
function* ObjectType4(path, current2, next5) {
  AssertDiffable(current2);
  AssertDiffable(next5);
  if (!IsStandardObject(next5))
    return yield CreateUpdate(path, next5);
  const currentKeys = globalThis.Object.getOwnPropertyNames(current2);
  const nextKeys = globalThis.Object.getOwnPropertyNames(next5);
  for (const key of nextKeys) {
    if (HasPropertyKey2(current2, key))
      continue;
    yield CreateInsert(`${path}/${key}`, next5[key]);
  }
  for (const key of currentKeys) {
    if (!HasPropertyKey2(next5, key))
      continue;
    if (Equal(current2, next5))
      continue;
    yield* Visit15(`${path}/${key}`, current2[key], next5[key]);
  }
  for (const key of currentKeys) {
    if (HasPropertyKey2(next5, key))
      continue;
    yield CreateDelete(`${path}/${key}`);
  }
}
function* ArrayType4(path, current2, next5) {
  if (!IsArray2(next5))
    return yield CreateUpdate(path, next5);
  for (let i = 0;i < Math.min(current2.length, next5.length); i++) {
    yield* Visit15(`${path}/${i}`, current2[i], next5[i]);
  }
  for (let i = 0;i < next5.length; i++) {
    if (i < current2.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next5[i]);
  }
  for (let i = current2.length - 1;i >= 0; i--) {
    if (i < next5.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current2, next5) {
  if (!IsTypedArray(next5) || current2.length !== next5.length || globalThis.Object.getPrototypeOf(current2).constructor.name !== globalThis.Object.getPrototypeOf(next5).constructor.name)
    return yield CreateUpdate(path, next5);
  for (let i = 0;i < Math.min(current2.length, next5.length); i++) {
    yield* Visit15(`${path}/${i}`, current2[i], next5[i]);
  }
}
function* ValueType2(path, current2, next5) {
  if (current2 === next5)
    return;
  yield CreateUpdate(path, next5);
}
function* Visit15(path, current2, next5) {
  if (IsStandardObject(current2))
    return yield* ObjectType4(path, current2, next5);
  if (IsArray2(current2))
    return yield* ArrayType4(path, current2, next5);
  if (IsTypedArray(current2))
    return yield* TypedArrayType2(path, current2, next5);
  if (IsValueType(current2))
    return yield* ValueType2(path, current2, next5);
  throw new ValueDiffError(current2, "Unable to diff value");
}
function Diff(current2, next5) {
  return [...Visit15("", current2, next5)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current2, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current2);
  }
  const clone2 = Clone2(current2);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
var Insert = Object2({
  type: Literal2("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal2("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal2("delete"),
  path: String2()
});
var Edit = Union2([Insert, Update, Delete4]);

class ValueDiffError extends TypeBoxError {
  constructor(value6, message) {
    super(message);
    this.value = value6;
  }
}
// node_modules/@sinclair/typebox/build/esm/value/encode/encode.mjs
function Encode(...args2) {
  const [schema, references, value6] = args2.length === 3 ? [args2[0], args2[1], args2[2]] : [args2[0], [], args2[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value6) : value6;
  if (!Check(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
  return encoded;
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
function IsStandardObject2(value6) {
  return IsObject2(value6) && !IsArray2(value6);
}
function ObjectType5(root, path, current2, next5) {
  if (!IsStandardObject2(current2)) {
    exports_pointer.Set(root, path, Clone2(next5));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current2);
    const nextKeys = Object.getOwnPropertyNames(next5);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current2[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current2[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit16(root, `${path}/${nextKey}`, current2[nextKey], next5[nextKey]);
    }
  }
}
function ArrayType5(root, path, current2, next5) {
  if (!IsArray2(current2)) {
    exports_pointer.Set(root, path, Clone2(next5));
  } else {
    for (let index = 0;index < next5.length; index++) {
      Visit16(root, `${path}/${index}`, current2[index], next5[index]);
    }
    current2.splice(next5.length);
  }
}
function TypedArrayType3(root, path, current2, next5) {
  if (IsTypedArray(current2) && current2.length === next5.length) {
    for (let i = 0;i < current2.length; i++) {
      current2[i] = next5[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next5));
  }
}
function ValueType3(root, path, current2, next5) {
  if (current2 === next5)
    return;
  exports_pointer.Set(root, path, next5);
}
function Visit16(root, path, current2, next5) {
  if (IsArray2(next5))
    return ArrayType5(root, path, current2, next5);
  if (IsTypedArray(next5))
    return TypedArrayType3(root, path, current2, next5);
  if (IsStandardObject2(next5))
    return ObjectType5(root, path, current2, next5);
  if (IsValueType(next5))
    return ValueType3(root, path, current2, next5);
}
function IsNonMutableValue(value6) {
  return IsTypedArray(value6) || IsValueType(value6);
}
function IsMismatchedValue(current2, next5) {
  return IsStandardObject2(current2) && IsArray2(next5) || IsArray2(current2) && IsStandardObject2(next5);
}
function Mutate(current2, next5) {
  if (IsNonMutableValue(current2) || IsNonMutableValue(next5))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current2, next5))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit16(current2, "", current2, next5);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/value/parse/parse.mjs
function ParseValue(operations, type2, references, value6) {
  return operations.reduce((value7, operationKey) => {
    const operation = ParseRegistry.Get(operationKey);
    if (IsUndefined2(operation))
      throw new ParseError2(`Unable to find Parse operation '${operationKey}'`);
    return operation(type2, references, value7);
  }, value6);
}
function Parse(...args2) {
  const [operations, schema, references, value6] = args2.length === 4 ? [args2[0], args2[1], args2[2], args2[3]] : args2.length === 3 ? IsArray2(args2[0]) ? [args2[0], args2[1], [], args2[2]] : [ParseDefault, args2[0], args2[1], args2[2]] : args2.length === 2 ? [ParseDefault, args2[0], [], args2[1]] : (() => {
    throw new ParseError2("Invalid Arguments");
  })();
  return ParseValue(operations, schema, references, value6);
}

class ParseError2 extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
var ParseRegistry;
(function(ParseRegistry2) {
  const registry = new Map([
    ["Assert", (type2, references, value6) => {
      Assert(type2, references, value6);
      return value6;
    }],
    ["Cast", (type2, references, value6) => Cast(type2, references, value6)],
    ["Clean", (type2, references, value6) => Clean(type2, references, value6)],
    ["Clone", (_type, _references, value6) => Clone2(value6)],
    ["Convert", (type2, references, value6) => Convert(type2, references, value6)],
    ["Decode", (type2, references, value6) => HasTransform(type2, references) ? TransformDecode(type2, references, value6) : value6],
    ["Default", (type2, references, value6) => Default5(type2, references, value6)],
    ["Encode", (type2, references, value6) => HasTransform(type2, references) ? TransformEncode(type2, references, value6) : value6]
  ]);
  function Delete5(key) {
    registry.delete(key);
  }
  ParseRegistry2.Delete = Delete5;
  function Set5(key, callback) {
    registry.set(key, callback);
  }
  ParseRegistry2.Set = Set5;
  function Get4(key) {
    return registry.get(key);
  }
  ParseRegistry2.Get = Get4;
})(ParseRegistry || (ParseRegistry = {}));
var ParseDefault = [
  "Clone",
  "Clean",
  "Default",
  "Convert",
  "Assert",
  "Decode"
];
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  ValueErrorIterator: () => ValueErrorIterator,
  Patch: () => Patch,
  Parse: () => Parse,
  Mutate: () => Mutate,
  Hash: () => Hash,
  Errors: () => Errors,
  Equal: () => Equal,
  Encode: () => Encode,
  Edit: () => Edit,
  Diff: () => Diff,
  Default: () => Default5,
  Decode: () => Decode,
  Create: () => Create2,
  Convert: () => Convert,
  Clone: () => Clone2,
  Clean: () => Clean,
  Check: () => Check,
  Cast: () => Cast,
  Assert: () => Assert
});
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema, references, checkFunc, code) {
    this.schema = schema;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema, references);
  }
  Code() {
    return this.code;
  }
  Schema() {
    return this.schema;
  }
  References() {
    return this.references;
  }
  Errors(value6) {
    return Errors(this.schema, this.references, value6);
  }
  Check(value6) {
    return this.checkFunc(value6);
  }
  Decode(value6) {
    if (!this.checkFunc(value6))
      throw new TransformDecodeCheckError(this.schema, value6, this.Errors(value6).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value6) : value6;
  }
  Encode(value6) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value6) : value6;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value6, this.Errors(value6).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value6) {
    if (value6.length === 0)
      return false;
    return Character.IsNumeric(value6.charCodeAt(0));
  }
  function IsAccessor(value6) {
    if (IsFirstCharacterNumeric(value6))
      return false;
    for (let i = 0;i < value6.length; i++) {
      const code = value6.charCodeAt(i);
      const check4 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check4)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object, key) {
    return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer3 = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer3.push($id.charAt(i));
      } else {
        buffer3.push(`_${code}_`);
      }
    }
    return buffer3.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value6, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value6} ? ${expression} : true)` : `(${MemberExpression.Encode(value6, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value6) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value6} === 'object' && ${value6} !== null && !Array.isArray(${value6}))` : `(typeof ${value6} === 'object' && ${value6} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value6) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value6} === 'object' && ${value6} !== null && !Array.isArray(${value6}) && !(${value6} instanceof Date) && !(${value6} instanceof Uint8Array))` : `(typeof ${value6} === 'object' && ${value6} !== null && !(${value6} instanceof Date) && !(${value6} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value6) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value6} === 'number'` : `Number.isFinite(${value6})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value6) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value6} === undefined || ${value6} === null)` : `${value6} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema) {
    return schema[Kind] === "Any" || schema[Kind] === "Unknown";
  }
  function* FromAny5(schema, references, value6) {
    yield "true";
  }
  function* FromArgument5(schema, references, value6) {
    yield "true";
  }
  function* FromArray18(schema, references, value6) {
    yield `Array.isArray(${value6})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber2(schema.maxItems))
      yield `${value6}.length <= ${schema.maxItems}`;
    if (IsNumber2(schema.minItems))
      yield `${value6}.length >= ${schema.minItems}`;
    const elementExpression = CreateExpression(schema.items, references, "value");
    yield `${value6}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema.contains) || IsNumber2(schema.minContains) || IsNumber2(schema.maxContains)) {
      const containsSchema = IsSchema2(schema.contains) ? schema.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber2(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
      const checkMaxContains = IsNumber2(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check4 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check4}})(${value6})`;
    }
    if (schema.uniqueItems === true) {
      const check4 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check4} }`;
      yield `((${parameter}) => { ${block} )(${value6})`;
    }
  }
  function* FromAsyncIterator8(schema, references, value6) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value6})`;
  }
  function* FromBigInt6(schema, references, value6) {
    yield `(typeof ${value6} === 'bigint')`;
    if (IsBigInt2(schema.exclusiveMaximum))
      yield `${value6} < BigInt(${schema.exclusiveMaximum})`;
    if (IsBigInt2(schema.exclusiveMinimum))
      yield `${value6} > BigInt(${schema.exclusiveMinimum})`;
    if (IsBigInt2(schema.maximum))
      yield `${value6} <= BigInt(${schema.maximum})`;
    if (IsBigInt2(schema.minimum))
      yield `${value6} >= BigInt(${schema.minimum})`;
    if (IsBigInt2(schema.multipleOf))
      yield `(${value6} % BigInt(${schema.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema, references, value6) {
    yield `(typeof ${value6} === 'boolean')`;
  }
  function* FromConstructor9(schema, references, value6) {
    yield* Visit17(schema.returns, references, `${value6}.prototype`);
  }
  function* FromDate8(schema, references, value6) {
    yield `(${value6} instanceof Date) && Number.isFinite(${value6}.getTime())`;
    if (IsNumber2(schema.exclusiveMaximumTimestamp))
      yield `${value6}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
    if (IsNumber2(schema.exclusiveMinimumTimestamp))
      yield `${value6}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
    if (IsNumber2(schema.maximumTimestamp))
      yield `${value6}.getTime() <= ${schema.maximumTimestamp}`;
    if (IsNumber2(schema.minimumTimestamp))
      yield `${value6}.getTime() >= ${schema.minimumTimestamp}`;
    if (IsNumber2(schema.multipleOfTimestamp))
      yield `(${value6}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction8(schema, references, value6) {
    yield `(typeof ${value6} === 'function')`;
  }
  function* FromImport11(schema, references, value6) {
    const members = globalThis.Object.getOwnPropertyNames(schema.$defs).reduce((result, key) => {
      return [...result, schema.$defs[key]];
    }, []);
    yield* Visit17(Ref(schema.$ref), [...references, ...members], value6);
  }
  function* FromInteger6(schema, references, value6) {
    yield `Number.isInteger(${value6})`;
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value6} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value6} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value6} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value6} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value6} % ${schema.multipleOf}) === 0`;
  }
  function* FromIntersect19(schema, references, value6) {
    const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value6)).join(" && ");
    if (schema.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value6}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema))};`);
      const check22 = `Object.getOwnPropertyNames(${value6}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value6}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator8(schema, references, value6) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value6})`;
  }
  function* FromLiteral7(schema, references, value6) {
    if (typeof schema.const === "number" || typeof schema.const === "boolean") {
      yield `(${value6} === ${schema.const})`;
    } else {
      yield `(${value6} === '${LiteralString.Escape(schema.const)}')`;
    }
  }
  function* FromNever6(schema, references, value6) {
    yield `false`;
  }
  function* FromNot8(schema, references, value6) {
    const expression = CreateExpression(schema.not, references, value6);
    yield `(!${expression})`;
  }
  function* FromNull6(schema, references, value6) {
    yield `(${value6} === null)`;
  }
  function* FromNumber6(schema, references, value6) {
    yield Policy.IsNumberLike(value6);
    if (IsNumber2(schema.exclusiveMaximum))
      yield `${value6} < ${schema.exclusiveMaximum}`;
    if (IsNumber2(schema.exclusiveMinimum))
      yield `${value6} > ${schema.exclusiveMinimum}`;
    if (IsNumber2(schema.maximum))
      yield `${value6} <= ${schema.maximum}`;
    if (IsNumber2(schema.minimum))
      yield `${value6} >= ${schema.minimum}`;
    if (IsNumber2(schema.multipleOf))
      yield `(${value6} % ${schema.multipleOf}) === 0`;
  }
  function* FromObject19(schema, references, value6) {
    yield Policy.IsObjectLike(value6);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value6}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value6}).length <= ${schema.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value6, knownKey);
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value6})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value6, knownKey, expression);
      }
    }
    if (schema.additionalProperties === false) {
      if (schema.required && schema.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value6}).length === ${knownKeys.length}`;
      } else {
        const keys9 = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value6}).every(key => ${keys9}.includes(key))`;
      }
    }
    if (typeof schema.additionalProperties === "object") {
      const expression = CreateExpression(schema.additionalProperties, references, `${value6}[key]`);
      const keys9 = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value6}).every(key => ${keys9}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema, references, value6) {
    yield `${value6} instanceof Promise`;
  }
  function* FromRecord14(schema, references, value6) {
    yield Policy.IsRecordLike(value6);
    if (IsNumber2(schema.minProperties))
      yield `Object.getOwnPropertyNames(${value6}).length >= ${schema.minProperties}`;
    if (IsNumber2(schema.maxProperties))
      yield `Object.getOwnPropertyNames(${value6}).length <= ${schema.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value6) : schema.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value6}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef15(schema, references, value6) {
    const target = Deref(schema, references);
    if (state.functions.has(schema.$ref))
      return yield `${CreateFunctionName(schema.$ref)}(${value6})`;
    yield* Visit17(target, references, value6);
  }
  function* FromRegExp5(schema, references, value6) {
    const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
    yield `(typeof ${value6} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value6}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value6}.length >= ${schema.minLength}`;
    yield `${variable}.test(${value6})`;
  }
  function* FromString6(schema, references, value6) {
    yield `(typeof ${value6} === 'string')`;
    if (IsNumber2(schema.maxLength))
      yield `${value6}.length <= ${schema.maxLength}`;
    if (IsNumber2(schema.minLength))
      yield `${value6}.length >= ${schema.minLength}`;
    if (schema.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value6})`;
    }
    if (schema.format !== undefined) {
      yield `format('${schema.format}', ${value6})`;
    }
  }
  function* FromSymbol6(schema, references, value6) {
    yield `(typeof ${value6} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema, references, value6) {
    yield `(typeof ${value6} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
    yield `${variable}.test(${value6})`;
  }
  function* FromThis11(schema, references, value6) {
    yield `${CreateFunctionName(schema.$ref)}(${value6})`;
  }
  function* FromTuple16(schema, references, value6) {
    yield `Array.isArray(${value6})`;
    if (schema.items === undefined)
      return yield `${value6}.length === 0`;
    yield `(${value6}.length === ${schema.maxItems})`;
    for (let i = 0;i < schema.items.length; i++) {
      const expression = CreateExpression(schema.items[i], references, `${value6}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema, references, value6) {
    yield `${value6} === undefined`;
  }
  function* FromUnion21(schema, references, value6) {
    const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value6));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema, references, value6) {
    yield `${value6} instanceof Uint8Array`;
    if (IsNumber2(schema.maxByteLength))
      yield `(${value6}.length <= ${schema.maxByteLength})`;
    if (IsNumber2(schema.minByteLength))
      yield `(${value6}.length >= ${schema.minByteLength})`;
  }
  function* FromUnknown5(schema, references, value6) {
    yield "true";
  }
  function* FromVoid5(schema, references, value6) {
    yield Policy.IsVoidLike(value6);
  }
  function* FromKind4(schema, references, value6) {
    const instance = state.instances.size;
    state.instances.set(instance, schema);
    yield `kind('${schema[Kind]}', ${instance}, ${value6})`;
  }
  function* Visit17(schema, references, value6, useHoisting = true) {
    const references_ = IsString2(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (useHoisting && IsString2(schema.$id)) {
      const functionName = CreateFunctionName(schema.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value6})`;
      } else {
        state.functions.set(functionName, "<deferred>");
        const functionCode = CreateFunction(functionName, schema, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value6})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value6);
      case "Argument":
        return yield* FromArgument5(schema_, references_, value6);
      case "Array":
        return yield* FromArray18(schema_, references_, value6);
      case "AsyncIterator":
        return yield* FromAsyncIterator8(schema_, references_, value6);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value6);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value6);
      case "Constructor":
        return yield* FromConstructor9(schema_, references_, value6);
      case "Date":
        return yield* FromDate8(schema_, references_, value6);
      case "Function":
        return yield* FromFunction8(schema_, references_, value6);
      case "Import":
        return yield* FromImport11(schema_, references_, value6);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value6);
      case "Intersect":
        return yield* FromIntersect19(schema_, references_, value6);
      case "Iterator":
        return yield* FromIterator8(schema_, references_, value6);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value6);
      case "Never":
        return yield* FromNever6(schema_, references_, value6);
      case "Not":
        return yield* FromNot8(schema_, references_, value6);
      case "Null":
        return yield* FromNull6(schema_, references_, value6);
      case "Number":
        return yield* FromNumber6(schema_, references_, value6);
      case "Object":
        return yield* FromObject19(schema_, references_, value6);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value6);
      case "Record":
        return yield* FromRecord14(schema_, references_, value6);
      case "Ref":
        return yield* FromRef15(schema_, references_, value6);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value6);
      case "String":
        return yield* FromString6(schema_, references_, value6);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value6);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value6);
      case "This":
        return yield* FromThis11(schema_, references_, value6);
      case "Tuple":
        return yield* FromTuple16(schema_, references_, value6);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value6);
      case "Union":
        return yield* FromUnion21(schema_, references_, value6);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value6);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value6);
      case "Void":
        return yield* FromVoid5(schema_, references_, value6);
      default:
        if (!exports_type2.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema);
        return yield* FromKind4(schema_, references_, value6);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema, references, value6, useHoisting = true) {
    return `(${[...Visit17(schema, references, value6, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema, references, value6, useHoisting = true) {
    const [newline, pad] = ["\n", (length3) => "".padStart(length3, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema, references, value6, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type2) {
    const annotation = state.language === "typescript" ? `: ${type2}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type2) {
    return state.language === "typescript" ? `: ${type2}` : "";
  }
  function Build(schema, references, options) {
    const functionCode = CreateFunction("check", schema, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString2(schema.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args2) {
    const defaults = { language: "javascript" };
    const [schema, references, options] = args2.length === 2 && IsArray2(args2[1]) ? [args2[0], args2[1], defaults] : args2.length === 2 && !IsArray2(args2[1]) ? [args2[0], [], args2[1]] : args2.length === 3 ? [args2[0], args2[1], args2[2]] : args2.length === 1 ? [args2[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema))
      throw new TypeCompilerTypeGuardError(schema);
    for (const schema2 of references)
      if (!IsSchema2(schema2))
        throw new TypeCompilerTypeGuardError(schema2);
    return Build(schema, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema, references = []) {
    const generatedCode = Code(schema, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value6) {
      if (!exports_type2.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type2.Get(kind);
      const schema2 = instances.get(instance);
      return checkFunc(schema2, value6);
    }
    function formatRegistryFunction(format6, value6) {
      if (!exports_format.Has(format6))
        return false;
      const checkFunc = exports_format.Get(format6);
      return checkFunc(value6);
    }
    function hashFunction(value6) {
      return Hash(value6);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));

// node_modules/elysia/dist/bun/index.js
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
async function getResponseLength(response) {
  if (response.bodyUsed || !response.body)
    return 0;
  let length3 = 0, reader = response.body.getReader();
  while (true) {
    let { done: done14, value: value6 } = await reader.read();
    if (done14)
      break;
    length3 += value6.byteLength;
  }
  return length3;
}
function createType(kind, func) {
  if (!exports_type2.Has(kind))
    exports_type2.Set(kind, func);
  return (options = {}) => Unsafe({ ...options, [Kind]: kind });
}
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder2 = new TextDecoder;
  try {
    while (true) {
      let { done: done14, value: value6 } = await reader.read();
      if (done14)
        break;
      if (typeof value6 === "string")
        yield value6;
      else
        yield decoder2.decode(value6);
    }
  } finally {
    reader.releaseLock();
  }
}
function parseQueryFromURL(input, startIndex = 0, array7, object) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i = 0;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(input, i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (array7?.[finalKey])
      if (finalValue.charCodeAt(0) === 91) {
        if (object?.[finalKey])
          finalValue = JSON.parse(finalValue);
        else
          finalValue = finalValue.slice(1, -1).split(",");
        if (currentValue === undefined)
          result[finalKey] = finalValue;
        else if (Array.isArray(currentValue))
          currentValue.push(...finalValue);
        else
          result[finalKey] = finalValue, result[finalKey].unshift(currentValue);
      } else if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    else
      result[finalKey] = finalValue;
  }
}
function parseQueryStandardSchema(input, startIndex = 0) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = startIndex - 1, equalityIndex = startingIndex;
  for (let i = 0;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(input, i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (finalValue.charCodeAt(0) === 91 && finalValue.charCodeAt(finalValue.length - 1) === 93) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {
      }
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else if (finalValue.charCodeAt(0) === 123 && finalValue.charCodeAt(finalValue.length - 1) === 125) {
      try {
        finalValue = JSON.parse(finalValue);
      } catch {
      }
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    } else {
      if (finalValue.includes(","))
        finalValue = finalValue.split(",");
      if (currentValue === undefined)
        result[finalKey] = finalValue;
      else if (Array.isArray(currentValue))
        currentValue.push(finalValue);
      else
        result[finalKey] = [currentValue, finalValue];
    }
  }
}
function parseQuery(input) {
  let result = Object.create(null), flags = 0, inputLength = input.length, startingIndex = -1, equalityIndex = -1;
  for (let i = 0;i < inputLength; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        processKeyValuePair(input, i), startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= VALUE_NEEDS_DECODE;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= VALUE_HAS_PLUS;
        else
          flags |= KEY_HAS_PLUS;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= VALUE_NEEDS_DECODE;
        else
          flags |= KEY_NEEDS_DECODE;
        break;
    }
  if (startingIndex < inputLength)
    processKeyValuePair(input, inputLength);
  return result;
  function processKeyValuePair(input2, endIndex) {
    let hasBothKeyValuePair = equalityIndex > startingIndex, effectiveEqualityIndex = hasBothKeyValuePair ? equalityIndex : endIndex, keySlice = input2.slice(startingIndex + 1, effectiveEqualityIndex);
    if (!hasBothKeyValuePair && keySlice.length === 0)
      return;
    let finalKey = keySlice;
    if (flags & KEY_HAS_PLUS)
      finalKey = finalKey.replace(/\+/g, " ");
    if (flags & KEY_NEEDS_DECODE)
      finalKey = import_fast_decode_uri_component2.default(finalKey) || finalKey;
    let finalValue = "";
    if (hasBothKeyValuePair) {
      let valueSlice = input2.slice(equalityIndex + 1, endIndex);
      if (flags & VALUE_HAS_PLUS)
        valueSlice = valueSlice.replace(/\+/g, " ");
      if (flags & VALUE_NEEDS_DECODE)
        valueSlice = import_fast_decode_uri_component2.default(valueSlice) || valueSlice;
      finalValue = valueSlice;
    }
    let currentValue = result[finalKey];
    if (currentValue === undefined)
      result[finalKey] = finalValue;
    else if (Array.isArray(currentValue))
      currentValue.push(finalValue);
    else
      result[finalKey] = [currentValue, finalValue];
  }
}
function deepClone(source, weak = new WeakMap) {
  if (source === null || typeof source !== "object" || typeof source === "function")
    return source;
  if (weak.has(source))
    return weak.get(source);
  if (Array.isArray(source)) {
    let copy4 = Array(source.length);
    weak.set(source, copy4);
    for (let i = 0;i < source.length; i++)
      copy4[i] = deepClone(source[i], weak);
    return copy4;
  }
  if (typeof source === "object") {
    let keys9 = Object.keys(source).concat(Object.getOwnPropertySymbols(source)), cloned = {};
    for (let key of keys9)
      cloned[key] = deepClone(source[key], weak);
    return cloned;
  }
  return source;
}
var __create2 = Object.create;
var { getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = import.meta.require;
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
  var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function decodeURIComponent2(uri2) {
    var percentPosition = uri2.indexOf("%");
    if (percentPosition === -1)
      return uri2;
    var length3 = uri2.length, decoded = "", last6 = 0, codepoint = 0, startOfOctets = percentPosition, state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length3) {
      var high = hexCodeToInt(uri2[percentPosition + 1], 4), low = hexCodeToInt(uri2[percentPosition + 2], 0), byte2 = high | low, type2 = UTF8_DATA[byte2];
      if (state = UTF8_DATA[256 + state + type2], codepoint = codepoint << 6 | byte2 & UTF8_DATA[364 + type2], state === UTF8_ACCEPT)
        decoded += uri2.slice(last6, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last6 = percentPosition + 3, percentPosition = startOfOctets = uri2.indexOf("%", last6);
      else if (state === UTF8_REJECT)
        return null;
      else {
        if (percentPosition += 3, percentPosition < length3 && uri2.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri2.slice(last6);
  }
  var HEX = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function hexCodeToInt(c, shift2) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift2;
  }
  module.exports = decodeURIComponent2;
});
var require_dist = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse4;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/, domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/, __toString = Object.prototype.toString, NullObject = (() => {
    let C = function() {
    };
    return C.prototype = Object.create(null), C;
  })();
  function parse4(str, options) {
    let obj = new NullObject, len = str.length;
    if (len < 2)
      return obj;
    let dec = options?.decode || decode6, index = 0;
    do {
      let eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      let colonIdx = str.indexOf(";", index), endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      let keyStartIdx = startIndex(str, index, eqIdx), keyEndIdx = endIndex(str, eqIdx, keyStartIdx), key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx), valEndIdx = endIndex(str, endIdx, valStartIdx), value6 = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value6;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max7) {
    do {
      let code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max7);
    return max7;
  }
  function endIndex(str, index, min4) {
    while (index > min4) {
      let code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min4;
  }
  function serialize(name, val, options) {
    let enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name))
      throw TypeError(`argument name is invalid: ${name}`);
    let value6 = enc(val);
    if (!cookieValueRegExp.test(value6))
      throw TypeError(`argument val is invalid: ${val}`);
    let str = name + "=" + value6;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge))
        throw TypeError(`option maxAge is invalid: ${options.maxAge}`);
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain))
        throw TypeError(`option domain is invalid: ${options.domain}`);
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path))
        throw TypeError(`option path is invalid: ${options.path}`);
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate2(options.expires) || !Number.isFinite(options.expires.valueOf()))
        throw TypeError(`option expires is invalid: ${options.expires}`);
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly)
      str += "; HttpOnly";
    if (options.secure)
      str += "; Secure";
    if (options.partitioned)
      str += "; Partitioned";
    if (options.priority)
      switch (typeof options.priority === "string" ? options.priority.toLowerCase() : undefined) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw TypeError(`option priority is invalid: ${options.priority}`);
      }
    if (options.sameSite)
      switch (typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    return str;
  }
  function decode6(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate2(val) {
    return __toString.call(val) === "[object Date]";
  }
});
var Y = (v, b) => {
  let A = b?.length ? {} : null;
  if (A)
    for (let Q of b)
      A[Q.part.charCodeAt(0)] = Q;
  return { part: v, store: null, inert: A, params: null, wildcardStore: null };
};
var k = (v, b) => ({ ...v, part: b });
var T = (v) => ({ name: v, store: null, inert: null });

class _ {
  config;
  root = {};
  history = [];
  deferred = [];
  constructor(v = {}) {
    if (this.config = v, v.lazy)
      this.find = this.lazyFind;
    if (v.onParam && !Array.isArray(v.onParam))
      this.config.onParam = [this.config.onParam];
  }
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /(\/:\w+\?)/g };
  lazyFind = (v, b) => {
    if (!this.config.lazy)
      return this.find;
    return this.build(), this.find(v, b);
  };
  build() {
    if (!this.config.lazy)
      return;
    for (let [v, b, A] of this.deferred)
      this.add(v, b, A, { lazy: false, ignoreHistory: true });
    this.deferred = [], this.find = (v, b) => {
      let A = this.root[v];
      if (!A)
        return null;
      return $(b, b.length, A, 0, this.config.onParam);
    };
  }
  add(v, b, A, { ignoreError: Q = false, ignoreHistory: O = false, lazy: V = this.config.lazy } = {}) {
    if (V)
      return this.find = this.lazyFind, this.deferred.push([v, b, A]), A;
    if (typeof b !== "string")
      throw TypeError("Route path must be a string");
    if (b === "")
      b = "/";
    else if (b[0] !== "/")
      b = `/${b}`;
    let X = b[b.length - 1] === "*", J = b.match(_.regex.optionalParams);
    if (J) {
      let F = b.replaceAll("?", "");
      this.add(v, F, A, { ignoreError: Q, ignoreHistory: O, lazy: V });
      for (let B = 0;B < J.length; B++) {
        let D = b.replace(J[B], "");
        this.add(v, D, A, { ignoreError: true, ignoreHistory: O, lazy: V });
      }
      return A;
    }
    if (J)
      b = b.replaceAll("?", "");
    if (this.history.find(([F, B, D]) => F === v && B === b))
      return A;
    if (X || J && b.charCodeAt(b.length - 1) === 63)
      b = b.slice(0, -1);
    if (!O)
      this.history.push([v, b, A]);
    let K = b.split(_.regex.static), G = b.match(_.regex.params) || [];
    if (K[K.length - 1] === "")
      K.pop();
    let q;
    if (!this.root[v])
      q = this.root[v] = Y("/");
    else
      q = this.root[v];
    let U = 0;
    for (let F = 0;F < K.length; ++F) {
      let B = K[F];
      if (F > 0) {
        let D = G[U++].slice(1);
        if (q.params === null)
          q.params = T(D);
        else if (q.params.name !== D)
          if (Q)
            return A;
          else
            throw Error(`Cannot create route "${b}" with parameter "${D}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
        let S = q.params;
        if (S.inert === null) {
          q = S.inert = Y(B);
          continue;
        }
        q = S.inert;
      }
      for (let D = 0;; ) {
        if (D === B.length) {
          if (D < q.part.length) {
            let S = k(q, q.part.slice(D));
            Object.assign(q, Y(B, [S]));
          }
          break;
        }
        if (D === q.part.length) {
          if (q.inert === null)
            q.inert = {};
          let S = q.inert[B.charCodeAt(D)];
          if (S) {
            q = S, B = B.slice(D), D = 0;
            continue;
          }
          let Z = Y(B.slice(D));
          q.inert[B.charCodeAt(D)] = Z, q = Z;
          break;
        }
        if (B[D] !== q.part[D]) {
          let S = k(q, q.part.slice(D)), Z = Y(B.slice(D));
          Object.assign(q, Y(q.part.slice(0, D), [S, Z])), q = Z;
          break;
        }
        ++D;
      }
    }
    if (U < G.length) {
      let B = G[U].slice(1);
      if (q.params === null)
        q.params = T(B);
      else if (q.params.name !== B)
        if (Q)
          return A;
        else
          throw Error(`Cannot create route "${b}" with parameter "${B}" because a route already exists with a different parameter name ("${q.params.name}") in the same location`);
      if (q.params.store === null)
        q.params.store = A;
      return q.params.store;
    }
    if (X) {
      if (q.wildcardStore === null)
        q.wildcardStore = A;
      return q.wildcardStore;
    }
    if (q.store === null)
      q.store = A;
    return q.store;
  }
  find(v, b) {
    let A = this.root[v];
    if (!A)
      return null;
    return $(b, b.length, A, 0, this.config.onParam);
  }
}
var $ = (v, b, A, Q, O) => {
  let V = A.part, X = V.length, J = Q + X;
  if (X > 1) {
    if (J > b)
      return null;
    if (X < 15) {
      for (let K = 1, G = Q + 1;K < X; ++K, ++G)
        if (V.charCodeAt(K) !== v.charCodeAt(G))
          return null;
    } else if (v.slice(Q, J) !== V)
      return null;
  }
  if (J === b) {
    if (A.store !== null)
      return { store: A.store, params: {} };
    if (A.wildcardStore !== null)
      return { store: A.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (A.inert !== null) {
    let K = A.inert[v.charCodeAt(J)];
    if (K !== undefined) {
      let G = $(v, b, K, J, O);
      if (G !== null)
        return G;
    }
  }
  if (A.params !== null) {
    let { store: K, name: G, inert: q } = A.params, U = v.indexOf("/", J);
    if (U !== J) {
      if (U === -1 || U >= b) {
        if (K !== null) {
          let F = {};
          if (F[G] = v.substring(J, b), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F[G], G);
              if (D !== undefined)
                F[G] = D;
            }
          return { store: K, params: F };
        }
      } else if (q !== null) {
        let F = $(v, b, q, U, O);
        if (F !== null) {
          if (F.params[G] = v.substring(J, U), O)
            for (let B = 0;B < O.length; B++) {
              let D = O[B](F.params[G], G);
              if (D !== undefined)
                F.params[G] = D;
            }
          return F;
        }
      }
    }
  }
  if (A.wildcardStore !== null)
    return { store: A.wildcardStore, params: { "*": v.substring(J, b) } };
  return null;
};
var import_fast_decode_uri_component4 = __toESM2(require_fast_decode_uri_component(), 1);
var fullFormats = { date: date2, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
var parseDateTimeEmptySpace = (str) => {
  if (str.charCodeAt(str.length - 6) === 32)
    return str.slice(0, -6) + "+" + str.slice(-5);
  return str;
};
var DATE_TIME_SEPARATOR = /t|\s/i;
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
var Z_ANCHOR = /[^\\]\\Z/;
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  exports_format.Set("date", (value6) => {
    let temp = parseDateTimeEmptySpace(value6).replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  exports_format.Set("date-time", (value6) => {
    let temp = value6.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      exports_format.Set(formatName, (value6) => formatValue.test(value6));
    else if (typeof formatValue === "function")
      exports_format.Set(formatName, formatValue);
  }
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value6) => !!value6 && !isNaN(+value6));
if (!exports_format.Has("integer"))
  exports_format.Set("integer", (value6) => !!value6 && Number.isInteger(+value6));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value6) => value6 === "true" || value6 === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value6) => {
    let start5 = value6.charCodeAt(0);
    if (start5 === 9 || start5 === 10 || start5 === 32)
      start5 = value6.trimStart().charCodeAt(0);
    if (start5 !== 123 && start5 !== 91)
      return false;
    try {
      return JSON.parse(value6), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value6) => {
    let start5 = value6.charCodeAt(0);
    if (start5 === 9 || start5 === 10 || start5 === 32)
      start5 = value6.trimStart().charCodeAt(0);
    if (start5 !== 123 && start5 !== 91)
      return false;
    try {
      return JSON.parse(value6), true;
    } catch {
      return false;
    }
  });
var isBun = typeof Bun < "u";
var mime = { aac: "audio/aac", abw: "application/x-abiword", ai: "application/postscript", arc: "application/octet-stream", avi: "video/x-msvideo", azw: "application/vnd.amazon.ebook", bin: "application/octet-stream", bz: "application/x-bzip", bz2: "application/x-bzip2", csh: "application/x-csh", css: "text/css", csv: "text/csv", doc: "application/msword", dll: "application/octet-stream", eot: "application/vnd.ms-fontobject", epub: "application/epub+zip", gif: "image/gif", htm: "text/html", html: "text/html", ico: "image/x-icon", ics: "text/calendar", jar: "application/java-archive", jpeg: "image/jpeg", jpg: "image/jpeg", js: "application/javascript", json: "application/json", mid: "audio/midi", midi: "audio/midi", mp2: "audio/mpeg", mp3: "audio/mpeg", mp4: "video/mp4", mpa: "video/mpeg", mpe: "video/mpeg", mpeg: "video/mpeg", mpkg: "application/vnd.apple.installer+xml", odp: "application/vnd.oasis.opendocument.presentation", ods: "application/vnd.oasis.opendocument.spreadsheet", odt: "application/vnd.oasis.opendocument.text", oga: "audio/ogg", ogv: "video/ogg", ogx: "application/ogg", otf: "font/otf", png: "image/png", pdf: "application/pdf", ppt: "application/vnd.ms-powerpoint", rar: "application/x-rar-compressed", rtf: "application/rtf", sh: "application/x-sh", svg: "image/svg+xml", swf: "application/x-shockwave-flash", tar: "application/x-tar", tif: "image/tiff", tiff: "image/tiff", ts: "application/typescript", ttf: "font/ttf", txt: "text/plain", vsd: "application/vnd.visio", wav: "audio/x-wav", weba: "audio/webm", webm: "video/webm", webp: "image/webp", woff: "font/woff", woff2: "font/woff2", xhtml: "application/xhtml+xml", xls: "application/vnd.ms-excel", xlsx: "application/vnd.ms-excel", xlsx_OLD: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", xml: "application/xml", xul: "application/vnd.mozilla.xul+xml", zip: "application/zip", "3gp": "video/3gpp", "3gp_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp", "3gp2": "video/3gpp2", "3gp2_DOES_NOT_CONTAIN_VIDEO": "audio/3gpp2", "7z": "application/x-7z-compressed" };
var getFileExtension = (path) => {
  let index = path.lastIndexOf(".");
  if (index === -1)
    return "";
  return path.slice(index + 1);
};
var createReadStream;
var stat;

class ElysiaFile {
  path;
  value;
  stats;
  constructor(path) {
    this.path = path;
    if (isBun)
      this.value = Bun.file(path);
    else if (typeof window < "u")
      console.warn("Browser environment does not support file");
    else if (!createReadStream || !stat)
      try {
        this.value = import("fs").then((fs) => {
          return createReadStream = fs.createReadStream, fs.createReadStream(path);
        }), this.stats = import("fs/promises").then((fs) => {
          return stat = fs.stat, fs.stat(path);
        });
      } catch {
      }
    else
      this.value = createReadStream(path), this.stats = stat(path);
  }
  get type() {
    return mime[getFileExtension(this.path)] || "application/octet-stream";
  }
  get length() {
    if (isBun)
      return this.value.size;
    return this.stats?.then((x) => x.size) ?? 0;
  }
}
var hasHeaderShorthand = "toJSON" in new Headers;
var replaceUrlPath = (url2, pathname) => {
  let urlObject = new URL(url2);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString && v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject2 = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, options) => {
  let skipKeys = options?.skipKeys, override = options?.override ?? true, mergeArray = options?.mergeArray ?? false;
  if (!isObject2(target) || !isObject2(source))
    return target;
  for (let [key, value6] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (mergeArray && Array.isArray(value6)) {
      target[key] = Array.isArray(target[key]) ? [...target[key], ...value6] : target[key] = value6;
      continue;
    }
    if (!isObject2(value6) || !(key in target) || isClass(value6)) {
      if ((override || !(key in target)) && !Object.isFrozen(target))
        try {
          target[key] = value6;
        } catch {
        }
      continue;
    }
    if (!Object.isFrozen(target[key]))
      try {
        target[key] = mergeDeep(target[key], value6, { skipKeys, override, mergeArray });
      } catch {
      }
  }
  return target;
};
var mergeCookie = (a, b) => {
  let v = mergeDeep(Object.assign({}, a), b, { skipKeys: ["properties"], mergeArray: false });
  if (v.properties)
    delete v.properties;
  return v;
};
var mergeObjectArray = (a, b) => {
  if (!b)
    return a;
  let array7 = [], checksums = [];
  if (a) {
    if (!Array.isArray(a))
      a = [a];
    for (let item of a)
      if (array7.push(item), item.checksum)
        checksums.push(item.checksum);
  }
  if (b) {
    if (!Array.isArray(b))
      b = [b];
    for (let item of b)
      if (!checksums.includes(item.checksum))
        array7.push(item);
  }
  return array7;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every((x2) => !isNaN(+x2));
var mergeResponse = (a, b) => {
  if (isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({}, a, b);
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return Object.assign({ 200: a }, b);
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  if (!a && !b)
    return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  if (!b)
    return a ?? {};
  if (!a)
    return b ?? {};
  if (!Object.values(b).find((x) => x !== undefined && x !== null))
    return { ...a };
  let hook = { ...a, ...b, body: b.body ?? a.body, headers: b.headers ?? a.headers, params: b.params ?? a.params, query: b.query ?? a.query, cookie: b.cookie ?? a.cookie, response: mergeResponse(a.response, b.response), type: a.type || b.type, detail: mergeDeep(b.detail ?? {}, a.detail ?? {}), parse: mergeObjectArray(a.parse, b.parse), transform: mergeObjectArray(a.transform, b.transform), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), mergeObjectArray(fnToContainer(b.resolve, "resolve"), b.beforeHandle)), afterHandle: mergeObjectArray(a.afterHandle, b.afterHandle), mapResponse: mergeObjectArray(a.mapResponse, b.mapResponse), afterResponse: mergeObjectArray(a.afterResponse, b.afterResponse), trace: mergeObjectArray(a.trace, b.trace), error: mergeObjectArray(a.error, b.error), standaloneSchema: a.standaloneSchema || b.standaloneSchema ? a.standaloneSchema && !b.standaloneSchema ? a.standaloneSchema : b.standaloneSchema && !a.standaloneSchema ? b.standaloneSchema : [...a.standaloneSchema ?? [], ...b.standaloneSchema ?? []] : undefined };
  if (hook.resolve)
    delete hook.resolve;
  return hook;
};
var lifeCycleToArray = (a) => {
  if (a.parse && !Array.isArray(a.parse))
    a.parse = [a.parse];
  if (a.transform && !Array.isArray(a.transform))
    a.transform = [a.transform];
  if (a.afterHandle && !Array.isArray(a.afterHandle))
    a.afterHandle = [a.afterHandle];
  if (a.mapResponse && !Array.isArray(a.mapResponse))
    a.mapResponse = [a.mapResponse];
  if (a.afterResponse && !Array.isArray(a.afterResponse))
    a.afterResponse = [a.afterResponse];
  if (a.trace && !Array.isArray(a.trace))
    a.trace = [a.trace];
  if (a.error && !Array.isArray(a.error))
    a.error = [a.error];
  let beforeHandle = [];
  if (a.resolve)
    beforeHandle = fnToContainer(Array.isArray(a.resolve) ? a.resolve : [a.resolve], "resolve"), delete a.resolve;
  if (a.beforeHandle)
    if (beforeHandle.length)
      beforeHandle = beforeHandle.concat(Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle]);
    else
      beforeHandle = Array.isArray(a.beforeHandle) ? a.beforeHandle : [a.beforeHandle];
  if (beforeHandle.length)
    a.beforeHandle = beforeHandle;
  return a;
};
var isBun2 = typeof Bun < "u";
var hasBunHash = isBun2 && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasBunHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var injectChecksum = (checksum2, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn2 = x;
    if (checksum2 && !fn2.checksum)
      fn2.checksum = checksum2;
    if (fn2.scope === "scoped")
      fn2.scope = "local";
    return fn2;
  }
  let fns = [...x];
  for (let fn2 of fns) {
    if (checksum2 && !fn2.checksum)
      fn2.checksum = checksum2;
    if (fn2.scope === "scoped")
      fn2.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(mergeObjectArray(fnToContainer(a.resolve, "resolve"), a.beforeHandle), injectChecksum(checksum2, mergeObjectArray(fnToContainer(b?.resolve, "resolve"), b?.beforeHandle))), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn2, inject, { skipIfHasType = false }) => {
  if (!fn2)
    return fn2;
  if (!Array.isArray(fn2)) {
    if (skipIfHasType)
      fn2.scope ??= inject;
    else
      fn2.scope = inject;
    return fn2;
  }
  for (let x of fn2)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn2;
};
var filterGlobal = (fn2) => {
  if (!fn2)
    return fn2;
  if (!Array.isArray(fn2))
    switch (fn2.scope) {
      case "global":
      case "scoped":
        return { ...fn2 };
      default:
        return { fn: fn2 };
    }
  let array7 = [];
  for (let x of fn2)
    switch (x.scope) {
      case "global":
      case "scoped":
        array7.push({ ...x });
        break;
    }
  return array7;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Enhance Your Calm": 420, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k2, v]) => [v, k2]));
var encoder2 = new TextEncoder;
var signCookie = async (val, secret2) => {
  if (typeof val === "object")
    val = JSON.stringify(val);
  else if (typeof val !== "string")
    val = val + "";
  if (secret2 === null)
    throw TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder2.encode(secret2), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder2.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret2) => {
  if (typeof input !== "string")
    throw TypeError("Signed cookie string must be provided.");
  if (secret2 === null)
    throw TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret2) === input ? tentativeValue : false;
};
var insertStandaloneValidator = (hook, name, value6) => {
  if (!hook.standaloneValidator?.length || !Array.isArray(hook.standaloneValidator)) {
    hook.standaloneValidator = [{ [name]: value6 }];
    return;
  }
  let last6 = hook.standaloneValidator[hook.standaloneValidator.length - 1];
  if (name in last6)
    hook.standaloneValidator.push({ [name]: value6 });
  else
    last6[name] = value6;
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length3 = Number(message);
    if (Number.isNaN(length3))
      return null;
    return length3;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number5 = Number(message);
    if (Number.isNaN(number5) || number5.toString() !== message)
      return null;
    return number5;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  onFinally;
  root = null;
  promises = [];
  constructor(onError4 = console.error, onFinally = () => {
  }) {
    this.onError = onError4;
    this.onFinally = onFinally;
  }
  get size() {
    return this.promises.length;
  }
  add(promise3) {
    if (this.promises.push(promise3), this.root ||= this.drain(), this.promises.length === 1)
      this.then(this.onFinally);
    return promise3;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error2) {
        this.onError(error2);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn2, subType) => {
  if (!fn2)
    return fn2;
  if (!Array.isArray(fn2)) {
    if (typeof fn2 === "function" || typeof fn2 === "string")
      return subType ? { fn: fn2, subType } : { fn: fn2 };
    else if ("fn" in fn2)
      return fn2;
  }
  let fns = [];
  for (let x of fn2)
    if (typeof x === "function" || typeof x === "string")
      fns.push(subType ? { fn: x, subType } : { fn: x });
    else if ("fn" in x)
      fns.push(x);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  if (a.start)
    a.start = fnToContainer(a.start);
  if (a.request)
    a.request = fnToContainer(a.request);
  if (a.parse)
    a.parse = fnToContainer(a.parse);
  if (a.transform)
    a.transform = fnToContainer(a.transform);
  if (a.beforeHandle)
    a.beforeHandle = fnToContainer(a.beforeHandle);
  if (a.afterHandle)
    a.afterHandle = fnToContainer(a.afterHandle);
  if (a.mapResponse)
    a.mapResponse = fnToContainer(a.mapResponse);
  if (a.afterResponse)
    a.afterResponse = fnToContainer(a.afterResponse);
  if (a.trace)
    a.trace = fnToContainer(a.trace);
  if (a.error)
    a.error = fnToContainer(a.error);
  if (a.stop)
    a.stop = fnToContainer(a.stop);
  return a;
};
var lifeCycleToFn = (a) => {
  let lifecycle = Object.create(null);
  if (a.start?.map)
    lifecycle.start = a.start.map((x) => x.fn);
  if (a.request?.map)
    lifecycle.request = a.request.map((x) => x.fn);
  if (a.parse?.map)
    lifecycle.parse = a.parse.map((x) => x.fn);
  if (a.transform?.map)
    lifecycle.transform = a.transform.map((x) => x.fn);
  if (a.beforeHandle?.map)
    lifecycle.beforeHandle = a.beforeHandle.map((x) => x.fn);
  if (a.afterHandle?.map)
    lifecycle.afterHandle = a.afterHandle.map((x) => x.fn);
  if (a.mapResponse?.map)
    lifecycle.mapResponse = a.mapResponse.map((x) => x.fn);
  if (a.afterResponse?.map)
    lifecycle.afterResponse = a.afterResponse.map((x) => x.fn);
  if (a.error?.map)
    lifecycle.error = a.error.map((x) => x.fn);
  if (a.stop?.map)
    lifecycle.stop = a.stop.map((x) => x.fn);
  if (a.trace?.map)
    lifecycle.trace = a.trace.map((x) => x.fn);
  else
    lifecycle.trace = [];
  return lifecycle;
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server, path: inference.path, route: inference.route, url: inference.url });
var redirect = (url2, status2 = 302) => Response.redirect(url2, status2);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var form = (items) => {
  let formData = new FormData;
  if (formData[ELYSIA_FORM_DATA] = {}, items)
    for (let [key, value6] of Object.entries(items)) {
      if (Array.isArray(value6)) {
        formData[ELYSIA_FORM_DATA][key] = [];
        for (let v of value6) {
          if (value6 instanceof File)
            formData.append(key, value6, value6.name);
          else if (value6 instanceof ElysiaFile)
            formData.append(key, value6.value, value6.value?.name);
          else
            formData.append(key, value6);
          formData[ELYSIA_FORM_DATA][key].push(value6);
        }
        continue;
      }
      if (value6 instanceof File)
        formData.append(key, value6, value6.name);
      else if (value6 instanceof ElysiaFile)
        formData.append(key, value6.value, value6.value?.name);
      else
        formData.append(key, value6);
      formData[ELYSIA_FORM_DATA][key] = value6;
    }
  return formData;
};
var randomId = () => {
  let uuid = crypto.randomUUID();
  return uuid.slice(0, 8) + uuid.slice(24, 32);
};
var deduplicateChecksum = (array7) => {
  if (!array7.length)
    return [];
  let hashes = [];
  for (let i = 0;i < array7.length; i++) {
    let item = array7[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array7.splice(i, 1), i--;
      hashes.push(item.checksum);
    }
  }
  return array7;
};
var promoteEvent = (events, as10 = "scoped") => {
  if (!events)
    return;
  if (as10 === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var getLoosePath = (path) => {
  if (path.charCodeAt(path.length - 1) === 47)
    return path.slice(0, path.length - 1);
  return path + "/";
};
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let _2 in obj)
    return true;
  return false;
};
var encodePath = (path, { dynamic = false } = {}) => {
  let encoded = encodeURIComponent(path).replace(/%2F/g, "/");
  if (dynamic)
    encoded = encoded.replace(/%3A/g, ":").replace(/%3F/g, "?");
  return encoded;
};
var supportPerMethodInlineHandler = (() => {
  if (typeof Bun > "u")
    return true;
  let semver = Bun.version.split(".");
  if (+semver[0] < 1 || +semver[1] < 2 || +semver[2] < 14)
    return false;
  return true;
})();
var emptySchema = { headers: true, cookie: true, query: true, params: true, body: true, response: true };
var env = typeof Bun < "u" ? Bun.env : typeof process < "u" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var emptyHttpStatus = { 101: undefined, 204: undefined, 205: undefined, 304: undefined, 307: undefined, 308: undefined };

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    if (this.code = StatusMap[code] ?? code, code in emptyHttpStatus)
      this.response = undefined;
    else
      this.response = res;
  }
}
var status2 = (code, response) => new ElysiaCustomStatusResponse(code, response);
class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError3 extends Error {
  code = "PARSE";
  status = 400;
  constructor(cause3) {
    super("Bad Request", { cause: cause3 });
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error2) => {
  if (!error2)
    return { summary: undefined };
  let { message, path, value: value6, type: type2 } = error2, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type2) {
    case 42:
      return { ...error2, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error2, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format6 = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error2, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format6}` };
    case 54:
      return { ...error2, summary: `${message.slice(0, 9).trim()} property '${property}' to be ${message.slice(8).trim()} but found: ${value6}` };
    case 62:
      let union11 = error2.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return { ...error2, summary: isRoot ? `Value should be one of ${union11}` : `Property '${property}' should be one of: ${union11}` };
    default:
      return { summary: message, ...error2 };
  }
};

class InvalidFileType extends Error {
  property;
  expected;
  message;
  code = "INVALID_FILE_TYPE";
  status = 422;
  constructor(property, expected, message = `"${property}" has invalid file type`) {
    super(message);
    this.property = property;
    this.expected = expected;
    this.message = message;
    Object.setPrototypeOf(this, InvalidFileType.prototype);
  }
  toResponse(headers) {
    if (isProduction)
      return new Response(JSON.stringify({ type: "validation", on: "body" }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
    return new Response(JSON.stringify({ type: "validation", on: "body", summary: "Invalid file type", message: this.message, property: this.property, expected: this.expected }), { status: 422, headers: { ...headers, "content-type": "application/json" } });
  }
}

class ValidationError extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  valueError;
  expected;
  customError;
  constructor(type2, validator, value6, errors) {
    let message = "", error2, expected, customError;
    if (validator?.provider === "standard" || "~standard" in validator || validator.schema && "~standard" in validator.schema) {
      let standard2 = ("~standard" in validator ? validator : validator.schema)["~standard"];
      if (error2 = (errors ?? standard2.validate(value6).issues)?.[0], isProduction)
        message = JSON.stringify({ type: "validation", on: type2, found: value6 });
      else
        message = JSON.stringify({ type: "validation", on: type2, property: error2.path?.[0] || "root", message: error2?.message, summary: error2?.problem, expected, found: value6, errors }, null, 2);
      customError = error2?.message;
    } else {
      if (value6 && typeof value6 === "object" && value6 instanceof ElysiaCustomStatusResponse)
        value6 = value6.response;
      error2 = errors?.First() ?? ("Errors" in validator ? validator.Errors(value6).First() : exports_value2.Errors(validator, value6).First());
      let accessor = error2?.path || "root", schema = validator?.schema ?? validator;
      if (!isProduction)
        try {
          expected = exports_value2.Create(schema);
        } catch (error22) {
          expected = { type: "Could not create expected value", message: error22?.message, error: error22 };
        }
      if (customError = error2?.schema?.message || error2?.schema?.error !== undefined ? typeof error2.schema.error === "function" ? error2.schema.error(isProduction ? { type: "validation", on: type2, found: value6 } : { type: "validation", on: type2, value: value6, property: accessor, message: error2?.message, summary: mapValueError(error2).summary, found: value6, expected, errors: "Errors" in validator ? [...validator.Errors(value6)].map(mapValueError) : [...exports_value2.Errors(validator, value6)].map(mapValueError) }, validator) : error2.schema.error : undefined, customError !== undefined)
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      else if (isProduction)
        message = JSON.stringify({ type: "validation", on: type2, found: value6 });
      else
        message = JSON.stringify({ type: "validation", on: type2, property: accessor, message: error2?.message, summary: mapValueError(error2).summary, expected, found: value6, errors: "Errors" in validator ? [...validator.Errors(value6)].map(mapValueError) : [...exports_value2.Errors(validator, value6)].map(mapValueError) }, null, 2);
    }
    super(message);
    this.type = type2;
    this.validator = validator;
    this.value = value6;
    this.valueError = error2, this.expected = expected, this.customError = customError, Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    if ("~standard" in this.validator)
      return this.validator;
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
  detail(message) {
    if (!this.customError)
      return this.message;
    let validator = this.validator, value6 = this.value, expected = this.expected, errors = this.all;
    return isProduction ? { type: "validation", on: this.type, found: value6, message } : { type: "validation", on: this.type, property: this.valueError?.path || "root", message, summary: mapValueError(this.valueError).summary, found: value6, expected, errors };
  }
}
var tryParse = (v, schema) => {
  try {
    return JSON.parse(v);
  } catch {
    throw new ValidationError("property", schema, v);
  }
};
var compile = (schema) => {
  try {
    let compiler = TypeCompiler.Compile(schema);
    return compiler.Create = () => exports_value2.Create(schema), compiler.Error = (v) => new ValidationError("property", schema, v, compiler.Errors(v)), compiler;
  } catch {
    return { Check: (v) => exports_value2.Check(schema, v), CheckThrow: (v) => {
      if (!exports_value2.Check(schema, v))
        throw new ValidationError("property", schema, v, exports_value2.Errors(schema, v));
    }, Decode: (v) => exports_value2.Decode(schema, v), Create: () => exports_value2.Create(schema), Error: (v) => new ValidationError("property", schema, v, exports_value2.Errors(schema, v)) };
  }
};
var parseFileUnit = (size21) => {
  if (typeof size21 === "string")
    switch (size21.slice(-1)) {
      case "k":
        return +size21.slice(0, size21.length - 1) * 1024;
      case "m":
        return +size21.slice(0, size21.length - 1) * 1048576;
      default:
        return +size21;
    }
  return size21;
};
var checkFileExtension = (type2, extension) => {
  if (type2.startsWith(extension))
    return true;
  return extension.charCodeAt(extension.length - 1) === 42 && extension.charCodeAt(extension.length - 2) === 47 && type2.startsWith(extension.slice(0, -1));
};
var _fileTypeFromBlobWarn = false;
var warnIfFileTypeIsNotInstalled = () => {
  if (!_fileTypeFromBlobWarn)
    console.warn("[Elysia] Attempt to validate file type without 'file-type'. This may lead to security risks. We recommend installing 'file-type' to properly validate file extension."), _fileTypeFromBlobWarn = true;
};
var loadFileType = async () => Promise.resolve().then(() => (init_file_type(), exports_file_type)).then((x) => {
  return _fileTypeFromBlob = x.fileTypeFromBlob, _fileTypeFromBlob;
}).catch(warnIfFileTypeIsNotInstalled);
var _fileTypeFromBlob;
var fileTypeFromBlob2 = (file2) => {
  if (_fileTypeFromBlob)
    return _fileTypeFromBlob(file2);
  return loadFileType().then((mod) => {
    if (mod)
      return mod(file2);
  });
};
var fileType = async (file2, extension, name = file2?.name ?? "") => {
  if (Array.isArray(file2))
    return await Promise.all(file2.map((f) => fileType(f, extension, name))), true;
  if (!file2)
    return false;
  let result = await fileTypeFromBlob2(file2);
  if (!result)
    throw new InvalidFileType(name, extension);
  if (typeof extension === "string") {
    if (!checkFileExtension(result.mime, extension))
      throw new InvalidFileType(name, extension);
  }
  for (let i = 0;i < extension.length; i++)
    if (checkFileExtension(result.mime, extension[i]))
      return true;
  throw new InvalidFileType(name, extension);
};
var validateFile = (options, value6) => {
  if (value6 instanceof ElysiaFile)
    return true;
  if (!(value6 instanceof Blob))
    return false;
  if (options.minSize && value6.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value6.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension) {
    if (typeof options.extension === "string")
      return checkFileExtension(value6.type, options.extension);
    for (let i = 0;i < options.extension.length; i++)
      if (checkFileExtension(value6.type, options.extension[i]))
        return true;
    return false;
  }
  return true;
};
var t = Object.assign({}, Type3);
createType("UnionEnum", (schema, value6) => (typeof value6 === "number" || typeof value6 === "string" || value6 === null) && schema.enum.includes(value6));
createType("ArrayBuffer", (schema, value6) => value6 instanceof ArrayBuffer);
var internalFiles = createType("Files", (options, value6) => {
  if (options.minItems && options.minItems > 1 && !Array.isArray(value6))
    return false;
  if (!Array.isArray(value6))
    return validateFile(options, value6);
  if (options.minItems && value6.length < options.minItems)
    return false;
  if (options.maxItems && value6.length > options.maxItems)
    return false;
  for (let i = 0;i < value6.length; i++)
    if (!validateFile(options, value6[i]))
      return false;
  return true;
});
var internalFormData = createType("ElysiaForm", ({ compiler, ...schema }, value6) => {
  if (!(value6 instanceof FormData))
    return false;
  if (compiler) {
    if (!(ELYSIA_FORM_DATA in value6))
      throw new ValidationError("property", schema, value6);
    if (!compiler.Check(value6[ELYSIA_FORM_DATA]))
      throw compiler.Error(value6[ELYSIA_FORM_DATA]);
  }
  return true;
});
var ElysiaType = { String: (property) => Type3.String(property), Numeric: (property) => {
  let schema = Type3.Number(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value6) => {
    let number5 = +value6;
    if (isNaN(number5))
      return value6;
    if (property && !compiler.Check(number5))
      throw compiler.Error(number5);
    return number5;
  }).Encode((value6) => value6);
}, Integer: (property) => {
  let schema = Type3.Integer(property), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "integer", default: 0 }), Type3.Integer(property)], property)).Decode((value6) => {
    let number5 = +value6;
    if (!compiler.Check(number5))
      throw compiler.Error(number5);
    return number5;
  }).Encode((value6) => value6);
}, Date: (property) => {
  let schema = Type3.Date(property), compiler = compile(schema), _default = property?.default ? new Date(property.default) : undefined;
  return t.Transform(t.Union([Type3.Date(property), t.String({ format: "date-time", default: _default?.toISOString() }), t.String({ format: "date", default: _default?.toISOString() }), t.Number({ default: _default?.getTime() })], property)).Decode((value6) => {
    if (typeof value6 === "number") {
      let date3 = new Date(value6);
      if (!compiler.Check(date3))
        throw compiler.Error(date3);
      return date3;
    }
    if (value6 instanceof Date)
      return value6;
    let date22 = new Date(parseDateTimeEmptySpace(value6));
    if (!date22 || isNaN(date22.getTime()))
      throw new ValidationError("property", schema, date22);
    if (!compiler.Check(date22))
      throw compiler.Error(date22);
    return date22;
  }).Encode((value6) => {
    if (value6 instanceof Date)
      return value6.toISOString();
    if (typeof value6 === "string") {
      if (isNaN(new Date(parseDateTimeEmptySpace(value6)).getTime()))
        throw new ValidationError("property", schema, value6);
      return value6;
    }
    if (!compiler.Check(value6))
      throw compiler.Error(value6);
    return value6;
  });
}, BooleanString: (property) => {
  let schema = Type3.Boolean(property), compiler = compile(schema);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value6) => {
    if (typeof value6 === "string")
      return value6 === "true";
    if (value6 !== undefined && !compiler.Check(value6))
      throw compiler.Error(value6);
    return value6;
  }).Encode((value6) => value6);
}, ObjectString: (properties, options) => {
  let schema = t.Object(properties, options), compiler = compile(schema);
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: "{}" }), schema], { elysiaMeta: "ObjectString" })).Decode((value6) => {
    if (typeof value6 === "string") {
      if (value6.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema, value6);
      if (!compiler.Check(value6 = tryParse(value6, schema)))
        throw compiler.Error(value6);
      return compiler.Decode(value6);
    }
    return value6;
  }).Encode((value6) => {
    let original;
    if (typeof value6 === "string")
      value6 = tryParse(original = value6, schema);
    if (!compiler.Check(value6))
      throw compiler.Error(value6);
    return original ?? JSON.stringify(value6);
  });
}, ArrayString: (children2 = t.String(), options) => {
  let schema = t.Array(children2, options), compiler = compile(schema), decode6 = (value6, isProperty = false) => {
    if (value6.charCodeAt(0) === 91) {
      if (!compiler.Check(value6 = tryParse(value6, schema)))
        throw compiler.Error(value6);
      return compiler.Decode(value6);
    }
    if (isProperty)
      return value6;
    throw new ValidationError("property", schema, value6);
  };
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: options?.default }), schema])).Decode((value6) => {
    if (Array.isArray(value6)) {
      let values7 = [];
      for (let i = 0;i < value6.length; i++) {
        let v = value6[i];
        if (typeof v === "string") {
          let t2 = decode6(v, true);
          if (Array.isArray(t2))
            values7 = values7.concat(t2);
          else
            values7.push(t2);
          continue;
        }
        values7.push(v);
      }
      return values7;
    }
    if (typeof value6 === "string")
      return decode6(value6);
    return value6;
  }).Encode((value6) => {
    let original;
    if (typeof value6 === "string")
      value6 = tryParse(original = value6, schema);
    if (!compiler.Check(value6))
      throw new ValidationError("property", schema, value6);
    return original ?? JSON.stringify(value6);
  });
}, ArrayQuery: (children2 = t.String(), options) => {
  let schema = t.Array(children2, options), compiler = compile(schema), decode6 = (value6) => {
    if (value6.indexOf(",") !== -1)
      return compiler.Decode(value6.split(","));
    return [value6];
  };
  return t.Transform(t.Union([t.String({ default: options?.default }), schema], { elysiaMeta: "ArrayQuery" })).Decode((value6) => {
    if (Array.isArray(value6)) {
      let values7 = [];
      for (let i = 0;i < value6.length; i++) {
        let v = value6[i];
        if (typeof v === "string") {
          let t2 = decode6(v);
          if (Array.isArray(t2))
            values7 = values7.concat(t2);
          else
            values7.push(t2);
          continue;
        }
        values7.push(v);
      }
      return values7;
    }
    if (typeof value6 === "string")
      return decode6(value6);
    return value6;
  }).Encode((value6) => {
    let original;
    if (typeof value6 === "string")
      value6 = tryParse(original = value6, schema);
    if (!compiler.Check(value6))
      throw new ValidationError("property", schema, value6);
    return original ?? JSON.stringify(value6);
  });
}, File: createType("File", validateFile), Files: (options = {}) => t.Transform(internalFiles(options)).Decode((value6) => {
  if (Array.isArray(value6))
    return value6;
  return [value6];
}).Encode((value6) => value6), Nullable: (schema, options) => t.Union([schema, t.Null()], { ...options, nullable: true }), MaybeEmpty: (schema, options) => t.Union([schema, t.Null(), t.Undefined()], options), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign: sign3, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign: sign3 }, v;
}, UnionEnum: (values7, options = {}) => {
  let type2 = values7.every((value6) => typeof value6 === "string") ? { type: "string" } : values7.every((value6) => typeof value6 === "number") ? { type: "number" } : values7.every((value6) => value6 === null) ? { type: "null" } : {};
  if (values7.some((x) => typeof x === "object" && x !== null))
    throw Error("This type does not support objects or arrays");
  return { default: values7[0], ...options, [Kind]: "UnionEnum", ...type2, enum: values7 };
}, NoValidate: (v, enabled2 = true) => {
  return v.noValidate = enabled2, v;
}, Form: (v, options = {}) => {
  let schema = t.Object(v, { default: form({}), ...options }), compiler = compile(schema);
  return t.Union([schema, internalFormData({ compiler })]);
}, ArrayBuffer(options = {}) {
  return { default: [1, 2, 3], ...options, [Kind]: "ArrayBuffer" };
}, Uint8Array: (options) => {
  let schema = Type3.Uint8Array(options), compiler = compile(schema);
  return t.Transform(t.Union([t.ArrayBuffer(), Type3.Uint8Array(options)])).Decode((value6) => {
    if (value6 instanceof ArrayBuffer) {
      if (!compiler.Check(value6 = new Uint8Array(value6)))
        throw compiler.Error(value6);
      return value6;
    }
    return value6;
  }).Encode((value6) => value6);
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.ArrayQuery = ElysiaType.ArrayQuery;
t.Numeric = ElysiaType.Numeric;
t.Integer = ElysiaType.Integer;
t.File = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
};
t.Files = (arg) => {
  if (arg?.type)
    loadFileType();
  return ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
};
t.Nullable = ElysiaType.Nullable;
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
t.NoValidate = ElysiaType.NoValidate;
t.Form = ElysiaType.Form;
t.ArrayBuffer = ElysiaType.ArrayBuffer;
t.Uint8Array = ElysiaType.Uint8Array;
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (/^(\w+)=>/g.test(code)) {
    if (index = code.indexOf("=>"), index !== -1) {
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(0, index), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end6 = code.indexOf(")");
    return [code.slice(index + 1, end6), code.slice(end6 + 2), { isArrowReturn: false }];
  }
  let start5 = code.indexOf("(");
  if (start5 !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end6 = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start5, end6), "{" + body, { isArrowReturn: false }];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start5 = parameter.indexOf("{");
  if (start5 === -1)
    return [-1, 0];
  let end6 = start5 + 1, deep = 1;
  for (;end6 < parameter.length; end6++) {
    let char = parameter.charCodeAt(end6);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start5, end6 + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end6 = parameter.lastIndexOf("}");
  if (end6 === -1)
    return [-1, 0];
  let start5 = end6 - 1, deep = 1;
  for (;start5 >= 0; start5--) {
    let char = parameter.charCodeAt(start5);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start5, end6 + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start5 = parameter.indexOf(":");
    if (start5 === -1)
      break;
    let end6 = parameter.indexOf(",", start5);
    if (end6 === -1)
      end6 = parameter.indexOf("}", start5) - 1;
    if (end6 === -2)
      end6 = parameter.length;
    parameter = parameter.slice(0, start5) + parameter.slice(end6);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters = [];
  while (true) {
    let [start5, end6] = bracketPairRange(parameter);
    if (start5 === -1)
      break;
    if (parameters.push(parameter.slice(0, start5 - 1)), parameter.charCodeAt(end6) === 44)
      end6++;
    parameter = parameter.slice(end6);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters = parameters.concat(parameter.split(","));
  let parameterMap = Object.create(null);
  for (let p of parameters) {
    if (p.indexOf(",") === -1) {
      parameterMap[p] = true;
      continue;
    }
    for (let q of p.split(","))
      parameterMap[q.trim()] = true;
  }
  return { hasParenthesis, parameters: parameterMap };
};
var findParameterReference = (parameter, inference) => {
  let { parameters, hasParenthesis } = retrieveRootParamters(parameter);
  if (parameters.query)
    inference.query = true;
  if (parameters.headers)
    inference.headers = true;
  if (parameters.body)
    inference.body = true;
  if (parameters.cookie)
    inference.cookie = true;
  if (parameters.set)
    inference.set = true;
  if (parameters.server)
    inference.server = true;
  if (parameters.route)
    inference.route = true;
  if (parameters.url)
    inference.url = true;
  if (parameters.path)
    inference.path = true;
  if (hasParenthesis)
    return `{ ${Object.keys(parameters).join(", ")} }`;
  return Object.keys(parameters).join(", ");
};
var findEndIndex = (type2, content, index) => {
  let regex2 = new RegExp(`${type2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}[\\n\\t,; ]`);
  if (index !== undefined)
    regex2.lastIndex = index;
  let match25 = regex2.exec(content);
  return match25 ? match25.index : -1;
};
var findAlias = (type2, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type2, content);
    if (index === -1)
      index = findEndIndex("=" + type2, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type2);
      if (lastIndex === -1)
        lastIndex = content.indexOf("=" + type2);
      if (lastIndex + 3 + type2.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), lastPart = part.lastIndexOf(" "), variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1);
    if (variable === "}") {
      let [start5, end6] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start5, end6))), content = content.slice(index + 3 + type2.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type2.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.indexOf("...") !== -1)
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type2, alias) => new RegExp(`${alias}\\.(${type2})|${alias}\\["${type2}"\\]|${alias}\\['${type2}'\\]`).test(code);
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters = retrieveRootParamters(alias).parameters;
      if (parameters.query)
        inference.query = true;
      if (parameters.headers)
        inference.headers = true;
      if (parameters.body)
        inference.body = true;
      if (parameters.cookie)
        inference.cookie = true;
      if (parameters.set)
        inference.set = true;
      if (parameters.server)
        inference.server = true;
      if (parameters.url)
        inference.url = true;
      if (parameters.route)
        inference.route = true;
      if (parameters.path)
        inference.path = true;
      continue;
    }
    if (!inference.query && (access("query", alias) || code.includes("return " + alias) || code.includes("return " + alias + ".query")))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (!inference.route && access("route", alias))
      inference.route = true;
    if (!inference.url && access("url", alias))
      inference.url = true;
    if (!inference.path && access("path", alias))
      inference.path = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.route && inference.url && inference.path)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context9, body, inference) => {
  try {
    let captureFunction = new RegExp(`\\w\\((.*?)?${context9}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, inference.url = true, inference.route = true, inference.path = true, true;
    return false;
  } catch (error2) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context9), true;
  }
};
var pendingGC;
var caches = {};
var clearSucroseCache = (delay3 = 0) => {
  if (pendingGC)
    clearTimeout(pendingGC);
  pendingGC = setTimeout(() => {
    if (caches = {}, pendingGC = undefined, isBun)
      Bun.gc(false);
  }, delay3);
};
var mergeInference = (a, b) => {
  return { body: a.body || b.body, cookie: a.cookie || b.cookie, headers: a.headers || b.headers, query: a.query || b.query, set: a.set || b.set, server: a.server || b.server, url: a.url || b.url, route: a.route || b.route, path: a.path || b.path };
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }) => {
  let events = [];
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  for (let i = 0;i < events.length; i++) {
    let e = events[i];
    if (!e)
      continue;
    let event = typeof e === "object" ? e.fn : e;
    if (typeof event !== "function")
      continue;
    let content = event.toString(), key = checksum(content), cachedInference = caches[key];
    if (cachedInference) {
      inference = mergeInference(inference, cachedInference);
      continue;
    }
    let fnInference = { query: false, headers: false, body: false, cookie: false, set: false, server: false, url: false, route: false, path: false }, [parameter, body] = separateFunction(content), rootParameters = findParameterReference(parameter, fnInference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body.slice(1, -1));
      aliases.splice(0, -1, mainParameter);
      let code = body;
      if (code.charCodeAt(0) === 123 && code.charCodeAt(body.length - 1) === 125)
        code = code.slice(1, -1);
      if (!isContextPassToFunction(mainParameter, code, fnInference))
        inferBodyReference(code, aliases, fnInference);
      if (!fnInference.query && code.includes("return " + mainParameter + ".query"))
        fnInference.query = true;
    }
    if (!caches[key])
      caches[key] = fnInference;
    if (inference = mergeInference(inference, fnInference), inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server && inference.url && inference.route && inference.path)
      break;
  }
  return inference;
};
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value6) {
    this.setCookie.value = value6;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config2) {
    return this.setCookie = Object.assign(this.cookie, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  set(config2) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config2 === "function" ? config2(this.cookie) : config2), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set22, store, initial) => {
  if (!set22.cookie)
    set22.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set22.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set22.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set22, cookieString, { secrets, sign: sign3, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set22, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign3 && sign3 !== true && !Array.isArray(sign3))
    sign3 = [sign3];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    if (v === undefined)
      continue;
    let value6 = import_fast_decode_uri_component.default(v);
    if (value6) {
      let starts = value6.charCodeAt(0), ends = value6.charCodeAt(value6.length - 1);
      if (starts === 123 && ends === 125 || starts === 91 && ends === 93)
        try {
          value6 = JSON.parse(value6);
        } catch {
        }
    }
    if (sign3 === true || sign3?.includes(name)) {
      if (!secrets)
        throw Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value6, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value6 = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie(value6, secrets[i]);
          if (temp !== false) {
            decoded = true, value6 = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value: value6 };
  }
  return createCookieJar(set22, jar, initial);
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set22 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value6 = property.value;
    if (value6 === undefined || value6 === null)
      continue;
    set22.push(import_cookie.serialize(key, typeof value6 === "object" ? JSON.stringify(value6) : value6 + "", property));
  }
  if (set22.length === 0)
    return;
  if (set22.length === 1)
    return set22[0];
  return set22;
};
var handleFile = (response, set22) => {
  if (!isBun && response instanceof Promise)
    return response.then((res) => handleFile(res, set22));
  let size21 = response.size, immutable = set22 && (set22.status === 206 || set22.status === 304 || set22.status === 412 || set22.status === 416), defaultHeader = immutable ? { "transfer-encoding": "chunked" } : { "accept-ranges": "bytes", "content-range": size21 ? `bytes 0-${size21 - 1}/${size21}` : undefined, "transfer-encoding": "chunked" };
  if (!set22 && !size21)
    return new Response(response);
  if (!set22)
    return new Response(response, { headers: defaultHeader });
  if (set22.headers instanceof Headers) {
    for (let key of Object.keys(defaultHeader))
      if (key in set22.headers)
        set22.headers.append(key, defaultHeader[key]);
    if (immutable)
      set22.headers.delete("content-length"), set22.headers.delete("accept-ranges");
    return new Response(response, set22);
  }
  if (isNotEmpty(set22.headers))
    return new Response(response, { status: set22.status, headers: Object.assign(defaultHeader, set22.headers) });
  return new Response(response, { status: set22.status, headers: defaultHeader });
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var responseToSetHeaders = (response, set22) => {
  if (set22?.headers) {
    if (response) {
      if (hasHeaderShorthand)
        Object.assign(set22.headers, response.headers.toJSON());
      else
        for (let [key, value6] of response.headers.entries())
          if (key in set22.headers)
            set22.headers[key] = value6;
    }
    if (set22.status === 200)
      set22.status = response.status;
    if (set22.headers["content-encoding"])
      delete set22.headers["content-encoding"];
    return set22;
  }
  if (!response)
    return { headers: {}, status: set22?.status ?? 200 };
  if (hasHeaderShorthand) {
    if (set22 = { headers: response.headers.toJSON(), status: set22?.status ?? 200 }, set22.headers["content-encoding"])
      delete set22.headers["content-encoding"];
    return set22;
  }
  set22 = { headers: {}, status: set22?.status ?? 200 };
  for (let [key, value6] of response.headers.entries()) {
    if (key === "content-encoding")
      continue;
    if (key in set22.headers)
      set22.headers[key] = value6;
  }
  return set22;
};
var createStreamHandler = ({ mapResponse, mapCompactResponse }) => async (generator, set22, request2) => {
  let init = generator.next?.();
  if (init instanceof Promise)
    init = await init;
  if (init?.value instanceof ReadableStream)
    generator = init.value;
  else if (init && (typeof init?.done > "u" || init?.done)) {
    if (set22)
      return mapResponse(init.value, set22, request2);
    return mapCompactResponse(init.value, request2);
  }
  let isSSE = init?.value?.sse ?? generator?.sse ?? set22?.headers["content-type"]?.startsWith("text/event-stream"), format6 = isSSE ? (data) => `data: ${data}

` : (data) => data, contentType = isSSE ? "text/event-stream" : init?.value && typeof init?.value === "object" ? "application/json" : "text/plain";
  if (set22?.headers) {
    if (!set22.headers["transfer-encoding"])
      set22.headers["transfer-encoding"] = "chunked";
    if (!set22.headers["content-type"])
      set22.headers["content-type"] = contentType;
    if (!set22.headers["cache-control"])
      set22.headers["cache-control"] = "no-cache";
  } else
    set22 = { status: 200, headers: { "content-type": contentType, "transfer-encoding": "chunked", "cache-control": "no-cache", connection: "keep-alive" } };
  return new Response(new ReadableStream({ async start(controller) {
    let end6 = false;
    if (request2?.signal?.addEventListener("abort", () => {
      end6 = true;
      try {
        controller.close();
      } catch {
      }
    }), !init || init.value instanceof ReadableStream)
      ;
    else if (init.value !== undefined && init.value !== null)
      if (init.value.toSSE)
        controller.enqueue(init.value.toSSE());
      else if (typeof init.value === "object")
        try {
          controller.enqueue(format6(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(format6(init.value.toString()));
        }
      else
        controller.enqueue(format6(init.value.toString()));
    try {
      for await (let chunk4 of generator) {
        if (end6)
          break;
        if (chunk4 === undefined || chunk4 === null)
          continue;
        if (chunk4.toSSE)
          controller.enqueue(chunk4.toSSE());
        else {
          if (typeof chunk4 === "object")
            try {
              controller.enqueue(format6(JSON.stringify(chunk4)));
            } catch {
              controller.enqueue(format6(chunk4.toString()));
            }
          else
            controller.enqueue(format6(chunk4.toString()));
          if (!isSSE)
            await new Promise((resolve) => setTimeout(() => resolve(), 0));
        }
      }
    } catch (error2) {
      console.warn(error2);
    }
    try {
      controller.close();
    } catch {
    }
  } }), set22);
};
var handleSet = (set22) => {
  if (typeof set22.status === "string")
    set22.status = StatusMap[set22.status];
  if (set22.cookie && isNotEmpty(set22.cookie)) {
    let cookie = serializeCookie(set22.cookie);
    if (cookie)
      set22.headers["set-cookie"] = cookie;
  }
  if (set22.headers["set-cookie"] && Array.isArray(set22.headers["set-cookie"]))
    set22.headers = parseSetCookies(new Headers(set22.headers), set22.headers["set-cookie"]);
};
var createResponseHandler = (handler) => {
  let handleStream = createStreamHandler(handler);
  return (response, set22, request2) => {
    let isCookieSet = false;
    if (set22.headers instanceof Headers)
      for (let key of set22.headers.keys())
        if (key === "set-cookie") {
          if (isCookieSet)
            continue;
          isCookieSet = true;
          for (let cookie of set22.headers.getSetCookie())
            response.headers.append("set-cookie", cookie);
        } else
          response.headers.append(key, set22.headers?.get(key) ?? "");
    else
      for (let key in set22.headers)
        response.headers.append(key, set22.headers[key]);
    let status22 = set22.status ?? 200;
    if (response.status !== status22 && status22 !== 200 && (response.status <= 300 || response.status > 400))
      return response.text().then((value6) => {
        let newResponse = new Response(value6, { headers: response.headers, status: set22.status });
        if (!newResponse.headers.has("content-length") && newResponse.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(newResponse), responseToSetHeaders(newResponse, set22), request2);
        return newResponse;
      });
    if (!response.headers.has("content-length") && response.headers.get("transfer-encoding") === "chunked")
      return handleStream(streamResponse(response), responseToSetHeaders(response, set22), request2);
    return response;
  };
};
var handleElysiaFile = (file2, set22 = { headers: {} }) => {
  let path = file2.path, contentType = mime[path.slice(path.lastIndexOf(".") + 1)];
  if (contentType)
    set22.headers["content-type"] = contentType;
  if (file2.stats && set22.status !== 206 && set22.status !== 304 && set22.status !== 412 && set22.status !== 416)
    return file2.stats.then((stat2) => {
      let size21 = stat2.size;
      if (size21 !== undefined)
        set22.headers["content-range"] = `bytes 0-${size21 - 1}/${size21}`, set22.headers["content-length"] = size21;
      return handleFile(file2.value, set22);
    });
  return handleFile(file2.value, set22);
};
var mapResponse = (response, set22, request2) => {
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.cookie)
    switch (handleSet(set22), response?.constructor?.name) {
      case "String":
        return set22.headers["content-type"] = "text/plain", new Response(response, set22);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleElysiaFile(response, set22);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapResponse(response.response, set22, request2);
      case undefined:
        if (!response)
          return new Response("", set22);
        return new Response(JSON.stringify(response), set22);
      case "Response":
        return handleResponse(response, set22, request2);
      case "Error":
        return errorToResponse(response, set22);
      case "Promise":
        return response.then((x) => mapResponse(x, set22, request2));
      case "Function":
        return mapResponse(response(), set22, request2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response, set22);
      default:
        if (response instanceof Response)
          return handleResponse(response, set22, request2);
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapResponse(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream(response, set22, request2);
  return mapCompactResponse(response, request2);
};
var mapEarlyResponse = (response, set22, request2) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.cookie)
    switch (handleSet(set22), response?.constructor?.name) {
      case "String":
        return set22.headers["content-type"] = "text/plain", new Response(response, set22);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleElysiaFile(response, set22);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse(response.response, set22, request2);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set22);
      case "Response":
        return handleResponse(response, set22, request2);
      case "Promise":
        return response.then((x) => mapEarlyResponse(x, set22));
      case "Error":
        return errorToResponse(response, set22);
      case "Function":
        return mapEarlyResponse(response(), set22);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      default:
        if (response instanceof Response)
          return handleResponse(response, set22, request2);
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return set22.headers["content-type"] = "text/plain", new Response(response);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleElysiaFile(response, set22);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse(response.response, set22, request2);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse(x, set22);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set22);
      case "Function":
        return mapCompactResponse(response(), request2);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request2) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response, { headers: { "Content-Type": "text/plain" } });
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleElysiaFile(response);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse(x, request2));
    case "Function":
      return mapCompactResponse(response(), request2);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse(x, request2));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream(response, undefined, request2);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error2, set22) => new Response(JSON.stringify({ name: error2?.name, message: error2?.message, cause: error2?.cause }), { status: set22?.status !== 200 ? set22?.status ?? 500 : 500, headers: set22?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse = createResponseHandler({ mapResponse, mapCompactResponse });
var handleStream = createStreamHandler({ mapResponse, mapCompactResponse });
var WebStandardAdapter = { name: "web-standard", isWebStandard: true, handler: { mapResponse, mapEarlyResponse, mapCompactResponse, createStaticHandler }, composeHandler: { mapResponseContext: "c.request", preferWebstandardHeaders: true, headers: `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
`, parser: { json(isOptional) {
  if (isOptional)
    return `try{c.body=await c.request.json()}catch{}
`;
  return `c.body=await c.request.json()
`;
}, text() {
  return `c.body=await c.request.text()
`;
}, urlencoded() {
  return `c.body=parseQuery(await c.request.text())
`;
}, arrayBuffer() {
  return `c.body=await c.request.arrayBuffer()
`;
}, formData(isOptional) {
  let fnLiteral = `
c.body={}
`;
  if (isOptional)
    fnLiteral += "let form;try{form=await c.request.formData()}catch{}";
  else
    fnLiteral += `const form=await c.request.formData()
`;
  return fnLiteral + `for(const key of form.keys()){if(c.body[key]) continue
const value=form.getAll(key)
if(value.length===1)c.body[key]=value[0]
else c.body[key]=value}`;
} } }, async stop(app, closeActiveConnections) {
  if (!app.server)
    throw Error("Elysia isn't running. Call `app.listen` to start the server.");
  if (app.server) {
    if (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i = 0;i < app.event.stop.length; i++)
        app.event.stop[i].fn(app);
  }
}, composeGeneralHandler: { parameters: "r", createContext(app) {
  let decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.decorator))
    decoratorsLiteral += `,'${key}':decorator['${key}']`;
  let standardHostname = app.config.handler?.standardHostname ?? true, hasTrace = !!app.event.trace?.length;
  if (fnLiteral += `const u=r.url,s=u.indexOf('/',${standardHostname ? 11 : 7}),qi=u.indexOf('?',s+1)
let p
if(qi===-1)p=u.substring(s)
else p=u.substring(s, qi)
`, hasTrace)
    fnLiteral += `const id=randomId()
`;
  if (fnLiteral += "const c={request:r,store,qi,path:p,url:u,redirect,status,set:{headers:", fnLiteral += Object.keys(defaultHeaders ?? {}).length ? "Object.assign({},app.setHeaders)" : "Object.create(null)", fnLiteral += ",status:200}", app.inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  return fnLiteral += decoratorsLiteral, fnLiteral += `}
`, fnLiteral;
}, error404(hasEventHook, hasErrorHook, afterHandle = "") {
  let findDynamicRoute = "if(route===null){" + afterHandle + `
return `;
  if (hasErrorHook)
    findDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`;
  else
    findDynamicRoute += hasEventHook ? "new Response(error404Message,{status:c.set.status===200?404:c.set.status,headers:c.set.headers})" : "error404.clone()";
  return findDynamicRoute += "}", { declare: hasErrorHook ? "" : `const error404Message=notFound.message.toString()
const error404=new Response(error404Message,{status:404})
`, code: findDynamicRoute };
} }, composeError: { mapResponseContext: "", validationError: "return new Response(error.message,{headers:Object.assign({'content-type':'application/json'},set.headers),status:set.status})", unknownError: "return new Response(error.message,{headers:set.headers,status:error.status??set.status??500})" }, listen() {
  return () => {
    throw Error("WebStandard does not support listen, you might want to export default Elysia.fetch instead");
  };
} };
var mapResponse2 = (response, set22, request2) => {
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.cookie)
    switch (handleSet(set22), response?.constructor?.name) {
      case "String":
        return new Response(response, set22);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapResponse2(response.response, set22, request2);
      case undefined:
        if (!response)
          return new Response("", set22);
        return new Response(JSON.stringify(response), set22);
      case "Response":
        return handleResponse2(response, set22, request2);
      case "Error":
        return errorToResponse2(response, set22);
      case "Promise":
        return response.then((x) => mapResponse2(x, set22, request2));
      case "Function":
        return mapResponse2(response(), set22, request2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response, set22);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set22, request2);
        if (response instanceof Promise)
          return response.then((x) => mapResponse2(x, set22));
        if (response instanceof Error)
          return errorToResponse2(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapResponse2(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse2(x, set22));
        if (typeof response?.toResponse === "function")
          return mapResponse2(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  if (typeof response?.next === "function" || response instanceof ReadableStream)
    return handleStream2(response, set22, request2);
  return mapCompactResponse2(response, request2);
};
var mapEarlyResponse2 = (response, set22, request2) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.cookie)
    switch (handleSet(set22), response?.constructor?.name) {
      case "String":
        return new Response(response, set22);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse2(response.response, set22, request2);
      case undefined:
        if (!response)
          return;
        return new Response(JSON.stringify(response), set22);
      case "Response":
        return handleResponse2(response, set22, request2);
      case "Promise":
        return response.then((x) => mapEarlyResponse2(x, set22));
      case "Error":
        return errorToResponse2(response, set22);
      case "Function":
        return mapEarlyResponse2(response(), set22);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      default:
        if (response instanceof Response)
          return handleResponse2(response, set22, request2);
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set22));
        if (response instanceof Error)
          return errorToResponse2(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse2(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Array":
      case "Object":
        return set22.headers["content-type"] = "application/json", new Response(JSON.stringify(response), set22);
      case "ElysiaFile":
        return handleFile(response.value);
      case "File":
        return handleFile(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse2(response.response, set22, request2);
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse2(x, set22);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse2(response, set22);
      case "Function":
        return mapCompactResponse2(response(), request2);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse2(x, set22));
        if (response instanceof Error)
          return errorToResponse2(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse2(response.response, set22, request2);
        if (typeof response?.next === "function" || response instanceof ReadableStream)
          return handleStream2(response, set22, request2);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse2(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse2(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse2 = (response, request2) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
    case "ElysiaFile":
      return handleFile(response.value);
    case "File":
      return handleFile(response);
    case "Blob":
      return handleFile(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse2(response.response, { status: response.code, headers: {} });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      return response;
    case "Error":
      return errorToResponse2(response);
    case "Promise":
      return response.then((x) => mapCompactResponse2(x, request2));
    case "Function":
      return mapCompactResponse2(response(), request2);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse2(x, request2));
      if (response instanceof Error)
        return errorToResponse2(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse2(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function" || response instanceof ReadableStream)
        return handleStream2(response, undefined, request2);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse2(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse2(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse2 = (error2, set22) => new Response(JSON.stringify({ name: error2?.name, message: error2?.message, cause: error2?.cause }), { status: set22?.status !== 200 ? set22?.status ?? 500 : 500, headers: set22?.headers });
var createStaticHandler2 = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse2(handle, { headers: setHeaders });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length)
    return () => response.clone();
};
var handleResponse2 = createResponseHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var handleStream2 = createStreamHandler({ mapResponse: mapResponse2, mapCompactResponse: mapCompactResponse2 });
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var KEY_HAS_PLUS = 1;
var KEY_NEEDS_DECODE = 2;
var VALUE_HAS_PLUS = 4;
var VALUE_NEEDS_DECODE = 8;
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise: promise3, resolve } = Promise.withResolvers(), { promise: end6, resolve: resolveEnd } = Promise.withResolvers(), { promise: error2, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise3;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i = 0;i < (process2.total ?? 0); i++) {
      let { promise: promise22, resolve: resolve2 } = Promise.withResolvers(), { promise: end22, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error22, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise22;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end22, error: error22, index: i, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end22;
        } };
        resolve2(result2);
        for (let i2 = 0;i2 < callbacks2.length; i2++)
          callbacks2[i2](result2);
        return (error3 = null) => {
          let end32 = performance.now();
          if (error3)
            groupError = error3;
          let detail = { end: end32, error: error3, get elapsed() {
            return end32 - process3.begin;
          } };
          for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
            callbacksEnd2[i2](detail);
          resolveEnd2(end32), resolveError2(error3);
        };
      });
    }
    let result = { ...process2, end: end6, error: error2, onEvent(callback) {
      for (let i = 0;i < processes.length; i++)
        processes[i](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end6;
    } };
    resolve(result);
    for (let i = 0;i < callbacks.length; i++)
      callbacks[i](result);
    return { resolveChild: resolvers, resolve(error22 = null) {
      let end22 = performance.now();
      if (!error22 && groupError)
        error22 = groupError;
      let detail = { end: end22, error: error22, get elapsed() {
        return end22 - process2.begin;
      } };
      for (let i = 0;i < callbacksEnd.length; i++)
        callbacksEnd[i](detail);
      resolveEnd(end22), resolveError(error22);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context9) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError4, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context9[ELYSIA_REQUEST_ID], context: context9, set: context9.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError: onError4, time: Date.now(), store: context9.store }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var Kind3 = Symbol.for("TypeBox.Kind");
var Hint2 = Symbol.for("TypeBox.Hint");
var isSpecialProperty = (name) => /(\ |-|\t|\n|\.)/.test(name) || !isNaN(+name[0]);
var joinProperty = (v1, v2, isOptional = false) => {
  if (typeof v2 === "number")
    return `${v1}[${v2}]`;
  if (isSpecialProperty(v2))
    return `${v1}${isOptional ? "?." : ""}["${v2}"]`;
  return `${v1}${isOptional ? "?" : ""}.${v2}`;
};
var encodeProperty = (v) => isSpecialProperty(v) ? `"${v}"` : v;
var sanitize = (key, sanitize2 = 0, schema) => {
  if (schema.type !== "string" || schema.const || schema.trusted)
    return key;
  let hof = "";
  for (let i = sanitize2 - 1;i >= 0; i--)
    hof += `d.h${i}(`;
  return hof + key + ")".repeat(sanitize2);
};
var mergeObjectIntersection = (schema) => {
  if (!schema.allOf || Kind3 in schema && (schema[Kind3] !== "Intersect" || schema.type !== "object"))
    return schema;
  let { allOf, ...newSchema } = schema;
  if (newSchema.properties = {}, Kind3 in newSchema)
    newSchema[Kind3] = "Object";
  for (let type2 of allOf) {
    if (type2.type !== "object")
      continue;
    let { properties, required: required2, type: _2, [Kind3]: __, ...rest } = type2;
    if (required2)
      newSchema.required = newSchema.required ? newSchema.required.concat(required2) : required2;
    Object.assign(newSchema, rest);
    for (let property in type2.properties)
      newSchema.properties[property] = mergeObjectIntersection(type2.properties[property]);
  }
  return newSchema;
};
var handleRecord = (schema, property, instruction) => {
  let child = schema.patternProperties["^(.*)$"] ?? schema.patternProperties[Object.keys(schema.patternProperties)[0]];
  if (!child)
    return property;
  let i = instruction.array;
  instruction.array++;
  let v = `(()=>{const ar${i}s=Object.keys(${property}),ar${i}v={};for(let i=0;i<ar${i}s.length;i++){const ar${i}p=${property}[ar${i}s[i]];ar${i}v[ar${i}s[i]]=${mirror(child, `ar${i}p`, instruction)}`, optionals = instruction.optionalsInArray[i + 1];
  if (optionals)
    for (let oi = 0;oi < optionals.length; oi++) {
      let target = `ar${i}v[ar${i}s[i]].${optionals[oi]}`;
      v += `;if(${target}===undefined)delete ${target}`;
    }
  return v += `}return ar${i}v})()`, v;
};
var handleTuple = (schema, property, instruction) => {
  let i = instruction.array;
  instruction.array++;
  let isRoot = property === "v" && !instruction.unions.length, v = "";
  if (!isRoot)
    v = "(()=>{";
  v += `const ar${i}v=[`;
  for (let i2 = 0;i2 < schema.length; i2++) {
    if (i2 !== 0)
      v += ",";
    v += mirror(schema[i2], joinProperty(property, i2, instruction.parentIsOptional), instruction);
  }
  if (v += "];", !isRoot)
    v += `return ar${i}v})()`;
  return v;
};
var handleUnion = (schemas, property, instruction) => {
  if (instruction.TypeCompiler === undefined) {
    if (!instruction.typeCompilerWanred)
      console.warn(Error("[exact-mirror] TypeBox's TypeCompiler is required to use Union")), instruction.typeCompilerWanred = true;
    return property;
  }
  instruction.unionKeys[property] = 1;
  let ui = instruction.unions.length, typeChecks = instruction.unions[ui] = [], v = `(()=>{
`, unwrapRef = (type2) => {
    if (!(Kind3 in type2) || !type2.$ref)
      return type2;
    if (type2[Kind3] === "This")
      return deepClone(instruction.definitions[type2.$ref]);
    else if (type2[Kind3] === "Ref")
      if (!instruction.modules)
        console.warn(Error("[exact-mirror] modules is required when using nested cyclic reference"));
      else
        return instruction.modules.Import(type2.$ref);
    return type2;
  };
  for (let i = 0;i < schemas.length; i++) {
    let type2 = unwrapRef(schemas[i]);
    if (Array.isArray(type2.anyOf))
      for (let i2 = 0;i2 < type2.anyOf.length; i2++)
        type2.anyOf[i2] = unwrapRef(type2.anyOf[i2]);
    else if (type2.items)
      if (Array.isArray(type2.items))
        for (let i2 = 0;i2 < type2.items.length; i2++)
          type2.items[i2] = unwrapRef(type2.items[i2]);
      else
        type2.items = unwrapRef(type2.items);
    typeChecks.push(TypeCompiler.Compile(type2)), v += `if(d.unions[${ui}][${i}].Check(${property})){return ${mirror(type2, property, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: true })}}
`;
  }
  return v += `return ${instruction.removeUnknownUnionType ? "undefined" : property}})()`, v;
};
var mirror = (schema, property, instruction) => {
  if (!schema)
    return "";
  let isRoot = property === "v" && !instruction.unions.length;
  if (Kind3 in schema && schema[Kind3] === "Import" && schema.$ref in schema.$defs)
    return mirror(schema.$defs[schema.$ref], property, { ...instruction, definitions: Object.assign(instruction.definitions, schema.$defs) });
  if (isRoot && schema.type !== "object" && schema.type !== "array" && !schema.anyOf)
    return `return ${sanitize("v", instruction.sanitize?.length, schema)}`;
  if (instruction.recursion >= instruction.recursionLimit)
    return property;
  let v = "";
  if (schema.$id && Hint2 in schema)
    instruction.definitions[schema.$id] = schema;
  switch (schema.type) {
    case "object":
      if (schema[Kind3] === "Record") {
        v = handleRecord(schema, property, instruction);
        break;
      }
      if (schema = mergeObjectIntersection(schema), v += "{", schema.additionalProperties)
        v += `...${property},`;
      let keys9 = Object.keys(schema.properties);
      for (let i2 = 0;i2 < keys9.length; i2++) {
        let key = keys9[i2], isOptional = !schema.required || schema.required && !schema.required.includes(key) || Array.isArray(schema.properties[key].anyOf), name = joinProperty(property, key, instruction.parentIsOptional);
        if (isOptional) {
          let index = instruction.array;
          if (property.startsWith("ar")) {
            let refName = name.slice(name.indexOf(".") + 1), array7 = instruction.optionalsInArray;
            if (array7[index])
              array7[index].push(refName);
            else
              array7[index] = [refName];
          } else
            instruction.optionals.push(name);
        }
        let child = schema.properties[key];
        if (i2 !== 0)
          v += ",";
        v += `${encodeProperty(key)}:${isOptional ? `${name}===undefined?undefined:` : ""}${mirror(child, name, { ...instruction, recursion: instruction.recursion + 1, parentIsOptional: isOptional })}`;
      }
      v += "}";
      break;
    case "array":
      if (schema.items.type !== "object" && schema.items.type !== "array")
        if (Array.isArray(schema.items)) {
          v = handleTuple(schema.items, property, instruction);
          break;
        } else if (isRoot)
          return "return v";
        else if (Kind3 in schema.items && schema.items.$ref && (schema.items[Kind3] === "Ref" || schema.items[Kind3] === "This"))
          v = mirror(deepClone(instruction.definitions[schema.items.$ref]), property, { ...instruction, parentIsOptional: true, recursion: instruction.recursion + 1 });
        else {
          v = property;
          break;
        }
      let i = instruction.array;
      instruction.array++;
      let reference = property;
      if (isRoot)
        v = `const ar${i}v=new Array(${property}.length);`;
      else
        reference = `ar${i}s`, v = `((${reference})=>{const ar${i}v=new Array(${reference}.length);`;
      v += `for(let i=0;i<${reference}.length;i++){const ar${i}p=${reference}[i];ar${i}v[i]=${mirror(schema.items, `ar${i}p`, instruction)}`;
      let optionals = instruction.optionalsInArray[i + 1];
      if (optionals)
        for (let oi = 0;oi < optionals.length; oi++) {
          let target = `ar${i}v[i].${optionals[oi]}`;
          v += `;if(${target}===undefined)delete ${target}`;
        }
      if (v += "}", !isRoot)
        v += `return ar${i}v})(${property})`;
      break;
    default:
      if (schema.$ref && schema.$ref in instruction.definitions)
        return mirror(instruction.definitions[schema.$ref], property, instruction);
      if (Array.isArray(schema.anyOf)) {
        v = handleUnion(schema.anyOf, property, instruction);
        break;
      }
      v = sanitize(property, instruction.sanitize?.length, schema);
      break;
  }
  if (!isRoot)
    return v;
  if (schema.type === "array")
    v = `${v}const x=ar0v;`;
  else
    v = `const x=${v}
`;
  for (let i = 0;i < instruction.optionals.length; i++) {
    let key = instruction.optionals[i], prop = key.slice(1);
    if (v += `if(${key}===undefined`, instruction.unionKeys[key])
      v += `||x${prop}===undefined`;
    let shouldQuestion = prop.charCodeAt(0) !== 63 && schema.type !== "array";
    v += `)delete x${shouldQuestion ? prop.charCodeAt(0) === 91 ? "?." : "?" : ""}${prop}
`;
  }
  return `${v}return x`;
};
var createMirror = (schema, { TypeCompiler: TypeCompiler22, modules, definitions, sanitize: sanitize2, recursionLimit = 8, removeUnknownUnionType = false } = {}) => {
  let unions = [];
  if (typeof sanitize2 === "function")
    sanitize2 = [sanitize2];
  let f = mirror(schema, "v", { optionals: [], optionalsInArray: [], array: 0, parentIsOptional: false, unions, unionKeys: {}, TypeCompiler: TypeCompiler22, modules, definitions: definitions ?? modules?.$defs ?? {}, sanitize: sanitize2, recursion: 0, recursionLimit, removeUnknownUnionType });
  if (!unions.length && !sanitize2?.length)
    return Function("v", f);
  let hof;
  if (sanitize2?.length) {
    hof = {};
    for (let i = 0;i < sanitize2.length; i++)
      hof[`h${i}`] = sanitize2[i];
  }
  return Function("d", `return function mirror(v){${f}}`)({ unions, ...hof });
};
var isOptional = (schema) => {
  if (!schema)
    return false;
  if (schema?.[Kind] === "Import" && schema.References)
    return schema.References().some(isOptional);
  if (schema.schema)
    schema = schema.schema;
  return !!schema && OptionalKind in schema;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some(hasAdditionalProperties);
  if (schema.anyOf)
    return schema.anyOf.some(hasAdditionalProperties);
  if (schema.someOf)
    return schema.someOf.some(hasAdditionalProperties);
  if (schema.allOf)
    return schema.allOf.some(hasAdditionalProperties);
  if (schema.not)
    return schema.not.some(hasAdditionalProperties);
  if (schema.type === "object") {
    let properties = schema.properties;
    if ("additionalProperties" in schema)
      return schema.additionalProperties;
    if ("patternProperties" in schema)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasAdditionalProperties(schema.items);
  return false;
};
var hasType = (type2, schema) => {
  if (!schema)
    return false;
  if (Kind in schema && schema[Kind] === type2)
    return true;
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasType(type2, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type2, property.anyOf[i]))
            return true;
      }
      if (Kind in property && property[Kind] === type2)
        return true;
    }
    return false;
  }
  return !!schema.properties && Kind in schema.properties && schema.properties[Kind] === type2;
};
var hasElysiaMeta = (meta, _schema) => {
  if (!_schema)
    return false;
  let schema = _schema?.schema ?? _schema;
  if (schema.elysiaMeta === meta)
    return true;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.anyOf)
    return schema.anyOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.someOf)
    return schema.someOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.allOf)
    return schema.allOf.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.not)
    return schema.not.some((schema2) => hasElysiaMeta(meta, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasElysiaMeta(meta, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasElysiaMeta(meta, property.anyOf[i]))
            return true;
      }
      return schema.elysiaMeta === meta;
    }
    return false;
  }
  if (schema.type === "array" && schema.items && !Array.isArray(schema.items))
    return hasElysiaMeta(meta, schema.items);
  return false;
};
var hasProperty2 = (expectedProperty, _schema) => {
  if (!_schema)
    return;
  let schema = _schema.schema ?? _schema;
  if (schema[Kind] === "Import" && _schema.References)
    return _schema.References().some((schema2) => hasProperty2(expectedProperty, schema2));
  if (schema.type === "object") {
    let properties = schema.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty2(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty2(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema;
};
var hasRef = (schema) => {
  if (!schema)
    return false;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasRef(schema.anyOf[i]))
        return true;
  }
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasRef(schema.oneOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasRef(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasRef(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasRef(property))
        return true;
      if (property.type === "array" && property.items && hasRef(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasRef(schema.items))
    return true;
  return schema[Kind] === "Ref" && "$ref" in schema;
};
var hasTransform = (schema) => {
  if (!schema)
    return false;
  if (schema.$ref && schema.$defs && schema.$ref in schema.$defs && hasTransform(schema.$defs[schema.$ref]))
    return true;
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      if (hasTransform(schema.oneOf[i]))
        return true;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      if (hasTransform(schema.anyOf[i]))
        return true;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      if (hasTransform(schema.allOf[i]))
        return true;
  }
  if (schema.not && hasTransform(schema.not))
    return true;
  if (schema.type === "object" && schema.properties) {
    let properties = schema.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (hasTransform(property))
        return true;
      if (property.type === "array" && property.items && hasTransform(property.items))
        return true;
    }
  }
  if (schema.type === "array" && schema.items && hasTransform(schema.items))
    return true;
  return TransformKind in schema;
};
var replaceSchemaType = (schema, options, _config = {}) => {
  let config2 = _config;
  if (config2.root = true, !Array.isArray(options))
    return options.original = schema, _replaceSchemaType(schema, options, config2);
  for (let option6 of options)
    option6.original = schema, schema = _replaceSchemaType(schema, option6, config2);
  return schema;
};
var _replaceSchemaType = (schema, options, config2) => {
  if (!schema)
    return schema;
  let root = config2.root;
  if (options.onlyFirst && schema.type === options.onlyFirst)
    return options.to(schema) ?? schema;
  if (options.untilObjectFound && !root && schema.type === "object")
    return schema;
  let fromSymbol = options.from[Kind];
  if (schema.oneOf) {
    for (let i = 0;i < schema.oneOf.length; i++)
      schema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, config2);
    return schema;
  }
  if (schema.anyOf) {
    for (let i = 0;i < schema.anyOf.length; i++)
      schema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, config2);
    return schema;
  }
  if (schema.allOf) {
    for (let i = 0;i < schema.allOf.length; i++)
      schema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, config2);
    return schema;
  }
  if (schema.not)
    return _replaceSchemaType(schema.not, options, config2);
  let isRoot = root && !!options.excludeRoot;
  if (schema[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not: not3, properties: properties2, items, ...rest } = schema, to = options.to(rest);
    if (!to)
      return schema;
    let transform6, composeProperties = (schema2) => {
      let v = _composeProperties(schema2);
      if (v.$id)
        delete v.$id;
      return v;
    }, _composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value22] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value22, options, { ...config2, root: false });
        return { ...rest, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest, ...v, items: _replaceSchemaType(items, options, { ...config2, root: false }) };
      let value6 = { ...rest, ...v };
      if (delete value6.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform6 = t.ObjectString(properties2, rest), value6.properties = properties2;
      else if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform6 = t.ArrayString(items, rest), value6.items = items;
      return value6;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value6] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value6, options, { ...config2, root: false });
        return { ...rest, properties: newProperties };
      } else if (items?.map)
        return { ...rest, items: items.map((v) => _replaceSchemaType(v, options, { ...config2, root: false })) };
      return rest;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      to.not = composeProperties(to.not);
    if (transform6)
      to[TransformKind] = transform6[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value6] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value6, options, { ...config2, root: false });
      return { ...rest, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest, ...to, items: items.map((v) => _replaceSchemaType(v, options, { ...config2, root: false })) };
    return { ...rest, ...to };
  }
  let properties = schema?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value6] of Object.entries(properties))
      switch (value6[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not: not3, type: type2, ...rest } = value6, to = options.to(rest);
          if (!to)
            return schema;
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest, ...to.allOf[i] };
          else if (to.not)
            to.not = { ...rest, ...to.not };
          properties[key] = { ...rest, ..._replaceSchemaType(rest, options, { ...config2, root: false }) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value6, options, { ...config2, root: false });
          break;
        default:
          if (Array.isArray(value6.items))
            for (let i = 0;i < value6.items.length; i++)
              value6.items[i] = _replaceSchemaType(value6.items[i], options, { ...config2, root: false });
          else if (value6.anyOf || value6.oneOf || value6.allOf || value6.not)
            properties[key] = _replaceSchemaType(value6, options, { ...config2, root: false });
          else if (value6.type === "array")
            value6.items = _replaceSchemaType(value6.items, options, { ...config2, root: false });
          break;
      }
  if (schema.type === "array" && schema.items)
    if (Array.isArray(schema.items))
      schema.items = schema.items.map((item) => _replaceSchemaType(item, options, { ...config2, root: false }));
    else
      schema.items = _replaceSchemaType(schema.items, options, { ...config2, root: false });
  return schema;
};
var createCleaner = (schema) => (value6) => {
  if (typeof value6 === "object")
    try {
      return exports_value2.Clean(schema, value6);
    } catch {
    }
  return value6;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, modules, normalize: normalize2 = false, additionalProperties = false, forceAdditionalProperties = false, coerce = false, additionalCoerce = [], validators, sanitize: sanitize2 } = {}) => {
  if (validators = validators?.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let doesHaveRef = undefined, replaceSchema = (schema2) => {
    if (coerce)
      return replaceSchemaType(schema2, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    return replaceSchemaType(schema2, additionalCoerce);
  }, mapSchema = (s2) => {
    if (s2 && typeof s2 !== "string" && "~standard" in s2)
      return s2;
    if (!s2)
      return;
    let schema2;
    if (typeof s2 !== "string")
      schema2 = s2;
    else if (schema2 = modules && s2 in modules.$defs ? modules.Import(s2) : models[s2], !schema2)
      return;
    if (Kind in schema2) {
      if (schema2[Kind] === "Import") {
        if (!hasRef(schema2.$defs[schema2.$ref])) {
          if (schema2 = schema2.$defs[schema2.$ref], coerce || additionalCoerce)
            schema2 = replaceSchema(schema2);
        }
      } else if (hasRef(schema2)) {
        let id2 = randomId();
        schema2 = t.Module({ ...modules?.$defs, [id2]: schema2 }).Import(id2);
      } else if (coerce || additionalCoerce)
        schema2 = replaceSchema(schema2);
    }
    return schema2;
  }, schema = mapSchema(s), _validators = validators;
  if ("~standard" in schema || validators?.length && validators.some((x) => x && typeof x !== "string" && ("~standard" in x))) {
    let typeboxSubValidator = (schema2) => {
      let mirror2;
      if (normalize2 === true || normalize2 === "exactMirror")
        try {
          mirror2 = createMirror(schema2, { TypeCompiler, sanitize: sanitize2?.(), modules });
        } catch {
          console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema2), mirror2 = createCleaner(schema2);
        }
      let vali = getSchemaValidator(schema2, { models, modules, dynamic, normalize: normalize2, additionalProperties: true, forceAdditionalProperties: true, coerce, additionalCoerce });
      return vali.Decode = mirror2, (v) => {
        if (vali.Check(v))
          return { value: vali.Decode(v) };
        else
          return { issues: [...vali.Errors(v)] };
      };
    }, mainCheck = schema["~standard"] ? schema["~standard"].validate : typeboxSubValidator(schema), checkers = [];
    if (validators?.length)
      for (let validator2 of validators) {
        if (!validator2)
          continue;
        if (typeof validator2 === "string")
          continue;
        if (validator2?.["~standard"]) {
          checkers.push(validator2["~standard"]);
          continue;
        }
        if (Kind in validator2) {
          checkers.push(typeboxSubValidator(validator2));
          continue;
        }
      }
    async function Check2(value6) {
      let v = mainCheck(value6);
      if (v instanceof Promise)
        v = await v;
      if (v.issues)
        return v;
      let values7 = [];
      if (v && typeof v === "object")
        values7.push(v.value);
      for (let i = 0;i < checkers.length; i++) {
        if (v = checkers[i].validate(value6), v instanceof Promise)
          v = await v;
        if (v.issues)
          return v;
        if (v && typeof v === "object")
          values7.push(v.value);
      }
      if (!values7.length)
        return { value: v };
      if (values7.length === 1)
        return { value: values7[0] };
      if (values7.length === 2)
        return { value: mergeDeep(values7[0], values7[1]) };
      let newValue = mergeDeep(values7[0], values7[1]);
      for (let i = 2;i < values7.length; i++)
        newValue = mergeDeep(newValue, values7[i]);
      return { value: newValue };
    }
    let validator = { provider: "standard", schema, references: "", checkFunc: () => {
    }, code: "", Check: Check2, Errors: (value6) => Check2(value6)?.then?.((x) => x?.issues), Code: () => "", Decode: Check2, Encode: (value6) => value6, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
    return validator.parse = (v) => {
      try {
        return validator.Decode(validator.Clean?.(v) ?? v);
      } catch (error2) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
      } catch (error2) {
        let errors = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors[0]?.summary, errors };
      }
    }, validator;
  } else if (validators?.length) {
    let hasAdditional = false, validators2 = _validators, { schema: mergedObjectSchema, notObjects } = mergeObjectSchemas([schema, ...validators2.map(mapSchema)]);
    if (notObjects) {
      if (schema = t.Intersect([...mergedObjectSchema ? [mergedObjectSchema] : [], ...notObjects.map((x) => {
        let schema2 = mapSchema(x);
        if (schema2.type === "object" && "additionalProperties" in schema2) {
          if (!hasAdditional && schema2.additionalProperties === false)
            hasAdditional = true;
          delete schema2.additionalProperties;
        }
        return schema2;
      })]), schema.type === "object" && hasAdditional)
        schema.additionalProperties = false;
    }
  } else if (schema.type === "object" && (("additionalProperties" in schema) === false || forceAdditionalProperties))
    schema.additionalProperties = additionalProperties;
  else
    schema = replaceSchemaType(schema, { onlyFirst: "object", from: t.Object({}), to({ properties, ...options }) {
      if (!properties)
        return;
      if ("additionalProperties" in schema)
        return;
      return t.Object(properties, { ...options, additionalProperties: false });
    } });
  if (dynamic)
    if (Kind in schema) {
      let validator = { provider: "typebox", schema, references: "", checkFunc: () => {
      }, code: "", Check: (value6) => exports_value2.Check(schema, value6), Errors: (value6) => exports_value2.Errors(schema, value6), Code: () => "", Clean: createCleaner(schema), Decode: (value6) => exports_value2.Decode(schema, value6), Encode: (value6) => exports_value2.Encode(schema, value6), get hasAdditionalProperties() {
        if ("~hasAdditionalProperties" in this)
          return this["~hasAdditionalProperties"];
        return this["~hasAdditionalProperties"] = hasAdditionalProperties(schema);
      }, get hasDefault() {
        if ("~hasDefault" in this)
          return this["~hasDefault"];
        return this["~hasDefault"] = hasProperty2("default", schema);
      }, get isOptional() {
        if ("~isOptional" in this)
          return this["~isOptional"];
        return this["~isOptional"] = isOptional(schema);
      }, get hasTransform() {
        if ("~hasTransform" in this)
          return this["~hasTransform"];
        return this["~hasTransform"] = hasTransform(schema);
      }, "~hasRef": doesHaveRef, get hasRef() {
        if ("~hasRef" in this)
          return this["~hasRef"];
        return this["~hasRef"] = hasTransform(schema);
      } };
      if (schema.config) {
        if (validator.config = schema.config, validator?.schema?.config)
          delete validator.schema.config;
      }
      if (normalize2 && schema.additionalProperties === false)
        if (normalize2 === true || normalize2 === "exactMirror")
          try {
            validator.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
          } catch {
            console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.warn(schema), validator.Clean = createCleaner(schema);
          }
        else
          validator.Clean = createCleaner(schema);
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error2) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error2) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    } else {
      let validator = { provider: "standard", schema, references: "", checkFunc: () => {
      }, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value6) {
        let response = schema["~standard"].validate(value6);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response.issues;
      }, Code: () => "", Decode(value6) {
        let response = schema["~standard"].validate(value6);
        if (response instanceof Promise)
          throw Error("Async validation is not supported in non-dynamic schema");
        return response;
      }, Encode: (value6) => value6, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
      return validator.parse = (v) => {
        try {
          return validator.Decode(validator.Clean?.(v) ?? v);
        } catch (error2) {
          throw [...validator.Errors(v)].map(mapValueError);
        }
      }, validator.safeParse = (v) => {
        try {
          return { success: true, data: validator.Decode(validator.Clean?.(v) ?? v), error: null };
        } catch (error2) {
          let errors = [...compiled.Errors(v)].map(mapValueError);
          return { success: false, data: null, error: errors[0]?.summary, errors };
        }
      }, validator;
    }
  let compiled;
  if (Kind in schema) {
    if (compiled = TypeCompiler.Compile(schema, Object.values(models).filter((x) => (Kind in x))), compiled.provider = "typebox", schema.config) {
      if (compiled.config = schema.config, compiled?.schema?.config)
        delete compiled.schema.config;
    }
    if (normalize2 === true || normalize2 === "exactMirror")
      try {
        compiled.Clean = createMirror(schema, { TypeCompiler, sanitize: sanitize2?.(), modules });
      } catch (error2) {
        console.warn("Failed to create exactMirror. Please report the following code to https://github.com/elysiajs/elysia/issues"), console.dir(schema, { depth: null }), compiled.Clean = createCleaner(schema);
      }
    else if (normalize2 === "typebox")
      compiled.Clean = createCleaner(schema);
  } else
    compiled = { provider: "standard", schema, references: "", checkFunc(value6) {
      let response = schema["~standard"].validate(value6);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, code: "", Check: (v) => schema["~standard"].validate(v), Errors(value6) {
      let response = schema["~standard"].validate(value6);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response.issues;
    }, Code: () => "", Decode(value6) {
      let response = schema["~standard"].validate(value6);
      if (response instanceof Promise)
        throw Error("Async validation is not supported in non-dynamic schema");
      return response;
    }, Encode: (value6) => value6, hasAdditionalProperties: false, hasDefault: false, isOptional: false, hasTransform: false, hasRef: false };
  if (compiled.parse = (v) => {
    try {
      return compiled.Decode(compiled.Clean?.(v) ?? v);
    } catch (error2) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(compiled.Clean?.(v) ?? v), error: null };
    } catch (error2) {
      let errors = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors[0]?.summary, errors };
    }
  }, Kind in schema)
    Object.assign(compiled, { get hasAdditionalProperties() {
      if ("~hasAdditionalProperties" in this)
        return this["~hasAdditionalProperties"];
      return this["~hasAdditionalProperties"] = hasAdditionalProperties(compiled);
    }, get hasDefault() {
      if ("~hasDefault" in this)
        return this["~hasDefault"];
      return this["~hasDefault"] = hasProperty2("default", compiled);
    }, get isOptional() {
      if ("~isOptional" in this)
        return this["~isOptional"];
      return this["~isOptional"] = isOptional(compiled);
    }, get hasTransform() {
      if ("~hasTransform" in this)
        return this["~hasTransform"];
      return this["~hasTransform"] = hasTransform(schema);
    }, get hasRef() {
      if ("~hasRef" in this)
        return this["~hasRef"];
      return this["~hasRef"] = hasRef(schema);
    }, "~hasRef": doesHaveRef });
  return compiled;
};
var isUnion2 = (schema) => schema[Kind] === "Union" || !schema.schema && !!schema.anyOf;
var mergeObjectSchemas = (schemas) => {
  if (schemas.length === 0)
    return { schema: undefined, notObjects: [] };
  if (schemas.length === 1)
    return schemas[0].type === "object" ? { schema: schemas[0], notObjects: [] } : { schema: undefined, notObjects: schemas };
  let newSchema, notObjects = [], additionalPropertiesIsTrue = false, additionalPropertiesIsFalse = false;
  for (let schema of schemas) {
    if (schema.type !== "object") {
      notObjects.push(schema);
      continue;
    }
    if ("additionalProperties" in schema) {
      if (schema.additionalProperties === true)
        additionalPropertiesIsTrue = true;
      else if (schema.additionalProperties === false)
        additionalPropertiesIsFalse = true;
    }
    if (!newSchema) {
      newSchema = schema;
      continue;
    }
    newSchema = { ...newSchema, ...schema, properties: { ...newSchema.properties, ...schema.properties }, required: [...newSchema?.required ?? [], ...schema.required] };
  }
  if (newSchema) {
    if (newSchema.required)
      newSchema.required = [...new Set(newSchema.required)];
    if (additionalPropertiesIsFalse)
      newSchema.additionalProperties = false;
    else if (additionalPropertiesIsTrue)
      newSchema.additionalProperties = true;
  }
  return { schema: newSchema, notObjects };
};
var getResponseSchemaValidator = (s, { models = {}, modules, dynamic = false, normalize: normalize2 = false, additionalProperties = false, validators = [], sanitize: sanitize2 }) => {
  if (validators = validators.filter((x) => x), !s) {
    if (!validators?.length)
      return;
    s = validators[0], validators = validators.slice(1);
  }
  let maybeSchemaOrRecord;
  if (typeof s !== "string")
    maybeSchemaOrRecord = s;
  else if (maybeSchemaOrRecord = modules && s in modules.$defs ? modules.Import(s) : models[s], !maybeSchemaOrRecord)
    return;
  if (!maybeSchemaOrRecord)
    return;
  if (Kind in maybeSchemaOrRecord || "~standard" in maybeSchemaOrRecord)
    return { 200: getSchemaValidator(maybeSchemaOrRecord, { modules, models, additionalProperties, dynamic, normalize: normalize2, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[200]), sanitize: sanitize2 }) };
  let record2 = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status22) => {
    if (isNaN(+status22))
      return;
    let maybeNameOrSchema = maybeSchemaOrRecord[+status22];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema = models[maybeNameOrSchema];
        if (!schema)
          return;
        record2[+status22] = Kind in schema || "~standard" in schema ? getSchemaValidator(schema, { modules, models, additionalProperties, dynamic, normalize: normalize2, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[+status22]), sanitize: sanitize2 }) : schema;
      }
      return;
    }
    record2[+status22] = Kind in maybeNameOrSchema || "~standard" in maybeNameOrSchema ? getSchemaValidator(maybeNameOrSchema, { modules, models, additionalProperties, dynamic, normalize: normalize2, coerce: false, additionalCoerce: [], validators: validators.map((x) => x[+status22]), sanitize: sanitize2 }) : maybeNameOrSchema;
  }), record2;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _queryCoercions;
var queryCoercions = () => {
  if (!_queryCoercions)
    _queryCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayQuery(t.Any()) }];
  return _queryCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, modules, defaultConfig = {}, config: config2, dynamic, normalize: normalize2 = false, models, validators, sanitize: sanitize2 }) => {
  let cookieValidator = validator?.provider ? validator : getSchemaValidator(validator, { modules, dynamic, models, normalize: normalize2, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators, sanitize: sanitize2 });
  if (cookieValidator)
    cookieValidator.config = mergeCookie(cookieValidator.config, config2);
  else
    cookieValidator = getSchemaValidator(t.Cookie(t.Any()), { modules, dynamic, models, additionalProperties: true, validators, sanitize: sanitize2 }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var unwrapImportSchema = (schema) => schema && schema[Kind] === "Import" && schema.$defs[schema.$ref][Kind] === "Object" ? schema.$defs[schema.$ref] : schema;
var allocateIf = (value6, condition) => condition ? value6 : "";
var defaultParsers = ["json", "text", "urlencoded", "arrayBuffer", "formdata", "application/json", "text/plain", "application/x-www-form-urlencoded", "application/octet-stream", "multipart/form-data"];
var createReport = ({ context: context9 = "c", trace: trace2 = [], addFn }) => {
  if (!trace2.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let i = 0;i < trace2.length; i++)
    addFn(`let report${i},reportChild${i},reportErr${i},reportErrChild${i};let trace${i}=${context9}[ELYSIA_TRACE]?.[${i}]??trace[${i}](${context9});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace2.length; i++)
      addFn(`${reporter}${i} = trace${i}.${event}({id,event:'${event}',name:'${name}',begin:performance.now(),total:${total}})
`);
    return { resolve() {
      for (let i = 0;i < trace2.length; i++)
        addFn(`${reporter}${i}.resolve()
`);
    }, resolveChild(name2) {
      for (let i = 0;i < trace2.length; i++)
        addFn(`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({id,event:'${event}',name:'${name2}',begin:performance.now()})
`);
      return (binding) => {
        for (let i = 0;i < trace2.length; i++)
          if (binding)
            addFn(`if(${binding} instanceof Error){${reporter}Child${i}?.(${binding}) }else{${reporter}Child${i}?.()}`);
          else
            addFn(`${reporter}Child${i}?.()
`);
      };
    } };
  };
};
var composeCleaner = ({ schema, name, type: type2, typeAlias = type2, normalize: normalize2, ignoreTryCatch = false }) => {
  if (!normalize2 || !schema.Clean)
    return "";
  if (normalize2 === true || normalize2 === "exactMirror") {
    if (ignoreTryCatch)
      return `${name}=validator.${typeAlias}.Clean(${name})
`;
    return `try{${name}=validator.${typeAlias}.Clean(${name})
}catch{}`;
  }
  if (normalize2 === "typebox")
    return `${name}=validator.${typeAlias}.Clean(${name})
`;
  return "";
};
var composeValidationFactory = ({ injectResponse = "", normalize: normalize2 = false, validator, encodeSchema = false, isStaticResponse = false, hasSanitize = false }) => ({ validate: (type2, value6 = `c.${type2}`, error2) => `c.set.status=422;throw new ValidationError('${type2}',validator.${type2},${value6}${error2 ? "," + error2 : ""})`, response: (name = "r") => {
  if (isStaticResponse || !validator.response)
    return "";
  let code = injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse){c.set.status=${name}.code
${name}=${name}.response}if(${name} instanceof Response === false)switch(c.set.status){`;
  for (let [status22, value6] of Object.entries(validator.response)) {
    if (code += `
case ${status22}:
`, value6.provider === "standard") {
      code += `let vare${status22}=validator.response[${status22}].Check(${name})
if(vare${status22} instanceof Promise)vare${status22}=await vare${status22}
if(vare${status22}.issues)throw new ValidationError('response',validator.response[${status22}],${name},vare${status22}.issues)
${name}=vare${status22}.value
c.set.status=${status22}
break
`;
      continue;
    }
    let noValidate = value6.schema?.noValidate === true;
    if (!noValidate && value6.schema?.$ref && value6.schema?.$defs) {
      let refKey = value6.schema.$ref, defKey = typeof refKey === "string" && refKey.includes("/") ? refKey.split("/").pop() : refKey;
      if (value6.schema.$defs[defKey]?.noValidate === true)
        noValidate = true;
    }
    let appliedCleaner = noValidate || hasSanitize, clean2 = ({ ignoreTryCatch = false } = {}) => composeCleaner({ name, schema: value6, type: "response", typeAlias: `response[${status22}]`, normalize: normalize2, ignoreTryCatch });
    if (appliedCleaner)
      code += clean2();
    let applyErrorCleaner = !appliedCleaner && normalize2 && !noValidate;
    if (encodeSchema && value6.hasTransform && !noValidate) {
      if (code += `try{${name}=validator.response[${status22}].Encode(${name})
`, !appliedCleaner)
        code += clean2({ ignoreTryCatch: true });
      code += `c.set.status=${status22}}catch{` + (applyErrorCleaner ? `try{
` + clean2({ ignoreTryCatch: true }) + `${name}=validator.response[${status22}].Encode(${name})
}catch{throw new ValidationError('response',validator.response[${status22}],${name})}` : `throw new ValidationError('response',validator.response[${status22}],${name})`) + "}";
    } else {
      if (!appliedCleaner)
        code += clean2();
      if (!noValidate)
        code += `if(validator.response[${status22}].Check(${name})===false)throw new ValidationError('response',validator.response[${status22}],${name})
c.set.status=${status22}
`;
    }
    code += `break
`;
  }
  return code + "}";
} });
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var matchResponseClone = /=>\s?response\.clone\(/;
var matchFnReturn = /(?:return|=>)\s?\S+\(|a(?:sync|wait)/;
var isAsync = (v) => {
  let isObject22 = typeof v === "object";
  if (isObject22 && v.isAsync !== undefined)
    return v.isAsync;
  let fn2 = isObject22 ? v.fn : v;
  if (fn2.constructor.name === "AsyncFunction")
    return true;
  let literal2 = fn2.toString();
  if (matchResponseClone.test(literal2)) {
    if (isObject22)
      v.isAsync = false;
    return false;
  }
  let result = matchFnReturn.test(literal2);
  if (isObject22)
    v.isAsync = result;
  return result;
};
var hasReturn = (v) => {
  let isObject22 = typeof v === "object";
  if (isObject22 && v.hasReturn !== undefined)
    return v.hasReturn;
  let fnLiteral = isObject22 ? v.fn.toString() : typeof v === "string" ? v.toString() : v, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    if (isObject22)
      v.hasReturn = true;
    return true;
  }
  let result = fnLiteral.includes("return");
  if (isObject22)
    v.hasReturn = result;
  return result;
};
var isGenerator = (v) => {
  let fn2 = v?.fn ?? v;
  return fn2.constructor.name === "AsyncGeneratorFunction" || fn2.constructor.name === "GeneratorFunction";
};
var coerceTransformDecodeError = (fnLiteral, type2, value6 = `c.${type2}`) => `try{${fnLiteral}}catch(error){if(error.constructor.name === 'TransformDecodeError'){c.set.status=422
throw error.error ?? new ValidationError('${type2}',validator.${type2},${value6})}}`;
var composeHandler = ({ app, path, method, hooks, validator, handler, allowMeta = false, inference }) => {
  let adapter2 = app["~adapter"].composeHandler, adapterHandler = app["~adapter"].handler, isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    handler = adapterHandler.mapResponse(handler, { headers: app.setHeaders ?? {} });
    let isResponse = handler instanceof Response || handler?.constructor?.name === "Response" && typeof handler?.clone === "function";
    if (hooks.parse?.length && hooks.transform?.length && hooks.beforeHandle?.length && hooks.afterHandle?.length) {
      if (isResponse)
        return Function("a", `"use strict";
return function(){return a.clone()}`)(handler);
      return Function("a", `"use strict";
return function(){return a}`)(handler);
    }
    if (isResponse) {
      let response = handler;
      handler = () => response.clone();
    }
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasTrace = !!hooks.trace?.length, fnLiteral = "";
  if (inference = sucrose(hooks, inference), inference = sucrose({ handler }, inference), adapter2.declare) {
    let literal2 = adapter2.declare(inference);
    if (literal2)
      fnLiteral += literal2;
  }
  if (inference.server)
    fnLiteral += `Object.defineProperty(c,'server',{get:function(){return getServer()}})
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasValidation = !!validator.body || !!validator.headers || !!validator.params || !!validator.query || !!validator.cookie || !!validator.response, hasQuery = inference.query || !!validator.query, requestNoBody = hooks.parse?.length === 1 && hooks.parse[0].fn === "none", hasBody = method !== "" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || !!hooks.parse?.length) && !requestNoBody, defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || !!validator.headers || adapter2.preferWebstandardHeaders !== true && inference.body, hasCookie = inference.cookie || !!validator.cookie, cookieMeta = validator.cookie?.config ? mergeCookie(validator?.cookie?.config, app.config.cookie) : app.config.cookie, _encodeCookie = "", encodeCookie = () => {
    if (_encodeCookie)
      return _encodeCookie;
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      let secret2 = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (_encodeCookie += `const _setCookie = c.set.cookie
if(_setCookie){`, cookieMeta.sign === true)
        _encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)){c.set.cookie[key].value=await signCookie(cookie.value,'${secret2}')}`;
      else
        for (let name of cookieMeta.sign)
          _encodeCookie += `if(_setCookie['${name}']?.value)c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret2}')
`;
      _encodeCookie += `}
`;
    }
    return _encodeCookie;
  }, normalize2 = app.config.normalize, encodeSchema = app.config.encodeSchema, validation = composeValidationFactory({ normalize: normalize2, validator, encodeSchema, isStaticResponse: handler instanceof Response, hasSanitize: !!app.config.sanitize });
  if (hasHeaders)
    fnLiteral += adapter2.headers;
  if (hasTrace)
    fnLiteral += `const id=c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  if (fnLiteral += "try{", hasCookie) {
    let get32 = (name, defaultValue) => {
      let value6 = cookieMeta?.[name] ?? defaultValue;
      if (!value6)
        return typeof defaultValue === "string" ? `${name}:"${defaultValue}",` : `${name}:${defaultValue},`;
      if (typeof value6 === "string")
        return `${name}:'${value6}',`;
      if (value6 instanceof Date)
        return `${name}: new Date(${value6.getTime()}),`;
      return `${name}:${value6},`;
    }, options = cookieMeta ? `{secrets:${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},sign:${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},` + get32("domain") + get32("expires") + get32("httpOnly") + get32("maxAge") + get32("path", "/") + get32("priority") + get32("sameSite") + get32("secure") + "}" : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.headers.cookie,${options})
`;
    else
      fnLiteral += `
c.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})
`;
  }
  if (hasQuery) {
    let arrayProperties = {}, objectProperties = {}, hasArrayProperty = false, hasObjectProperty = false;
    if (validator.query?.schema) {
      let schema = unwrapImportSchema(validator.query?.schema);
      if (Kind in schema && schema.properties)
        for (let [key, value6] of Object.entries(schema.properties)) {
          if (hasElysiaMeta("ArrayQuery", value6))
            arrayProperties[key] = 1, hasArrayProperty = true;
          if (hasElysiaMeta("ObjectString", value6))
            objectProperties[key] = 1, hasObjectProperty = true;
        }
    }
    fnLiteral += `if(c.qi===-1){c.query=Object.create(null)}else{c.query=parseQueryFromURL(c.url,c.qi+1,${hasArrayProperty ? JSON.stringify(arrayProperties) : undefined},${hasObjectProperty ? JSON.stringify(objectProperties) : undefined})}`;
  }
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse?.length ? "c.response=c.responseValue= " : "", responseKeys = Object.keys(validator.response ?? {}), hasMultipleResponses = responseKeys.length > 1, hasSingle200 = responseKeys.length === 0 || responseKeys.length === 1 && responseKeys[0] === "200", maybeAsync = hasCookie || hasBody || isAsyncHandler || !!hooks.parse?.length || !!hooks.afterHandle?.some(isAsync) || !!hooks.beforeHandle?.some(isAsync) || !!hooks.transform?.some(isAsync) || !!hooks.mapResponse?.some(isAsync) || validator.body?.provider === "standard" || validator.headers?.provider === "standard" || validator.query?.provider === "standard" || validator.params?.provider === "standard" || validator.cookie?.provider === "standard" || Object.values(validator.response ?? {}).find((x) => x.provider === "standard"), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || !!hooks.beforeHandle?.some(isGenerator) || !!hooks.afterHandle?.some(isGenerator) || !!hooks.transform?.some(isGenerator), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || hasMultipleResponses || !hasSingle200 || isHandleFn && hasDefaultHeaders || maybeStream, afterResponse = () => {
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "", prefix = hooks.afterResponse?.some(isAsync) ? "async " : "";
    afterResponse2 += `
setImmediate(${prefix}()=>{`;
    let reporter = createReport({ trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name), prefix2 = isAsync(hooks.afterResponse[i]) ? "await " : "";
        afterResponse2 += `
${prefix2}e.afterResponse[${i}](c)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, afterResponse2;
  }, mapResponse3 = (r = "r") => {
    let after3 = afterResponse(), response = `${hasSet ? "mapResponse" : "mapCompactResponse"}(${saveResponse}${r}${hasSet ? ",c.set" : ""}${mapResponseContext})
`;
    if (!after3)
      return `return ${response}`;
    return `const _res=${response}` + after3 + "return _res";
  }, mapResponseContext = maybeStream || adapter2.mapResponseContext ? `,${adapter2.mapResponseContext}` : "";
  if (hasTrace || inference.route)
    fnLiteral += `c.route=\`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse?.length });
  if (hasBody) {
    let hasBodyInference = !!hooks.parse?.length || inference.body || validator.body;
    if (adapter2.parser.declare)
      fnLiteral += adapter2.parser.declare;
    fnLiteral += `
try{`;
    let parser = typeof hooks.parse === "string" ? hooks.parse : Array.isArray(hooks.parse) && hooks.parse.length === 1 ? typeof hooks.parse[0] === "string" ? hooks.parse[0] : typeof hooks.parse[0].fn === "string" ? hooks.parse[0].fn : undefined : undefined;
    if (!parser && validator.body && !hooks.parse?.length) {
      let schema = validator.body.schema;
      if (schema && schema.anyOf && schema[Kind] === "Union" && schema.anyOf?.length === 2 && schema.anyOf?.find((x) => x[Kind] === "ElysiaForm"))
        parser = "formdata";
    }
    if (parser && defaultParsers.includes(parser)) {
      let reporter = report("parse", { total: hooks.parse?.length }), isOptionalBody = !!validator.body?.isOptional;
      switch (parser) {
        case "json":
        case "application/json":
          fnLiteral += adapter2.parser.json(isOptionalBody);
          break;
        case "text":
        case "text/plain":
          fnLiteral += adapter2.parser.text(isOptionalBody);
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += adapter2.parser.urlencoded(isOptionalBody);
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += adapter2.parser.arrayBuffer(isOptionalBody);
          break;
        case "formdata":
        case "multipart/form-data":
          fnLiteral += adapter2.parser.formData(isOptionalBody);
          break;
        default:
          if (parser[0] in app["~parser"])
            fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
if(contentType){const index=contentType.indexOf(';')
if(index!==-1)contentType=contentType.substring(0,index)}
else{contentType=''}c.contentType=contentType
let result=parser['${parser}'](c, contentType)
if(result instanceof Promise)result=await result
if(result instanceof ElysiaCustomStatusResponse)throw result
if(result!==undefined)c.body=result
delete c.contentType
`;
          break;
      }
      reporter.resolve();
    } else if (hasBodyInference) {
      fnLiteral += `
`, fnLiteral += `let contentType
if(c.request.body)`, fnLiteral += hasHeaders ? `contentType=c.headers['content-type']
` : `contentType=c.request.headers.get('content-type')
`;
      let hasDefaultParser = false;
      if (hooks.parse?.length)
        fnLiteral += `if(contentType){
const index=contentType.indexOf(';')

if(index!==-1)contentType=contentType.substring(0,index)}else{contentType=''}let used=false
c.contentType=contentType
`;
      else {
        hasDefaultParser = true;
        let isOptionalBody = !!validator.body?.isOptional;
        fnLiteral += `if(contentType)switch(contentType.charCodeAt(12)){
case 106:` + adapter2.parser.json(isOptionalBody) + `break
case 120:` + adapter2.parser.urlencoded(isOptionalBody) + `break
case 111:` + adapter2.parser.arrayBuffer(isOptionalBody) + `break
case 114:` + adapter2.parser.formData(isOptionalBody) + `break
default:if(contentType.charCodeAt(0)===116){` + adapter2.parser.text(isOptionalBody) + `}break
}`;
      }
      let reporter = report("parse", { total: hooks.parse?.length });
      if (hooks.parse)
        for (let i = 0;i < hooks.parse.length; i++) {
          let name = `bo${i}`;
          if (i !== 0)
            fnLiteral += `
if(!used){`;
          if (typeof hooks.parse[i].fn === "string") {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn), isOptionalBody = !!validator.body?.isOptional;
            switch (hooks.parse[i].fn) {
              case "json":
              case "application/json":
                hasDefaultParser = true, fnLiteral += adapter2.parser.json(isOptionalBody);
                break;
              case "text":
              case "text/plain":
                hasDefaultParser = true, fnLiteral += adapter2.parser.text(isOptionalBody);
                break;
              case "urlencoded":
              case "application/x-www-form-urlencoded":
                hasDefaultParser = true, fnLiteral += adapter2.parser.urlencoded(isOptionalBody);
                break;
              case "arrayBuffer":
              case "application/octet-stream":
                hasDefaultParser = true, fnLiteral += adapter2.parser.arrayBuffer(isOptionalBody);
                break;
              case "formdata":
              case "multipart/form-data":
                hasDefaultParser = true, fnLiteral += adapter2.parser.formData(isOptionalBody);
                break;
              default:
                fnLiteral += `let ${name}=parser['${hooks.parse[i].fn}'](c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true;}
`;
            }
            endUnit();
          } else {
            let endUnit = reporter.resolveChild(hooks.parse[i].fn.name);
            fnLiteral += `let ${name}=e.parse[${i}]
${name}=${name}(c,contentType)
if(${name} instanceof Promise)${name}=await ${name}
if(${name}!==undefined){c.body=${name};used=true}`, endUnit();
          }
          if (i !== 0)
            fnLiteral += "}";
          if (hasDefaultParser)
            break;
        }
      if (reporter.resolve(), !hasDefaultParser) {
        let isOptionalBody = !!validator.body?.isOptional;
        if (hooks.parse?.length)
          fnLiteral += `
if(!used){
`;
        fnLiteral += `switch(contentType){case 'application/json':
` + adapter2.parser.json(isOptionalBody) + `break
case 'text/plain':` + adapter2.parser.text(isOptionalBody) + `break
case 'application/x-www-form-urlencoded':` + adapter2.parser.urlencoded(isOptionalBody) + `break
case 'application/octet-stream':` + adapter2.parser.arrayBuffer(isOptionalBody) + `break
case 'multipart/form-data':` + adapter2.parser.formData(isOptionalBody) + `break
`;
        for (let key of Object.keys(app["~parser"]))
          fnLiteral += `case '${key}':let bo${key}=parser['${key}'](c,contentType)
if(bo${key} instanceof Promise)bo${key}=await bo${key}
if(bo${key} instanceof ElysiaCustomStatusResponse){` + mapResponse3(`bo${key}`) + `}if(bo${key}!==undefined)c.body=bo${key}
break
`;
        if (hooks.parse?.length)
          fnLiteral += "}";
        fnLiteral += "}";
      }
      if (hooks.parse?.length)
        fnLiteral += `
delete c.contentType`;
    }
    fnLiteral += "}catch(error){throw new ParseError(error)}";
  }
  if (parseReporter.resolve(), hooks?.transform || hasTrace) {
    let reporter = report("transform", { total: hooks.transform?.length });
    if (hooks.transform?.length) {
      fnLiteral += `let transformed
`;
      for (let i = 0;i < hooks.transform.length; i++) {
        let transform6 = hooks.transform[i], endUnit = reporter.resolveChild(transform6.fn.name);
        if (fnLiteral += isAsync(transform6) ? `transformed=await e.transform[${i}](c)
` : `transformed=e.transform[${i}](c)
`, transform6.subType === "mapDerive")
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else{transformed.request=c.request
transformed.store=c.store
transformed.qi=c.qi
transformed.path=c.path
transformed.url=c.url
transformed.redirect=c.redirect
transformed.set=c.set
transformed.error=c.error
c=transformed}`;
        else
          fnLiteral += "if(transformed instanceof ElysiaCustomStatusResponse){" + mapResponse3("transformed") + `}else Object.assign(c,transformed)
`;
        endUnit();
      }
    }
    reporter.resolve();
  }
  let fileUnions = [];
  if (validator) {
    if (validator.headers) {
      if (validator.headers.hasDefault)
        for (let [key, value6] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value6 === "object" ? JSON.stringify(value6) : typeof value6 === "string" ? `'${value6}'` : value6;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}']??=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.headers", schema: validator.headers, type: "headers", normalize: normalize2 }), validator.headers.isOptional)
        fnLiteral += "if(isNotEmpty(c.headers)){";
      if (validator.headers?.provider === "standard")
        fnLiteral += `let vah=validator.headers.Check(c.headers)
if(vah instanceof Promise)vah=await vah
if(vah.issues){` + validation.validate("headers", undefined, "vah.issues") + `}else{c.headers=vah.value}
`;
      else if (validator.headers?.schema?.noValidate !== true)
        fnLiteral += "if(validator.headers.Check(c.headers) === false){" + validation.validate("headers") + "}";
      if (validator.headers.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.headers=validator.headers.Decode(c.headers)
`, "headers");
      if (validator.headers.isOptional)
        fnLiteral += "}";
    }
    if (validator.params) {
      if (validator.params.hasDefault)
        for (let [key, value6] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value6 === "object" ? JSON.stringify(value6) : typeof value6 === "string" ? `'${value6}'` : value6;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}']??=${parsed}
`;
        }
      if (validator.params.provider === "standard")
        fnLiteral += `let vap=validator.params.Check(c.params)
if(vap instanceof Promise)vap=await vap
if(vap.issues){` + validation.validate("params", undefined, "vap.issues") + `}else{c.params=vap.value}
`;
      else if (validator.params?.schema?.noValidate !== true)
        fnLiteral += "if(validator.params.Check(c.params)===false){" + validation.validate("params") + "}";
      if (validator.params.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.params=validator.params.Decode(c.params)
`, "params");
    }
    if (validator.query) {
      if (Kind in validator.query?.schema && validator.query.hasDefault)
        for (let [key, value6] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value6 === "object" ? JSON.stringify(value6) : typeof value6 === "string" ? `'${value6}'` : value6;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}
`;
        }
      if (fnLiteral += composeCleaner({ name: "c.query", schema: validator.query, type: "query", normalize: normalize2 }), validator.query.isOptional)
        fnLiteral += "if(isNotEmpty(c.query)){";
      if (validator.query.provider === "standard")
        fnLiteral += `let vaq=validator.query.Check(c.query)
if(vaq instanceof Promise)vaq=await vaq
if(vaq.issues){` + validation.validate("query", undefined, "vaq.issues") + `}else{c.query=vaq.value}
`;
      else if (validator.query?.schema?.noValidate !== true)
        fnLiteral += "if(validator.query.Check(c.query)===false){" + validation.validate("query") + "}";
      if (validator.query.hasTransform)
        fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query"), fnLiteral += coerceTransformDecodeError(`c.query=validator.query.Decode(c.query)
`, "query");
      if (validator.query.isOptional)
        fnLiteral += "}";
    }
    if (hasBody && validator.body) {
      if (validator.body.hasTransform || validator.body.isOptional)
        fnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body==="object"&&(isNotEmpty(c.body)||c.body instanceof ArrayBuffer))
`;
      let hasUnion = isUnion2(validator.body.schema), hasNonUnionFileWithDefault = false;
      if (validator.body.hasDefault) {
        let value6 = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" || unwrapImportSchema(validator.body.schema)[Kind] === "Object" ? {} : undefined), schema = unwrapImportSchema(validator.body.schema);
        if (!hasUnion && value6 && typeof value6 === "object" && (hasType("File", schema) || hasType("Files", schema))) {
          hasNonUnionFileWithDefault = true;
          for (let [k2, v] of Object.entries(value6))
            if (v === "File" || v === "Files")
              delete value6[k2];
          if (!isNotEmpty(value6))
            value6 = undefined;
        }
        let parsed = typeof value6 === "object" ? JSON.stringify(value6) : typeof value6 === "string" ? `'${value6}'` : value6;
        if (value6 !== undefined && value6 !== null)
          if (Array.isArray(value6))
            fnLiteral += `if(!c.body)c.body=${parsed}
`;
          else if (typeof value6 === "object")
            fnLiteral += `c.body=Object.assign(${parsed},c.body)
`;
          else
            fnLiteral += `c.body=${parsed}
`;
        if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize: normalize2 }), validator.body.provider === "standard")
          fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
        else if (validator.body?.schema?.noValidate !== true)
          if (validator.body.isOptional)
            fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
          else
            fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      } else if (fnLiteral += composeCleaner({ name: "c.body", schema: validator.body, type: "body", normalize: normalize2 }), validator.body.provider === "standard")
        fnLiteral += `let vab=validator.body.Check(c.body)
if(vab instanceof Promise)vab=await vab
if(vab.issues){` + validation.validate("body", undefined, "vab.issues") + `}else{c.body=vab.value}
`;
      else if (validator.body?.schema?.noValidate !== true)
        if (validator.body.isOptional)
          fnLiteral += "if(isNotEmptyObject&&validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
        else
          fnLiteral += "if(validator.body.Check(c.body)===false){" + validation.validate("body") + "}";
      if (validator.body.hasTransform)
        fnLiteral += coerceTransformDecodeError(`if(isNotEmptyObject)c.body=validator.body.Decode(c.body)
`, "body");
      if (hasUnion && validator.body.schema.anyOf?.length) {
        let iterator = Object.values(validator.body.schema.anyOf);
        for (let i = 0;i < iterator.length; i++) {
          let type2 = iterator[i];
          if (hasType("File", type2) || hasType("Files", type2)) {
            let candidate = getSchemaValidator(type2, { modules: app.definitions.typebox, dynamic: !app.config.aot, models: app.definitions.type, normalize: app.config.normalize, additionalCoerce: coercePrimitiveRoot(), sanitize: () => app.config.sanitize });
            if (candidate) {
              let isFirst = fileUnions.length === 0, iterator2 = Object.entries(type2.properties), validator2 = isFirst ? `
` : " else ";
              validator2 += `if(fileUnions[${fileUnions.length}].Check(c.body)){`;
              let validateFile2 = "", validatorLength = 0;
              for (let i2 = 0;i2 < iterator2.length; i2++) {
                let [k2, v] = iterator2[i2];
                if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
                  continue;
                if (validatorLength)
                  validateFile2 += ",";
                validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, validatorLength++;
              }
              if (validateFile2) {
                if (validatorLength === 1)
                  validator2 += `await ${validateFile2}
`;
                else if (validatorLength > 1)
                  validator2 += `await Promise.all([${validateFile2}])
`;
                validator2 += "}", fnLiteral += validator2, fileUnions.push(candidate);
              }
            }
          }
        }
      } else if (hasNonUnionFileWithDefault || !hasUnion && (hasType("File", unwrapImportSchema(validator.body.schema)) || hasType("Files", unwrapImportSchema(validator.body.schema)))) {
        let validateFile2 = "", i = 0;
        for (let [k2, v] of Object.entries(unwrapImportSchema(validator.body.schema).properties)) {
          if (!v.extension || v[Kind] !== "File" && v[Kind] !== "Files")
            continue;
          if (i)
            validateFile2 += ",";
          validateFile2 += `fileType(c.body.${k2},${JSON.stringify(v.extension)},'body.${k2}')`, i++;
        }
        if (i)
          fnLiteral += `
`;
        if (i === 1)
          fnLiteral += `await ${validateFile2}
`;
        else if (i > 1)
          fnLiteral += `await Promise.all([${validateFile2}])
`;
      }
    }
    if (validator.cookie) {
      if (validator.cookie.config = mergeCookie(validator.cookie.config, validator.cookie?.config ?? {}), fnLiteral += `let cookieValue={}
for(const [key,value] of Object.entries(c.cookie))cookieValue[key]=value.value
`, validator.cookie.isOptional)
        fnLiteral += "if(isNotEmpty(c.cookie)){";
      if (validator.cookie.provider === "standard")
        fnLiteral += `let vac=validator.cookie.Check(cookieValue)
if(vac instanceof Promise)vac=await vac
if(vac.issues){` + validation.validate("cookie", undefined, "vac.issues") + `}else{cookieValue=vac.value}
`, fnLiteral += `for(const k of Object.keys(cookieValue))c.cookie[k].value=cookieValue[k]
`;
      else if (validator.body?.schema?.noValidate !== true) {
        if (fnLiteral += "if(validator.cookie.Check(cookieValue)===false){" + validation.validate("cookie", "cookieValue") + "}", validator.cookie.hasTransform)
          fnLiteral += coerceTransformDecodeError("for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue))){c.cookie[key].value=value}", "cookie");
      }
      if (validator.cookie.isOptional)
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle || hasTrace) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle?.length }), hasResolve = false;
    if (hooks.beforeHandle?.length)
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
        if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
          if (!hasResolve)
            hasResolve = true, fnLiteral += `
let resolved
`;
          if (fnLiteral += isAsync(beforeHandle) ? `resolved=await e.beforeHandle[${i}](c);
` : `resolved=e.beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve")
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else{resolved.request=c.request
resolved.store=c.store
resolved.qi=c.qi
resolved.path=c.path
resolved.url=c.url
resolved.redirect=c.redirect
resolved.set=c.set
resolved.error=c.error
c=resolved}`;
          else
            fnLiteral += "if(resolved instanceof ElysiaCustomStatusResponse){" + mapResponse3("resolved") + `}else Object.assign(c, resolved)
`;
          endUnit();
        } else if (!returning)
          fnLiteral += isAsync(beforeHandle) ? `await e.beforeHandle[${i}](c)
` : `e.beforeHandle[${i}](c)
`, endUnit();
        else {
          if (fnLiteral += isAsync(beforeHandle) ? `be=await e.beforeHandle[${i}](c)
` : `be=e.beforeHandle[${i}](c)
`, endUnit("be"), fnLiteral += "if(be!==undefined){", reporter.resolve(), hooks.afterHandle?.length || hasTrace) {
            report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
            let reporter2 = report("afterHandle", { total: hooks.afterHandle?.length });
            if (hooks.afterHandle?.length)
              for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                let hook = hooks.afterHandle[i2], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
                if (fnLiteral += `c.response = be
`, !returning2)
                  fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i2}](c, be)
` : `e.afterHandle[${i2}](c, be)
`;
                else
                  fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i2}](c)
` : `af=e.afterHandle[${i2}](c)
`, fnLiteral += `if(af!==undefined) c.response=c.responseValue=be=af
`;
                endUnit2("af");
              }
            reporter2.resolve();
          }
          if (validator.response)
            fnLiteral += validation.response("be");
          let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
          if (hooks.mapResponse?.length) {
            fnLiteral += `c.response=c.responseValue=be
`;
            for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
              let mapResponse4 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
              fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i2}](c)
if(mr!==undefined)be=c.response=c.responseValue=mr}`, endUnit2();
            }
          }
          mapResponseReporter.resolve(), fnLiteral += encodeCookie(), fnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${mapResponseContext})}
`;
        }
      }
    reporter.resolve();
  }
  if (hooks.afterHandle?.length || hasTrace) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle?.length)
      fnLiteral += isAsyncHandler ? `let r=c.response=c.responseValue=await ${handle}
` : `let r=c.response=c.responseValue=${handle}
`;
    else
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle?.length });
    if (hooks.afterHandle?.length)
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let hook = hooks.afterHandle[i], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
        if (!returning)
          fnLiteral += isAsync(hook.fn) ? `await e.afterHandle[${i}](c)
` : `e.afterHandle[${i}](c)
`, endUnit();
        else if (fnLiteral += isAsync(hook.fn) ? `af=await e.afterHandle[${i}](c)
` : `af=e.afterHandle[${i}](c)
`, endUnit("af"), validator.response)
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += validation.response("af"), fnLiteral += "c.response=c.responseValue=af}";
        else
          fnLiteral += "if(af!==undefined){", reporter.resolve(), fnLiteral += "c.response=c.responseValue=af}";
      }
    if (reporter.resolve(), hooks.afterHandle?.length)
      fnLiteral += `r=c.response
`;
    if (validator.response)
      fnLiteral += validation.response();
    fnLiteral += encodeCookie();
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
    if (hooks.mapResponse?.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
        fnLiteral += `mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr
`, endUnit();
      }
    mapResponseReporter.resolve(), fnLiteral += mapResponse3();
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse?.length || hasTrace) {
      if (fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve(), validator.response)
        fnLiteral += validation.response();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `
c.response=c.responseValue=r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `
if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie(), handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else
        fnLiteral += mapResponse3();
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r=await ${handle}
` : `let r=${handle}
`, handleReporter.resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
      if (hooks.mapResponse?.length) {
        fnLiteral += `c.response=c.responseValue= r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse4 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse4) ? "await " : ""}e.mapResponse[${i}](c)
if(mr!==undefined)r=c.response=c.responseValue=mr}`, endUnit();
        }
      }
      mapResponseReporter.resolve(), fnLiteral += encodeCookie() + mapResponse3();
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (handler instanceof Response)
        fnLiteral += afterResponse(), fnLiteral += inference.set ? `if(isNotEmpty(c.set.headers)||c.set.status!==200||c.set.redirect||c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${mapResponseContext})
else return ${handle}.clone()
` : `return ${handle}.clone()
`;
      else
        fnLiteral += mapResponse3(handled);
    }
  }
  if (fnLiteral += `
}catch(error){`, !maybeAsync && hooks.error?.length)
    fnLiteral += "return(async()=>{";
  if (fnLiteral += `const set=c.set
if(!set.status||set.status<300)set.status=error?.status||500
`, hasCookie)
    fnLiteral += encodeCookie();
  if (hasTrace && hooks.trace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)
`;
  let errorReporter = report("error", { total: hooks.error?.length });
  if (hooks.error?.length) {
    if (fnLiteral += `c.error=error
`, hasValidation)
      fnLiteral += `if(error instanceof TypeBoxError){c.code="VALIDATION"
c.set.status=422}else{c.code=error.code??error[ERROR_CODE]??"UNKNOWN"}`;
    else
      fnLiteral += `c.code=error.code??error[ERROR_CODE]??"UNKNOWN"
`;
    if (fnLiteral += `let er
`, hooks.mapResponse?.length)
      fnLiteral += `let mep
`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync(hooks.error[i]))
        fnLiteral += `er=await e.error[${i}](c)
`;
      else
        fnLiteral += `er=e.error[${i}](c)
if(er instanceof Promise)er=await er
`;
      if (endUnit(), hooks.mapResponse?.length) {
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length });
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse4 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse4.fn.name);
          fnLiteral += `c.response=c.responseValue=er
mep=e.mapResponse[${i2}](c)
if(mep instanceof Promise)er=await er
if(mep!==undefined)er=mep
`, endUnit2();
        }
        mapResponseReporter.resolve();
      }
      if (fnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})
`, fnLiteral += "if(er){", hasTrace && hooks.trace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += "return er}";
    }
  }
  if (errorReporter.resolve(), fnLiteral += "return handleError(c,error,true)", !maybeAsync && hooks.error?.length)
    fnLiteral += "})()";
  fnLiteral += "}";
  let adapterVariables = adapter2.inject ? Object.keys(adapter2.inject).join(",") + "," : "", init = "const {handler,handleError,hooks:e, " + allocateIf("validator,", hasValidation) + "mapResponse,mapCompactResponse,mapEarlyResponse,isNotEmpty,utils:{" + allocateIf("parseQuery,", hasBody) + allocateIf("parseQueryFromURL,", hasQuery) + "},error:{" + allocateIf("ValidationError,", hasValidation) + allocateIf("ParseError", hasBody) + "},fileType,schema,definitions,ERROR_CODE," + allocateIf("parseCookie,", hasCookie) + allocateIf("signCookie,", hasCookie) + allocateIf("decodeURIComponent,", hasQuery) + "ElysiaCustomStatusResponse," + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + allocateIf("parser,", hooks.parse?.length) + allocateIf("getServer,", inference.server) + allocateIf("fileUnions,", fileUnions.length) + adapterVariables + allocateIf("TypeBoxError", hasValidation) + `}=hooks
const trace=e.trace
return ${maybeAsync ? "async " : ""}function handle(c){`;
  if (hooks.beforeHandle?.length)
    init += `let be
`;
  if (hooks.afterHandle?.length)
    init += `let af
`;
  if (hooks.mapResponse?.length)
    init += `let mr
`;
  if (allowMeta)
    init += `c.schema=schema
c.defs=definitions
`;
  fnLiteral = init + fnLiteral + "}", init = "";
  try {
    return Function("hooks", `"use strict";
` + fnLiteral)({ handler, hooks: lifeCycleToFn(hooks), validator: hasValidation ? validator : undefined, handleError: app.handleError, mapResponse: adapterHandler.mapResponse, mapCompactResponse: adapterHandler.mapCompactResponse, mapEarlyResponse: adapterHandler.mapEarlyResponse, isNotEmpty, utils: { parseQuery: hasBody ? parseQuery : undefined, parseQueryFromURL: hasQuery ? validator.query?.provider === "standard" ? parseQueryStandardSchema : parseQueryFromURL : undefined }, error: { ValidationError: hasValidation ? ValidationError : undefined, ParseError: hasBody ? ParseError3 : undefined }, fileType, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE, parseCookie: hasCookie ? parseCookie : undefined, signCookie: hasCookie ? signCookie : undefined, decodeURIComponent: hasQuery ? import_fast_decode_uri_component3.default : undefined, ElysiaCustomStatusResponse, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, getServer: inference.server ? () => app.getServer() : undefined, fileUnions: fileUnions.length ? fileUnions : undefined, TypeBoxError: hasValidation ? TypeBoxError : undefined, parser: app["~parser"], ...adapter2.inject });
  } catch (error2) {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, instruction: fnLiteral, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x) => x.toString()), resolve: debugHooks?.resolve?.map?.((x) => x.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()), parse: debugHooks?.parse?.map?.((x) => x.toString()), error: debugHooks?.error?.map?.((x) => x.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()), stop: debugHooks?.stop?.map?.((x) => x.toString()) }, validator, definitions: app.definitions.type, error: error2 }), console.log("---"), process.exit(1);
  }
};
var createOnRequestHandler = (app, addFn) => {
  let fnLiteral = "", reporter = createReport({ trace: app.event.trace, addFn: addFn ?? ((word) => {
    fnLiteral += word;
  }) })("request", { total: app.event.request?.length });
  if (app.event.request?.length) {
    fnLiteral += "try{";
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn(hook), maybeAsync = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn)
        fnLiteral += `re=mapEarlyResponse(${maybeAsync ? "await " : ""}onRequest[${i}](c),c.set)
`, endUnit("re"), fnLiteral += `if(re!==undefined)return re
`;
      else
        fnLiteral += `${maybeAsync ? "await " : ""}onRequest[${i}](c)
`, endUnit();
    }
    fnLiteral += "}catch(error){return app.handleError(c,error,false)}";
  }
  return reporter.resolve(), fnLiteral;
};
var createHoc = (app, fnName = "map") => {
  let hoc = app.extender.higherOrderFunctions;
  if (!hoc.length)
    return "return " + fnName;
  let adapter2 = app["~adapter"].composeGeneralHandler, handler = fnName;
  for (let i = 0;i < hoc.length; i++)
    handler = `hoc[${i}](${handler},${adapter2.parameters})`;
  return `return function hocMap(${adapter2.parameters}){return ${handler}(${adapter2.parameters})}`;
};
var composeGeneralHandler = (app) => {
  let adapter2 = app["~adapter"].composeGeneralHandler;
  app.router.http.build();
  let isWebstandard = app["~adapter"].isWebStandard, hasTrace = app.event.trace?.length, fnLiteral = "", router = app.router, findDynamicRoute = router.http.root.WS ? "const route=router.find(r.method==='GET'&&r.headers.get('upgrade')==='websocket'?'WS':r.method,p)" : "const route=router.find(r.method,p)";
  if (findDynamicRoute += router.http.root.ALL ? `??router.find('ALL',p)
` : `
`, isWebstandard)
    findDynamicRoute += `if(r.method==='HEAD'){const route=router.find('GET',p)
if(route){c.params=route.params
const _res=route.store.handler?route.store.handler(c):route.store.compile()(c)
if(_res)return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})}}`;
  let afterResponse = `c.error=notFound
`;
  if (app.event.afterResponse?.length && !app.event.error) {
    afterResponse = `
c.error=notFound
`;
    let prefix = app.event.afterResponse.some(isAsync) ? "async" : "";
    afterResponse += `
setImmediate(${prefix}()=>{`;
    for (let i = 0;i < app.event.afterResponse.length; i++) {
      let fn22 = app.event.afterResponse[i].fn;
      afterResponse += `
${isAsyncName(fn22) ? "await " : ""}afterResponse[${i}](c)
`;
    }
    afterResponse += `})
`;
  }
  if (app.inference.query)
    afterResponse += `
if(c.qi===-1){c.query={}}else{c.query=parseQueryFromURL(c.url,c.qi+1)}`;
  let error404 = adapter2.error404(!!app.event.request?.length, !!app.event.error?.length, afterResponse);
  findDynamicRoute += error404.code, findDynamicRoute += `
c.params=route.params
if(route.store.handler)return route.store.handler(c)
return route.store.compile()(c)
`;
  let switchMap = "";
  for (let [path, methods] of Object.entries(router.static)) {
    if (switchMap += `case'${path}':`, app.config.strictPath !== true)
      switchMap += `case'${getLoosePath(path)}':`;
    let encoded = encodePath(path);
    if (path !== encoded)
      switchMap += `case'${encoded}':`;
    if (switchMap += "switch(r.method){", "GET" in methods || "WS" in methods) {
      if (switchMap += "case 'GET':", "WS" in methods) {
        if (switchMap += `if(r.headers.get('upgrade')==='websocket')return ht[${methods.WS}].composed(c)
`, "GET" in methods === false)
          if ("ALL" in methods)
            switchMap += `return ht[${methods.ALL}].composed(c)
`;
          else
            switchMap += `break map
`;
      }
      if ("GET" in methods)
        switchMap += `return ht[${methods.GET}].composed(c)
`;
    }
    if (isWebstandard && (("GET" in methods) || ("ALL" in methods)) && "HEAD" in methods === false)
      switchMap += `case 'HEAD':const _res=ht[${methods.GET ?? methods.ALL}].composed(c)
return getResponseLength(_res).then((length)=>{_res.headers.set('content-length', length)
return new Response(null,{status:_res.status,statusText:_res.statusText,headers:_res.headers})
})
`;
    for (let [method, index] of Object.entries(methods)) {
      if (method === "ALL" || method === "GET" || method === "WS")
        continue;
      switchMap += `case '${method}':return ht[${index}].composed(c)
`;
    }
    if ("ALL" in methods)
      switchMap += `default:return ht[${methods.ALL}].composed(c)
`;
    else
      switchMap += `default:break map
`;
    switchMap += "}";
  }
  let maybeAsync = !!app.event.request?.some(isAsync), adapterVariables = adapter2.inject ? Object.keys(adapter2.inject).join(",") + "," : "";
  if (fnLiteral += `
const {app,mapEarlyResponse,NotFoundError,randomId,handleError,status,redirect,getResponseLength,` + allocateIf("parseQueryFromURL,", app.inference.query) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=data
const store=app.singleton.store
const decorator=app.singleton.decorator
const staticRouter=app.router.static.http
const ht=app.router.history
const router=app.router.http
const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]
const notFound=new NotFoundError()
const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)
`, app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  if (app.event.afterResponse?.length)
    fnLiteral += `const afterResponse=app.event.afterResponse.map(x=>x.fn)
`;
  if (fnLiteral += error404.declare, app.event.trace?.length)
    fnLiteral += "const " + app.event.trace.map((_2, i) => `tr${i}=app.event.trace[${i}].fn`).join(",") + `
`;
  if (fnLiteral += `${maybeAsync ? "async " : ""}function map(${adapter2.parameters}){`, app.event.request?.length)
    fnLiteral += `let re
`;
  if (fnLiteral += adapter2.createContext(app), app.event.trace?.length)
    fnLiteral += "c[ELYSIA_TRACE]=[" + app.event.trace.map((_2, i) => `tr${i}(c)`).join(",") + `]
`;
  if (fnLiteral += createOnRequestHandler(app), switchMap)
    fnLiteral += `
map: switch(p){
` + switchMap + "}";
  fnLiteral += findDynamicRoute + `}
` + createHoc(app);
  let handleError = composeErrorHandler(app);
  app.handleError = handleError;
  let fn2 = Function("data", `"use strict";
` + fnLiteral)({ app, mapEarlyResponse: app["~adapter"].handler.mapEarlyResponse, NotFoundError, randomId, handleError, status: status2, redirect, getResponseLength, parseQueryFromURL: app.inference.query ? parseQueryFromURL : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter2.inject });
  if (isBun)
    Bun.gc(false);
  return fn2;
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "", adapter2 = app["~adapter"].composeError, adapterVariables = adapter2.inject ? Object.keys(adapter2.inject).join(",") + "," : "", hasTrace = !!app.event.trace?.length;
  if (fnLiteral += "const {mapResponse,ERROR_CODE,ElysiaCustomStatusResponse," + allocateIf("onError,", app.event.error) + allocateIf("afterResponse,", app.event.afterResponse) + allocateIf("trace,", app.event.trace) + allocateIf("onMapResponse,", app.event.mapResponse) + allocateIf("ELYSIA_TRACE,", hasTrace) + allocateIf("ELYSIA_REQUEST_ID,", hasTrace) + adapterVariables + `}=inject
`, fnLiteral += `return ${app.event.error?.find(isAsync) || app.event.mapResponse?.find(isAsync) ? "async " : ""}function(context,error,skipGlobal){`, fnLiteral += "", hasTrace)
    fnLiteral += `const id=context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } }), afterResponse = () => {
    if (!hooks.afterResponse?.length && !hasTrace)
      return "";
    let afterResponse2 = "", prefix = hooks.afterResponse?.some(isAsync) ? "async" : "";
    afterResponse2 += `
setImmediate(${prefix}()=>{`;
    let reporter = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
      afterResponse2 += word;
    } })("afterResponse", { total: hooks.afterResponse?.length, name: "context" });
    if (hooks.afterResponse?.length && hooks.afterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let fn2 = hooks.afterResponse[i].fn, endUnit = reporter.resolveChild(fn2.name);
        afterResponse2 += `
${isAsyncName(fn2) ? "await " : ""}afterResponse[${i}](context)
`, endUnit();
      }
    return reporter.resolve(), afterResponse2 += `})
`, afterResponse2;
  };
  if (fnLiteral += `const set=context.set
let _r
if(!context.code)context.code=error.code??error[ERROR_CODE]
if(!(context.error instanceof Error))context.error=error
if(error instanceof ElysiaCustomStatusResponse){set.status=error.status=error.code
error.message=error.response}`, adapter2.declare)
    fnLiteral += adapter2.declare;
  let saveResponse = hasTrace || !!hooks.afterResponse?.length ? "context.response = " : "";
  if (app.event.error)
    for (let i = 0;i < app.event.error.length; i++) {
      let handler = app.event.error[i], response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)
`;
      if (fnLiteral += "if(skipGlobal!==true){", hasReturn(handler)) {
        fnLiteral += `_r=${response}
if(_r!==undefined){if(_r instanceof Response){` + afterResponse() + `return mapResponse(_r,set${adapter2.mapResponseContext})}if(_r instanceof ElysiaCustomStatusResponse){error.status=error.code
error.message = error.response}if(set.status===200||!set.status)set.status=error.status
`;
        let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
        if (hooks.mapResponse?.length)
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse3 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse3.fn.name);
            fnLiteral += `context.response=context.responseValue=_r_r=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i2}](context)
`, endUnit();
          }
        mapResponseReporter2.resolve(), fnLiteral += afterResponse() + `return mapResponse(${saveResponse}_r,set${adapter2.mapResponseContext})}`;
      } else
        fnLiteral += response;
      fnLiteral += "}";
    }
  fnLiteral += `if(error.constructor.name==="ValidationError"||error.constructor.name==="TransformDecodeError"){
if(error.error)error=error.error
set.status=error.status??422
` + afterResponse() + adapter2.validationError + `
}
`, fnLiteral += "if(error instanceof Error){" + afterResponse() + `
if(typeof error.toResponse==='function')return context.response=context.responseValue=error.toResponse()
` + adapter2.unknownError + `
}`;
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse?.length, name: "context" });
  if (fnLiteral += `
if(!context.response)context.response=context.responseValue=error.message??error
`, hooks.mapResponse?.length) {
    fnLiteral += `let mr
`;
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse3 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse3.fn.name);
      fnLiteral += `if(mr===undefined){mr=${isAsyncName(mapResponse3) ? "await " : ""}onMapResponse[${i}](context)
if(mr!==undefined)error=context.response=context.responseValue=mr}`, endUnit();
    }
  }
  mapResponseReporter.resolve(), fnLiteral += afterResponse() + `
return mapResponse(${saveResponse}error,set${adapter2.mapResponseContext})}`;
  let mapFn = (x) => typeof x === "function" ? x : x.fn;
  return Function("inject", `"use strict";
` + fnLiteral)({ mapResponse: app["~adapter"].handler.mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, onError: app.event.error?.map(mapFn), afterResponse: app.event.afterResponse?.map(mapFn), trace: app.event.trace?.map(mapFn), onMapResponse: app.event.mapResponse?.map(mapFn), ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, ...adapter2.inject });
};
var allocateIf2 = (value6, condition) => condition ? value6 : "";
var createContext = (app, route, inference, isInline = false) => {
  let fnLiteral = "", defaultHeaders = app.setHeaders, hasTrace = !!app.event.trace?.length;
  if (hasTrace)
    fnLiteral += `const id=randomId()
`;
  let isDynamic = /[:*]/.test(route.path), getQi = `const u=request.url,s=u.indexOf('/',${app.config.handler?.standardHostname ?? true ? 11 : 7}),qi=u.indexOf('?', s + 1)
`, needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x) => x.query) || app.event.request?.length;
  if (needsQuery)
    fnLiteral += getQi;
  let getPath = !inference.path ? "" : !isDynamic ? `path:'${route.path}',` : "get path(){" + (needsQuery ? "" : getQi) + `if(qi===-1)return u.substring(s)
return u.substring(s,qi)
},`;
  if (fnLiteral += allocateIf2("const c=", !isInline) + "{request,store," + allocateIf2("qi,", needsQuery) + allocateIf2("params:request.params,", isDynamic) + getPath + allocateIf2("url:request.url,", hasTrace || inference.url || needsQuery) + "redirect,status,set:{headers:" + (isNotEmpty(defaultHeaders) ? "Object.assign({},app.setHeaders)" : "Object.create(null)") + ",status:200}", inference.server)
    fnLiteral += ",get server(){return app.getServer()}";
  if (hasTrace)
    fnLiteral += ",[ELYSIA_REQUEST_ID]:id";
  {
    let decoratorsLiteral = "";
    for (let key of Object.keys(app.singleton.decorator))
      decoratorsLiteral += `,'${key}':decorator['${key}']`;
    fnLiteral += decoratorsLiteral;
  }
  return fnLiteral += `}
`, fnLiteral;
};
var createBunRouteHandler = (app, route) => {
  let hasTrace = !!app.event.trace?.length, hasHoc = !!app.extender.higherOrderFunctions.length, inference = sucrose(route.hooks, app.inference);
  inference = sucrose({ handler: route.handler }, inference);
  let fnLiteral = "const handler=data.handler,app=data.app,store=data.store,decorator=data.decorator,redirect=data.redirect,route=data.route,mapEarlyResponse=data.mapEarlyResponse," + allocateIf2("randomId=data.randomId,", hasTrace) + allocateIf2("ELYSIA_REQUEST_ID=data.ELYSIA_REQUEST_ID,", hasTrace) + allocateIf2("ELYSIA_TRACE=data.ELYSIA_TRACE,", hasTrace) + allocateIf2("trace=data.trace,", hasTrace) + allocateIf2("hoc=data.hoc,", hasHoc) + `status=data.status
`;
  if (app.event.request?.length)
    fnLiteral += `const onRequest=app.event.request.map(x=>x.fn)
`;
  fnLiteral += `${app.event.request?.find(isAsync) ? "async" : ""} function map(request){`;
  let needsQuery = inference.query || !!route.hooks.query || !!route.hooks.standaloneValidator?.find((x) => x.query);
  if (hasTrace || needsQuery || app.event.request?.length)
    fnLiteral += createContext(app, route, inference), fnLiteral += createOnRequestHandler(app), fnLiteral += "return handler(c)}";
  else
    fnLiteral += `return handler(${createContext(app, route, inference, true)})}`;
  return fnLiteral += createHoc(app), Function("data", fnLiteral)({ app, handler: route.compile?.() ?? route.composed, redirect, status: status2, hoc: app.extender.higherOrderFunctions.map((x) => x.fn), store: app.store, decorator: app.decorator, route: route.path, randomId: hasTrace ? randomId : undefined, ELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined, ELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined, trace: hasTrace ? app.event.trace?.map((x) => x?.fn ?? x) : undefined, mapEarlyResponse: mapEarlyResponse2 });
};
var createNativeStaticHandler = (handle, hooks, set22) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  if (isHTMLBundle(handle))
    return () => handle;
  let response = mapResponse2(handle, set22 ?? { headers: {} });
  if (!hooks.parse?.length && !hooks.transform?.length && !hooks.beforeHandle?.length && !hooks.afterHandle?.length) {
    if (response instanceof Promise)
      return response.then((response2) => {
        if (!response2)
          return;
        if (!response2.headers.has("content-type"))
          response2.headers.append("content-type", "text/plain");
        return response2.clone();
      });
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain");
    return () => response.clone();
  }
};
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  body;
  constructor(raw, data, body = undefined) {
    this.raw = raw;
    this.data = data;
    this.body = body;
    this.validator = raw.data?.validator, this.sendText = raw.sendText.bind(raw), this.sendBinary = raw.sendBinary.bind(raw), this.close = raw.close.bind(raw), this.terminate = raw.terminate.bind(raw), this.publishText = raw.publishText.bind(raw), this.publishBinary = raw.publishBinary.bind(raw), this.subscribe = raw.subscribe.bind(raw), this.unsubscribe = raw.unsubscribe.bind(raw), this.isSubscribed = raw.isSubscribed.bind(raw), this.cork = raw.cork.bind(raw), this.remoteAddress = raw.remoteAddress, this.binaryType = raw.binaryType, this.data = raw.data, this.send = this.send.bind(this), this.ping = this.ping.bind(this), this.pong = this.pong.bind(this), this.publish = this.publish.bind(this);
  }
  send(data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.send(data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.send(data, compress);
  }
  ping(data) {
    if (Buffer.isBuffer(data))
      return this.raw.ping(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.ping(data);
  }
  pong(data) {
    if (Buffer.isBuffer(data))
      return this.raw.pong(data);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.pong(data);
  }
  publish(topic, data, compress) {
    if (Buffer.isBuffer(data))
      return this.raw.publish(topic, data, compress);
    if (this.validator?.Check(data) === false)
      return this.raw.send(new ValidationError("message", this.validator, data).message);
    if (typeof data === "object")
      data = JSON.stringify(data);
    return this.raw.publish(topic, data, compress);
  }
  sendText;
  sendBinary;
  close;
  terminate;
  publishText;
  publishBinary;
  subscribe;
  unsubscribe;
  isSubscribed;
  cork;
  remoteAddress;
  binaryType;
  get readyState() {
    return this.raw.readyState;
  }
  validator;
  ["~types"];
  get id() {
    return this.data.id;
  }
}
var createWSMessageParser = (parse22) => {
  let parsers = typeof parse22 === "function" ? [parse22] : parse22;
  return async function(ws, message) {
    if (typeof message === "string") {
      let start5 = message?.charCodeAt(0);
      if (start5 === 34 || start5 === 47 || start5 === 91 || start5 === 123)
        try {
          message = JSON.parse(message);
        } catch {
        }
      else if (isNumericString(message))
        message = +message;
      else if (message === "true")
        message = true;
      else if (message === "false")
        message = false;
      else if (message === "null")
        message = null;
    }
    if (parsers)
      for (let i = 0;i < parsers.length; i++) {
        let temp = parsers[i](ws, message);
        if (temp instanceof Promise)
          temp = await temp;
        if (temp !== undefined)
          return temp;
      }
    return message;
  };
};
var createHandleWSResponse = (validateResponse) => {
  let handleWSResponse = (ws, data) => {
    if (data instanceof Promise)
      return data.then((data2) => handleWSResponse(ws, data2));
    if (Buffer.isBuffer(data))
      return ws.send(data.toString());
    if (data === undefined)
      return;
    let send = (datum) => {
      if (validateResponse?.Check(datum) === false)
        return ws.send(new ValidationError("message", validateResponse, datum).message);
      if (typeof datum === "object")
        return ws.send(JSON.stringify(datum));
      ws.send(datum);
    };
    if (typeof data?.next !== "function")
      return void send(data);
    let init = data.next();
    if (init instanceof Promise)
      return (async () => {
        let first4 = await init;
        if (validateResponse?.Check(first4) === false)
          return ws.send(new ValidationError("message", validateResponse, first4).message);
        if (send(first4.value), !first4.done)
          for await (let datum of data)
            send(datum);
      })();
    if (send(init.value), !init.done)
      for (let datum of data)
        send(datum);
  };
  return handleWSResponse;
};
var optionalParam = /:.+?\?(?=\/|$)/;
var getPossibleParams = (path) => {
  let match25 = optionalParam.exec(path);
  if (!match25)
    return [path];
  let routes = [], head8 = path.slice(0, match25.index), param = match25[0].slice(0, -1), tail = path.slice(match25.index + match25[0].length);
  routes.push(head8.slice(0, -1)), routes.push(head8 + param);
  for (let fragment of getPossibleParams(tail)) {
    if (!fragment)
      continue;
    if (!fragment.startsWith("/:"))
      routes.push(head8.slice(0, -1) + fragment);
    routes.push(head8 + param + fragment);
  }
  return routes;
};
var isHTMLBundle = (handle) => {
  return typeof handle === "object" && handle !== null && (handle.toString() === "[object HTMLBundle]" || typeof handle.index === "string");
};
var supportedMethods = { GET: true, HEAD: true, OPTIONS: true, DELETE: true, PATCH: true, POST: true, PUT: true };
var mapRoutes = (app) => {
  if (!app.config.aot || !app.config.systemRouter)
    return;
  let routes = {}, add8 = (route, handler) => {
    if (routes[route.path]) {
      if (!routes[route.path][route.method])
        routes[route.path][route.method] = handler;
    } else
      routes[route.path] = { [route.method]: handler };
  }, tree = app.routeTree;
  for (let route of app.router.history) {
    if (typeof route.handler !== "function")
      continue;
    let method = route.method;
    if (method === "GET" && `WS_${route.path}` in tree || method === "WS" || route.path.charCodeAt(route.path.length - 1) === 42 || !(method in supportedMethods))
      continue;
    if (method === "ALL") {
      if (!(`WS_${route.path}` in tree))
        routes[route.path] = route.hooks?.config?.mount ? route.hooks.trace || app.event.trace || app.extender.higherOrderFunctions ? createBunRouteHandler(app, route) : route.hooks.mount || route.handler : route.handler;
      continue;
    }
    let compiled, handler = app.config.precompile ? createBunRouteHandler(app, route) : (request2) => {
      if (compiled)
        return compiled(request2);
      return (compiled = createBunRouteHandler(app, route))(request2);
    };
    for (let path of getPossibleParams(route.path))
      add8({ method, path }, handler);
  }
  return routes;
};
var mergeRoutes = (r1, r2) => {
  if (!r2)
    return r1;
  for (let key of Object.keys(r2)) {
    if (r1[key] === r2[key])
      continue;
    if (!r1[key]) {
      r1[key] = r2[key];
      continue;
    }
    if (r1[key] && r2[key]) {
      if (typeof r1[key] === "function" || r1[key] instanceof Response) {
        r1[key] = r2[key];
        continue;
      }
      r1[key] = { ...r1[key], ...r2[key] };
    }
  }
  return r1;
};
var BunAdapter = { ...WebStandardAdapter, name: "bun", handler: { mapResponse: mapResponse2, mapEarlyResponse: mapEarlyResponse2, mapCompactResponse: mapCompactResponse2, createStaticHandler: createStaticHandler2, createNativeStaticHandler }, composeHandler: { ...WebStandardAdapter.composeHandler, headers: hasHeaderShorthand ? `c.headers=c.request.headers.toJSON()
` : `c.headers={}
for(const [k,v] of c.request.headers.entries())c.headers[k]=v
` }, listen(app) {
  return (options, callback) => {
    if (typeof Bun > "u")
      throw Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (app.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let createStaticRoute = (iterator, { withAsync = false } = {}) => {
      let staticRoutes = {}, ops = [];
      for (let [path, route] of Object.entries(iterator))
        if (supportPerMethodInlineHandler) {
          if (!route)
            continue;
          for (let [method, value6] of Object.entries(route)) {
            if (!value6 || !(method in supportedMethods))
              continue;
            if (value6 instanceof Promise) {
              if (withAsync) {
                if (!staticRoutes[path])
                  staticRoutes[path] = {};
                ops.push(value6.then((awaited) => {
                  if (awaited instanceof Response)
                    staticRoutes[path][method] = awaited;
                  if (isHTMLBundle(awaited))
                    staticRoutes[path][method] = awaited;
                }));
              }
              continue;
            }
            if (!(value6 instanceof Response) && !isHTMLBundle(value6))
              continue;
            if (!staticRoutes[path])
              staticRoutes[path] = {};
            staticRoutes[path][method] = value6;
          }
        } else {
          if (!route)
            continue;
          if (route instanceof Promise) {
            if (withAsync) {
              if (!staticRoutes[path])
                staticRoutes[path] = {};
              ops.push(route.then((awaited) => {
                if (awaited instanceof Response)
                  staticRoutes[path] = awaited;
              }));
            }
            continue;
          }
          if (!(route instanceof Response))
            continue;
          staticRoutes[path] = route;
        }
      if (withAsync)
        return Promise.all(ops).then(() => staticRoutes);
      return staticRoutes;
    }, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, ...options || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {}, ...options.websocket || {} }, fetch: app.fetch } : { development: !isProduction, reusePort: true, idleTimeout: 30, ...app.config.serve || {}, routes: mergeRoutes(mergeRoutes(createStaticRoute(app.router.response), mapRoutes(app)), app.config.serve?.routes), websocket: { ...app.config.websocket || {}, ...websocket || {} }, port: options, fetch: app.fetch };
    if (app.server = Bun.serve(serve), app.event.start)
      for (let i = 0;i < app.event.start.length; i++)
        app.event.start[i].fn(app);
    if (callback)
      callback(app.server);
    process.on("beforeExit", () => {
      if (app.server) {
        if (app.server.stop?.(), app.server = null, app.event.stop)
          for (let i = 0;i < app.event.stop.length; i++)
            app.event.stop[i].fn(app);
      }
    }), app.promisedModules.then(async () => {
      app.server?.reload({ ...serve, fetch: app.fetch, routes: mergeRoutes(mergeRoutes(await createStaticRoute(app.router.response, { withAsync: true }), mapRoutes(app)), app.config.serve?.routes) }), Bun?.gc(false);
    });
  };
}, async stop(app, closeActiveConnections) {
  if (app.server) {
    if (app.server.stop(closeActiveConnections), app.server = null, app.event.stop?.length)
      for (let i = 0;i < app.event.stop.length; i++)
        app.event.stop[i].fn(app);
  } else
    console.log("Elysia isn't running. Call `app.listen` to start the server.", Error().stack);
}, ws(app, path, options) {
  let { parse: parse22, body, response, ...rest } = options, validateMessage = getSchemaValidator(body, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize }), validateResponse = getSchemaValidator(response, { modules: app.definitions.typebox, models: app.definitions.type, normalize: app.config.normalize });
  app.route("WS", path, async (context9) => {
    let server = context9.server ?? app.server, { set: set22, path: path2, qi, headers, query, params } = context9;
    if (context9.validator = validateResponse, options.upgrade) {
      if (typeof options.upgrade === "function") {
        let temp = options.upgrade(context9);
        if (temp instanceof Promise)
          await temp;
      } else if (options.upgrade)
        Object.assign(set22.headers, options.upgrade);
    }
    if (set22.cookie && isNotEmpty(set22.cookie)) {
      let cookie = serializeCookie(set22.cookie);
      if (cookie)
        set22.headers["set-cookie"] = cookie;
    }
    if (set22.headers["set-cookie"] && Array.isArray(set22.headers["set-cookie"]))
      set22.headers = parseSetCookies(new Headers(set22.headers), set22.headers["set-cookie"]);
    let handleResponse3 = createHandleWSResponse(validateResponse), parseMessage = createWSMessageParser(parse22), _id;
    if (typeof options.beforeHandle === "function") {
      let result = options.beforeHandle(context9);
      if (result instanceof Promise)
        await result;
    }
    let errorHandlers = [...options.error ? Array.isArray(options.error) ? options.error : [options.error] : [], ...(app.event.error ?? []).map((x) => typeof x === "function" ? x : x.fn)].filter((x) => x), hasCustomErrorHandlers = errorHandlers.length > 0, handleErrors = !hasCustomErrorHandlers ? () => {
    } : async (ws, error2) => {
      for (let handleError of errorHandlers) {
        let response2 = handleError(Object.assign(context9, { error: error2 }));
        if (response2 instanceof Promise)
          response2 = await response2;
        if (await handleResponse3(ws, response2), response2)
          break;
      }
    };
    if (server?.upgrade(context9.request, { headers: isNotEmpty(set22.headers) ? set22.headers : undefined, data: { ...context9, get id() {
      if (_id)
        return _id;
      return _id = randomId();
    }, validator: validateResponse, ping(data) {
      options.ping?.(data);
    }, pong(data) {
      options.pong?.(data);
    }, open: async (ws) => {
      try {
        await handleResponse3(ws, options.open?.(new ElysiaWS(ws, context9)));
      } catch (error2) {
        handleErrors(ws, error2);
      }
    }, message: async (ws, _message) => {
      let message = await parseMessage(ws, _message);
      if (validateMessage?.Check(message) === false) {
        let validationError = new ValidationError("message", validateMessage, message);
        if (!hasCustomErrorHandlers)
          return void ws.send(validationError.message);
        return handleErrors(ws, validationError);
      }
      try {
        await handleResponse3(ws, options.message?.(new ElysiaWS(ws, context9, message), message));
      } catch (error2) {
        handleErrors(ws, error2);
      }
    }, drain: async (ws) => {
      try {
        await handleResponse3(ws, options.drain?.(new ElysiaWS(ws, context9)));
      } catch (error2) {
        handleErrors(ws, error2);
      }
    }, close: async (ws, code, reason) => {
      try {
        await handleResponse3(ws, options.close?.(new ElysiaWS(ws, context9), code, reason));
      } catch (error2) {
        handleErrors(ws, error2);
      }
    } } }))
      return;
    return set22.status = 400, "Expected a websocket connection";
  }, { ...rest, websocket: options });
} };
var env2 = isBun ? Bun.env : typeof process < "u" && process?.env ? process.env : {};
var injectDefaultValues = (typeChecker, obj) => {
  let schema = typeChecker.schema;
  if (!schema)
    return;
  if (schema.$defs?.[schema.$ref])
    schema = schema.$defs[schema.$ref];
  if (!schema?.properties)
    return;
  for (let [key, keySchema] of Object.entries(schema.properties))
    obj[key] ??= keySchema.default;
};
var createDynamicHandler = (app) => {
  let { mapResponse: mapResponse3, mapEarlyResponse: mapEarlyResponse3 } = app["~adapter"].handler, defaultHeader = app.setHeaders;
  return async (request2) => {
    let url2 = request2.url, s = url2.indexOf("/", 11), qi = url2.indexOf("?", s + 1), path = qi === -1 ? url2.substring(s) : url2.substring(s, qi), set22 = { cookie: {}, status: 200, headers: defaultHeader ? { ...defaultHeader } : {} }, context9 = Object.assign({}, app.singleton.decorator, { set: set22, store: app.singleton.store, request: request2, path, qi, error: status2, status: status2, redirect });
    try {
      if (app.event.request)
        for (let i = 0;i < app.event.request.length; i++) {
          let onRequest = app.event.request[i].fn, response2 = onRequest(context9);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 = mapEarlyResponse3(response2, set22), response2)
            return context9.response = response2;
        }
      let methodKey = request2.method === "GET" && request2.headers.get("upgrade")?.toLowerCase() === "websocket" ? "WS" : request2.method, handler = app.router.dynamic.find(request2.method, path) ?? app.router.dynamic.find(methodKey, path) ?? app.router.dynamic.find("ALL", path);
      if (!handler)
        throw context9.query = qi === -1 ? {} : parseQuery(url2.substring(qi + 1)), new NotFoundError;
      let { handle, hooks, validator, content, route } = handler.store, body;
      if (request2.method !== "GET" && request2.method !== "HEAD")
        if (content)
          switch (content) {
            case "application/json":
              body = await request2.json();
              break;
            case "text/plain":
              body = await request2.text();
              break;
            case "application/x-www-form-urlencoded":
              body = parseQuery(await request2.text());
              break;
            case "application/octet-stream":
              body = await request2.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              let form2 = await request2.formData();
              for (let key of form2.keys()) {
                if (body[key])
                  continue;
                let value6 = form2.getAll(key);
                if (value6.length === 1)
                  body[key] = value6[0];
                else
                  body[key] = value6;
              }
              break;
          }
        else {
          let contentType;
          if (request2.body)
            contentType = request2.headers.get("content-type");
          if (contentType) {
            let index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            if (context9.contentType = contentType, hooks.parse)
              for (let i = 0;i < hooks.parse.length; i++) {
                let hook = hooks.parse[i].fn;
                if (typeof hook === "string")
                  switch (hook) {
                    case "json":
                    case "application/json":
                      body = await request2.json();
                      break;
                    case "text":
                    case "text/plain":
                      body = await request2.text();
                      break;
                    case "urlencoded":
                    case "application/x-www-form-urlencoded":
                      body = parseQuery(await request2.text());
                      break;
                    case "arrayBuffer":
                    case "application/octet-stream":
                      body = await request2.arrayBuffer();
                      break;
                    case "formdata":
                    case "multipart/form-data":
                      body = {};
                      let form2 = await request2.formData();
                      for (let key of form2.keys()) {
                        if (body[key])
                          continue;
                        let value6 = form2.getAll(key);
                        if (value6.length === 1)
                          body[key] = value6[0];
                        else
                          body[key] = value6;
                      }
                      break;
                    default:
                      let parser = app["~parser"][hook];
                      if (parser) {
                        let temp = parser(context9, contentType);
                        if (temp instanceof Promise)
                          temp = await temp;
                        if (temp) {
                          body = temp;
                          break;
                        }
                      }
                      break;
                  }
                else {
                  let temp = hook(context9, contentType);
                  if (temp instanceof Promise)
                    temp = await temp;
                  if (temp) {
                    body = temp;
                    break;
                  }
                }
              }
            if (delete context9.contentType, body === undefined)
              switch (contentType) {
                case "application/json":
                  body = await request2.json();
                  break;
                case "text/plain":
                  body = await request2.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = parseQuery(await request2.text());
                  break;
                case "application/octet-stream":
                  body = await request2.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  let form2 = await request2.formData();
                  for (let key of form2.keys()) {
                    if (body[key])
                      continue;
                    let value6 = form2.getAll(key);
                    if (value6.length === 1)
                      body[key] = value6[0];
                    else
                      body[key] = value6;
                  }
                  break;
              }
          }
        }
      context9.route = route, context9.body = body, context9.params = handler?.params || undefined, context9.query = qi === -1 ? {} : parseQuery(url2.substring(qi + 1)), context9.headers = {};
      for (let [key, value6] of request2.headers.entries())
        context9.headers[key] = value6;
      let cookieMeta = { domain: app.config.cookie?.domain ?? validator?.cookie?.config.domain, expires: app.config.cookie?.expires ?? validator?.cookie?.config.expires, httpOnly: app.config.cookie?.httpOnly ?? validator?.cookie?.config.httpOnly, maxAge: app.config.cookie?.maxAge ?? validator?.cookie?.config.maxAge, path: app.config.cookie?.path ?? validator?.cookie?.config.path, priority: app.config.cookie?.priority ?? validator?.cookie?.config.priority, partitioned: app.config.cookie?.partitioned ?? validator?.cookie?.config.partitioned, sameSite: app.config.cookie?.sameSite ?? validator?.cookie?.config.sameSite, secure: app.config.cookie?.secure ?? validator?.cookie?.config.secure, secrets: app.config.cookie?.secrets ?? validator?.cookie?.config.secrets, sign: app.config.cookie?.sign ?? validator?.cookie?.config.sign }, cookieHeaderValue = request2.headers.get("cookie");
      context9.cookie = await parseCookie(context9.set, cookieHeaderValue, cookieMeta);
      let headerValidator = validator?.createHeaders?.();
      if (headerValidator)
        injectDefaultValues(headerValidator, context9.headers);
      let paramsValidator = validator?.createParams?.();
      if (paramsValidator)
        injectDefaultValues(paramsValidator, context9.params);
      let queryValidator = validator?.createQuery?.();
      if (queryValidator)
        injectDefaultValues(queryValidator, context9.query);
      if (hooks.transform)
        for (let i = 0;i < hooks.transform.length; i++) {
          let hook = hooks.transform[i], response2 = hook.fn(context9);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context9.set);
            if (result)
              return context9.response = result;
          }
          if (hook.subType === "derive")
            Object.assign(context9, response2);
        }
      if (validator) {
        if (headerValidator) {
          let _header = structuredClone(context9.headers);
          for (let [key, value6] of request2.headers)
            _header[key] = value6;
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        } else if (validator.headers?.Decode)
          context9.headers = validator.headers.Decode(context9.headers);
        if (paramsValidator?.Check(context9.params) === false)
          throw new ValidationError("params", validator.params, context9.params);
        else if (validator.params?.Decode)
          context9.params = validator.params.Decode(context9.params);
        if (validator.query?.schema) {
          let schema = validator.query.schema;
          if (schema.$defs?.[schema.$ref])
            schema = schema.$defs[schema.$ref];
          let properties = schema.properties;
          for (let property of Object.keys(properties)) {
            let value6 = properties[property];
            if ((value6.type === "array" || value6.items?.type === "string") && typeof context9.query[property] === "string" && context9.query[property])
              context9.query[property] = context9.query[property].split(",");
          }
        }
        if (queryValidator?.Check(context9.query) === false)
          throw new ValidationError("query", validator.query, context9.query);
        else if (validator.query?.Decode)
          context9.query = validator.query.Decode(context9.query);
        if (validator.createCookie?.()) {
          let cookieValue = {};
          for (let [key, value6] of Object.entries(context9.cookie))
            cookieValue[key] = value6.value;
          if (validator.cookie.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
          else if (validator.cookie?.Decode)
            cookieValue = validator.cookie.Decode(cookieValue);
        }
        if (validator.createBody?.()?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
        else if (validator.body?.Decode)
          context9.body = validator.body.Decode(body);
      }
      if (hooks.beforeHandle)
        for (let i = 0;i < hooks.beforeHandle.length; i++) {
          let hook = hooks.beforeHandle[i], response2 = hook.fn(context9);
          if (response2 instanceof Promise)
            response2 = await response2;
          if (response2 instanceof ElysiaCustomStatusResponse) {
            let result = mapEarlyResponse3(response2, context9.set);
            if (result)
              return context9.response = result;
          }
          if (hook.subType === "resolve") {
            Object.assign(context9, response2);
            continue;
          }
          if (response2 !== undefined) {
            if (context9.response = response2, hooks.afterHandle)
              for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
                let newResponse = hooks.afterHandle[i2].fn(context9);
                if (newResponse instanceof Promise)
                  newResponse = await newResponse;
                if (newResponse)
                  response2 = newResponse;
              }
            let result = mapEarlyResponse3(response2, context9.set);
            if (result)
              return context9.response = result;
          }
        }
      let response = typeof handle === "function" ? handle(context9) : handle;
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle?.length) {
        let isCustomStatuResponse = response instanceof ElysiaCustomStatusResponse, status22 = isCustomStatuResponse ? response.code : set22.status ? typeof set22.status === "string" ? StatusMap[set22.status] : set22.status : 200;
        if (isCustomStatuResponse)
          set22.status = status22, response = response.response;
        let responseValidator = validator?.createResponse?.()?.[status22];
        if (responseValidator?.Check(response) === false)
          if (responseValidator?.Clean) {
            let temp = responseValidator.Clean(response);
            if (responseValidator?.Check(temp) === false)
              throw new ValidationError("response", responseValidator, response);
            response = temp;
          } else
            throw new ValidationError("response", responseValidator, response);
        if (responseValidator?.Encode)
          response = responseValidator.Encode(response);
        if (responseValidator?.Clean)
          response = responseValidator.Clean(response);
      } else {
        context9.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let response2 = hooks.afterHandle[i].fn(context9);
          if (response2 instanceof Promise)
            response2 = await response2;
          let isCustomStatuResponse = response2 instanceof ElysiaCustomStatusResponse, status22 = isCustomStatuResponse ? response2.code : set22.status ? typeof set22.status === "string" ? StatusMap[set22.status] : set22.status : 200;
          if (isCustomStatuResponse)
            set22.status = status22, response2 = response2.response;
          let responseValidator = validator?.createResponse?.()?.[status22];
          if (responseValidator?.Check(response2) === false)
            if (responseValidator?.Clean) {
              let temp = responseValidator.Clean(response2);
              if (responseValidator?.Check(temp) === false)
                throw new ValidationError("response", responseValidator, response2);
              response2 = temp;
            } else
              throw new ValidationError("response", responseValidator, response2);
          if (responseValidator?.Encode)
            context9.response = response2 = responseValidator.Encode(response2);
          if (responseValidator?.Clean)
            context9.response = response2 = responseValidator.Clean(response2);
          let result = mapEarlyResponse3(response2, context9.set);
          if (result !== undefined)
            return context9.response = result;
        }
      }
      if (context9.set.cookie && cookieMeta?.sign) {
        let secret2 = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true) {
          if (secret2)
            for (let [key, cookie] of Object.entries(context9.set.cookie))
              context9.set.cookie[key].value = await signCookie(cookie.value, secret2);
        } else {
          let properties = validator?.cookie?.schema?.properties;
          if (secret2)
            for (let name of cookieMeta.sign) {
              if (!(name in properties))
                continue;
              if (context9.set.cookie[name]?.value)
                context9.set.cookie[name].value = await signCookie(context9.set.cookie[name].value, secret2);
            }
        }
      }
      return mapResponse3(context9.response = response, context9.set);
    } catch (error2) {
      let reportedError = error2 instanceof TransformDecodeError && error2.error ? error2.error : error2;
      return app.handleError(context9, reportedError);
    } finally {
      if (app.event.afterResponse)
        setImmediate(async () => {
          for (let afterResponse of app.event.afterResponse)
            await afterResponse.fn(context9);
        });
    }
  };
};
var createDynamicErrorHandler = (app) => {
  let { mapResponse: mapResponse3 } = app["~adapter"].handler;
  return async (context9, error2) => {
    let errorContext = Object.assign(context9, { error: error2, code: error2.code });
    if (errorContext.set = context9.set, app.event.error)
      for (let i = 0;i < app.event.error.length; i++) {
        let response = app.event.error[i].fn(errorContext);
        if (response instanceof Promise)
          response = await response;
        if (response !== undefined && response !== null)
          return context9.response = mapResponse3(response, context9.set);
      }
    return new Response(typeof error2.cause === "string" ? error2.cause : error2.message, { headers: context9.set.headers, status: error2.status ?? 500 });
  };
};

class Elysia {
  config;
  server = null;
  dependencies = {};
  "~Prefix" = "";
  "~Singleton" = null;
  "~Definitions" = null;
  "~Metadata" = null;
  "~Ephemeral" = null;
  "~Volatile" = null;
  "~Routes" = null;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  definitions = { typebox: t.Module({}), type: {}, error: {} };
  extender = { macro: {}, higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    if (!this.global && !this.scoped && !this.local)
      return { body: undefined, headers: undefined, params: undefined, query: undefined, cookie: undefined, response: undefined };
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  standaloneValidator = { global: null, scoped: null, local: null };
  event = {};
  telemetry;
  router = { "~http": undefined, get http() {
    if (!this["~http"])
      this["~http"] = new _({ lazy: true, onParam: import_fast_decode_uri_component4.default });
    return this["~http"];
  }, "~dynamic": undefined, get dynamic() {
    if (!this["~dynamic"])
      this["~dynamic"] = new _({ onParam: import_fast_decode_uri_component4.default });
    return this["~dynamic"];
  }, static: {}, response: {}, history: [] };
  routeTree = {};
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  getGlobalDefinitions() {
    return this.definitions;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false, path: false, route: false, url: false };
  getServer() {
    return this.server;
  }
  getParent() {
    return null;
  }
  "~parser" = {};
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup(console.error, () => {
      });
    return this._promisedModules;
  }
  constructor(config2 = {}) {
    if (config2.tags)
      if (!config2.detail)
        config2.detail = { tags: config2.tags };
      else
        config2.detail.tags = config2.tags;
    if (this.config = { aot: env2.ELYSIA_AOT !== "false", nativeStaticResponse: true, systemRouter: true, encodeSchema: true, normalize: true, ...config2, prefix: config2.prefix ? config2.prefix.charCodeAt(0) === 47 ? config2.prefix : `/${config2.prefix}` : undefined, cookie: { path: "/", ...config2?.cookie }, experimental: config2?.experimental ?? {}, seed: config2?.seed === undefined ? "" : config2?.seed }, this["~adapter"] = config2.adapter ?? (typeof Bun < "u" ? BunAdapter : WebStandardAdapter), config2?.analytic && (config2?.name || config2?.seed !== undefined))
      this.telemetry = { stack: Error().stack };
  }
  "~adapter";
  env(model, _env = env2) {
    if (getSchemaValidator(model, { modules: this.definitions.typebox, dynamic: true, additionalProperties: true, coerce: true, sanitize: () => this.config.sanitize }).Check(_env) === false) {
      let error2 = new ValidationError("env", model, _env);
      throw Error(error2.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn2) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn2.toString() })), fn: fn2 }), this;
  }
  get models() {
    let models = {};
    for (let name of Object.keys(this.definitions.type))
      models[name] = getSchemaValidator(this.definitions.typebox.Import(name));
    return models.modules = this.definitions.typebox, models;
  }
  add(method, path, handle, localHook, options) {
    let skipPrefix = options?.skipPrefix ?? false, allowMeta = options?.allowMeta ?? false;
    localHook ??= {}, this.applyMacro(localHook);
    let standaloneValidators = [];
    if (localHook.standaloneValidator)
      standaloneValidators = standaloneValidators.concat(localHook.standaloneValidator);
    if (this.standaloneValidator.local)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.local);
    if (this.standaloneValidator.scoped)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.scoped);
    if (this.standaloneValidator.global)
      standaloneValidators = standaloneValidators.concat(this.standaloneValidator.global);
    if (path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let instanceValidator = this.validator.getCandidate(), cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, createValidator = () => {
      let models = this.definitions.type, dynamic = !this.config.aot, normalize2 = this.config.normalize, modules = this.definitions.typebox, sanitize2 = () => this.config.sanitize, cookieValidator = () => {
        if (cloned.cookie || standaloneValidators.find((x) => x.cookie))
          return getCookieValidator({ modules, validator: cloned.cookie, defaultConfig: this.config.cookie, normalize: normalize2, config: cloned.cookie?.config ?? {}, dynamic, models, validators: standaloneValidators.map((x) => x.cookie), sanitize: sanitize2 });
      };
      return shouldPrecompile ? { body: getSchemaValidator(cloned.body, { modules, dynamic, models, normalize: normalize2, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x) => x.body), sanitize: sanitize2 }), headers: getSchemaValidator(cloned.headers, { modules, dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.headers), sanitize: sanitize2 }), params: getSchemaValidator(cloned.params, { modules, dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.params), sanitize: sanitize2 }), query: getSchemaValidator(cloned.query, { modules, dynamic, models, normalize: normalize2, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x) => x.query), sanitize: sanitize2 }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize: normalize2, validators: standaloneValidators.map((x) => x.response), sanitize: sanitize2 }) } : { createBody() {
        if (this.body)
          return this.body;
        return this.body = getSchemaValidator(cloned.body, { modules, dynamic, models, normalize: normalize2, additionalCoerce: coercePrimitiveRoot(), validators: standaloneValidators.map((x) => x.body), sanitize: sanitize2 });
      }, createHeaders() {
        if (this.headers)
          return this.headers;
        return this.headers = getSchemaValidator(cloned.headers, { modules, dynamic, models, normalize: normalize2, additionalProperties: !normalize2, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.headers), sanitize: sanitize2 });
      }, createParams() {
        if (this.params)
          return this.params;
        return this.params = getSchemaValidator(cloned.params, { modules, dynamic, models, normalize: normalize2, coerce: true, additionalCoerce: stringToStructureCoercions(), validators: standaloneValidators.map((x) => x.params), sanitize: sanitize2 });
      }, createQuery() {
        if (this.query)
          return this.query;
        return this.query = getSchemaValidator(cloned.query, { modules, dynamic, models, normalize: normalize2, coerce: true, additionalCoerce: queryCoercions(), validators: standaloneValidators.map((x) => x.query), sanitize: sanitize2 });
      }, createCookie() {
        if (this.cookie)
          return this.cookie;
        return this.cookie = cookieValidator();
      }, createResponse() {
        if (this.response)
          return this.response;
        return this.response = getResponseSchemaValidator(cloned.response, { modules, dynamic, models, normalize: normalize2, validators: standaloneValidators.map((x) => x.response), sanitize: sanitize2 });
      } };
    };
    if (instanceValidator.body || instanceValidator.cookie || instanceValidator.headers || instanceValidator.params || instanceValidator.query || instanceValidator.response)
      localHook = mergeHook(localHook, instanceValidator);
    if (localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    let hooks = isNotEmpty(this.event) ? mergeHook(this.event, localHookToLifeCycleStore(localHook)) : { ...lifeCycleToArray(localHookToLifeCycleStore(localHook)) };
    if (standaloneValidators.length)
      Object.assign(hooks, { standaloneValidator: standaloneValidators });
    if (this.config.aot === false) {
      let validator = createValidator();
      this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle, route: path });
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.dynamic.add(method, encoded, { validator, hooks, content: localHook?.type, handle, route: path });
      if (this.config.strictPath === false) {
        let loosePath = getLoosePath(path);
        this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
        let encoded2 = encodePath(loosePath);
        if (loosePath !== encoded2)
          this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle, route: path });
      }
      this.router.history.push({ method, path, composed: null, handler: handle, compile: undefined, hooks });
      return;
    }
    let adapter2 = this["~adapter"].handler, nativeStaticHandler = typeof handle !== "function" ? () => {
      let context9 = { redirect, request: this["~adapter"].isWebStandard ? new Request(`http://e.ly${path}`, { method }) : undefined, server: null, set: { headers: Object.assign({}, this.setHeaders) }, status: status2, store: this.store };
      try {
        this.event.request?.map((x) => {
          if (typeof x.fn === "function")
            return x.fn(context9);
          if (typeof x === "function")
            return x(context9);
        });
      } catch (error2) {
        let res;
        if (context9.error = error2, this.event.error?.some((x) => {
          if (typeof x.fn === "function")
            return res = x.fn(context9);
          if (typeof x === "function")
            return res = x(context9);
        }), res !== undefined)
          handle = res;
      }
      let fn2 = adapter2.createNativeStaticHandler?.(handle, hooks, context9.set);
      return fn2 instanceof Promise ? fn2.then((fn22) => {
        if (fn22)
          return fn22;
      }) : fn2?.();
    } : undefined, useNativeStaticResponse = this.config.nativeStaticResponse === true, addResponsePath = (path2) => {
      if (!useNativeStaticResponse || !nativeStaticHandler)
        return;
      if (supportPerMethodInlineHandler)
        if (this.router.response[path2])
          this.router.response[path2][method] = nativeStaticHandler();
        else
          this.router.response[path2] = { [method]: nativeStaticHandler() };
      else
        this.router.response[path2] = nativeStaticHandler();
    };
    addResponsePath(path);
    let _compiled, compile2 = () => {
      if (_compiled)
        return _compiled;
      return _compiled = composeHandler({ app: this, path, method, hooks, validator: createValidator(), handler: typeof handle !== "function" && typeof adapter2.createStaticHandler !== "function" ? () => handle : handle, allowMeta, inference: this.inference });
    }, oldIndex;
    if (`${method}_${path}` in this.routeTree)
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          oldIndex = i;
          break;
        }
      }
    else
      this.routeTree[`${method}_${path}`] = this.router.history.length;
    let index = oldIndex ?? this.router.history.length, mainHandler = shouldPrecompile ? compile2() : (ctx) => (this.router.history[index].composed = compile2())(ctx);
    if (oldIndex !== undefined)
      this.router.history[oldIndex] = Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, standaloneValidators.length ? { standaloneValidators } : undefined, localHook.webSocket ? { websocket: localHook.websocket } : undefined);
    else
      this.router.history.push(Object.assign({ method, path, composed: mainHandler, compile: compile2, handler: handle, hooks }, localHook.webSocket ? { websocket: localHook.websocket } : undefined));
    let handler = { handler: shouldPrecompile ? mainHandler : undefined, compile() {
      return this.handler = compile2();
    } }, staticRouter = this.router.static, isStaticPath = path.indexOf(":") === -1 && path.indexOf("*") === -1;
    if (method === "WS") {
      if (isStaticPath) {
        if (path in staticRouter)
          staticRouter[path][method] = index;
        else
          staticRouter[path] = { [method]: index };
        return;
      }
      if (this.router.http.add("WS", path, handler), !this.config.strictPath)
        this.router.http.add("WS", getLoosePath(path), handler);
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add("WS", encoded, handler);
      return;
    }
    if (isStaticPath) {
      if (path in staticRouter)
        staticRouter[path][method] = index;
      else
        staticRouter[path] = { [method]: index };
      if (!this.config.strictPath)
        addResponsePath(getLoosePath(path));
    } else {
      if (this.router.http.add(method, path, handler), !this.config.strictPath) {
        let loosePath = getLoosePath(path);
        addResponsePath(loosePath), this.router.http.add(method, loosePath, handler);
      }
      let encoded = encodePath(path, { dynamic: true });
      if (path !== encoded)
        this.router.http.add(method, encoded, handler), addResponsePath(encoded);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler) {
      if (typeof options === "string")
        return this.on("parse", this["~parser"][options]);
      return this.on("parse", options);
    }
    return this.on(options, "parse", handler);
  }
  parser(name, parser) {
    return this["~parser"][name] = parser, this;
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn2 of handler)
      this.on(options, "trace", createTracer(fn2));
    return this;
  }
  error(name, error2) {
    switch (typeof name) {
      case "string":
        return error2.prototype[ERROR_CODE] = name, this.definitions.error[name] = error2, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error22] of Object.entries(name))
      error22.prototype[ERROR_CODE] = code, this.definitions.error[code] = error22;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type2;
    switch (typeof optionsOrType) {
      case "string":
        type2 = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type2 = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      if (handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local", type2 === "resolve" || type2 === "derive")
        handle.subType = type2;
    if (type2 !== "trace")
      this.inference = sucrose({ [type2]: handles.map((x) => x.fn) }, this.inference);
    for (let handle of handles) {
      let fn2 = asHookType(handle, "global", { skipIfHasType: true });
      switch (type2) {
        case "start":
          this.event.start ??= [], this.event.start.push(fn2);
          break;
        case "request":
          this.event.request ??= [], this.event.request.push(fn2);
          break;
        case "parse":
          this.event.parse ??= [], this.event.parse.push(fn2);
          break;
        case "transform":
          this.event.transform ??= [], this.event.transform.push(fn2);
          break;
        case "derive":
          this.event.transform ??= [], this.event.transform.push(fnToContainer(fn2, "derive"));
          break;
        case "beforeHandle":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fn2);
          break;
        case "resolve":
          this.event.beforeHandle ??= [], this.event.beforeHandle.push(fnToContainer(fn2, "resolve"));
          break;
        case "afterHandle":
          this.event.afterHandle ??= [], this.event.afterHandle.push(fn2);
          break;
        case "mapResponse":
          this.event.mapResponse ??= [], this.event.mapResponse.push(fn2);
          break;
        case "afterResponse":
          this.event.afterResponse ??= [], this.event.afterResponse.push(fn2);
          break;
        case "trace":
          this.event.trace ??= [], this.event.trace.push(fn2);
          break;
        case "error":
          this.event.error ??= [], this.event.error.push(fn2);
          break;
        case "stop":
          this.event.stop ??= [], this.event.stop.push(fn2);
          break;
      }
    }
    return this;
  }
  as(type2) {
    if (promoteEvent(this.event.parse, type2), promoteEvent(this.event.transform, type2), promoteEvent(this.event.beforeHandle, type2), promoteEvent(this.event.afterHandle, type2), promoteEvent(this.event.mapResponse, type2), promoteEvent(this.event.afterResponse, type2), promoteEvent(this.event.trace, type2), promoteEvent(this.event.error, type2), type2 === "scoped") {
      if (this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
    } else if (type2 === "global") {
      if (this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null, this.standaloneValidator.local !== null)
        this.standaloneValidator.scoped ||= [], this.standaloneValidator.scoped.push(...this.standaloneValidator.local), this.standaloneValidator.local = null;
      if (this.standaloneValidator.scoped !== null)
        this.standaloneValidator.global ||= [], this.standaloneValidator.global.push(...this.standaloneValidator.scoped), this.standaloneValidator.scoped = null;
    }
    return this;
  }
  group(prefix, schemaOrRun, run4) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance["~parser"] = this["~parser"], instance.standaloneValidator = { local: [...this.standaloneValidator.local ?? []], scoped: [...this.standaloneValidator.scoped ?? []], global: [...this.standaloneValidator.global ?? []] };
    let isSchema = typeof schemaOrRun === "object", sandbox3 = (isSchema ? run4 : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox3.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox3.event.request || []];
    if (sandbox3.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox3.event.mapResponse || []];
    return this.model(sandbox3.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix ?? "") + prefix + path, isSchema) {
        let { body, headers, query, params, cookie, response, ...hook } = schemaOrRun, localHook = hooks, hasStandaloneSchema = body || headers || query || params || cookie || response;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox3.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox3.event.error ?? []] : [localHook.error, ...sandbox3.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }), undefined);
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox3.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run4) {
    if (!run4) {
      if (typeof hook === "object") {
        if (this.applyMacro(hook), hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        let type2 = hook.as ?? "local";
        if (hook.schema === "standalone") {
          if (!this.standaloneValidator[type2])
            this.standaloneValidator[type2] = [];
          let response = !hook?.response ? undefined : typeof hook.response === "string" || (Kind in hook.response) || ("~standard" in hook.response) ? { 200: hook.response } : hook?.response;
          this.standaloneValidator[type2].push({ body: hook.body, headers: hook.headers, params: hook.params, query: hook.query, response, cookie: hook.cookie });
        } else
          this.validator[type2] = { body: hook.body ?? this.validator[type2]?.body, headers: hook.headers ?? this.validator[type2]?.headers, params: hook.params ?? this.validator[type2]?.params, query: hook.query ?? this.validator[type2]?.query, response: hook.response ?? this.validator[type2]?.response, cookie: hook.cookie ?? this.validator[type2]?.cookie };
        if (hook.parse)
          this.on({ as: type2 }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type2 }, "transform", hook.transform);
        if (hook.derive)
          this.on({ as: type2 }, "derive", hook.derive);
        if (hook.beforeHandle)
          this.on({ as: type2 }, "beforeHandle", hook.beforeHandle);
        if (hook.resolve)
          this.on({ as: type2 }, "resolve", hook.resolve);
        if (hook.afterHandle)
          this.on({ as: type2 }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type2 }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type2 }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type2 }, "error", hook.error);
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender }, instance.getServer = () => this.getServer();
    let sandbox3 = run4(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox3.getServer = () => this.server, sandbox3.event.request?.length)
      this.event.request = [...this.event.request || [], ...sandbox3.event.request || []];
    if (sandbox3.event.mapResponse?.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox3.event.mapResponse || []];
    return this.model(sandbox3.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      let { body, headers, query, params, cookie, response, ...guardHook } = hook, hasStandaloneSchema = body || headers || query || params || cookie || response;
      this.add(method, path, handler, mergeHook(guardHook, { ...localHook || {}, error: !localHook.error ? sandbox3.event.error : Array.isArray(localHook.error) ? [...localHook.error ?? [], ...sandbox3.event.error ?? []] : [localHook.error, ...sandbox3.event.error ?? []], standaloneValidator: !hasStandaloneSchema ? localHook.standaloneValidator : [...localHook.standaloneValidator ?? [], { body, headers, query, params, cookie, response }] }));
    }), this;
  }
  use(plugin) {
    if (!plugin)
      return this;
    if (Array.isArray(plugin)) {
      let app = this;
      for (let p of plugin)
        app = app.use(p);
      return app;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "Elysia")
          return this._use(plugin2.default);
        if (plugin2.constructor?.name === "_Elysia")
          return this._use(plugin2.default);
        try {
          return this._use(plugin2.default);
        } catch (error2) {
          throw console.error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.'), error2;
        }
      }).then((v) => {
        if (v && typeof v.compile === "function")
          v.compile();
        return v;
      })), this;
    return this._use(plugin);
  }
  propagatePromiseModules(plugin) {
    if (plugin.promisedModules.size <= 0)
      return this;
    for (let promise3 of plugin.promisedModules.promises)
      this.promisedModules.add(promise3.then((v) => {
        if (!v)
          return;
        let t2 = this._use(v);
        if (t2 instanceof Promise)
          return t2.then((v2) => {
            if (v2)
              v2.compile();
            else
              v.compile();
          });
        return v.compile();
      }));
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, hooks, undefined);
            if (plugin2 === this)
              return;
            return this.propagatePromiseModules(plugin2), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((v) => {
          if (v && typeof v.compile === "function")
            v.compile();
          return v;
        })), this;
      return instance;
    }
    this.propagatePromiseModules(plugin);
    let name = plugin.config.name, seed = plugin.config.seed;
    if (plugin.getParent = () => this, plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.getGlobalDefinitions = () => this.getGlobalDefinitions(), plugin.standaloneValidator?.scoped)
      if (this.standaloneValidator.local)
        this.standaloneValidator.local = this.standaloneValidator.local.concat(plugin.standaloneValidator.scoped);
      else
        this.standaloneValidator.local = plugin.standaloneValidator.scoped;
    if (plugin.standaloneValidator?.global)
      if (this.standaloneValidator.global)
        this.standaloneValidator.global = this.standaloneValidator.global.concat(plugin.standaloneValidator.global);
      else
        this.standaloneValidator.global = plugin.standaloneValidator.global;
    if (isNotEmpty(plugin["~parser"]))
      this["~parser"] = { ...plugin["~parser"], ...this["~parser"] };
    if (plugin.setHeaders)
      this.headers(plugin.setHeaders);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current2 = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (!this.dependencies[name].some(({ checksum: checksum2 }) => current2 === checksum2))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro }, this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    } else {
      if (isNotEmpty(plugin.extender.macro))
        this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
      if (plugin.extender.higherOrderFunctions.length)
        this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
    }
    if (plugin.extender.higherOrderFunctions.length) {
      deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
        let hof = this.extender.higherOrderFunctions[i];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum))
            this.extender.higherOrderFunctions.splice(i, 1), i--;
          hofHashes.push(hof.checksum);
        }
      }
      hofHashes.length = 0;
    }
    if (this.inference = mergeInference(this.inference, plugin.inference), isNotEmpty(plugin.singleton.decorator))
      this.decorate(plugin.singleton.decorator);
    if (isNotEmpty(plugin.singleton.store))
      this.state(plugin.singleton.store);
    if (isNotEmpty(plugin.definitions.type))
      this.model(plugin.definitions.type);
    if (isNotEmpty(plugin.definitions.error))
      this.error(plugin.definitions.error);
    if (isNotEmpty(plugin.extender.macro))
      this.extender.macro = { ...this.extender.macro, ...plugin.extender.macro };
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, hooks);
    if (name) {
      if (!(name in this.dependencies))
        this.dependencies[name] = [];
      let current2 = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
      if (this.dependencies[name].some(({ checksum: checksum2 }) => current2 === checksum2))
        return this;
      if (this.dependencies[name].push(this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current2, dependencies: plugin.dependencies, stack: plugin.telemetry?.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, error: plugin.definitions.error, derive: plugin.event.transform?.filter((x) => x?.subType === "derive").map((x) => ({ fn: x.toString(), stack: Error().stack ?? "" })), resolve: plugin.event.transform?.filter((x) => x?.subType === "resolve").map((x) => ({ fn: x.toString(), stack: Error().stack ?? "" })) } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current2, dependencies: plugin.dependencies }), isNotEmpty(plugin.event))
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current2);
    } else if (isNotEmpty(plugin.event))
      this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    if (plugin.validator.global)
      this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global });
    if (plugin.validator.scoped)
      this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped });
    return this;
  }
  macro(macroOrName, macro) {
    if (typeof macroOrName === "string" && !macro)
      throw Error("Macro function is required");
    if (typeof macroOrName === "string")
      this.extender.macro[macroOrName] = macro;
    else
      this.extender.macro = { ...this.extender.macro, ...macroOrName };
    return this;
  }
  applyMacro(localHook, appliable = localHook, { iteration = 0, applied = {} } = {}) {
    if (iteration >= 16)
      return;
    let macro = this.extender.macro;
    for (let [key, value6] of Object.entries(appliable)) {
      if (key in macro === false)
        continue;
      let macroHook = typeof macro[key] === "function" ? macro[key](value6) : macro[key];
      if (!macroHook || typeof macro[key] === "object" && value6 === false)
        return;
      let seed = checksum(key + JSON.stringify(macroHook.seed ?? value6));
      if (seed in applied)
        continue;
      applied[seed] = true;
      for (let [k2, value22] of Object.entries(macroHook)) {
        if (k2 === "seed")
          continue;
        if (k2 in emptySchema) {
          insertStandaloneValidator(localHook, k2, value22), delete localHook[key];
          continue;
        }
        if (k2 === "detail") {
          if (!localHook.detail)
            localHook.detail = {};
          localHook.detail = mergeDeep(localHook.detail, value22, { mergeArray: true }), delete localHook[key];
          continue;
        }
        if (k2 in macro) {
          this.applyMacro(localHook, { [k2]: value22 }, { applied, iteration: iteration + 1 }), delete localHook[key];
          continue;
        }
        if ((k2 === "derive" || k2 === "resolve") && typeof value22 === "function")
          value22 = { fn: value22, subType: k2 };
        switch (typeof localHook[k2]) {
          case "function":
            localHook[k2] = [localHook[k2], value22];
            break;
          case "object":
            if (Array.isArray(localHook[k2]))
              localHook[k2].push(value22);
            else
              localHook[k2] = [localHook[k2], value22];
            break;
          case "undefined":
            localHook[k2] = value22;
            break;
        }
        delete localHook[key];
      }
    }
  }
  mount(path, handleOrConfig, config2) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run4 = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
        throw Error("Invalid handler");
      })(), handler2 = ({ request: request2, path: path2 }) => run4(new Request(replaceUrlPath(request2.url, path2), { method: request2.method, headers: request2.headers, signal: request2.signal, credentials: request2.credentials, referrerPolicy: request2.referrerPolicy, duplex: request2.duplex, redirect: request2.redirect, mode: request2.mode, keepalive: request2.keepalive, integrity: request2.integrity, body: request2.body }));
      return this.route("ALL", "/*", handler2, { parse: "none", ...config2, detail: { ...config2?.detail, hide: true }, config: { mount: run4 } }), this;
    }
    let handle = handleOrConfig instanceof Elysia ? handleOrConfig.compile().fetch : typeof handleOrConfig === "function" ? handleOrConfig : (() => {
      throw Error("Invalid handler");
    })(), length3 = path.length - (path.endsWith("*") ? 1 : 0), handler = ({ request: request2, path: path2 }) => handle(new Request(replaceUrlPath(request2.url, path2.slice(length3) || "/"), { method: request2.method, headers: request2.headers, signal: request2.signal, credentials: request2.credentials, referrerPolicy: request2.referrerPolicy, duplex: request2.duplex, redirect: request2.redirect, mode: request2.mode, keepalive: request2.keepalive, integrity: request2.integrity, body: request2.body }));
    return this.route("ALL", path, handler, { parse: "none", ...config2, detail: { ...config2?.detail, hide: true }, config: { mount: handle } }), this.route("ALL", path + (path.endsWith("/") ? "*" : "/*"), handler, { parse: "none", ...config2, detail: { ...config2?.detail, hide: true }, config: { mount: handle } }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    if (this["~adapter"].ws)
      this["~adapter"].ws(this, path, options);
    else
      console.warn("Current adapter doesn't support WebSocket");
    return this;
  }
  state(options, name, value6) {
    if (name === undefined)
      value6 = options, options = { as: "append" }, name = "";
    else if (value6 === undefined) {
      if (typeof options === "string")
        value6 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value6 = name, name = "";
    }
    let { as: as10 } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value6) {
      case "object":
        if (!value6 || !isNotEmpty(value6))
          return this;
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value6, { override: as10 === "override" });
          else
            this.singleton.store[name] = value6;
          return this;
        }
        if (value6 === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value6, { override: as10 === "override" }), this;
      case "function":
        if (name) {
          if (as10 === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value6;
        } else
          this.singleton.store = value6(this.singleton.store);
        return this;
      default:
        if (as10 === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value6;
        return this;
    }
  }
  decorate(options, name, value6) {
    if (name === undefined)
      value6 = options, options = { as: "append" }, name = "";
    else if (value6 === undefined) {
      if (typeof options === "string")
        value6 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value6 = name, name = "";
    }
    let { as: as10 } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value6) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value6, { override: as10 === "override" });
          else
            this.singleton.decorator[name] = value6;
          return this;
        }
        if (value6 === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value6, { override: as10 === "override" }), this;
      case "function":
        if (name) {
          if (as10 === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value6;
        } else
          this.singleton.decorator = value6(this.singleton.decorator);
        return this;
      default:
        if (as10 === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value6;
        return this;
    }
  }
  derive(optionsOrTransform, transform6) {
    if (!transform6)
      transform6 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform6 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    let onlyTypebox = (a) => {
      let res = {};
      for (let key in a)
        if (!("~standard" in a[key]))
          res[key] = a[key];
      return res;
    };
    switch (typeof name) {
      case "object":
        let parsedTypebox = {}, kvs = Object.entries(name);
        if (!kvs.length)
          return this;
        for (let [key, value6] of kvs) {
          if (key in this.definitions.type)
            continue;
          if ("~standard" in value6)
            this.definitions.type[key] = value6;
          else
            parsedTypebox[key] = this.definitions.type[key] = value6, parsedTypebox[key].$id ??= `#/components/schemas/${key}`;
        }
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...parsedTypebox }), this;
      case "function":
        let result = name(this.definitions.type);
        return this.definitions.type = result, this.definitions.typebox = t.Module(onlyTypebox(result)), this;
      case "string":
        if (!model)
          break;
        if (this.definitions.type[name] = model, "~standard" in model)
          return this;
        let newModel = { ...model, id: model.$id ?? `#/components/schemas/${name}` };
        return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, ...newModel }), this;
    }
    if (!model)
      return this;
    if (this.definitions.type[name] = model, "~standard" in model)
      return this;
    return this.definitions.typebox = t.Module({ ...this.definitions.typebox.$defs, [name]: model }), this;
  }
  Ref(key) {
    return t.Ref(key);
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type2, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix), remap = (type22) => {
      let store = {};
      switch (type22) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type2) ? type2 : [type2];
    for (let type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type22);
    return this;
  }
  prefix(type2, word) {
    return this.affix("prefix", type2, word);
  }
  suffix(type2, word) {
    return this.affix("suffix", type2, word);
  }
  compile() {
    if (this["~adapter"].isWebStandard) {
      if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
        this.server.reload({ ...this.server || {}, fetch: this.fetch });
      return this;
    }
    if (typeof this.server?.reload === "function")
      this.server.reload(this.server || {});
    return this._handle = composeGeneralHandler(this), this;
  }
  handle = async (request2) => this.fetch(request2);
  fetch = (request2) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request2);
  };
  handleError = async (context9, error2) => {
    return (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context9, error2);
  };
  listen = (options, callback) => {
    if (this["~adapter"].listen(this)(options, callback), this.promisedModules.size)
      clearSucroseCache(5000);
    return this.promisedModules.then(() => {
      clearSucroseCache(1000);
    }), this;
  };
  stop = async (closeActiveConnections) => {
    return await this["~adapter"].stop?.(this, closeActiveConnections), this;
  };
  [Symbol.dispose] = () => {
    if (this.server)
      this.stop();
  };
  get modules() {
    return this.promisedModules;
  }
}

// node_modules/@effect/schema/dist/esm/internal/util.js
var getKeysForIndexSignature2 = (input, parameter) => {
  switch (parameter._tag) {
    case "StringKeyword":
    case "TemplateLiteral":
      return Object.keys(input);
    case "SymbolKeyword":
      return Object.getOwnPropertySymbols(input);
    case "Refinement":
      return getKeysForIndexSignature2(input, parameter.from);
  }
};
var ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
var memoizeThunk2 = (f) => {
  let done14 = false;
  let a;
  return () => {
    if (done14) {
      return a;
    }
    a = f();
    done14 = true;
    return a;
  };
};
var formatUnknown2 = (u) => {
  if (isString(u)) {
    return JSON.stringify(u);
  } else if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u) || isDate(u)) {
    return String(u);
  } else if (isBigInt(u)) {
    return String(u) + "n";
  } else if (!isArray(u) && hasProperty(u, "toString") && isFunction2(u["toString"]) && u["toString"] !== Object.prototype.toString) {
    return u["toString"]();
  }
  try {
    JSON.stringify(u);
    if (isArray(u)) {
      return `[${u.map(formatUnknown2).join(",")}]`;
    } else {
      return `{${ownKeys(u).map((k2) => `${isString(k2) ? JSON.stringify(k2) : String(k2)}:${formatUnknown2(u[k2])}`).join(",")}}`;
    }
  } catch (e) {
    return String(u);
  }
};
var formatPropertyKey2 = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
var isNonEmpty9 = (x) => Array.isArray(x);
var isSingle2 = (x) => !Array.isArray(x);
var formatPathKey2 = (key) => `[${formatPropertyKey2(key)}]`;
var formatPath2 = (path) => isNonEmpty9(path) ? path.map(formatPathKey2).join("") : formatPathKey2(path);

// node_modules/@effect/schema/dist/esm/internal/errors.js
var getErrorMessage2 = (reason, details, path, ast) => {
  let out = reason;
  if (path && isNonEmptyReadonlyArray(path)) {
    out += `\nat path: ${formatPath2(path)}`;
  }
  if (details !== undefined) {
    out += `\ndetails: ${details}`;
  }
  if (ast) {
    out += `\nschema (${ast._tag}): ${ast}`;
  }
  return out;
};
var getInvalidArgumentErrorMessage2 = (details) => getErrorMessage2("Invalid Argument", details);
var getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage2("Unsupported schema", details, path, ast);
var getSchemaExtendErrorMessage2 = (x, y, path) => getErrorMessage2("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
var getSchemaUnsupportedLiteralSpanErrorMessage2 = (ast) => getErrorMessage2("Unsupported template literal span", undefined, undefined, ast);
var getASTUnsupportedSchema = (ast) => getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
var getASTUnsupportedKeySchema = (ast) => getErrorMessage2("Unsupported key schema", undefined, undefined, ast);
var getASTUnsupportedLiteral = (literal2) => getErrorMessage2("Unsupported literal", `literal value: ${formatUnknown2(literal2)}`);
var getASTDuplicateIndexSignatureErrorMessage2 = (type2) => getErrorMessage2("Duplicate index signature", `${type2} index signature`);
var getASTIndexSignatureParameterErrorMessage2 = /* @__PURE__ */ getErrorMessage2("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
var getASTRequiredElementFollowinAnOptionalElementErrorMessage2 = /* @__PURE__ */ getErrorMessage2("Invalid element", "A required element cannot follow an optional element. ts(1257)");
var getASTDuplicatePropertySignatureTransformationErrorMessage2 = (key) => getErrorMessage2("Duplicate property signature transformation", `Duplicate key ${formatUnknown2(key)}`);
var getASTUnsupportedRenameSchema = (ast) => getUnsupportedSchemaErrorMessage(undefined, undefined, ast);
var getASTDuplicatePropertySignatureErrorMessage2 = (key) => getErrorMessage2("Duplicate property signature", `Duplicate key ${formatUnknown2(key)}`);

// node_modules/@effect/schema/dist/esm/AST.js
function changeMap2(as10, f) {
  let changed = false;
  const out = allocate(as10.length);
  for (let i = 0;i < as10.length; i++) {
    const a = as10[i];
    const fa = f(a);
    if (fa !== a) {
      changed = true;
    }
    out[i] = fa;
  }
  return changed ? out : as10;
}
var BrandAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Brand");
var TypeAnnotationId = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Type");
var MessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Message");
var MissingMessageAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/MissingMessage");
var IdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Identifier");
var TitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Title");
var DescriptionAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Description");
var ExamplesAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Examples");
var DefaultAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Default");
var JSONSchemaAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONSchema");
var DocumentationAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Documentation");
var ConcurrencyAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Concurrency");
var BatchingAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Batching");
var ParseIssueTitleAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseIssueTitle");
var ParseOptionsAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/ParseOptions");
var SurrogateAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/Surrogate");
var StableFilterAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/StableFilter");
var getAnnotation2 = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some2(annotated.annotations[key]) : none2());
var getBrandAnnotation2 = /* @__PURE__ */ getAnnotation2(BrandAnnotationId2);
var getMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MessageAnnotationId2);
var getMissingMessageAnnotation2 = /* @__PURE__ */ getAnnotation2(MissingMessageAnnotationId2);
var getTitleAnnotation2 = /* @__PURE__ */ getAnnotation2(TitleAnnotationId2);
var getIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(IdentifierAnnotationId2);
var getDescriptionAnnotation2 = /* @__PURE__ */ getAnnotation2(DescriptionAnnotationId2);
var getConcurrencyAnnotation2 = /* @__PURE__ */ getAnnotation2(ConcurrencyAnnotationId2);
var getBatchingAnnotation2 = /* @__PURE__ */ getAnnotation2(BatchingAnnotationId2);
var getParseIssueTitleAnnotation3 = /* @__PURE__ */ getAnnotation2(ParseIssueTitleAnnotationId2);
var getParseOptionsAnnotation2 = /* @__PURE__ */ getAnnotation2(ParseOptionsAnnotationId2);
var getSurrogateAnnotation2 = /* @__PURE__ */ getAnnotation2(SurrogateAnnotationId2);
var getStableFilterAnnotation2 = /* @__PURE__ */ getAnnotation2(StableFilterAnnotationId2);
var JSONIdentifierAnnotationId2 = /* @__PURE__ */ Symbol.for("@effect/schema/annotation/JSONIdentifier");
var getJSONIdentifierAnnotation2 = /* @__PURE__ */ getAnnotation2(JSONIdentifierAnnotationId2);

class Declaration2 {
  typeParameters;
  decodeUnknown;
  encodeUnknown;
  annotations;
  _tag = "Declaration";
  constructor(typeParameters, decodeUnknown3, encodeUnknown2, annotations2 = {}) {
    this.typeParameters = typeParameters;
    this.decodeUnknown = decodeUnknown3;
    this.encodeUnknown = encodeUnknown2;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => "<declaration schema>");
  }
  toJSON() {
    return {
      _tag: this._tag,
      typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var createASTGuard2 = (tag2) => (ast) => ast._tag === tag2;
class Literal3 {
  literal;
  annotations;
  _tag = "Literal";
  constructor(literal2, annotations2 = {}) {
    this.literal = literal2;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatUnknown2(this.literal));
  }
  toJSON() {
    return {
      _tag: this._tag,
      literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isLiteral2 = /* @__PURE__ */ createASTGuard2("Literal");
var $null2 = /* @__PURE__ */ new Literal3(null, {
  [IdentifierAnnotationId2]: "null"
});
class UniqueSymbol2 {
  symbol;
  annotations;
  _tag = "UniqueSymbol";
  constructor(symbol4, annotations2 = {}) {
    this.symbol = symbol4;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatUnknown2(this.symbol));
  }
  toJSON() {
    return {
      _tag: this._tag,
      symbol: String(this.symbol),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isUniqueSymbol = /* @__PURE__ */ createASTGuard2("UniqueSymbol");

class UndefinedKeyword2 {
  annotations;
  _tag = "UndefinedKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var undefinedKeyword2 = /* @__PURE__ */ new UndefinedKeyword2({
  [TitleAnnotationId2]: "undefined"
});
class VoidKeyword2 {
  annotations;
  _tag = "VoidKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var voidKeyword2 = /* @__PURE__ */ new VoidKeyword2({
  [TitleAnnotationId2]: "void"
});
class NeverKeyword2 {
  annotations;
  _tag = "NeverKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var neverKeyword2 = /* @__PURE__ */ new NeverKeyword2({
  [TitleAnnotationId2]: "never"
});
class UnknownKeyword2 {
  annotations;
  _tag = "UnknownKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var unknownKeyword2 = /* @__PURE__ */ new UnknownKeyword2({
  [TitleAnnotationId2]: "unknown"
});
class AnyKeyword2 {
  annotations;
  _tag = "AnyKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var anyKeyword2 = /* @__PURE__ */ new AnyKeyword2({
  [TitleAnnotationId2]: "any"
});
class StringKeyword2 {
  annotations;
  _tag = "StringKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var stringKeyword2 = /* @__PURE__ */ new StringKeyword2({
  [TitleAnnotationId2]: "string",
  [DescriptionAnnotationId2]: "a string"
});
var isStringKeyword2 = /* @__PURE__ */ createASTGuard2("StringKeyword");

class NumberKeyword2 {
  annotations;
  _tag = "NumberKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var numberKeyword2 = /* @__PURE__ */ new NumberKeyword2({
  [TitleAnnotationId2]: "number",
  [DescriptionAnnotationId2]: "a number"
});
var isNumberKeyword2 = /* @__PURE__ */ createASTGuard2("NumberKeyword");

class BooleanKeyword2 {
  annotations;
  _tag = "BooleanKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var booleanKeyword2 = /* @__PURE__ */ new BooleanKeyword2({
  [TitleAnnotationId2]: "boolean",
  [DescriptionAnnotationId2]: "a boolean"
});
class BigIntKeyword2 {
  annotations;
  _tag = "BigIntKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var bigIntKeyword2 = /* @__PURE__ */ new BigIntKeyword2({
  [TitleAnnotationId2]: "bigint",
  [DescriptionAnnotationId2]: "a bigint"
});
class SymbolKeyword2 {
  annotations;
  _tag = "SymbolKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var symbolKeyword2 = /* @__PURE__ */ new SymbolKeyword2({
  [TitleAnnotationId2]: "symbol",
  [DescriptionAnnotationId2]: "a symbol"
});
var isSymbolKeyword2 = /* @__PURE__ */ createASTGuard2("SymbolKeyword");

class ObjectKeyword2 {
  annotations;
  _tag = "ObjectKeyword";
  constructor(annotations2 = {}) {
    this.annotations = annotations2;
  }
  toString() {
    return formatKeyword2(this);
  }
  toJSON() {
    return {
      _tag: this._tag,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var objectKeyword2 = /* @__PURE__ */ new ObjectKeyword2({
  [IdentifierAnnotationId2]: "object",
  [TitleAnnotationId2]: "object",
  [DescriptionAnnotationId2]: "an object in the TypeScript meaning, i.e. the `object` type"
});
class Enums2 {
  enums;
  annotations;
  _tag = "Enums";
  constructor(enums, annotations2 = {}) {
    this.enums = enums;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => `<enum ${this.enums.length} value(s): ${this.enums.map((_2, value6) => JSON.stringify(value6)).join(" | ")}>`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      enums: this.enums,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isEnums = /* @__PURE__ */ createASTGuard2("Enums");

class TemplateLiteralSpan2 {
  type;
  literal;
  constructor(type2, literal2) {
    this.type = type2;
    this.literal = literal2;
  }
  toString() {
    switch (this.type._tag) {
      case "StringKeyword":
        return "${string}";
      case "NumberKeyword":
        return "${number}";
    }
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      literal: this.literal
    };
  }
}

class TemplateLiteral3 {
  head;
  spans;
  annotations;
  _tag = "TemplateLiteral";
  constructor(head8, spans, annotations2 = {}) {
    this.head = head8;
    this.spans = spans;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatTemplateLiteral(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      head: this.head,
      spans: this.spans.map((span4) => span4.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var formatTemplateLiteral = (ast) => "`" + ast.head + ast.spans.map((span4) => String(span4) + span4.literal).join("") + "`";
var isTemplateLiteral = /* @__PURE__ */ createASTGuard2("TemplateLiteral");

class Type4 {
  type;
  annotations;
  constructor(type2, annotations2 = {}) {
    this.type = type2;
    this.annotations = annotations2;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  toString() {
    return String(this.type);
  }
}

class OptionalType2 extends Type4 {
  isOptional;
  constructor(type2, isOptional2, annotations2 = {}) {
    super(type2, annotations2);
    this.isOptional = isOptional2;
  }
  toJSON() {
    return {
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
  toString() {
    return String(this.type) + (this.isOptional ? "?" : "");
  }
}
var getRestASTs2 = (rest) => rest.map((annotatedAST) => annotatedAST.type);

class TupleType2 {
  elements;
  rest;
  isReadonly;
  annotations;
  _tag = "TupleType";
  constructor(elements, rest, isReadonly, annotations2 = {}) {
    this.elements = elements;
    this.rest = rest;
    this.isReadonly = isReadonly;
    this.annotations = annotations2;
    let hasOptionalElement = false;
    let hasIllegalRequiredElement = false;
    for (const e of elements) {
      if (e.isOptional) {
        hasOptionalElement = true;
      } else if (hasOptionalElement) {
        hasIllegalRequiredElement = true;
        break;
      }
    }
    if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
      throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage2);
    }
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatTuple2(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      elements: this.elements.map((e) => e.toJSON()),
      rest: this.rest.map((ast) => ast.toJSON()),
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var formatTuple2 = (ast) => {
  const formattedElements = ast.elements.map(String).join(", ");
  return matchLeft(ast.rest, {
    onEmpty: () => `readonly [${formattedElements}]`,
    onNonEmpty: (head8, tail) => {
      const formattedHead = String(head8);
      const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
      if (tail.length > 0) {
        const formattedTail = tail.map(String).join(", ");
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
        } else {
          return `readonly [...${wrappedHead}[], ${formattedTail}]`;
        }
      } else {
        if (ast.elements.length > 0) {
          return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
        } else {
          return `ReadonlyArray<${formattedHead}>`;
        }
      }
    }
  });
};
class PropertySignature2 extends OptionalType2 {
  name;
  isReadonly;
  constructor(name, type2, isOptional2, isReadonly, annotations2) {
    super(type2, isOptional2, annotations2);
    this.name = name;
    this.isReadonly = isReadonly;
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
  }
  toJSON() {
    return {
      name: String(this.name),
      type: this.type.toJSON(),
      isOptional: this.isOptional,
      isReadonly: this.isReadonly,
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isParameter2 = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return true;
    case "Refinement":
      return isParameter2(ast.from);
  }
  return false;
};

class IndexSignature2 {
  type;
  isReadonly;
  parameter;
  constructor(parameter, type2, isReadonly) {
    this.type = type2;
    this.isReadonly = isReadonly;
    if (isParameter2(parameter)) {
      this.parameter = parameter;
    } else {
      throw new Error(getASTIndexSignatureParameterErrorMessage2);
    }
  }
  toString() {
    return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
  }
  toJSON() {
    return {
      parameter: this.parameter.toJSON(),
      type: this.type.toJSON(),
      isReadonly: this.isReadonly
    };
  }
}

class TypeLiteral2 {
  annotations;
  _tag = "TypeLiteral";
  propertySignatures;
  indexSignatures;
  constructor(propertySignatures, indexSignatures, annotations2 = {}) {
    this.annotations = annotations2;
    const keys9 = {};
    for (let i = 0;i < propertySignatures.length; i++) {
      const name = propertySignatures[i].name;
      if (Object.prototype.hasOwnProperty.call(keys9, name)) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage2(name));
      }
      keys9[name] = null;
    }
    const parameters = {
      string: false,
      symbol: false
    };
    for (let i = 0;i < indexSignatures.length; i++) {
      const parameter = getParameterBase(indexSignatures[i].parameter);
      if (isStringKeyword2(parameter)) {
        if (parameters.string) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("string"));
        }
        parameters.string = true;
      } else if (isSymbolKeyword2(parameter)) {
        if (parameters.symbol) {
          throw new Error(getASTDuplicateIndexSignatureErrorMessage2("symbol"));
        }
        parameters.symbol = true;
      }
    }
    this.propertySignatures = sortPropertySignatures(propertySignatures);
    this.indexSignatures = sortIndexSignatures(indexSignatures);
  }
  toString() {
    return getOrElse(getExpected2(this), () => formatTypeLiteral2(this));
  }
  toJSON() {
    return {
      _tag: this._tag,
      propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
      indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var formatIndexSignatures2 = (iss) => iss.map(String).join("; ");
var formatTypeLiteral2 = (ast) => {
  if (ast.propertySignatures.length > 0) {
    const pss = ast.propertySignatures.map(String).join("; ");
    if (ast.indexSignatures.length > 0) {
      return `{ ${pss}; ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return `{ ${pss} }`;
    }
  } else {
    if (ast.indexSignatures.length > 0) {
      return `{ ${formatIndexSignatures2(ast.indexSignatures)} }`;
    } else {
      return "{}";
    }
  }
};
var isTypeLiteral2 = /* @__PURE__ */ createASTGuard2("TypeLiteral");
var removeNevers = (candidates) => candidates.filter((ast) => !(ast === neverKeyword2));
var sortCandidates2 = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ast) => {
  switch (ast._tag) {
    case "AnyKeyword":
      return 0;
    case "UnknownKeyword":
      return 1;
    case "ObjectKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
  }
  return 4;
}));
var literalMap2 = {
  string: "StringKeyword",
  number: "NumberKeyword",
  boolean: "BooleanKeyword",
  bigint: "BigIntKeyword"
};
var flatten14 = (candidates) => flatMap2(candidates, (ast) => isUnion3(ast) ? flatten14(ast.types) : [ast]);
var unify2 = (candidates) => {
  const cs = sortCandidates2(candidates);
  const out = [];
  const uniques = {};
  const literals = [];
  for (const ast of cs) {
    switch (ast._tag) {
      case "NeverKeyword":
        break;
      case "AnyKeyword":
        return [anyKeyword2];
      case "UnknownKeyword":
        return [unknownKeyword2];
      case "ObjectKeyword":
      case "UndefinedKeyword":
      case "VoidKeyword":
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword": {
        if (!uniques[ast._tag]) {
          uniques[ast._tag] = ast;
          out.push(ast);
        }
        break;
      }
      case "Literal": {
        const type2 = typeof ast.literal;
        switch (type2) {
          case "string":
          case "number":
          case "bigint":
          case "boolean": {
            const _tag = literalMap2[type2];
            if (!uniques[_tag] && !literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
          case "object": {
            if (!literals.includes(ast.literal)) {
              literals.push(ast.literal);
              out.push(ast);
            }
            break;
          }
        }
        break;
      }
      case "UniqueSymbol": {
        if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
          literals.push(ast.symbol);
          out.push(ast);
        }
        break;
      }
      case "TupleType": {
        if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          if (!uniques["{}"]) {
            uniques["{}"] = ast;
            out.push(ast);
          }
        } else if (!uniques["ObjectKeyword"]) {
          out.push(ast);
        }
        break;
      }
      default:
        out.push(ast);
    }
  }
  return out;
};

class Union4 {
  types;
  annotations;
  static make = (candidates, annotations2) => {
    const types = [];
    const memo = new Set;
    for (let i = 0;i < candidates.length; i++) {
      const ast = candidates[i];
      if (ast === neverKeyword2 || memo.has(ast)) {
        continue;
      }
      memo.add(ast);
      types.push(ast);
    }
    return Union4.union(types, annotations2);
  };
  static members = (candidates, annotations2) => {
    return Union4.union(removeNevers(candidates), annotations2);
  };
  static unify = (candidates, annotations2) => {
    return Union4.union(unify2(flatten14(candidates)), annotations2);
  };
  static union = (types, annotations2) => {
    return isMembers2(types) ? new Union4(types, annotations2) : types.length === 1 ? types[0] : neverKeyword2;
  };
  _tag = "Union";
  constructor(types, annotations2 = {}) {
    this.types = types;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => this.types.map(String).join(" | "));
  }
  toJSON() {
    return {
      _tag: this._tag,
      types: this.types.map((ast) => ast.toJSON()),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var mapMembers2 = (members, f) => members.map(f);
var isMembers2 = (as10) => as10.length > 1;
var isUnion3 = /* @__PURE__ */ createASTGuard2("Union");
var toJSONMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/AST/toJSONMemoMap"), () => new WeakMap);

class Suspend2 {
  f;
  annotations;
  _tag = "Suspend";
  constructor(f, annotations2 = {}) {
    this.f = f;
    this.annotations = annotations2;
    this.f = memoizeThunk2(f);
  }
  toString() {
    return getExpected2(this).pipe(orElse(() => flatMap(liftThrowable(this.f)(), (ast) => getExpected2(ast))), getOrElse(() => "<suspended schema>"));
  }
  toJSON() {
    const ast = this.f();
    let out = toJSONMemoMap2.get(ast);
    if (out) {
      return out;
    }
    toJSONMemoMap2.set(ast, {
      _tag: this._tag
    });
    out = {
      _tag: this._tag,
      ast: ast.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
    toJSONMemoMap2.set(ast, out);
    return out;
  }
}
class Refinement3 {
  from;
  filter;
  annotations;
  _tag = "Refinement";
  constructor(from, filter16, annotations2 = {}) {
    this.from = from;
    this.filter = filter16;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => `{ ${this.from} | filter }`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isRefinement3 = /* @__PURE__ */ createASTGuard2("Refinement");
var defaultParseOption2 = {};

class Transformation3 {
  from;
  to;
  transformation;
  annotations;
  _tag = "Transformation";
  constructor(from, to, transformation, annotations2 = {}) {
    this.from = from;
    this.to = to;
    this.transformation = transformation;
    this.annotations = annotations2;
  }
  toString() {
    return getOrElse(getExpected2(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
  }
  toJSON() {
    return {
      _tag: this._tag,
      from: this.from.toJSON(),
      to: this.to.toJSON(),
      annotations: toJSONAnnotations2(this.annotations)
    };
  }
}
var isTransformation3 = /* @__PURE__ */ createASTGuard2("Transformation");

class FinalTransformation2 {
  decode;
  encode;
  _tag = "FinalTransformation";
  constructor(decode6, encode5) {
    this.decode = decode6;
    this.encode = encode5;
  }
}
var createTransformationGuard = (tag2) => (ast) => ast._tag === tag2;
class ComposeTransformation {
  _tag = "ComposeTransformation";
}
var composeTransformation2 = /* @__PURE__ */ new ComposeTransformation;
class PropertySignatureTransformation2 {
  from;
  to;
  decode;
  encode;
  constructor(from, to, decode6, encode5) {
    this.from = from;
    this.to = to;
    this.decode = decode6;
    this.encode = encode5;
  }
}
var isRenamingPropertySignatureTransformation = (t2) => t2.decode === identity && t2.encode === identity;

class TypeLiteralTransformation2 {
  propertySignatureTransformations;
  _tag = "TypeLiteralTransformation";
  constructor(propertySignatureTransformations) {
    this.propertySignatureTransformations = propertySignatureTransformations;
    const fromKeys = {};
    const toKeys = {};
    for (const pst of propertySignatureTransformations) {
      const from = pst.from;
      if (fromKeys[from]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(from));
      }
      fromKeys[from] = true;
      const to = pst.to;
      if (toKeys[to]) {
        throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage2(to));
      }
      toKeys[to] = true;
    }
  }
}
var isTypeLiteralTransformation2 = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
var annotations2 = (ast, annotations3) => {
  const d = Object.getOwnPropertyDescriptors(ast);
  d.annotations.value = {
    ...ast.annotations,
    ...annotations3
  };
  return Object.create(Object.getPrototypeOf(ast), d);
};
var keyof2 = (ast) => Union4.unify(_keyof(ast));
var STRING_KEYWORD_PATTERN2 = ".*";
var NUMBER_KEYWORD_PATTERN2 = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
var getTemplateLiteralRegExp2 = (ast) => {
  let pattern2 = `^${escape(ast.head)}`;
  for (const span4 of ast.spans) {
    if (isStringKeyword2(span4.type)) {
      pattern2 += STRING_KEYWORD_PATTERN2;
    } else if (isNumberKeyword2(span4.type)) {
      pattern2 += NUMBER_KEYWORD_PATTERN2;
    }
    pattern2 += escape(span4.literal);
  }
  pattern2 += "$";
  return new RegExp(pattern2);
};
var getNumberIndexedAccess2 = (ast) => {
  switch (ast._tag) {
    case "TupleType": {
      let hasOptional = false;
      let out = [];
      for (const e of ast.elements) {
        if (e.isOptional) {
          hasOptional = true;
        }
        out.push(e.type);
      }
      if (hasOptional) {
        out.push(undefinedKeyword2);
      }
      out = out.concat(getRestASTs2(ast.rest));
      return Union4.make(out);
    }
    case "Refinement":
      return getNumberIndexedAccess2(ast.from);
    case "Union":
      return Union4.make(ast.types.map(getNumberIndexedAccess2));
    case "Suspend":
      return getNumberIndexedAccess2(ast.f());
  }
  throw new Error(getASTUnsupportedSchema(ast));
};
var getPropertyKeyIndexedAccess2 = (ast, name) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getPropertyKeyIndexedAccess2(annotation.value, name);
      }
      break;
    }
    case "TypeLiteral": {
      const ops = findFirst2(ast.propertySignatures, (ps) => ps.name === name);
      if (isSome2(ops)) {
        return ops.value;
      } else {
        if (isString(name)) {
          for (const is3 of ast.indexSignatures) {
            const parameterBase = getParameterBase(is3.parameter);
            switch (parameterBase._tag) {
              case "TemplateLiteral": {
                const regex2 = getTemplateLiteralRegExp2(parameterBase);
                if (regex2.test(name)) {
                  return new PropertySignature2(name, is3.type, false, true);
                }
                break;
              }
              case "StringKeyword":
                return new PropertySignature2(name, is3.type, false, true);
            }
          }
        } else if (isSymbol(name)) {
          for (const is3 of ast.indexSignatures) {
            const parameterBase = getParameterBase(is3.parameter);
            if (isSymbolKeyword2(parameterBase)) {
              return new PropertySignature2(name, is3.type, false, true);
            }
          }
        }
      }
      break;
    }
    case "Union":
      return new PropertySignature2(name, Union4.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess2(ast2, name).type)), false, true);
    case "Suspend":
      return getPropertyKeyIndexedAccess2(ast.f(), name);
  }
  return new PropertySignature2(name, neverKeyword2, false, true);
};
var getPropertyKeys = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getPropertyKeys(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((ps) => ps.name);
    case "Suspend":
      return getPropertyKeys(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
    case "Transformation":
      return getPropertyKeys(ast.to);
  }
  return [];
};
var record2 = (key, value6) => {
  const propertySignatures = [];
  const indexSignatures = [];
  const go2 = (key2) => {
    switch (key2._tag) {
      case "NeverKeyword":
        break;
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
      case "Refinement":
        indexSignatures.push(new IndexSignature2(key2, value6, true));
        break;
      case "Literal":
        if (isString(key2.literal) || isNumber(key2.literal)) {
          propertySignatures.push(new PropertySignature2(key2.literal, value6, false, true));
        } else {
          throw new Error(getASTUnsupportedLiteral(key2.literal));
        }
        break;
      case "Enums": {
        for (const [_2, name] of key2.enums) {
          propertySignatures.push(new PropertySignature2(name, value6, false, true));
        }
        break;
      }
      case "UniqueSymbol":
        propertySignatures.push(new PropertySignature2(key2.symbol, value6, false, true));
        break;
      case "Union":
        key2.types.forEach(go2);
        break;
      default:
        throw new Error(getASTUnsupportedKeySchema(key2));
    }
  };
  go2(key);
  return {
    propertySignatures,
    indexSignatures
  };
};
var pick5 = (ast, keys9) => {
  if (isTransformation3(ast)) {
    switch (ast.transformation._tag) {
      case "ComposeTransformation":
        return new Transformation3(pick5(ast.from, keys9), pick5(ast.to, keys9), composeTransformation2);
      case "TypeLiteralTransformation": {
        const ts = [];
        const fromKeys = [];
        for (const k2 of keys9) {
          const t2 = ast.transformation.propertySignatureTransformations.find((t3) => t3.to === k2);
          if (t2) {
            ts.push(t2);
            fromKeys.push(t2.from);
          } else {
            fromKeys.push(k2);
          }
        }
        return isNonEmptyReadonlyArray(ts) ? new Transformation3(pick5(ast.from, fromKeys), pick5(ast.to, keys9), new TypeLiteralTransformation2(ts)) : pick5(ast.from, fromKeys);
      }
      case "FinalTransformation": {
        const annotation = getSurrogateAnnotation2(ast);
        if (isSome2(annotation)) {
          return pick5(annotation.value, keys9);
        }
        throw new Error(getASTUnsupportedSchema(ast));
      }
    }
  }
  return new TypeLiteral2(keys9.map((key) => getPropertyKeyIndexedAccess2(ast, key)), []);
};
var omit5 = (ast, keys9) => pick5(ast, getPropertyKeys(ast).filter((name) => !keys9.includes(name)));
var orUndefined2 = (ast) => Union4.make([ast, undefinedKeyword2]);
var partial2 = (ast, options) => {
  const exact = options?.exact === true;
  switch (ast._tag) {
    case "TupleType":
      return new TupleType2(ast.elements.map((e) => new OptionalType2(exact ? e.type : orUndefined2(e.type), true)), match3(ast.rest, {
        onEmpty: () => ast.rest,
        onNonEmpty: (rest) => [new Type4(Union4.make([...getRestASTs2(rest), undefinedKeyword2]))]
      }), ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral2(ast.propertySignatures.map((ps) => new PropertySignature2(ps.name, exact ? ps.type : orUndefined2(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is3) => new IndexSignature2(is3.parameter, orUndefined2(is3.type), is3.isReadonly)));
    case "Union":
      return Union4.make(ast.types.map((member) => partial2(member, options)));
    case "Suspend":
      return new Suspend2(() => partial2(ast.f(), options));
    case "Declaration":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Refinement":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation2(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation3(partial2(ast.from, options), partial2(ast.to, options), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchema(ast));
    }
  }
  return ast;
};
var required2 = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return new TupleType2(ast.elements.map((e) => new OptionalType2(e.type, false)), ast.rest, ast.isReadonly);
    case "TypeLiteral":
      return new TypeLiteral2(ast.propertySignatures.map((f) => new PropertySignature2(f.name, f.type, false, f.isReadonly, f.annotations)), ast.indexSignatures);
    case "Union":
      return Union4.make(ast.types.map((member) => required2(member)));
    case "Suspend":
      return new Suspend2(() => required2(ast.f()));
    case "Declaration":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Refinement":
      throw new Error(getASTUnsupportedSchema(ast));
    case "Transformation": {
      if (isTypeLiteralTransformation2(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
        return new Transformation3(required2(ast.from), required2(ast.to), ast.transformation);
      }
      throw new Error(getASTUnsupportedSchema(ast));
    }
  }
  return ast;
};
var mutable2 = (ast) => {
  switch (ast._tag) {
    case "TupleType":
      return ast.isReadonly === false ? ast : new TupleType2(ast.elements, ast.rest, false, ast.annotations);
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature2(ps.name, ps.type, ps.isOptional, false, ps.annotations));
      const indexSignatures = changeMap2(ast.indexSignatures, (is3) => is3.isReadonly === false ? is3 : new IndexSignature2(is3.parameter, is3.type, false));
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap2(ast.types, mutable2);
      return types === ast.types ? ast : Union4.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend2(() => mutable2(ast.f()), ast.annotations);
    case "Refinement": {
      const from = mutable2(ast.from);
      return from === ast.from ? ast : new Refinement3(from, ast.filter, ast.annotations);
    }
    case "Transformation": {
      const from = mutable2(ast.from);
      const to = mutable2(ast.to);
      return from === ast.from && to === ast.to ? ast : new Transformation3(from, to, ast.transformation, ast.annotations);
    }
  }
  return ast;
};
var typeAST2 = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, typeAST2);
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type2 = typeAST2(e.type);
        return type2 === e.type ? e : new OptionalType2(type2, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, typeAST2);
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((type2) => new Type4(type2)), ast.isReadonly, ast.annotations);
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (p) => {
        const type2 = typeAST2(p.type);
        return type2 === p.type ? p : new PropertySignature2(p.name, type2, p.isOptional, p.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is3) => {
        const type2 = typeAST2(is3.type);
        return type2 === is3.type ? is3 : new IndexSignature2(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, ast.annotations);
    }
    case "Union": {
      const types = changeMap2(ast.types, typeAST2);
      return types === ast.types ? ast : Union4.make(types, ast.annotations);
    }
    case "Suspend":
      return new Suspend2(() => typeAST2(ast.f()), ast.annotations);
    case "Refinement": {
      const from = typeAST2(ast.from);
      return from === ast.from ? ast : new Refinement3(from, ast.filter, ast.annotations);
    }
    case "Transformation":
      return typeAST2(ast.to);
  }
  return ast;
};
var preserveAnnotations = (annotationIds) => (annotated) => {
  let out = undefined;
  for (const id2 of annotationIds) {
    if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
      if (out === undefined) {
        out = {};
      }
      out[id2] = annotated.annotations[id2];
    }
  }
  return out;
};
var getJSONIdentifier2 = (annotated) => orElse(getJSONIdentifierAnnotation2(annotated), () => getIdentifierAnnotation2(annotated));
var createJSONIdentifierAnnotation = (annotated) => match2(getJSONIdentifier2(annotated), {
  onNone: () => {
    return;
  },
  onSome: (identifier2) => ({
    [JSONIdentifierAnnotationId2]: identifier2
  })
});
var encodedAST_2 = (ast, isBound) => {
  switch (ast._tag) {
    case "Declaration": {
      const typeParameters = changeMap2(ast.typeParameters, (ast2) => encodedAST_2(ast2, isBound));
      return typeParameters === ast.typeParameters ? ast : new Declaration2(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
    }
    case "TupleType": {
      const elements = changeMap2(ast.elements, (e) => {
        const type2 = encodedAST_2(e.type, isBound);
        return type2 === e.type ? e : new OptionalType2(type2, e.isOptional);
      });
      const restASTs = getRestASTs2(ast.rest);
      const rest = changeMap2(restASTs, (ast2) => encodedAST_2(ast2, isBound));
      return elements === ast.elements && rest === restASTs ? ast : new TupleType2(elements, rest.map((ast2) => new Type4(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
    }
    case "TypeLiteral": {
      const propertySignatures = changeMap2(ast.propertySignatures, (ps) => {
        const type2 = encodedAST_2(ps.type, isBound);
        return type2 === ps.type ? ps : new PropertySignature2(ps.name, type2, ps.isOptional, ps.isReadonly);
      });
      const indexSignatures = changeMap2(ast.indexSignatures, (is3) => {
        const type2 = encodedAST_2(is3.type, isBound);
        return type2 === is3.type ? is3 : new IndexSignature2(is3.parameter, type2, is3.isReadonly);
      });
      return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral2(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
    }
    case "Union": {
      const types = changeMap2(ast.types, (ast2) => encodedAST_2(ast2, isBound));
      return types === ast.types ? ast : Union4.make(types, createJSONIdentifierAnnotation(ast));
    }
    case "Suspend":
      return new Suspend2(() => encodedAST_2(ast.f(), isBound), createJSONIdentifierAnnotation(ast));
    case "Refinement": {
      const from = encodedAST_2(ast.from, isBound);
      if (isBound) {
        if (from === ast.from) {
          return ast;
        }
        if (!isTransformation3(ast.from)) {
          const annotations3 = getStableFilterAnnotation2(ast);
          if (isSome2(annotations3) && annotations3.value === true) {
            return new Refinement3(from, ast.filter);
          }
        }
      }
      return from;
    }
    case "Transformation":
      return encodedAST_2(ast.from, isBound);
  }
  return ast;
};
var encodedAST2 = (ast) => encodedAST_2(ast, false);
var encodedBoundAST2 = (ast) => encodedAST_2(ast, true);
var toJSONAnnotations2 = (annotations3) => {
  const out = {};
  for (const k2 of Object.getOwnPropertySymbols(annotations3)) {
    out[String(k2)] = annotations3[k2];
  }
  return out;
};
var getCardinality = (ast) => {
  switch (ast._tag) {
    case "NeverKeyword":
      return 0;
    case "Literal":
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "UniqueSymbol":
      return 1;
    case "BooleanKeyword":
      return 2;
    case "StringKeyword":
    case "NumberKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
      return 3;
    case "ObjectKeyword":
      return 5;
    case "UnknownKeyword":
    case "AnyKeyword":
      return 6;
    default:
      return 4;
  }
};
var sortPropertySignatures = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (ps) => getCardinality(ps.type)));
var sortIndexSignatures = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput2(Order, (is3) => {
  switch (getParameterBase(is3.parameter)._tag) {
    case "StringKeyword":
      return 2;
    case "SymbolKeyword":
      return 3;
    case "TemplateLiteral":
      return 1;
  }
}));
var getParameterBase = (ast) => {
  switch (ast._tag) {
    case "StringKeyword":
    case "SymbolKeyword":
    case "TemplateLiteral":
      return ast;
    case "Refinement":
      return getParameterBase(ast.from);
  }
};
var equalsTemplateLiteralSpan = /* @__PURE__ */ getEquivalence3((self2, that) => self2.type._tag === that.type._tag && self2.literal === that.literal);
var equalsEnums = /* @__PURE__ */ getEquivalence3((self2, that) => that[0] === self2[0] && that[1] === self2[1]);
var equals5 = (self2, that) => {
  switch (self2._tag) {
    case "Literal":
      return isLiteral2(that) && that.literal === self2.literal;
    case "UniqueSymbol":
      return isUniqueSymbol(that) && that.symbol === self2.symbol;
    case "UndefinedKeyword":
    case "VoidKeyword":
    case "NeverKeyword":
    case "UnknownKeyword":
    case "AnyKeyword":
    case "StringKeyword":
    case "NumberKeyword":
    case "BooleanKeyword":
    case "BigIntKeyword":
    case "SymbolKeyword":
    case "ObjectKeyword":
      return that._tag === self2._tag;
    case "TemplateLiteral":
      return isTemplateLiteral(that) && that.head === self2.head && equalsTemplateLiteralSpan(that.spans, self2.spans);
    case "Enums":
      return isEnums(that) && equalsEnums(that.enums, self2.enums);
    case "Refinement":
    case "TupleType":
    case "TypeLiteral":
    case "Union":
    case "Suspend":
    case "Transformation":
    case "Declaration":
      return self2 === that;
  }
};
var intersection4 = /* @__PURE__ */ intersectionWith(equals5);
var _keyof = (ast) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return _keyof(annotation.value);
      }
      break;
    }
    case "TypeLiteral":
      return ast.propertySignatures.map((p) => isSymbol(p.name) ? new UniqueSymbol2(p.name) : new Literal3(p.name)).concat(ast.indexSignatures.map((is3) => getParameterBase(is3.parameter)));
    case "Suspend":
      return _keyof(ast.f());
    case "Union":
      return ast.types.slice(1).reduce((out, ast2) => intersection4(out, _keyof(ast2)), _keyof(ast.types[0]));
    case "Transformation":
      return _keyof(ast.to);
  }
  throw new Error(getASTUnsupportedSchema(ast));
};
var compose3 = (ab, cd) => new Transformation3(ab, cd, composeTransformation2);
var rename2 = (ast, mapping) => {
  switch (ast._tag) {
    case "TypeLiteral": {
      const propertySignatureTransformations = [];
      for (const key of ownKeys(mapping)) {
        const name = mapping[key];
        if (name !== undefined) {
          propertySignatureTransformations.push(new PropertySignatureTransformation2(key, name, identity, identity));
        }
      }
      if (propertySignatureTransformations.length === 0) {
        return ast;
      }
      return new Transformation3(ast, new TypeLiteral2(ast.propertySignatures.map((ps) => {
        const name = mapping[ps.name];
        return new PropertySignature2(name === undefined ? ps.name : name, typeAST2(ps.type), ps.isOptional, ps.isReadonly, ps.annotations);
      }), ast.indexSignatures), new TypeLiteralTransformation2(propertySignatureTransformations));
    }
    case "Union":
      return Union4.make(ast.types.map((ast2) => rename2(ast2, mapping)));
    case "Suspend":
      return new Suspend2(() => rename2(ast.f(), mapping));
    case "Transformation":
      return compose3(ast, rename2(typeAST2(ast), mapping));
  }
  throw new Error(getASTUnsupportedRenameSchema(ast));
};
var formatKeyword2 = (ast) => getOrElse(getExpected2(ast), () => ast._tag);
var getExpected2 = (ast) => {
  return getIdentifierAnnotation2(ast).pipe(orElse(() => getTitleAnnotation2(ast)), orElse(() => getDescriptionAnnotation2(ast)));
};
// node_modules/@effect/schema/dist/esm/internal/filters.js
var GreaterThanTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThan");
var GreaterThanOrEqualToTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualTo");
var LessThanTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThan");
var LessThanOrEqualToTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualTo");
var IntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Int");
var BetweenTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Between");
var GreaterThanBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanBigint");
var GreaterThanOrEqualToBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigint");
var LessThanBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanBigint");
var LessThanOrEqualToBigIntTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigint");
var BetweenBigintTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenBigint");
var MinLengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinLength");
var MaxLengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxLength");
var LengthTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Length");
var MinItemsTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MinItems");
var MaxItemsTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MaxItems");
var ItemsCountTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ItemsCount");
var ParseJsonTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ParseJson");

// node_modules/@effect/schema/dist/esm/Arbitrary.js
var ArbitraryHookId = /* @__PURE__ */ Symbol.for("@effect/schema/ArbitraryHookId");
// node_modules/@effect/schema/dist/esm/TreeFormatter.js
var make89 = (value6, forest = []) => ({
  value: value6,
  forest
});
var formatIssue = (issue) => map13(go2(issue), (tree) => drawTree2(tree));
var formatIssueSync = (issue) => runSync(formatIssue(issue));
var formatErrorSync = (error2) => formatIssueSync(error2.issue);
var drawTree2 = (tree) => tree.value + draw2("\n", tree.forest);
var draw2 = (indentation, forest) => {
  let r = "";
  const len = forest.length;
  let tree;
  for (let i = 0;i < len; i++) {
    tree = forest[i];
    const isLast = i === len - 1;
    r += indentation + (isLast ? "\u2514" : "\u251C") + "\u2500 " + tree.value;
    r += draw2(indentation + (len > 1 && !isLast ? "\u2502  " : "   "), tree.forest);
  }
  return r;
};
var formatTransformationKind2 = (kind) => {
  switch (kind) {
    case "Encoded":
      return "Encoded side transformation failure";
    case "Transformation":
      return "Transformation process failure";
    case "Type":
      return "Type side transformation failure";
  }
};
var formatRefinementKind2 = (kind) => {
  switch (kind) {
    case "From":
      return "From side refinement failure";
    case "Predicate":
      return "Predicate refinement failure";
  }
};
var getAnnotated2 = (issue) => ("ast" in issue) ? some2(issue.ast) : none2();
var getCurrentMessage2 = (issue) => getAnnotated2(issue).pipe(flatMap(getMessageAnnotation2), flatMap10((annotation) => {
  const out = annotation(issue);
  return isString(out) ? succeed7({
    message: out,
    override: false
  }) : isEffect2(out) ? map13(out, (message) => ({
    message,
    override: false
  })) : isString(out.message) ? succeed7({
    message: out.message,
    override: out.override
  }) : map13(out.message, (message) => ({
    message,
    override: out.override
  }));
}));
var createParseIssueGuard2 = (tag2) => (issue) => issue._tag === tag2;
var isComposite3 = /* @__PURE__ */ createParseIssueGuard2("Composite");
var isRefinement4 = /* @__PURE__ */ createParseIssueGuard2("Refinement");
var isTransformation4 = /* @__PURE__ */ createParseIssueGuard2("Transformation");
var getMessage2 = (issue) => getCurrentMessage2(issue).pipe(flatMap10((currentMessage) => {
  const useInnerMessage = !currentMessage.override && (isComposite3(issue) || isRefinement4(issue) && issue.kind === "From" || isTransformation4(issue) && issue.kind !== "Transformation");
  return useInnerMessage ? isTransformation4(issue) || isRefinement4(issue) ? getMessage2(issue.issue) : none2() : succeed7(currentMessage.message);
}));
var getParseIssueTitleAnnotation4 = (issue) => getAnnotated2(issue).pipe(flatMap(getParseIssueTitleAnnotation3), filterMap((annotation) => fromNullable(annotation(issue))));
var formatTypeMessage2 = (e) => getMessage2(e).pipe(orElse5(() => getParseIssueTitleAnnotation4(e)), catchAll3(() => succeed7(e.message ?? `Expected ${String(e.ast)}, actual ${formatUnknown2(e.actual)}`)));
var getParseIssueTitle2 = (issue) => getOrElse(getParseIssueTitleAnnotation4(issue), () => String(issue.ast));
var formatForbiddenMessage2 = (e) => e.message ?? "is forbidden";
var formatUnexpectedMessage2 = (e) => e.message ?? "is unexpected";
var formatMissingMessage2 = (e) => getMissingMessageAnnotation2(e.ast).pipe(flatMap10((annotation) => {
  const out = annotation();
  return isString(out) ? succeed7(out) : out;
}), catchAll3(() => succeed7(e.message ?? "is missing")));
var getTree = (issue, onFailure) => matchEffect2(getMessage2(issue), {
  onFailure,
  onSuccess: (message) => succeed7(make89(message))
});
var go2 = (e) => {
  switch (e._tag) {
    case "Type":
      return map13(formatTypeMessage2(e), make89);
    case "Forbidden":
      return succeed7(make89(getParseIssueTitle2(e), [make89(formatForbiddenMessage2(e))]));
    case "Unexpected":
      return succeed7(make89(formatUnexpectedMessage2(e)));
    case "Missing":
      return map13(formatMissingMessage2(e), make89);
    case "Transformation":
      return getTree(e, () => map13(go2(e.issue), (tree) => make89(getParseIssueTitle2(e), [make89(formatTransformationKind2(e.kind), [tree])])));
    case "Refinement":
      return getTree(e, () => map13(go2(e.issue), (tree) => make89(getParseIssueTitle2(e), [make89(formatRefinementKind2(e.kind), [tree])])));
    case "Pointer":
      return map13(go2(e.issue), (tree) => make89(formatPath2(e.path), [tree]));
    case "Composite": {
      const parseIssueTitle = getParseIssueTitle2(e);
      return getTree(e, () => isNonEmpty9(e.issues) ? map13(forEach8(e.issues, go2), (forest) => make89(parseIssueTitle, forest)) : map13(go2(e.issues), (tree) => make89(parseIssueTitle, [tree])));
    }
  }
};
// node_modules/@effect/schema/dist/esm/ParseResult.js
function sortByIndex2(es) {
  return es.sort(compare2).map((t2) => t2[1]);
}

class Pointer2 {
  path;
  actual;
  issue;
  _tag = "Pointer";
  constructor(path, actual, issue) {
    this.path = path;
    this.actual = actual;
    this.issue = issue;
  }
}

class Unexpected2 {
  actual;
  message;
  _tag = "Unexpected";
  constructor(actual, message) {
    this.actual = actual;
    this.message = message;
  }
}

class Missing2 {
  ast;
  message;
  _tag = "Missing";
  actual = undefined;
  constructor(ast, message) {
    this.ast = ast;
    this.message = message;
  }
}

class Composite4 {
  ast;
  actual;
  issues;
  output;
  _tag = "Composite";
  constructor(ast, actual, issues, output) {
    this.ast = ast;
    this.actual = actual;
    this.issues = issues;
    this.output = output;
  }
}
class Refinement4 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Refinement";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Transformation4 {
  ast;
  actual;
  kind;
  issue;
  _tag = "Transformation";
  constructor(ast, actual, kind, issue) {
    this.ast = ast;
    this.actual = actual;
    this.kind = kind;
    this.issue = issue;
  }
}

class Type5 {
  ast;
  actual;
  message;
  _tag = "Type";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}

class Forbidden2 {
  ast;
  actual;
  message;
  _tag = "Forbidden";
  constructor(ast, actual, message) {
    this.ast = ast;
    this.actual = actual;
    this.message = message;
  }
}
var ParseErrorTypeId2 = /* @__PURE__ */ Symbol.for("@effect/schema/ParseErrorTypeId");
class ParseError4 extends (/* @__PURE__ */ TaggedError("ParseError")) {
  [ParseErrorTypeId2] = ParseErrorTypeId2;
  get message() {
    return this.toString();
  }
  toString() {
    return formatIssueSync(this.issue);
  }
  toJSON() {
    return {
      _id: "ParseError",
      message: this.toString()
    };
  }
  [NodeInspectSymbol]() {
    return this.toJSON();
  }
}
var parseError2 = (issue) => new ParseError4({
  issue
});
var succeed22 = right2;
var fail20 = left2;
var _try2 = try_;
var fromOption6 = fromOption2;
var flatMap19 = /* @__PURE__ */ dual(2, (self2, f) => {
  const s = self2;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return f(s.right);
  }
  return flatMap10(self2, f);
});
var map33 = /* @__PURE__ */ dual(2, (self2, f) => {
  const s = self2;
  if (s["_tag"] === "Left") {
    return s;
  }
  if (s["_tag"] === "Right") {
    return right2(f(s.right));
  }
  return map13(self2, f);
});
var mapError10 = /* @__PURE__ */ dual(2, (self2, f) => {
  const s = self2;
  if (s["_tag"] === "Left") {
    return left2(f(s.left));
  }
  if (s["_tag"] === "Right") {
    return s;
  }
  return mapError3(self2, f);
});
var eitherOrUndefined = (self2) => {
  const s = self2;
  if (s["_tag"] === "Left" || s["_tag"] === "Right") {
    return s;
  }
};
var mapBoth9 = /* @__PURE__ */ dual(2, (self2, options) => {
  const s = self2;
  if (s["_tag"] === "Left") {
    return left2(options.onFailure(s.left));
  }
  if (s["_tag"] === "Right") {
    return right2(options.onSuccess(s.right));
  }
  return mapBoth2(self2, options);
});
var mergeInternalOptions2 = (options, overrideOptions) => {
  if (overrideOptions === undefined || isNumber(overrideOptions)) {
    return options;
  }
  if (options === undefined) {
    return overrideOptions;
  }
  return {
    ...options,
    ...overrideOptions
  };
};
var getEither2 = (ast, isDecoding, options) => {
  const parser = goMemo2(ast, isDecoding);
  return (u, overrideOptions) => parser(u, mergeInternalOptions2(options, overrideOptions));
};
var getSync2 = (ast, isDecoding, options) => {
  const parser = getEither2(ast, isDecoding, options);
  return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError2);
};
var getOption4 = (ast, isDecoding, options) => {
  const parser = getEither2(ast, isDecoding, options);
  return (input, overrideOptions) => getRight2(parser(input, overrideOptions));
};
var getEffect = (ast, isDecoding, options) => {
  const parser = goMemo2(ast, isDecoding);
  return (input, overrideOptions) => parser(input, {
    ...mergeInternalOptions2(options, overrideOptions),
    isEffectAllowed: true
  });
};
var decodeUnknownSync2 = (schema, options) => getSync2(schema.ast, true, options);
var decodeUnknownOption2 = (schema, options) => getOption4(schema.ast, true, options);
var decodeUnknownEither2 = (schema, options) => getEither2(schema.ast, true, options);
var decodeUnknown3 = (schema, options) => getEffect(schema.ast, true, options);
var encodeUnknownSync2 = (schema, options) => getSync2(schema.ast, false, options);
var encodeUnknownOption2 = (schema, options) => getOption4(schema.ast, false, options);
var encodeUnknownEither2 = (schema, options) => getEither2(schema.ast, false, options);
var encodeUnknown2 = (schema, options) => getEffect(schema.ast, false, options);
var decodeSync2 = decodeUnknownSync2;
var decodeOption2 = decodeUnknownOption2;
var validateSync2 = (schema, options) => getSync2(typeAST2(schema.ast), true, options);
var validateOption2 = (schema, options) => getOption4(typeAST2(schema.ast), true, options);
var validateEither2 = (schema, options) => getEither2(typeAST2(schema.ast), true, options);
var validate5 = (schema, options) => getEffect(typeAST2(schema.ast), true, options);
var is3 = (schema, options) => {
  const parser = goMemo2(typeAST2(schema.ast), true);
  return (u, overrideOptions) => isRight2(parser(u, {
    exact: true,
    ...mergeInternalOptions2(options, overrideOptions)
  }));
};
var asserts2 = (schema, options) => {
  const parser = goMemo2(typeAST2(schema.ast), true);
  return (u, overrideOptions) => {
    const result = parser(u, {
      exact: true,
      ...mergeInternalOptions2(options, overrideOptions)
    });
    if (isLeft2(result)) {
      throw parseError2(result.left);
    }
  };
};
var encodeSync2 = encodeUnknownSync2;
var encodeOption2 = encodeUnknownOption2;
var decodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/decodeMemoMap"), () => new WeakMap);
var encodeMemoMap2 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/schema/Parser/encodeMemoMap"), () => new WeakMap);
var goMemo2 = (ast, isDecoding) => {
  const memoMap = isDecoding ? decodeMemoMap2 : encodeMemoMap2;
  const memo = memoMap.get(ast);
  if (memo) {
    return memo;
  }
  const raw = go3(ast, isDecoding);
  const parseOptionsAnnotation = getParseOptionsAnnotation2(ast);
  const parser = isSome2(parseOptionsAnnotation) ? (i, options) => raw(i, mergeInternalOptions2(options, parseOptionsAnnotation.value)) : raw;
  memoMap.set(ast, parser);
  return parser;
};
var getConcurrency2 = (ast) => getOrUndefined(getConcurrencyAnnotation2(ast));
var getBatching2 = (ast) => getOrUndefined(getBatchingAnnotation2(ast));
var go3 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Refinement": {
      if (isDecoding) {
        const from = goMemo2(ast.from, true);
        return (i, options) => handleForbidden2(flatMap19(mapError10(from(i, options), (e) => new Refinement4(ast, i, "From", e)), (a) => match2(ast.filter(a, options ?? defaultParseOption2, ast), {
          onNone: () => right2(a),
          onSome: (e) => left2(new Refinement4(ast, i, "Predicate", e))
        })), ast, i, options);
      } else {
        const from = goMemo2(typeAST2(ast), true);
        const to = goMemo2(dropRightRefinement2(ast.from), false);
        return (i, options) => handleForbidden2(flatMap19(from(i, options), (a) => to(a, options)), ast, i, options);
      }
    }
    case "Transformation": {
      const transform6 = getFinalTransformation2(ast.transformation, isDecoding);
      const from = isDecoding ? goMemo2(ast.from, true) : goMemo2(ast.to, false);
      const to = isDecoding ? goMemo2(ast.to, true) : goMemo2(ast.from, false);
      return (i1, options) => handleForbidden2(flatMap19(mapError10(from(i1, options), (e) => new Transformation4(ast, i1, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap19(mapError10(transform6(a, options ?? defaultParseOption2, ast), (e) => new Transformation4(ast, i1, "Transformation", e)), (i2) => mapError10(to(i2, options), (e) => new Transformation4(ast, i1, isDecoding ? "Type" : "Encoded", e)))), ast, i1, options);
    }
    case "Declaration": {
      const parse4 = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
      return (i, options) => handleForbidden2(parse4(i, options ?? defaultParseOption2, ast), ast, i, options);
    }
    case "Literal":
      return fromRefinement2(ast, (u) => u === ast.literal);
    case "UniqueSymbol":
      return fromRefinement2(ast, (u) => u === ast.symbol);
    case "UndefinedKeyword":
      return fromRefinement2(ast, isUndefined);
    case "VoidKeyword":
      return fromRefinement2(ast, isUndefined);
    case "NeverKeyword":
      return fromRefinement2(ast, isNever);
    case "UnknownKeyword":
    case "AnyKeyword":
      return right2;
    case "StringKeyword":
      return fromRefinement2(ast, isString);
    case "NumberKeyword":
      return fromRefinement2(ast, isNumber);
    case "BooleanKeyword":
      return fromRefinement2(ast, isBoolean);
    case "BigIntKeyword":
      return fromRefinement2(ast, isBigInt);
    case "SymbolKeyword":
      return fromRefinement2(ast, isSymbol);
    case "ObjectKeyword":
      return fromRefinement2(ast, isObject);
    case "Enums":
      return fromRefinement2(ast, (u) => ast.enums.some(([_2, value6]) => value6 === u));
    case "TemplateLiteral": {
      const regex2 = getTemplateLiteralRegExp2(ast);
      return fromRefinement2(ast, (u) => isString(u) && regex2.test(u));
    }
    case "TupleType": {
      const elements = ast.elements.map((e) => goMemo2(e.type, isDecoding));
      const rest = ast.rest.map((annotatedAST) => goMemo2(annotatedAST.type, isDecoding));
      let requiredTypes = ast.elements.filter((e) => !e.isOptional);
      if (ast.rest.length > 0) {
        requiredTypes = requiredTypes.concat(ast.rest.slice(1));
      }
      const requiredLen = requiredTypes.length;
      const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_2, i) => i).join(" | ") : "never";
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options) => {
        if (!isArray(input)) {
          return left2(new Type5(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const output = [];
        const len = input.length;
        for (let i2 = len;i2 <= requiredLen - 1; i2++) {
          const e = new Pointer2(i2, input, new Missing2(requiredTypes[i2 - len]));
          if (allErrors) {
            es.push([stepKey++, e]);
            continue;
          } else {
            return left2(new Composite4(ast, input, e, output));
          }
        }
        if (ast.rest.length === 0) {
          for (let i2 = ast.elements.length;i2 <= len - 1; i2++) {
            const e = new Pointer2(i2, input, new Unexpected2(input[i2], `is unexpected, expected: ${expectedIndexes}`));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left2(new Composite4(ast, input, e, output));
            }
          }
        }
        let i = 0;
        let queue = undefined;
        for (;i < elements.length; i++) {
          if (len < i + 1) {
            if (ast.elements[i].isOptional) {
              continue;
            }
          } else {
            const parser = elements[i];
            const te = parser(input[i], options);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite4(ast, input, e, sortByIndex2(output)));
                }
              }
              output.push([stepKey++, eu.right]);
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t2) => {
                if (isLeft2(t2)) {
                  const e = new Pointer2(index, input, t2.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite4(ast, input, e, sortByIndex2(output2)));
                  }
                }
                output2.push([nk, t2.right]);
                return _void;
              }));
            }
          }
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const [head8, ...tail] = rest;
          for (;i < len - tail.length; i++) {
            const te = head8(input[i], options);
            const eu = eitherOrUndefined(te);
            if (eu) {
              if (isLeft2(eu)) {
                const e = new Pointer2(i, input, eu.left);
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite4(ast, input, e, sortByIndex2(output)));
                }
              } else {
                output.push([stepKey++, eu.right]);
              }
            } else {
              const nk = stepKey++;
              const index = i;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap10(either3(te), (t2) => {
                if (isLeft2(t2)) {
                  const e = new Pointer2(index, input, t2.left);
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left2(new Composite4(ast, input, e, sortByIndex2(output2)));
                  }
                } else {
                  output2.push([nk, t2.right]);
                  return _void;
                }
              }));
            }
          }
          for (let j = 0;j < tail.length; j++) {
            i += j;
            if (len < i + 1) {
              continue;
            } else {
              const te = tail[j](input[i], options);
              const eu = eitherOrUndefined(te);
              if (eu) {
                if (isLeft2(eu)) {
                  const e = new Pointer2(i, input, eu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite4(ast, input, e, sortByIndex2(output)));
                  }
                }
                output.push([stepKey++, eu.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(te), (t2) => {
                  if (isLeft2(t2)) {
                    const e = new Pointer2(index, input, t2.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite4(ast, input, e, sortByIndex2(output2)));
                    }
                  }
                  output2.push([nk, t2.right]);
                  return _void;
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => isNonEmptyArray2(es2) ? left2(new Composite4(ast, input, sortByIndex2(es2), sortByIndex2(output2))) : right2(sortByIndex2(output2));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: copy(output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          output,
          es
        });
      };
    }
    case "TypeLiteral": {
      if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
        return fromRefinement2(ast, isNotNullable);
      }
      const propertySignatures = [];
      const expectedKeysMap = {};
      const expectedKeys = [];
      for (const ps of ast.propertySignatures) {
        propertySignatures.push([goMemo2(ps.type, isDecoding), ps]);
        expectedKeysMap[ps.name] = null;
        expectedKeys.push(ps.name);
      }
      const indexSignatures = ast.indexSignatures.map((is4) => [goMemo2(is4.parameter, isDecoding), goMemo2(is4.type, isDecoding), is4.parameter]);
      const expectedAST = Union4.make(ast.indexSignatures.map((is4) => is4.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol2(key) : new Literal3(key))));
      const expected = goMemo2(expectedAST, isDecoding);
      const concurrency = getConcurrency2(ast);
      const batching = getBatching2(ast);
      return (input, options) => {
        if (!isRecord(input)) {
          return left2(new Type5(ast, input));
        }
        const allErrors = options?.errors === "all";
        const es = [];
        let stepKey = 0;
        const onExcessPropertyError = options?.onExcessProperty === "error";
        const onExcessPropertyPreserve = options?.onExcessProperty === "preserve";
        const output = {};
        let inputKeys;
        if (onExcessPropertyError || onExcessPropertyPreserve) {
          inputKeys = ownKeys(input);
          for (const key of inputKeys) {
            const eu = eitherOrUndefined(expected(key, options));
            if (isLeft2(eu)) {
              if (onExcessPropertyError) {
                const e = new Pointer2(key, input, new Unexpected2(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left2(new Composite4(ast, input, e, output));
                }
              } else {
                output[key] = input[key];
              }
            }
          }
        }
        let queue = undefined;
        const isExact = options?.exact === true;
        for (let i = 0;i < propertySignatures.length; i++) {
          const ps = propertySignatures[i][1];
          const name = ps.name;
          const hasKey = Object.prototype.hasOwnProperty.call(input, name);
          if (!hasKey) {
            if (ps.isOptional) {
              continue;
            } else if (isExact) {
              const e = new Pointer2(name, input, new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite4(ast, input, e, output));
              }
            }
          }
          const parser = propertySignatures[i][0];
          const te = parser(input[name], options);
          const eu = eitherOrUndefined(te);
          if (eu) {
            if (isLeft2(eu)) {
              const e = new Pointer2(name, input, hasKey ? eu.left : new Missing2(ps));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left2(new Composite4(ast, input, e, output));
              }
            }
            output[name] = eu.right;
          } else {
            const nk = stepKey++;
            const index = name;
            if (!queue) {
              queue = [];
            }
            queue.push(({
              es: es2,
              output: output2
            }) => flatMap10(either3(te), (t2) => {
              if (isLeft2(t2)) {
                const e = new Pointer2(index, input, hasKey ? t2.left : new Missing2(ps));
                if (allErrors) {
                  es2.push([nk, e]);
                  return _void;
                } else {
                  return left2(new Composite4(ast, input, e, output2));
                }
              }
              output2[index] = t2.right;
              return _void;
            }));
          }
        }
        for (let i = 0;i < indexSignatures.length; i++) {
          const indexSignature = indexSignatures[i];
          const parameter = indexSignature[0];
          const type2 = indexSignature[1];
          const keys9 = getKeysForIndexSignature2(input, indexSignature[2]);
          for (const key of keys9) {
            const keu = eitherOrUndefined(parameter(key, options));
            if (keu && isRight2(keu)) {
              const vpr = type2(input[key], options);
              const veu = eitherOrUndefined(vpr);
              if (veu) {
                if (isLeft2(veu)) {
                  const e = new Pointer2(key, input, veu.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left2(new Composite4(ast, input, e, output));
                  }
                } else {
                  if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                    output[key] = veu.right;
                  }
                }
              } else {
                const nk = stepKey++;
                const index = key;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap10(either3(vpr), (tv) => {
                  if (isLeft2(tv)) {
                    const e = new Pointer2(index, input, tv.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left2(new Composite4(ast, input, e, output2));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output2[key] = tv.right;
                    }
                    return _void;
                  }
                }));
              }
            }
          }
        }
        const computeResult = ({
          es: es2,
          output: output2
        }) => {
          if (isNonEmptyArray2(es2)) {
            return left2(new Composite4(ast, input, sortByIndex2(es2), output2));
          }
          if (options?.propertyOrder === "original") {
            const keys9 = inputKeys || ownKeys(input);
            for (const name of expectedKeys) {
              if (keys9.indexOf(name) === -1) {
                keys9.push(name);
              }
            }
            const out = {};
            for (const key of keys9) {
              if (Object.prototype.hasOwnProperty.call(output2, key)) {
                out[key] = output2[key];
              }
            }
            return right2(out);
          }
          return right2(output2);
        };
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es),
              output: Object.assign({}, output)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => computeResult(state));
          });
        }
        return computeResult({
          es,
          output
        });
      };
    }
    case "Union": {
      const searchTree = getSearchTree2(ast.types, isDecoding);
      const ownKeys2 = ownKeys(searchTree.keys);
      const len = ownKeys2.length;
      const map34 = new Map;
      for (let i = 0;i < ast.types.length; i++) {
        map34.set(ast.types[i], goMemo2(ast.types[i], isDecoding));
      }
      const concurrency = getConcurrency2(ast) ?? 1;
      const batching = getBatching2(ast);
      return (input, options) => {
        const es = [];
        let stepKey = 0;
        let candidates = [];
        if (len > 0) {
          if (isRecord(input)) {
            for (let i = 0;i < len; i++) {
              const name = ownKeys2[i];
              const buckets = searchTree.keys[name].buckets;
              if (Object.prototype.hasOwnProperty.call(input, name)) {
                const literal2 = String(input[name]);
                if (Object.prototype.hasOwnProperty.call(buckets, literal2)) {
                  candidates = candidates.concat(buckets[literal2]);
                } else {
                  const literals = Union4.make(searchTree.keys[name].literals);
                  es.push([stepKey++, new Composite4(new TypeLiteral2([new PropertySignature2(name, literals, false, true)], []), input, new Pointer2(name, input, new Type5(literals, input[name])))]);
                }
              } else {
                const literals = Union4.make(searchTree.keys[name].literals);
                const fakeps = new PropertySignature2(name, literals, false, true);
                es.push([stepKey++, new Composite4(new TypeLiteral2([fakeps], []), input, new Pointer2(name, input, new Missing2(fakeps)))]);
              }
            }
          } else {
            es.push([stepKey++, new Type5(ast, input)]);
          }
        }
        if (searchTree.otherwise.length > 0) {
          candidates = candidates.concat(searchTree.otherwise);
        }
        let queue = undefined;
        for (let i = 0;i < candidates.length; i++) {
          const candidate = candidates[i];
          const pr = map34.get(candidate)(input, options);
          const eu = !queue || queue.length === 0 ? eitherOrUndefined(pr) : undefined;
          if (eu) {
            if (isRight2(eu)) {
              return right2(eu.right);
            } else {
              es.push([stepKey++, eu.left]);
            }
          } else {
            const nk = stepKey++;
            if (!queue) {
              queue = [];
            }
            queue.push((state) => suspend3(() => {
              if ("finalResult" in state) {
                return _void;
              } else {
                return flatMap10(either3(pr), (t2) => {
                  if (isRight2(t2)) {
                    state.finalResult = right2(t2.right);
                  } else {
                    state.es.push([nk, t2.left]);
                  }
                  return _void;
                });
              }
            }));
          }
        }
        const computeResult = (es2) => isNonEmptyArray2(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left2(es2[0][1]) : left2(new Composite4(ast, input, sortByIndex2(es2))) : left2(new Type5(ast, input));
        if (queue && queue.length > 0) {
          const cqueue = queue;
          return suspend3(() => {
            const state = {
              es: copy(es)
            };
            return flatMap10(forEach8(cqueue, (f) => f(state), {
              concurrency,
              batching,
              discard: true
            }), () => {
              if ("finalResult" in state) {
                return state.finalResult;
              }
              return computeResult(state.es);
            });
          });
        }
        return computeResult(es);
      };
    }
    case "Suspend": {
      const get32 = memoizeThunk2(() => goMemo2(annotations2(ast.f(), ast.annotations), isDecoding));
      return (a, options) => get32()(a, options);
    }
  }
};
var fromRefinement2 = (ast, refinement) => (u) => refinement(u) ? right2(u) : left2(new Type5(ast, u));
var getLiterals2 = (ast, isDecoding) => {
  switch (ast._tag) {
    case "Declaration": {
      const annotation = getSurrogateAnnotation2(ast);
      if (isSome2(annotation)) {
        return getLiterals2(annotation.value, isDecoding);
      }
      break;
    }
    case "TypeLiteral": {
      const out = [];
      for (let i = 0;i < ast.propertySignatures.length; i++) {
        const propertySignature = ast.propertySignatures[i];
        const type2 = isDecoding ? encodedAST2(propertySignature.type) : typeAST2(propertySignature.type);
        if (isLiteral2(type2) && !propertySignature.isOptional) {
          out.push([propertySignature.name, type2]);
        }
      }
      return out;
    }
    case "Refinement":
      return getLiterals2(ast.from, isDecoding);
    case "Suspend":
      return getLiterals2(ast.f(), isDecoding);
    case "Transformation":
      return getLiterals2(isDecoding ? ast.from : ast.to, isDecoding);
  }
  return [];
};
var getSearchTree2 = (members, isDecoding) => {
  const keys9 = {};
  const otherwise = [];
  for (let i = 0;i < members.length; i++) {
    const member = members[i];
    const tags2 = getLiterals2(member, isDecoding);
    if (tags2.length > 0) {
      for (let j = 0;j < tags2.length; j++) {
        const [key, literal2] = tags2[j];
        const hash3 = String(literal2.literal);
        keys9[key] = keys9[key] || {
          buckets: {},
          literals: []
        };
        const buckets = keys9[key].buckets;
        if (Object.prototype.hasOwnProperty.call(buckets, hash3)) {
          if (j < tags2.length - 1) {
            continue;
          }
          buckets[hash3].push(member);
          keys9[key].literals.push(literal2);
        } else {
          buckets[hash3] = [member];
          keys9[key].literals.push(literal2);
          break;
        }
      }
    } else {
      otherwise.push(member);
    }
  }
  return {
    keys: keys9,
    otherwise
  };
};
var dropRightRefinement2 = (ast) => isRefinement3(ast) ? dropRightRefinement2(ast.from) : ast;
var handleForbidden2 = (effect4, ast, actual, options) => {
  const eu = eitherOrUndefined(effect4);
  if (eu) {
    return eu;
  }
  if (options?.isEffectAllowed === true) {
    return effect4;
  }
  try {
    return runSync(either3(effect4));
  } catch (e) {
    return left2(new Forbidden2(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  }
};
var compare2 = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
var getFinalTransformation2 = (transformation, isDecoding) => {
  switch (transformation._tag) {
    case "FinalTransformation":
      return isDecoding ? transformation.decode : transformation.encode;
    case "ComposeTransformation":
      return right2;
    case "TypeLiteralTransformation":
      return (input) => {
        let out = right2(input);
        for (const pst of transformation.propertySignatureTransformations) {
          const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
          const transformation2 = isDecoding ? pst.decode : pst.encode;
          const f = (input2) => {
            const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some2(input2[from]) : none2());
            delete input2[from];
            if (isSome2(o)) {
              input2[to] = o.value;
            }
            return input2;
          };
          out = map33(out, f);
        }
        return out;
      };
  }
};

// node_modules/@effect/schema/dist/esm/Equivalence.js
var EquivalenceHookId = /* @__PURE__ */ Symbol.for("@effect/schema/EquivalenceHookId");
// node_modules/@effect/schema/dist/esm/Pretty.js
var PrettyHookId = /* @__PURE__ */ Symbol.for("@effect/schema/PrettyHookId");
// node_modules/@effect/schema/dist/esm/Schema.js
var exports_Schema2 = {};
__export(exports_Schema2, {
  withDefaults: () => withDefaults,
  withDecodingDefault: () => withDecodingDefault,
  withConstructorDefault: () => withConstructorDefault,
  validateSync: () => validateSync2,
  validatePromise: () => validatePromise,
  validateOption: () => validateOption2,
  validateEither: () => validateEither3,
  validate: () => validate6,
  validDate: () => validDate,
  uppercased: () => uppercased,
  uncapitalized: () => uncapitalized,
  typeSchema: () => typeSchema,
  trimmed: () => trimmed,
  transformOrFail: () => transformOrFail,
  transformLiterals: () => transformLiterals,
  transformLiteral: () => transformLiteral,
  transform: () => transform6,
  tag: () => tag2,
  suspend: () => suspend11,
  startsWith: () => startsWith,
  split: () => split3,
  requiredToOptional: () => requiredToOptional,
  required: () => required3,
  rename: () => rename3,
  refineTypeId: () => refineTypeId,
  propertySignature: () => propertySignature,
  positiveBigInt: () => positiveBigInt,
  positiveBigDecimal: () => positiveBigDecimal,
  positive: () => positive,
  pluck: () => pluck,
  pickLiteral: () => pickLiteral,
  pick: () => pick6,
  pattern: () => pattern2,
  partial: () => partial3,
  parseNumber: () => parseNumber,
  parseJson: () => parseJson,
  optionalToRequired: () => optionalToRequired,
  optionalToOptional: () => optionalToOptional,
  optionalElement: () => optionalElement,
  optional: () => optional,
  omit: () => omit6,
  nonPositiveBigInt: () => nonPositiveBigInt,
  nonPositiveBigDecimal: () => nonPositiveBigDecimal,
  nonPositive: () => nonPositive,
  nonNegativeBigInt: () => nonNegativeBigInt,
  nonNegativeBigDecimal: () => nonNegativeBigDecimal,
  nonNegative: () => nonNegative,
  nonNaN: () => nonNaN,
  nonEmpty: () => nonEmpty,
  negativeBigInt: () => negativeBigInt,
  negativeBigDecimal: () => negativeBigDecimal,
  negative: () => negative,
  mutable: () => mutable3,
  multipleOf: () => multipleOf,
  minLength: () => minLength,
  minItems: () => minItems,
  maxLength: () => maxLength,
  maxItems: () => maxItems,
  makePropertySignature: () => makePropertySignature,
  make: () => make90,
  lowercased: () => lowercased,
  lessThanOrEqualToDuration: () => lessThanOrEqualToDuration,
  lessThanOrEqualToBigInt: () => lessThanOrEqualToBigInt,
  lessThanOrEqualToBigDecimal: () => lessThanOrEqualToBigDecimal,
  lessThanOrEqualTo: () => lessThanOrEqualTo5,
  lessThanDuration: () => lessThanDuration,
  lessThanBigInt: () => lessThanBigInt,
  lessThanBigDecimal: () => lessThanBigDecimal,
  lessThan: () => lessThan9,
  length: () => length3,
  keyof: () => keyof3,
  itemsCount: () => itemsCount,
  isSchema: () => isSchema,
  is: () => is3,
  int: () => int,
  instanceOf: () => instanceOf2,
  includes: () => includes,
  headOrElse: () => headOrElse,
  head: () => head8,
  greaterThanOrEqualToDuration: () => greaterThanOrEqualToDuration,
  greaterThanOrEqualToBigInt: () => greaterThanOrEqualToBigInt,
  greaterThanOrEqualToBigDecimal: () => greaterThanOrEqualToBigDecimal,
  greaterThanOrEqualTo: () => greaterThanOrEqualTo6,
  greaterThanDuration: () => greaterThanDuration,
  greaterThanBigInt: () => greaterThanBigInt,
  greaterThanBigDecimal: () => greaterThanBigDecimal,
  greaterThan: () => greaterThan6,
  getNumberIndexedAccess: () => getNumberIndexedAccess3,
  getClassTag: () => getClassTag,
  fromKey: () => fromKey,
  fromBrand: () => fromBrand,
  format: () => format6,
  finite: () => finite,
  filterEffect: () => filterEffect2,
  filter: () => filter16,
  extend: () => extend3,
  endsWith: () => endsWith,
  encodedSchema: () => encodedSchema,
  encodedBoundSchema: () => encodedBoundSchema,
  encodeUnknownSync: () => encodeUnknownSync2,
  encodeUnknownPromise: () => encodeUnknownPromise,
  encodeUnknownOption: () => encodeUnknownOption2,
  encodeUnknownEither: () => encodeUnknownEither3,
  encodeUnknown: () => encodeUnknown3,
  encodeSync: () => encodeSync2,
  encodePromise: () => encodePromise,
  encodeOption: () => encodeOption2,
  encodeEither: () => encodeEither,
  encode: () => encode5,
  element: () => element,
  decodeUnknownSync: () => decodeUnknownSync2,
  decodeUnknownPromise: () => decodeUnknownPromise,
  decodeUnknownOption: () => decodeUnknownOption2,
  decodeUnknownEither: () => decodeUnknownEither3,
  decodeUnknown: () => decodeUnknown4,
  decodeSync: () => decodeSync2,
  decodePromise: () => decodePromise,
  decodeOption: () => decodeOption2,
  decodeEither: () => decodeEither,
  decode: () => decode6,
  declare: () => declare2,
  compose: () => compose4,
  clampDuration: () => clampDuration,
  clampBigInt: () => clampBigInt,
  clampBigDecimal: () => clampBigDecimal,
  clamp: () => clamp8,
  capitalized: () => capitalized,
  brand: () => brand,
  betweenDuration: () => betweenDuration,
  betweenBigInt: () => betweenBigInt,
  betweenBigDecimal: () => betweenBigDecimal,
  between: () => between5,
  attachPropertySignature: () => attachPropertySignature,
  asserts: () => asserts2,
  asSchema: () => asSchema,
  annotations: () => annotations3,
  Void: () => Void2,
  ValidDateTypeId: () => ValidDateTypeId,
  ValidDateFromSelf: () => ValidDateFromSelf,
  UppercasedTypeId: () => UppercasedTypeId,
  Uppercased: () => Uppercased,
  Uppercase: () => Uppercase2,
  Unknown: () => Unknown2,
  UniqueSymbolFromSelf: () => UniqueSymbolFromSelf,
  Union: () => Union5,
  UndefinedOr: () => UndefinedOr,
  Undefined: () => Undefined2,
  UncapitalizedTypeId: () => UncapitalizedTypeId,
  Uncapitalized: () => Uncapitalized,
  Uncapitalize: () => Uncapitalize2,
  Uint8ArrayFromSelf: () => Uint8ArrayFromSelf,
  Uint8Array: () => Uint8Array$,
  UUIDTypeId: () => UUIDTypeId,
  UUID: () => UUID2,
  ULIDTypeId: () => ULIDTypeId,
  ULID: () => ULID,
  TypeId: () => TypeId32,
  Tuple: () => Tuple2,
  TrimmedTypeId: () => TrimmedTypeId,
  Trimmed: () => Trimmed,
  Trim: () => Trim,
  ToPropertySignature: () => ToPropertySignature,
  TemplateLiteral: () => TemplateLiteral4,
  TaggedStruct: () => TaggedStruct,
  TaggedRequest: () => TaggedRequest,
  TaggedError: () => TaggedError2,
  TaggedClass: () => TaggedClass2,
  SymbolFromSelf: () => SymbolFromSelf,
  Symbol: () => Symbol$,
  Struct: () => Struct,
  String: () => String$2,
  StartsWithTypeId: () => StartsWithTypeId,
  SortedSetFromSelf: () => SortedSetFromSelf,
  SortedSet: () => SortedSet,
  SetFromSelf: () => SetFromSelf,
  Set: () => set16,
  RedactedFromSelf: () => RedactedFromSelf,
  Redacted: () => Redacted,
  Record: () => Record2,
  ReadonlySetFromSelf: () => ReadonlySetFromSelf,
  ReadonlySet: () => ReadonlySet,
  ReadonlyMapFromSelf: () => ReadonlyMapFromSelf,
  ReadonlyMapFromRecord: () => ReadonlyMapFromRecord,
  ReadonlyMap: () => ReadonlyMap,
  PropertySignatureTypeId: () => PropertySignatureTypeId,
  PropertySignatureTransformation: () => PropertySignatureTransformation3,
  PropertySignatureDeclaration: () => PropertySignatureDeclaration,
  PositiveBigIntFromSelf: () => PositiveBigIntFromSelf,
  PositiveBigInt: () => PositiveBigInt,
  PositiveBigDecimalTypeId: () => PositiveBigDecimalTypeId,
  PositiveBigDecimalFromSelf: () => PositiveBigDecimalFromSelf,
  Positive: () => Positive,
  PatternTypeId: () => PatternTypeId,
  OptionFromUndefinedOr: () => OptionFromUndefinedOr,
  OptionFromSelf: () => OptionFromSelf,
  OptionFromNullishOr: () => OptionFromNullishOr,
  OptionFromNullOr: () => OptionFromNullOr,
  Option: () => Option,
  Object: () => Object$,
  NumberFromString: () => NumberFromString,
  Number: () => Number$,
  NullishOr: () => NullishOr,
  NullOr: () => NullOr,
  Null: () => Null2,
  Not: () => Not3,
  NonPositiveBigIntFromSelf: () => NonPositiveBigIntFromSelf,
  NonPositiveBigInt: () => NonPositiveBigInt,
  NonPositiveBigDecimalTypeId: () => NonPositiveBigDecimalTypeId,
  NonPositiveBigDecimalFromSelf: () => NonPositiveBigDecimalFromSelf,
  NonPositive: () => NonPositive,
  NonNegativeBigIntFromSelf: () => NonNegativeBigIntFromSelf,
  NonNegativeBigInt: () => NonNegativeBigInt,
  NonNegativeBigDecimalTypeId: () => NonNegativeBigDecimalTypeId,
  NonNegativeBigDecimalFromSelf: () => NonNegativeBigDecimalFromSelf,
  NonNegative: () => NonNegative,
  NonNaNTypeId: () => NonNaNTypeId,
  NonNaN: () => NonNaN,
  NonEmptyChunkFromSelf: () => NonEmptyChunkFromSelf,
  NonEmptyChunk: () => NonEmptyChunk,
  NonEmptyArray: () => NonEmptyArray,
  NonEmpty: () => NonEmpty,
  Never: () => Never2,
  NegativeBigIntFromSelf: () => NegativeBigIntFromSelf,
  NegativeBigInt: () => NegativeBigInt,
  NegativeBigDecimalTypeId: () => NegativeBigDecimalTypeId,
  NegativeBigDecimalFromSelf: () => NegativeBigDecimalFromSelf,
  Negative: () => Negative,
  MultipleOfTypeId: () => MultipleOfTypeId,
  MinLengthTypeId: () => MinLengthTypeId2,
  MinItemsTypeId: () => MinItemsTypeId2,
  MaxLengthTypeId: () => MaxLengthTypeId2,
  MaxItemsTypeId: () => MaxItemsTypeId2,
  MapFromSelf: () => MapFromSelf,
  MapFromRecord: () => MapFromRecord,
  Map: () => map34,
  LowercasedTypeId: () => LowercasedTypeId,
  Lowercased: () => Lowercased,
  Lowercase: () => Lowercase2,
  Literal: () => Literal4,
  ListFromSelf: () => ListFromSelf,
  List: () => List,
  LessThanTypeId: () => LessThanTypeId2,
  LessThanOrEqualToTypeId: () => LessThanOrEqualToTypeId2,
  LessThanOrEqualToDurationTypeId: () => LessThanOrEqualToDurationTypeId,
  LessThanOrEqualToBigIntTypeId: () => LessThanOrEqualToBigIntTypeId2,
  LessThanOrEqualToBigDecimalTypeId: () => LessThanOrEqualToBigDecimalTypeId,
  LessThanDurationTypeId: () => LessThanDurationTypeId,
  LessThanBigIntTypeId: () => LessThanBigIntTypeId2,
  LessThanBigDecimalTypeId: () => LessThanBigDecimalTypeId,
  LengthTypeId: () => LengthTypeId2,
  JsonNumberTypeId: () => JsonNumberTypeId,
  JsonNumber: () => JsonNumber,
  ItemsCountTypeId: () => ItemsCountTypeId2,
  IntTypeId: () => IntTypeId2,
  Int: () => Int,
  InstanceOfTypeId: () => InstanceOfTypeId,
  IncludesTypeId: () => IncludesTypeId,
  Hex: () => Hex,
  HashSetFromSelf: () => HashSetFromSelf,
  HashSet: () => HashSet,
  HashMapFromSelf: () => HashMapFromSelf,
  HashMap: () => HashMap,
  GreaterThanTypeId: () => GreaterThanTypeId2,
  GreaterThanOrEqualToTypeId: () => GreaterThanOrEqualToTypeId2,
  GreaterThanOrEqualToDurationTypeId: () => GreaterThanOrEqualToDurationTypeId,
  GreaterThanOrEqualToBigIntTypeId: () => GreaterThanOrEqualToBigIntTypeId2,
  GreaterThanOrEqualToBigDecimalTypeId: () => GreaterThanOrEqualToBigDecimalTypeId,
  GreaterThanDurationTypeId: () => GreaterThanDurationTypeId,
  GreaterThanBigIntTypeId: () => GreaterThanBigIntTypeId,
  GreaterThanBigDecimalTypeId: () => GreaterThanBigDecimalTypeId,
  FromPropertySignature: () => FromPropertySignature,
  FiniteTypeId: () => FiniteTypeId,
  Finite: () => Finite,
  FiberIdFromSelf: () => FiberIdFromSelf,
  FiberId: () => FiberId,
  ExitFromSelf: () => ExitFromSelf,
  Exit: () => Exit,
  Enums: () => Enums3,
  EndsWithTypeId: () => EndsWithTypeId,
  EitherFromUnion: () => EitherFromUnion,
  EitherFromSelf: () => EitherFromSelf,
  Either: () => Either2,
  DurationFromSelf: () => DurationFromSelf,
  DurationFromNanos: () => DurationFromNanos,
  DurationFromMillis: () => DurationFromMillis,
  Duration: () => Duration,
  DateFromString: () => DateFromString,
  DateFromSelf: () => DateFromSelf2,
  DateFromNumber: () => DateFromNumber,
  Date: () => Date$,
  DataFromSelf: () => DataFromSelf,
  Data: () => Data,
  Config: () => Config,
  Class: () => Class5,
  ChunkFromSelf: () => ChunkFromSelf,
  Chunk: () => Chunk,
  Char: () => Char,
  CauseFromSelf: () => CauseFromSelf,
  CauseDefectUnknown: () => CauseDefectUnknown,
  Cause: () => Cause,
  CapitalizedTypeId: () => CapitalizedTypeId,
  Capitalized: () => Capitalized,
  Capitalize: () => Capitalize2,
  BrandTypeId: () => BrandTypeId,
  BooleanFromUnknown: () => BooleanFromUnknown,
  Boolean: () => Boolean$,
  BigIntFromSelf: () => BigIntFromSelf,
  BigIntFromNumber: () => BigIntFromNumber,
  BigInt: () => BigInt$,
  BigDecimalFromSelf: () => BigDecimalFromSelf,
  BigDecimalFromNumber: () => BigDecimalFromNumber,
  BigDecimal: () => BigDecimal,
  BetweenTypeId: () => BetweenTypeId2,
  BetweenDurationTypeId: () => BetweenDurationTypeId,
  BetweenBigIntTypeId: () => BetweenBigIntTypeId,
  BetweenBigDecimalTypeId: () => BetweenBigDecimalTypeId,
  Base64Url: () => Base64Url,
  Base64: () => Base64,
  Array: () => Array$,
  Any: () => Any2
});

// node_modules/@effect/schema/dist/esm/internal/serializable.js
var symbol4 = /* @__PURE__ */ Symbol.for("@effect/schema/Serializable/symbol");
var symbolResult = /* @__PURE__ */ Symbol.for("@effect/schema/Serializable/symbolResult");

// node_modules/@effect/schema/dist/esm/Schema.js
function Literal4(...literals) {
  return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never2;
}
function Union5(...members) {
  return isMembers2(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never2;
}
function Tuple2(...args2) {
  return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
}
function Struct(fields, ...records) {
  return makeTypeLiteralClass(fields, records);
}
function filter16(predicate, annotations3) {
  return (self2) => {
    function filter17(input, options, ast2) {
      return toFilterParseIssue2(predicate(input, options, ast2), ast2, input);
    }
    const ast = new Refinement3(self2.ast, filter17, toASTAnnotations2(annotations3));
    return makeRefineClass2(self2, filter17, ast);
  };
}
function transformLiterals(...pairs) {
  return Union5(...pairs.map(([from, to]) => transformLiteral(from, to)));
}
function causeDecode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return empty30;
    case "Fail":
      return fail4(cause3.error);
    case "Die":
      return die4(cause3.defect);
    case "Interrupt":
      return interrupt5(fiberIdDecode(cause3.fiberId));
    case "Sequential":
      return sequential4(causeDecode(cause3.left), causeDecode(cause3.right));
    case "Parallel":
      return parallel4(causeDecode(cause3.left), causeDecode(cause3.right));
  }
}
function causeEncode(cause3) {
  switch (cause3._tag) {
    case "Empty":
      return {
        _tag: "Empty"
      };
    case "Fail":
      return {
        _tag: "Fail",
        error: cause3.error
      };
    case "Die":
      return {
        _tag: "Die",
        defect: cause3.defect
      };
    case "Interrupt":
      return {
        _tag: "Interrupt",
        fiberId: cause3.fiberId
      };
    case "Sequential":
      return {
        _tag: "Sequential",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
    case "Parallel":
      return {
        _tag: "Parallel",
        left: causeEncode(cause3.left),
        right: causeEncode(cause3.right)
      };
  }
}
var TypeId32 = /* @__PURE__ */ Symbol.for("@effect/schema/Schema");
var make90 = (ast) => class SchemaClass {
  [TypeId32] = variance10;
  static Type;
  static Encoded;
  static [TypeId32] = variance10;
  static ast = ast;
  static annotations(annotations3) {
    return make90(mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static pipe() {
    return pipeArguments(this, arguments);
  }
  static toString() {
    return String(ast);
  }
};
var variance10 = {
  _A: (_2) => _2,
  _I: (_2) => _2,
  _R: (_2) => _2
};
var toASTAnnotations2 = (annotations3) => {
  if (!annotations3) {
    return {};
  }
  const out = {};
  const custom3 = Object.getOwnPropertySymbols(annotations3);
  for (const sym of custom3) {
    out[sym] = annotations3[sym];
  }
  if (annotations3.typeId !== undefined) {
    const typeId = annotations3.typeId;
    if (typeof typeId === "object") {
      out[TypeAnnotationId] = typeId.id;
      out[typeId.id] = typeId.annotation;
    } else {
      out[TypeAnnotationId] = typeId;
    }
  }
  const move = (from, to) => {
    if (annotations3[from] !== undefined) {
      out[to] = annotations3[from];
    }
  };
  move("message", MessageAnnotationId2);
  move("missingMessage", MissingMessageAnnotationId2);
  move("identifier", IdentifierAnnotationId2);
  move("title", TitleAnnotationId2);
  move("description", DescriptionAnnotationId2);
  move("examples", ExamplesAnnotationId2);
  move("default", DefaultAnnotationId2);
  move("documentation", DocumentationAnnotationId2);
  move("jsonSchema", JSONSchemaAnnotationId2);
  move("arbitrary", ArbitraryHookId);
  move("pretty", PrettyHookId);
  move("equivalence", EquivalenceHookId);
  move("concurrency", ConcurrencyAnnotationId2);
  move("batching", BatchingAnnotationId2);
  move("parseIssueTitle", ParseIssueTitleAnnotationId2);
  move("parseOptions", ParseOptionsAnnotationId2);
  return out;
};
var mergeSchemaAnnotations2 = (ast, annotations3) => annotations2(ast, toASTAnnotations2(annotations3));
var asSchema = (schema) => schema;
var format6 = (schema) => String(schema.ast);
var encodedSchema = (schema) => make90(encodedAST2(schema.ast));
var encodedBoundSchema = (schema) => make90(encodedBoundAST2(schema.ast));
var typeSchema = (schema) => make90(typeAST2(schema.ast));
var encodeUnknown3 = (schema, options) => {
  const encodeUnknown4 = encodeUnknown2(schema, options);
  return (u, overrideOptions) => mapError10(encodeUnknown4(u, overrideOptions), parseError2);
};
var encodeUnknownEither3 = (schema, options) => {
  const encodeUnknownEither4 = encodeUnknownEither2(schema, options);
  return (u, overrideOptions) => mapLeft(encodeUnknownEither4(u, overrideOptions), parseError2);
};
var encodeUnknownPromise = (schema, options) => {
  const parser = encodeUnknown3(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var encode5 = encodeUnknown3;
var encodeEither = encodeUnknownEither3;
var encodePromise = encodeUnknownPromise;
var decodeUnknown4 = (schema, options) => {
  const decodeUnknown5 = decodeUnknown3(schema, options);
  return (u, overrideOptions) => mapError10(decodeUnknown5(u, overrideOptions), parseError2);
};
var decodeUnknownEither3 = (schema, options) => {
  const decodeUnknownEither4 = decodeUnknownEither2(schema, options);
  return (u, overrideOptions) => mapLeft(decodeUnknownEither4(u, overrideOptions), parseError2);
};
var decodeUnknownPromise = (schema, options) => {
  const parser = decodeUnknown4(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var decode6 = decodeUnknown4;
var decodeEither = decodeUnknownEither3;
var decodePromise = decodeUnknownPromise;
var validate6 = (schema, options) => {
  const validate7 = validate5(schema, options);
  return (u, overrideOptions) => mapError10(validate7(u, overrideOptions), parseError2);
};
var validateEither3 = (schema, options) => {
  const validateEither4 = validateEither2(schema, options);
  return (u, overrideOptions) => mapLeft(validateEither4(u, overrideOptions), parseError2);
};
var validatePromise = (schema, options) => {
  const parser = validate6(schema, options);
  return (u, overrideOptions) => runPromise(parser(u, overrideOptions));
};
var isSchema = (u) => hasProperty(u, TypeId32) && isObject(u[TypeId32]);
var getDefaultLiteralAST = (literals) => isMembers2(literals) ? Union4.make(mapMembers2(literals, (literal2) => new Literal3(literal2))) : new Literal3(literals[0]);
var makeLiteralClass = (literals, ast = getDefaultLiteralAST(literals)) => class LiteralClass extends make90(ast) {
  static annotations(annotations3) {
    return makeLiteralClass(this.literals, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static literals = [...literals];
};
var pickLiteral = (...literals) => (_schema) => Literal4(...literals);
var UniqueSymbolFromSelf = (symbol5) => make90(new UniqueSymbol2(symbol5));
var getDefaultEnumsAST = (enums) => new Enums2(Object.keys(enums).filter((key) => typeof enums[enums[key]] !== "number").map((key) => [key, enums[key]]));
var makeEnumsClass = (enums, ast = getDefaultEnumsAST(enums)) => class EnumsClass extends make90(ast) {
  static annotations(annotations3) {
    return makeEnumsClass(this.enums, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static enums = {
    ...enums
  };
};
var Enums3 = (enums) => makeEnumsClass(enums);
var TemplateLiteral4 = (...[head8, ...tail]) => {
  let astOrs = getTemplateLiterals(getTemplateLiteralParameterAST(head8));
  for (const span4 of tail) {
    astOrs = flatMap2(astOrs, (a) => getTemplateLiterals(getTemplateLiteralParameterAST(span4)).map((b) => combineTemplateLiterals(a, b)));
  }
  return make90(Union4.make(astOrs.map((astOr) => isString(astOr) ? new Literal3(astOr) : astOr)));
};
var getTemplateLiteralParameterAST = (span4) => isSchema(span4) ? span4.ast : new Literal3(String(span4));
var combineTemplateLiterals = (a, b) => {
  if (isString(a)) {
    return isString(b) ? a + b : new TemplateLiteral3(a + b.head, b.spans);
  }
  if (isString(b)) {
    return new TemplateLiteral3(a.head, modifyNonEmptyLast(a.spans, (span4) => new TemplateLiteralSpan2(span4.type, span4.literal + b)));
  }
  return new TemplateLiteral3(a.head, appendAll(modifyNonEmptyLast(a.spans, (span4) => new TemplateLiteralSpan2(span4.type, span4.literal + String(b.head))), b.spans));
};
var getTemplateLiterals = (ast) => {
  switch (ast._tag) {
    case "Literal":
      return [String(ast.literal)];
    case "NumberKeyword":
    case "StringKeyword":
      return [new TemplateLiteral3("", [new TemplateLiteralSpan2(ast, "")])];
    case "Union":
      return flatMap2(ast.types, getTemplateLiterals);
  }
  throw new Error(getSchemaUnsupportedLiteralSpanErrorMessage2(ast));
};
var declareConstructor2 = (typeParameters, options, annotations3) => make90(new Declaration2(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options.decode(...typeParameters2.map(make90)), (...typeParameters2) => options.encode(...typeParameters2.map(make90)), toASTAnnotations2(annotations3)));
var declarePrimitive2 = (is4, annotations3) => {
  const decodeUnknown5 = () => (input, _2, ast) => is4(input) ? succeed22(input) : fail20(new Type5(ast, input));
  const encodeUnknown4 = decodeUnknown5;
  return make90(new Declaration2([], decodeUnknown5, encodeUnknown4, toASTAnnotations2(annotations3)));
};
var declare2 = function() {
  if (Array.isArray(arguments[0])) {
    const typeParameters = arguments[0];
    const options = arguments[1];
    const annotations4 = arguments[2];
    return declareConstructor2(typeParameters, options, annotations4);
  }
  const is4 = arguments[0];
  const annotations3 = arguments[1];
  return declarePrimitive2(is4, annotations3);
};
var BrandTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Brand");
var fromBrand = (constructor, annotations3) => (self2) => makeBrandClass(new Refinement3(self2.ast, function predicate(a, _2, ast) {
  const either8 = constructor.either(a);
  return isLeft2(either8) ? some2(new Type5(ast, a, either8.left.map((v) => v.message).join(", "))) : none2();
}, toASTAnnotations2({
  typeId: {
    id: BrandTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations3
})));
var InstanceOfTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/InstanceOf");
var instanceOf2 = (constructor, annotations3) => declare2((u) => u instanceof constructor, {
  title: constructor.name,
  description: `an instance of ${constructor.name}`,
  pretty: () => String,
  typeId: {
    id: InstanceOfTypeId,
    annotation: {
      constructor
    }
  },
  ...annotations3
});

class Undefined2 extends (/* @__PURE__ */ make90(undefinedKeyword2)) {
}

class Void2 extends (/* @__PURE__ */ make90(voidKeyword2)) {
}

class Null2 extends (/* @__PURE__ */ make90($null2)) {
}

class Never2 extends (/* @__PURE__ */ make90(neverKeyword2)) {
}

class Unknown2 extends (/* @__PURE__ */ make90(unknownKeyword2)) {
}

class Any2 extends (/* @__PURE__ */ make90(anyKeyword2)) {
}

class BigIntFromSelf extends (/* @__PURE__ */ make90(bigIntKeyword2)) {
}

class SymbolFromSelf extends (/* @__PURE__ */ make90(symbolKeyword2)) {
}

class String$2 extends (/* @__PURE__ */ make90(stringKeyword2)) {
}

class Number$ extends (/* @__PURE__ */ make90(numberKeyword2)) {
}

class Boolean$ extends (/* @__PURE__ */ make90(booleanKeyword2)) {
}

class Object$ extends (/* @__PURE__ */ make90(objectKeyword2)) {
}
var getDefaultUnionAST = (members) => Union4.members(members.map((m) => m.ast));
var makeUnionClass = (members, ast = getDefaultUnionAST(members)) => class UnionClass extends make90(ast) {
  static annotations(annotations3) {
    return makeUnionClass(this.members, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static members = [...members];
};
var NullOr = (self2) => Union5(self2, Null2);
var UndefinedOr = (self2) => Union5(self2, Undefined2);
var NullishOr = (self2) => Union5(self2, Null2, Undefined2);
var keyof3 = (self2) => make90(keyof2(self2.ast));
var element = (self2) => new ElementImpl(new OptionalType2(self2.ast, false), self2);
var optionalElement = (self2) => new ElementImpl(new OptionalType2(self2.ast, true), self2);

class ElementImpl {
  ast;
  from;
  [TypeId32];
  _Token;
  constructor(ast, from) {
    this.ast = ast;
    this.from = from;
  }
  annotations(annotations3) {
    return new ElementImpl(new OptionalType2(this.ast.type, this.ast.isOptional, {
      ...this.ast.annotations,
      ...toASTAnnotations2(annotations3)
    }), this.from);
  }
  toString() {
    return `${this.ast.type}${this.ast.isOptional ? "?" : ""}`;
  }
}
var getDefaultTupleTypeAST = (elements, rest) => new TupleType2(elements.map((el) => isSchema(el) ? new OptionalType2(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type4(el.ast) : el.ast), true);
var makeTupleTypeClass = (elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) => class TupleTypeClass extends make90(ast) {
  static annotations(annotations3) {
    return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static elements = [...elements];
  static rest = [...rest];
};
var makeArrayClass = (value6, ast) => class ArrayClass extends makeTupleTypeClass([], [value6], ast) {
  static annotations(annotations3) {
    return makeArrayClass(this.value, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static value = value6;
};
var Array$ = (value6) => makeArrayClass(value6);
var makeNonEmptyArrayClass = (value6, ast) => class NonEmptyArrayClass extends makeTupleTypeClass([value6], [value6], ast) {
  static annotations(annotations3) {
    return makeNonEmptyArrayClass(this.value, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static value = value6;
};
var NonEmptyArray = (value6) => makeNonEmptyArrayClass(value6);
var formatPropertySignatureToken = (isOptional2) => isOptional2 ? "\"?:\"" : "\":\"";

class PropertySignatureDeclaration extends OptionalType2 {
  isReadonly;
  defaultValue;
  _tag = "PropertySignatureDeclaration";
  constructor(type2, isOptional2, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional2, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
  toString() {
    const token = formatPropertySignatureToken(this.isOptional);
    const type2 = String(this.type);
    return `PropertySignature<${token}, ${type2}, never, ${token}, ${type2}>`;
  }
}

class FromPropertySignature extends OptionalType2 {
  isReadonly;
  fromKey;
  constructor(type2, isOptional2, isReadonly, annotations3, fromKey) {
    super(type2, isOptional2, annotations3);
    this.isReadonly = isReadonly;
    this.fromKey = fromKey;
  }
}

class ToPropertySignature extends OptionalType2 {
  isReadonly;
  defaultValue;
  constructor(type2, isOptional2, isReadonly, annotations3, defaultValue) {
    super(type2, isOptional2, annotations3);
    this.isReadonly = isReadonly;
    this.defaultValue = defaultValue;
  }
}
var formatPropertyKey3 = (p) => {
  if (p === undefined) {
    return "never";
  }
  if (isString(p)) {
    return JSON.stringify(p);
  }
  return String(p);
};

class PropertySignatureTransformation3 {
  from;
  to;
  decode;
  encode;
  _tag = "PropertySignatureTransformation";
  constructor(from, to, decode7, encode6) {
    this.from = from;
    this.to = to;
    this.decode = decode7;
    this.encode = encode6;
  }
  toString() {
    return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey3(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
  }
}
var mergeSignatureAnnotations = (ast, annotations3) => {
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
        ...ast.annotations,
        ...annotations3
      }, ast.defaultValue);
    }
    case "PropertySignatureTransformation": {
      return new PropertySignatureTransformation3(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations), new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
        ...ast.to.annotations,
        ...annotations3
      }, ast.to.defaultValue), ast.decode, ast.encode);
    }
  }
};
var PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/PropertySignature");

class PropertySignatureImpl {
  ast;
  [TypeId32];
  [PropertySignatureTypeId] = null;
  _TypeToken;
  _Key;
  _EncodedToken;
  _HasDefault;
  constructor(ast) {
    this.ast = ast;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  annotations(annotations3) {
    return new PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations2(annotations3)));
  }
  toString() {
    return String(this.ast);
  }
}
var makePropertySignature = (ast) => new PropertySignatureImpl(ast);

class PropertySignatureWithFromImpl extends PropertySignatureImpl {
  from;
  constructor(ast, from) {
    super(ast);
    this.from = from;
  }
  annotations(annotations3) {
    return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations2(annotations3)), this.from);
  }
}
var propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, undefined), self2);
var withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation3(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
  }
});
var applyDefaultValue = (o, defaultValue) => match2(o, {
  onNone: () => some2(defaultValue()),
  onSome: (value6) => some2(value6 === undefined ? defaultValue() : value6)
});
var withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration":
      return makePropertySignature(new PropertySignatureTransformation3(ast, new ToPropertySignature(typeAST2(ast.type), false, true, {}, undefined), (o) => applyDefaultValue(o, defaultValue), identity));
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation3(ast.from, new ToPropertySignature(ast.to.type, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
  }
});
var withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
var fromKey = /* @__PURE__ */ dual(2, (self2, key) => {
  const ast = self2.ast;
  switch (ast._tag) {
    case "PropertySignatureDeclaration": {
      return makePropertySignature(new PropertySignatureTransformation3(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, key), new ToPropertySignature(typeAST2(ast.type), ast.isOptional, ast.isReadonly, {}, ast.defaultValue), identity, identity));
    }
    case "PropertySignatureTransformation":
      return makePropertySignature(new PropertySignatureTransformation3(new FromPropertySignature(ast.from.type, ast.from.isOptional, ast.from.isReadonly, ast.from.annotations, key), ast.to, ast.decode, ast.encode));
  }
});
var optionalToRequired = (from, to, options) => makePropertySignature(new PropertySignatureTransformation3(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, false, true, {}, undefined), (o) => some2(options.decode(o)), flatMap(options.encode)));
var requiredToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation3(new FromPropertySignature(from.ast, false, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), flatMap(options.decode), (o) => some2(options.encode(o))));
var optionalToOptional = (from, to, options) => makePropertySignature(new PropertySignatureTransformation3(new FromPropertySignature(from.ast, true, true, {}, undefined), new ToPropertySignature(to.ast, true, true, {}, undefined), options.decode, options.encode));
var optionalPropertySignatureAST = (from, options) => {
  const isExact = options?.exact;
  const defaultValue = options?.default;
  const isNullable2 = options?.nullable;
  const asOption = options?.as == "Option";
  const asOptionEncode = options?.onNoneEncoding ? orElse(options.onNoneEncoding) : identity;
  if (isExact) {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullOr(from), typeSchema(from), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(from, typeSchema(from), {
          decode: match2({
            onNone: defaultValue,
            onSome: identity
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter(isNotNull),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(from, OptionFromSelf(typeSchema(from)), {
          decode: identity,
          encode: identity
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullOr(from), typeSchema(from), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(from.ast, true, true, {}, undefined);
      }
    }
  } else {
    if (defaultValue) {
      if (isNullable2) {
        return withConstructorDefault(optionalToRequired(NullishOr(from), typeSchema(from), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a == null ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      } else {
        return withConstructorDefault(optionalToRequired(UndefinedOr(from), typeSchema(from), {
          decode: match2({
            onNone: defaultValue,
            onSome: (a) => a === undefined ? defaultValue() : a
          }),
          encode: some2
        }), defaultValue).ast;
      }
    } else if (asOption) {
      if (isNullable2) {
        return optionalToRequired(NullishOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter((a) => a != null),
          encode: asOptionEncode
        }).ast;
      } else {
        return optionalToRequired(UndefinedOr(from), OptionFromSelf(typeSchema(from)), {
          decode: filter(isNotUndefined),
          encode: asOptionEncode
        }).ast;
      }
    } else {
      if (isNullable2) {
        return optionalToOptional(NullishOr(from), UndefinedOr(typeSchema(from)), {
          decode: filter(isNotNull),
          encode: identity
        }).ast;
      } else {
        return new PropertySignatureDeclaration(UndefinedOr(from).ast, true, true, {}, undefined);
      }
    }
  }
};
var optional = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (from, options) => {
  return new PropertySignatureWithFromImpl(optionalPropertySignatureAST(from, options), from);
});
var isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
var getDefaultTypeLiteralAST = (fields, records) => {
  const ownKeys2 = ownKeys(fields);
  const pss = [];
  if (ownKeys2.length > 0) {
    const from = [];
    const to = [];
    const transformations = [];
    for (let i = 0;i < ownKeys2.length; i++) {
      const key = ownKeys2[i];
      const field = fields[key];
      if (isPropertySignature(field)) {
        const ast = field.ast;
        switch (ast._tag) {
          case "PropertySignatureDeclaration": {
            const type2 = ast.type;
            const isOptional2 = ast.isOptional;
            const toAnnotations = ast.annotations;
            from.push(new PropertySignature2(key, type2, isOptional2, true));
            to.push(new PropertySignature2(key, typeAST2(type2), isOptional2, true, toAnnotations));
            pss.push(new PropertySignature2(key, type2, isOptional2, true, toAnnotations));
            break;
          }
          case "PropertySignatureTransformation": {
            const fromKey2 = ast.from.fromKey ?? key;
            from.push(new PropertySignature2(fromKey2, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
            to.push(new PropertySignature2(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
            transformations.push(new PropertySignatureTransformation2(fromKey2, key, ast.decode, ast.encode));
            break;
          }
        }
      } else {
        from.push(new PropertySignature2(key, field.ast, false, true));
        to.push(new PropertySignature2(key, typeAST2(field.ast), false, true));
        pss.push(new PropertySignature2(key, field.ast, false, true));
      }
    }
    if (isNonEmptyReadonlyArray(transformations)) {
      const issFrom = [];
      const issTo = [];
      for (const r of records) {
        const {
          indexSignatures,
          propertySignatures
        } = record2(r.key.ast, r.value.ast);
        propertySignatures.forEach((ps) => {
          from.push(ps);
          to.push(new PropertySignature2(ps.name, typeAST2(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
        });
        indexSignatures.forEach((is4) => {
          issFrom.push(is4);
          issTo.push(new IndexSignature2(is4.parameter, typeAST2(is4.type), is4.isReadonly));
        });
      }
      return new Transformation3(new TypeLiteral2(from, issFrom, {
        [TitleAnnotationId2]: "Struct (Encoded side)"
      }), new TypeLiteral2(to, issTo, {
        [TitleAnnotationId2]: "Struct (Type side)"
      }), new TypeLiteralTransformation2(transformations));
    }
  }
  const iss = [];
  for (const r of records) {
    const {
      indexSignatures,
      propertySignatures
    } = record2(r.key.ast, r.value.ast);
    propertySignatures.forEach((ps) => pss.push(ps));
    indexSignatures.forEach((is4) => iss.push(is4));
  }
  return new TypeLiteral2(pss, iss);
};
var lazilyMergeDefaults = (fields, out) => {
  const ownKeys2 = ownKeys(fields);
  for (const key of ownKeys2) {
    const field = fields[key];
    if (out[key] === undefined && isPropertySignature(field)) {
      const ast = field.ast;
      const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
      if (defaultValue !== undefined) {
        out[key] = defaultValue();
      }
    }
  }
  return out;
};
var makeTypeLiteralClass = (fields, records, ast = getDefaultTypeLiteralAST(fields, records)) => {
  return class TypeLiteralClass extends make90(ast) {
    static annotations(annotations3) {
      return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations2(this.ast, annotations3));
    }
    static fields = {
      ...fields
    };
    static records = [...records];
    static make = (props, options) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption2(options) ? propsWithDefaults : validateSync2(this)(propsWithDefaults);
    };
    static pick(...keys9) {
      return Struct(pick3(fields, ...keys9));
    }
    static omit(...keys9) {
      return Struct(omit3(fields, ...keys9));
    }
  };
};
var tag2 = (tag3) => Literal4(tag3).pipe(propertySignature, withConstructorDefault(() => tag3));
var TaggedStruct = (value6, fields) => Struct({
  _tag: tag2(value6),
  ...fields
});
var makeRecordClass = (key, value6, ast) => class RecordClass extends makeTypeLiteralClass({}, [{
  key,
  value: value6
}], ast) {
  static annotations(annotations3) {
    return makeRecordClass(key, value6, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static key = key;
  static value = value6;
};
var Record2 = (key, value6) => makeRecordClass(key, value6);
var pick6 = (...keys9) => (self2) => make90(pick5(self2.ast, keys9));
var omit6 = (...keys9) => (self2) => make90(omit5(self2.ast, keys9));
var pluck = /* @__PURE__ */ dual(2, (schema, key) => {
  const ps = getPropertyKeyIndexedAccess2(typeAST2(schema.ast), key);
  const value6 = make90(ps.isOptional ? orUndefined2(ps.type) : ps.type);
  return transform6(schema.pipe(pick6(key)), value6, {
    strict: true,
    decode: (a) => a[key],
    encode: (ak) => ps.isOptional && ak === undefined ? {} : {
      [key]: ak
    }
  });
});
var makeBrandClass = (ast) => class BrandClass extends make90(ast) {
  static annotations(annotations3) {
    return makeBrandClass(mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static make = (a, options) => {
    return getDisableValidationMakeOption2(options) ? a : validateSync2(this)(a);
  };
};
var brand = (brand2, annotations3) => (self2) => {
  const annotation = match2(getBrandAnnotation2(self2.ast), {
    onNone: () => [brand2],
    onSome: (brands) => [...brands, brand2]
  });
  const ast = annotations2(self2.ast, toASTAnnotations2({
    title: String(self2.ast) + ` & Brand<${formatUnknown2(brand2)}>`,
    ...annotations3,
    [BrandAnnotationId2]: annotation
  }));
  return makeBrandClass(ast);
};
var partial3 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, options) => make90(partial2(self2.ast, options)));
var required3 = (self2) => make90(required2(self2.ast));
var mutable3 = (schema) => make90(mutable2(schema.ast));
var intersectTypeLiterals = (x, y, path) => {
  if (isTypeLiteral2(x) && isTypeLiteral2(y)) {
    const propertySignatures = [...x.propertySignatures];
    for (const ps of y.propertySignatures) {
      const name = ps.name;
      const i = propertySignatures.findIndex((ps2) => ps2.name === name);
      if (i === -1) {
        propertySignatures.push(ps);
      } else {
        const {
          isOptional: isOptional2,
          type: type2
        } = propertySignatures[i];
        propertySignatures[i] = new PropertySignature2(name, extendAST(type2, ps.type, path.concat(name)), isOptional2, true);
      }
    }
    return new TypeLiteral2(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path));
};
var preserveRefinementAnnotations = /* @__PURE__ */ preserveAnnotations([MessageAnnotationId2, JSONSchemaAnnotationId2]);
var addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement3(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
var extendAST = (x, y, path) => Union4.make(intersectUnionMembers([x], [y], path));
var getTypes = (ast) => isUnion3(ast) ? ast.types : [ast];
var intersectUnionMembers = (xs, ys, path) => flatMap2(xs, (x) => flatMap2(ys, (y) => {
  switch (x._tag) {
    case "Union":
      return intersectUnionMembers(x.types, getTypes(y), path);
    case "Suspend":
      return [new Suspend2(() => extendAST(x.f(), y, path))];
    case "Refinement":
      return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), getTypes(y), path));
    case "TypeLiteral": {
      switch (y._tag) {
        case "Union":
          return intersectUnionMembers([x], y.types, path);
        case "Suspend":
          return [new Suspend2(() => extendAST(x, y.f(), path))];
        case "Refinement":
          return addRefinementToMembers(y, intersectUnionMembers([x], getTypes(y.from), path));
        case "TypeLiteral":
          return [intersectTypeLiterals(x, y, path)];
        case "Transformation": {
          if (isTypeLiteralTransformation2(y.transformation)) {
            return [new Transformation3(intersectTypeLiterals(x, y.from, path), intersectTypeLiterals(typeAST2(x), y.to, path), new TypeLiteralTransformation2(y.transformation.propertySignatureTransformations))];
          }
          break;
        }
      }
      break;
    }
    case "Transformation": {
      if (isTypeLiteralTransformation2(x.transformation)) {
        switch (y._tag) {
          case "Union":
            return intersectUnionMembers([x], y.types, path);
          case "Suspend":
            return [new Suspend2(() => extendAST(x, y.f(), path))];
          case "Refinement":
            return addRefinementToMembers(y, intersectUnionMembers([x], getTypes(y.from), path));
          case "TypeLiteral":
            return [new Transformation3(intersectTypeLiterals(x.from, y, path), intersectTypeLiterals(x.to, typeAST2(y), path), new TypeLiteralTransformation2(x.transformation.propertySignatureTransformations))];
          case "Transformation":
            {
              if (isTypeLiteralTransformation2(y.transformation)) {
                return [new Transformation3(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation2(x.transformation.propertySignatureTransformations.concat(y.transformation.propertySignatureTransformations)))];
              }
            }
            break;
        }
      }
      break;
    }
  }
  throw new Error(getSchemaExtendErrorMessage2(x, y, path));
}));
var extend3 = /* @__PURE__ */ dual(2, (self2, that) => make90(extendAST(self2.ast, that.ast, [])));
var compose4 = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => make90(compose3(from.ast, to.ast)));
var suspend11 = (f) => make90(new Suspend2(() => f().ast));
var refineTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/refine");
var makeRefineClass2 = (from, filter17, ast) => class RefineClass extends make90(ast) {
  static annotations(annotations3) {
    return makeRefineClass2(this.from, this.filter, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static [refineTypeId] = from;
  static from = from;
  static filter = filter17;
  static make = (a, options) => {
    return getDisableValidationMakeOption2(options) ? a : validateSync2(this)(a);
  };
};
var fromFilterPredicateReturnTypeItem2 = (item, ast, input) => {
  if (isBoolean(item)) {
    return item ? none2() : some2(new Type5(ast, input));
  }
  if (isString(item)) {
    return some2(new Type5(ast, input, item));
  }
  if (item !== undefined) {
    if ("_tag" in item) {
      return some2(item);
    }
    const issue = new Type5(ast, input, item.message);
    return some2(isNonEmptyReadonlyArray(item.path) ? new Pointer2(item.path, input, issue) : issue);
  }
  return none2();
};
var toFilterParseIssue2 = (out, ast, input) => {
  if (isSingle2(out)) {
    return fromFilterPredicateReturnTypeItem2(out, ast, input);
  }
  if (isNonEmptyReadonlyArray(out)) {
    const issues = filterMap2(out, (issue) => fromFilterPredicateReturnTypeItem2(issue, ast, input));
    if (isNonEmptyReadonlyArray(issues)) {
      return some2(issues.length === 1 ? issues[0] : new Composite4(ast, input, issues));
    }
  }
  return none2();
};
var filterEffect2 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(self2, typeSchema(self2), {
  strict: true,
  decode: (a, options, ast) => flatMap19(f(a, options, ast), (filterReturnType) => match2(toFilterParseIssue2(filterReturnType, ast, a), {
    onNone: () => succeed22(a),
    onSome: fail20
  })),
  encode: succeed22
}));
var makeTransformationClass = (from, to, ast) => class TransformationClass extends make90(ast) {
  static annotations(annotations3) {
    return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations2(this.ast, annotations3));
  }
  static from = from;
  static to = to;
};
var transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => makeTransformationClass(from, to, new Transformation3(from.ast, to.ast, new FinalTransformation2(options.decode, options.encode))));
var transform6 = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options) => transformOrFail(from, to, {
  strict: true,
  decode: (fromA) => succeed22(options.decode(fromA)),
  encode: (toI) => succeed22(options.encode(toI))
}));
var transformLiteral = (from, to) => transform6(Literal4(from), Literal4(to), {
  strict: true,
  decode: () => to,
  encode: () => from
});
var attachPropertySignature = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (schema, key, value6, annotations3) => {
  const ast = extend3(typeSchema(schema), Struct({
    [key]: isSymbol(value6) ? UniqueSymbolFromSelf(value6) : Literal4(value6)
  })).ast;
  return make90(new Transformation3(schema.ast, annotations3 ? mergeSchemaAnnotations2(ast, annotations3) : ast, new TypeLiteralTransformation2([new PropertySignatureTransformation2(key, key, () => some2(value6), () => none2())])));
});
var annotations3 = /* @__PURE__ */ dual(2, (self2, annotations4) => self2.annotations(annotations4));
var rename3 = /* @__PURE__ */ dual(2, (self2, mapping) => make90(rename2(self2.ast, mapping)));
var TrimmedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Trimmed");
var trimmed = (annotations4) => (self2) => self2.pipe(filter16((a) => a === a.trim(), {
  typeId: TrimmedTypeId,
  description: "a string with no leading or trailing whitespace",
  jsonSchema: {
    pattern: "^\\S[\\s\\S]*\\S$|^\\S$|^$"
  },
  ...annotations4
}));
var MaxLengthTypeId2 = MaxLengthTypeId;
var maxLength = (maxLength2, annotations4) => (self2) => self2.pipe(filter16((a) => a.length <= maxLength2, {
  typeId: MaxLengthTypeId2,
  description: `a string at most ${maxLength2} character(s) long`,
  jsonSchema: {
    maxLength: maxLength2
  },
  ...annotations4
}));
var MinLengthTypeId2 = MinLengthTypeId;
var minLength = (minLength2, annotations4) => (self2) => self2.pipe(filter16((a) => a.length >= minLength2, {
  typeId: MinLengthTypeId2,
  description: `a string at least ${minLength2} character(s) long`,
  jsonSchema: {
    minLength: minLength2
  },
  ...annotations4
}));
var PatternTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Pattern");
var pattern2 = (regex2, annotations4) => (self2) => {
  const pattern3 = regex2.source;
  return self2.pipe(filter16((a) => {
    regex2.lastIndex = 0;
    return regex2.test(a);
  }, {
    typeId: {
      id: PatternTypeId,
      annotation: {
        regex: regex2
      }
    },
    description: `a string matching the pattern ${pattern3}`,
    jsonSchema: {
      pattern: pattern3
    },
    arbitrary: () => (fc) => fc.stringMatching(regex2),
    ...annotations4
  }));
};
var StartsWithTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/StartsWith");
var startsWith = (startsWith2, annotations4) => (self2) => self2.pipe(filter16((a) => a.startsWith(startsWith2), {
  typeId: {
    id: StartsWithTypeId,
    annotation: {
      startsWith: startsWith2
    }
  },
  description: `a string starting with ${JSON.stringify(startsWith2)}`,
  jsonSchema: {
    pattern: `^${startsWith2}`
  },
  ...annotations4
}));
var EndsWithTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/EndsWith");
var endsWith = (endsWith2, annotations4) => (self2) => self2.pipe(filter16((a) => a.endsWith(endsWith2), {
  typeId: {
    id: EndsWithTypeId,
    annotation: {
      endsWith: endsWith2
    }
  },
  description: `a string ending with ${JSON.stringify(endsWith2)}`,
  jsonSchema: {
    pattern: `^.*${endsWith2}\$`
  },
  ...annotations4
}));
var IncludesTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Includes");
var includes = (searchString, annotations4) => (self2) => self2.pipe(filter16((a) => a.includes(searchString), {
  typeId: {
    id: IncludesTypeId,
    annotation: {
      includes: searchString
    }
  },
  description: `a string including ${JSON.stringify(searchString)}`,
  jsonSchema: {
    pattern: `.*${searchString}.*`
  },
  ...annotations4
}));
var LowercasedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Lowercased");
var lowercased = (annotations4) => (self2) => self2.pipe(filter16((a) => a === a.toLowerCase(), {
  typeId: LowercasedTypeId,
  description: "a lowercase string",
  ...annotations4
}));

class Lowercased extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ lowercased({
  identifier: "Lowercased",
  title: "Lowercased"
}))) {
}
var CapitalizedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Capitalized");
var capitalized = (annotations4) => (self2) => self2.pipe(filter16((a) => a[0]?.toUpperCase() === a[0], {
  typeId: CapitalizedTypeId,
  description: "a capitalized string",
  ...annotations4
}));

class Capitalized extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ capitalized({
  identifier: "Capitalized",
  title: "Capitalized"
}))) {
}
var UncapitalizedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Uncapitalized");
var uncapitalized = (annotations4) => (self2) => self2.pipe(filter16((a) => a[0]?.toLowerCase() === a[0], {
  typeId: UncapitalizedTypeId,
  description: "a uncapitalized string",
  ...annotations4
}));

class Uncapitalized extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ uncapitalized({
  identifier: "Uncapitalized",
  title: "Uncapitalized"
}))) {
}
var UppercasedTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Uppercased");
var uppercased = (annotations4) => (self2) => self2.pipe(filter16((a) => a === a.toUpperCase(), {
  typeId: UppercasedTypeId,
  description: "an uppercase string",
  ...annotations4
}));

class Uppercased extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ uppercased({
  identifier: "Uppercased",
  title: "Uppercased"
}))) {
}
var LengthTypeId2 = LengthTypeId;
var length3 = (length4, annotations4) => (self2) => {
  const minLength2 = isObject(length4) ? Math.max(0, Math.floor(length4.min)) : Math.max(0, Math.floor(length4));
  const maxLength2 = isObject(length4) ? Math.max(minLength2, Math.floor(length4.max)) : minLength2;
  if (minLength2 !== maxLength2) {
    return self2.pipe(filter16((a) => a.length >= minLength2 && a.length <= maxLength2, {
      typeId: LengthTypeId2,
      description: `a string at least ${minLength2} character(s) and at most ${maxLength2} character(s) long`,
      jsonSchema: {
        minLength: minLength2,
        maxLength: maxLength2
      },
      ...annotations4
    }));
  }
  return self2.pipe(filter16((a) => a.length === minLength2, {
    typeId: LengthTypeId2,
    description: minLength2 === 1 ? `a single character` : `a string ${minLength2} character(s) long`,
    jsonSchema: {
      minLength: minLength2,
      maxLength: minLength2
    },
    ...annotations4
  }));
};

class Char extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ length3(1, {
  identifier: "Char"
}))) {
}
var nonEmpty = (annotations4) => minLength(1, {
  description: "a non empty string",
  ...annotations4
});

class Lowercase2 extends (/* @__PURE__ */ transform6(String$2, Lowercased, {
  strict: true,
  decode: (s) => s.toLowerCase(),
  encode: identity
}).annotations({
  identifier: "Lowercase"
})) {
}

class Uppercase2 extends (/* @__PURE__ */ transform6(String$2, Uppercased, {
  strict: true,
  decode: (s) => s.toUpperCase(),
  encode: identity
}).annotations({
  identifier: "Uppercase"
})) {
}

class Capitalize2 extends (/* @__PURE__ */ transform6(String$2, Capitalized, {
  strict: true,
  decode: (s) => capitalize(s),
  encode: identity
}).annotations({
  identifier: "Capitalize"
})) {
}

class Uncapitalize2 extends (/* @__PURE__ */ transform6(String$2, Uncapitalized, {
  strict: true,
  decode: (s) => uncapitalize(s),
  encode: identity
}).annotations({
  identifier: "Uncapitalize"
})) {
}

class Trimmed extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ trimmed({
  identifier: "Trimmed",
  title: "Trimmed"
}))) {
}

class Trim extends (/* @__PURE__ */ transform6(String$2, Trimmed, {
  strict: true,
  decode: (s) => s.trim(),
  encode: identity
}).annotations({
  identifier: "Trim"
})) {
}
var split3 = (separator) => transform6(String$2, Array$(String$2), {
  strict: true,
  decode: split(separator),
  encode: join(separator)
});
var JsonString = /* @__PURE__ */ String$2.annotations({
  [IdentifierAnnotationId2]: "JsonString",
  [TitleAnnotationId2]: "JsonString",
  [DescriptionAnnotationId2]: "a JSON string"
});
var getParseJsonTransformation = (options) => transformOrFail(JsonString, Unknown2, {
  strict: true,
  decode: (s, _2, ast) => _try2({
    try: () => JSON.parse(s, options?.reviver),
    catch: (e) => new Type5(ast, s, e.message)
  }),
  encode: (u, _2, ast) => _try2({
    try: () => JSON.stringify(u, options?.replacer, options?.space),
    catch: (e) => new Type5(ast, u, e.message)
  })
}).annotations({
  typeId: ParseJsonTypeId
});
var parseJson = (schema, o) => isSchema(schema) ? compose4(parseJson(o), schema) : getParseJsonTransformation(schema);

class NonEmpty extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ nonEmpty({
  identifier: "NonEmpty",
  title: "NonEmpty"
}))) {
}
var UUIDTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/UUID");
var uuidRegexp2 = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;

class UUID2 extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ pattern2(uuidRegexp2, {
  typeId: UUIDTypeId,
  identifier: "UUID",
  title: "UUID",
  description: "a Universally Unique Identifier",
  arbitrary: () => (fc) => fc.uuid()
}))) {
}
var ULIDTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ULID");
var ulidRegexp = /^[0-7][0-9A-HJKMNP-TV-Z]{25}$/i;

class ULID extends (/* @__PURE__ */ String$2.pipe(/* @__PURE__ */ pattern2(ulidRegexp, {
  typeId: ULIDTypeId,
  identifier: "ULID",
  title: "ULID",
  description: "a Universally Unique Lexicographically Sortable Identifier",
  arbitrary: () => (fc) => fc.ulid()
}))) {
}
var FiniteTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/Finite");
var finite = (annotations4) => (self2) => self2.pipe(filter16((a) => Number.isFinite(a), {
  typeId: FiniteTypeId,
  description: "a finite number",
  ...annotations4
}));
var GreaterThanTypeId2 = GreaterThanTypeId;
var greaterThan6 = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => a > min4, {
  typeId: GreaterThanTypeId2,
  description: min4 === 0 ? "a positive number" : `a number greater than ${min4}`,
  jsonSchema: {
    exclusiveMinimum: min4
  },
  ...annotations4
}));
var GreaterThanOrEqualToTypeId2 = GreaterThanOrEqualToTypeId;
var greaterThanOrEqualTo6 = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => a >= min4, {
  typeId: GreaterThanOrEqualToTypeId2,
  description: min4 === 0 ? "a non-negative number" : `a number greater than or equal to ${min4}`,
  jsonSchema: {
    minimum: min4
  },
  ...annotations4
}));
var MultipleOfTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/MultipleOf");
var multipleOf = (divisor, annotations4) => (self2) => self2.pipe(filter16((a) => remainder(a, divisor) === 0, {
  typeId: MultipleOfTypeId,
  description: `a number divisible by ${divisor}`,
  jsonSchema: {
    multipleOf: Math.abs(divisor)
  },
  ...annotations4
}));
var IntTypeId2 = IntTypeId;
var int = (annotations4) => (self2) => self2.pipe(filter16((a) => Number.isSafeInteger(a), {
  typeId: IntTypeId2,
  title: "integer",
  description: "an integer",
  jsonSchema: {
    type: "integer"
  },
  ...annotations4
}));
var LessThanTypeId2 = LessThanTypeId;
var lessThan9 = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => a < max7, {
  typeId: LessThanTypeId2,
  description: max7 === 0 ? "a negative number" : `a number less than ${max7}`,
  jsonSchema: {
    exclusiveMaximum: max7
  },
  ...annotations4
}));
var LessThanOrEqualToTypeId2 = LessThanOrEqualToTypeId;
var lessThanOrEqualTo5 = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => a <= max7, {
  typeId: LessThanOrEqualToTypeId2,
  description: max7 === 0 ? "a non-positive number" : `a number less than or equal to ${max7}`,
  jsonSchema: {
    maximum: max7
  },
  ...annotations4
}));
var BetweenTypeId2 = BetweenTypeId;
var between5 = (min4, max7, annotations4) => (self2) => self2.pipe(filter16((a) => a >= min4 && a <= max7, {
  typeId: BetweenTypeId2,
  description: `a number between ${min4} and ${max7}`,
  jsonSchema: {
    maximum: max7,
    minimum: min4
  },
  ...annotations4
}));
var NonNaNTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonNaN");
var nonNaN = (annotations4) => (self2) => self2.pipe(filter16((a) => !Number.isNaN(a), {
  typeId: NonNaNTypeId,
  description: "a number excluding NaN",
  ...annotations4
}));
var positive = (annotations4) => greaterThan6(0, annotations4);
var negative = (annotations4) => lessThan9(0, annotations4);
var nonPositive = (annotations4) => lessThanOrEqualTo5(0, annotations4);
var nonNegative = (annotations4) => greaterThanOrEqualTo6(0, annotations4);
var clamp8 = (minimum, maximum) => (self2) => transform6(self2, self2.pipe(typeSchema, between5(minimum, maximum)), {
  strict: false,
  decode: (self3) => clamp3(self3, {
    minimum,
    maximum
  }),
  encode: identity
});
var parseNumber = (self2) => transformOrFail(self2, Number$, {
  strict: false,
  decode: (s, _2, ast) => fromOption6(parse(s), () => new Type5(ast, s)),
  encode: (n) => succeed22(String(n))
});

class NumberFromString extends (/* @__PURE__ */ parseNumber(String$2).annotations({
  identifier: "NumberFromString"
})) {
}

class Finite extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ finite({
  identifier: "Finite",
  title: "Finite"
}))) {
}

class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
  identifier: "Int",
  title: "Int"
}))) {
}

class NonNaN extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNaN({
  identifier: "NonNaN",
  title: "NonNaN"
}))) {
}

class Positive extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ positive({
  identifier: "Positive",
  title: "Positive"
}))) {
}

class Negative extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ negative({
  identifier: "Negative",
  title: "Negative"
}))) {
}

class NonPositive extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonPositive({
  identifier: "NonPositive",
  title: "NonPositive"
}))) {
}

class NonNegative extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
  identifier: "NonNegative",
  title: "NonNegative"
}))) {
}
var JsonNumberTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/JsonNumber");

class JsonNumber extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ filter16((n) => !Number.isNaN(n) && Number.isFinite(n), {
  typeId: JsonNumberTypeId,
  identifier: "JsonNumber",
  title: "JSON-compatible number",
  description: "a JSON-compatible number, excluding NaN, +Infinity, and -Infinity",
  jsonSchema: {
    type: "number"
  }
}))) {
}

class Not3 extends (/* @__PURE__ */ transform6(Boolean$, Boolean$, {
  strict: true,
  decode: not,
  encode: not
})) {
}

class Symbol$ extends (/* @__PURE__ */ transform6(String$2, SymbolFromSelf, {
  strict: false,
  decode: (s) => Symbol.for(s),
  encode: (sym) => sym.description
}).annotations({
  identifier: "symbol"
})) {
}
var GreaterThanBigIntTypeId = GreaterThanBigintTypeId;
var greaterThanBigInt = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => a > min4, {
  typeId: {
    id: GreaterThanBigIntTypeId,
    annotation: {
      min: min4
    }
  },
  description: min4 === 0n ? "a positive bigint" : `a bigint greater than ${min4}n`,
  ...annotations4
}));
var GreaterThanOrEqualToBigIntTypeId2 = GreaterThanOrEqualToBigIntTypeId;
var greaterThanOrEqualToBigInt = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => a >= min4, {
  typeId: {
    id: GreaterThanOrEqualToBigIntTypeId2,
    annotation: {
      min: min4
    }
  },
  description: min4 === 0n ? "a non-negative bigint" : `a bigint greater than or equal to ${min4}n`,
  ...annotations4
}));
var LessThanBigIntTypeId2 = LessThanBigIntTypeId;
var lessThanBigInt = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => a < max7, {
  typeId: {
    id: LessThanBigIntTypeId2,
    annotation: {
      max: max7
    }
  },
  description: max7 === 0n ? "a negative bigint" : `a bigint less than ${max7}n`,
  ...annotations4
}));
var LessThanOrEqualToBigIntTypeId2 = LessThanOrEqualToBigIntTypeId;
var lessThanOrEqualToBigInt = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => a <= max7, {
  typeId: {
    id: LessThanOrEqualToBigIntTypeId2,
    annotation: {
      max: max7
    }
  },
  description: max7 === 0n ? "a non-positive bigint" : `a bigint less than or equal to ${max7}n`,
  ...annotations4
}));
var BetweenBigIntTypeId = BetweenBigintTypeId;
var betweenBigInt = (min4, max7, annotations4) => (self2) => self2.pipe(filter16((a) => a >= min4 && a <= max7, {
  typeId: {
    id: BetweenBigIntTypeId,
    annotation: {
      max: max7,
      min: min4
    }
  },
  description: `a bigint between ${min4}n and ${max7}n`,
  ...annotations4
}));
var positiveBigInt = (annotations4) => greaterThanBigInt(0n, annotations4);
var negativeBigInt = (annotations4) => lessThanBigInt(0n, annotations4);
var nonNegativeBigInt = (annotations4) => greaterThanOrEqualToBigInt(0n, annotations4);
var nonPositiveBigInt = (annotations4) => lessThanOrEqualToBigInt(0n, annotations4);
var clampBigInt = (minimum, maximum) => (self2) => transform6(self2, self2.pipe(typeSchema, betweenBigInt(minimum, maximum)), {
  strict: false,
  decode: (self3) => clamp5(self3, {
    minimum,
    maximum
  }),
  encode: identity
});

class BigInt$ extends (/* @__PURE__ */ transformOrFail(String$2, BigIntFromSelf, {
  strict: true,
  decode: (s, _2, ast) => fromOption6(fromString2(s), () => new Type5(ast, s)),
  encode: (n) => succeed22(String(n))
}).annotations({
  identifier: "bigint"
})) {
}
var PositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigintFromSelf",
  title: "PositiveBigintFromSelf"
}));
var PositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ positiveBigInt({
  identifier: "PositiveBigint",
  title: "PositiveBigint"
}));
var NegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigintFromSelf",
  title: "NegativeBigintFromSelf"
}));
var NegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ negativeBigInt({
  identifier: "NegativeBigint",
  title: "NegativeBigint"
}));
var NonPositiveBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigintFromSelf",
  title: "NonPositiveBigintFromSelf"
}));
var NonPositiveBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonPositiveBigInt({
  identifier: "NonPositiveBigint",
  title: "NonPositiveBigint"
}));
var NonNegativeBigIntFromSelf = /* @__PURE__ */ BigIntFromSelf.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigintFromSelf",
  title: "NonNegativeBigintFromSelf"
}));
var NonNegativeBigInt = /* @__PURE__ */ BigInt$.pipe(/* @__PURE__ */ nonNegativeBigInt({
  identifier: "NonNegativeBigint",
  title: "NonNegativeBigint"
}));

class BigIntFromNumber extends (/* @__PURE__ */ transformOrFail(Number$, BigIntFromSelf, {
  strict: true,
  decode: (n, _2, ast) => fromOption6(fromNumber2(n), () => new Type5(ast, n)),
  encode: (b, _2, ast) => fromOption6(toNumber(b), () => new Type5(ast, b))
}).annotations({
  identifier: "BigintFromNumber"
})) {
}
var redactedArbitrary = (value6) => (fc) => value6(fc).map((x) => make66(x));
var toComposite = (eff, onSuccess, ast, actual) => mapBoth9(eff, {
  onFailure: (e) => new Composite4(ast, actual, e),
  onSuccess
});
var redactedParse = (decodeUnknown5) => (u, options, ast) => isRedacted2(u) ? toComposite(decodeUnknown5(value4(u), options), make66, ast, u) : fail20(new Type5(ast, u));
var RedactedFromSelf = (value6) => declare2([value6], {
  decode: (value7) => redactedParse(decodeUnknown3(value7)),
  encode: (value7) => redactedParse(encodeUnknown2(value7))
}, {
  description: "Redacted(<redacted>)",
  pretty: () => () => "Redacted(<redacted>)",
  arbitrary: redactedArbitrary,
  equivalence: getEquivalence7
});
var Redacted = (value6) => {
  return transform6(value6, RedactedFromSelf(typeSchema(value6)), {
    strict: true,
    decode: (value7) => make66(value7),
    encode: (value7) => value4(value7)
  });
};

class DurationFromSelf extends (/* @__PURE__ */ declare2(isDuration, {
  identifier: "DurationFromSelf",
  pretty: () => String,
  arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigUint().map((_2) => nanos(_2)), fc.bigUint().map((_2) => micros(_2)), fc.maxSafeNat().map((_2) => millis(_2)), fc.maxSafeNat().map((_2) => seconds(_2)), fc.maxSafeNat().map((_2) => minutes(_2)), fc.maxSafeNat().map((_2) => hours(_2)), fc.maxSafeNat().map((_2) => days(_2)), fc.maxSafeNat().map((_2) => weeks(_2))),
  equivalence: () => Equivalence2
})) {
}

class DurationFromNanos extends (/* @__PURE__ */ transformOrFail(BigIntFromSelf, DurationFromSelf, {
  strict: true,
  decode: (nanos2) => succeed22(nanos(nanos2)),
  encode: (duration3, _2, ast) => match2(toNanos(duration3), {
    onNone: () => fail20(new Type5(ast, duration3)),
    onSome: (val) => succeed22(val)
  })
}).annotations({
  identifier: "DurationFromNanos"
})) {
}

class DurationFromMillis extends (/* @__PURE__ */ transform6(Number$, DurationFromSelf, {
  strict: true,
  decode: (ms) => millis(ms),
  encode: (n) => toMillis(n)
}).annotations({
  identifier: "DurationFromMillis"
})) {
}
var hrTime = /* @__PURE__ */ Tuple2(/* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
  [TitleAnnotationId2]: "seconds",
  [DescriptionAnnotationId2]: "seconds"
})), /* @__PURE__ */ NonNegative.pipe(/* @__PURE__ */ finite({
  [TitleAnnotationId2]: "nanos",
  [DescriptionAnnotationId2]: "nanos"
})));

class Duration extends (/* @__PURE__ */ transform6(hrTime, DurationFromSelf, {
  strict: true,
  decode: ([seconds2, nanos2]) => nanos(BigInt(seconds2) * BigInt(1e9) + BigInt(nanos2)),
  encode: (duration3) => toHrTime(duration3)
}).annotations({
  identifier: "Duration"
})) {
}
var clampDuration = (minimum, maximum) => (self2) => transform6(self2, self2.pipe(typeSchema, betweenDuration(minimum, maximum)), {
  strict: false,
  decode: (self3) => clamp6(self3, {
    minimum,
    maximum
  }),
  encode: identity
});
var LessThanDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanDuration");
var lessThanDuration = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => lessThan3(a, max7), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a Duration less than ${decode(max7)}`,
  ...annotations4
}));
var LessThanOrEqualToDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToDuration");
var lessThanOrEqualToDuration = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => lessThanOrEqualTo3(a, max7), {
  typeId: {
    id: LessThanDurationTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a Duration less than or equal to ${decode(max7)}`,
  ...annotations4
}));
var GreaterThanDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanDuration");
var greaterThanDuration = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => greaterThan3(a, min4), {
  typeId: {
    id: GreaterThanDurationTypeId,
    annotation: {
      min: min4
    }
  },
  description: `a Duration greater than ${decode(min4)}`,
  ...annotations4
}));
var GreaterThanOrEqualToDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToDuration");
var greaterThanOrEqualToDuration = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => greaterThanOrEqualTo3(a, min4), {
  typeId: {
    id: GreaterThanOrEqualToDurationTypeId,
    annotation: {
      min: min4
    }
  },
  description: `a Duration greater than or equal to ${decode(min4)}`,
  ...annotations4
}));
var BetweenDurationTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenDuration");
var betweenDuration = (minimum, maximum, annotations4) => (self2) => self2.pipe(filter16((a) => between3(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenDurationTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a Duration between ${decode(minimum)} and ${decode(maximum)}`,
  ...annotations4
}));
var Uint8ArrayFromSelf = /* @__PURE__ */ declare2(isUint8Array, {
  identifier: "Uint8ArrayFromSelf",
  pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
  arbitrary: () => (fc) => fc.uint8Array(),
  equivalence: () => getEquivalence3(equals)
});
var Uint8Array$ = /* @__PURE__ */ transform6(Array$(Number$.pipe(between5(0, 255, {
  title: "8-bit unsigned integer",
  description: "a 8-bit unsigned integer"
}))).annotations({
  description: "an array of 8-bit unsigned integers"
}), Uint8ArrayFromSelf, {
  strict: true,
  decode: (numbers) => Uint8Array.from(numbers),
  encode: (uint8Array) => Array.from(uint8Array)
}).annotations({
  identifier: "Uint8Array"
});
var makeEncodingTransformation = (id2, decode7, encode6) => transformOrFail(String$2, Uint8ArrayFromSelf, {
  strict: true,
  decode: (s, _2, ast) => mapLeft(decode7(s), (decodeException) => new Type5(ast, s, decodeException.message)),
  encode: (u) => succeed22(encode6(u))
}).annotations({
  identifier: id2
});
var Base64 = /* @__PURE__ */ makeEncodingTransformation("Base64", decodeBase64, encodeBase64);
var Base64Url = /* @__PURE__ */ makeEncodingTransformation("Base64Url", decodeBase64Url, encodeBase64Url);
var Hex = /* @__PURE__ */ makeEncodingTransformation("Hex", decodeHex, encodeHex);
var MinItemsTypeId2 = MinItemsTypeId;
var minItems = (n, annotations4) => (self2) => {
  const minItems2 = Math.floor(n);
  if (minItems2 < 1) {
    throw new Error(getInvalidArgumentErrorMessage2(`Expected an integer greater than or equal to 1, actual ${n}`));
  }
  return self2.pipe(filter16((a) => a.length >= minItems2, {
    typeId: MinItemsTypeId2,
    description: `an array of at least ${minItems2} items`,
    jsonSchema: {
      minItems: minItems2
    },
    [StableFilterAnnotationId2]: true,
    ...annotations4
  }));
};
var MaxItemsTypeId2 = MaxItemsTypeId;
var maxItems = (n, annotations4) => (self2) => self2.pipe(filter16((a) => a.length <= n, {
  typeId: MaxItemsTypeId2,
  description: `an array of at most ${n} items`,
  jsonSchema: {
    maxItems: n
  },
  [StableFilterAnnotationId2]: true,
  ...annotations4
}));
var ItemsCountTypeId2 = ItemsCountTypeId;
var itemsCount = (n, annotations4) => (self2) => self2.pipe(filter16((a) => a.length === n, {
  typeId: ItemsCountTypeId2,
  description: `an array of exactly ${n} item(s)`,
  jsonSchema: {
    minItems: n,
    maxItems: n
  },
  [StableFilterAnnotationId2]: true,
  ...annotations4
}));
var getNumberIndexedAccess3 = (self2) => make90(getNumberIndexedAccess2(self2.ast));
var head8 = (self2) => transform6(self2, OptionFromSelf(getNumberIndexedAccess3(typeSchema(self2))), {
  strict: true,
  decode: head,
  encode: match2({
    onNone: () => [],
    onSome: of
  })
});
var headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess3(typeSchema(self2)), {
  strict: true,
  decode: (as10, _2, ast) => as10.length > 0 ? succeed22(as10[0]) : fallback ? succeed22(fallback()) : fail20(new Type5(ast, as10)),
  encode: (a) => succeed22(of(a))
}));
var ValidDateTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/ValidDate");
var validDate = (annotations4) => (self2) => self2.pipe(filter16((a) => !Number.isNaN(a.getTime()), {
  typeId: ValidDateTypeId,
  description: "a valid Date",
  ...annotations4
}));

class DateFromSelf2 extends (/* @__PURE__ */ declare2(isDate, {
  identifier: "DateFromSelf",
  description: "a potentially invalid Date instance",
  pretty: () => (date3) => `new Date(${JSON.stringify(date3)})`,
  arbitrary: () => (fc) => fc.date({
    noInvalidDate: false
  }),
  equivalence: () => Date2
})) {
}

class ValidDateFromSelf extends (/* @__PURE__ */ DateFromSelf2.pipe(/* @__PURE__ */ validDate({
  identifier: "ValidDateFromSelf",
  description: "a valid Date instance"
}))) {
}

class DateFromString extends (/* @__PURE__ */ transform6(String$2, DateFromSelf2, {
  strict: true,
  decode: (s) => new Date(s),
  encode: (d) => d.toISOString()
}).annotations({
  identifier: "DateFromString"
})) {
}

class Date$ extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
  identifier: "Date"
}))) {
}
class DateFromNumber extends (/* @__PURE__ */ transform6(Number$, DateFromSelf2, {
  strict: true,
  decode: (n) => new Date(n),
  encode: (d) => d.getTime()
}).annotations({
  identifier: "DateFromNumber"
})) {
}
var OptionNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("None")
}).annotations({
  description: "NoneEncoded"
});
var optionSomeEncoded = (value6) => Struct({
  _tag: Literal4("Some"),
  value: value6
}).annotations({
  description: `SomeEncoded<${format6(value6)}>`
});
var optionEncoded = (value6) => Union5(OptionNoneEncoded, optionSomeEncoded(value6)).annotations({
  description: `OptionEncoded<${format6(value6)}>`
});
var optionDecode = (input) => input._tag === "None" ? none2() : some2(input.value);
var optionArbitrary = (value6) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("None")
}), fc.record({
  _tag: fc.constant("Some"),
  value: value6(fc)
})).map(optionDecode);
var optionPretty = (value6) => match2({
  onNone: () => "none()",
  onSome: (a) => `some(${value6(a)})`
});
var optionParse = (decodeUnknown5) => (u, options, ast) => isOption2(u) ? isNone2(u) ? succeed22(none2()) : toComposite(decodeUnknown5(u.value, options), some2, ast, u) : fail20(new Type5(ast, u));
var OptionFromSelf = (value6) => {
  return declare2([value6], {
    decode: (value7) => optionParse(decodeUnknown3(value7)),
    encode: (value7) => optionParse(encodeUnknown2(value7))
  }, {
    description: `Option<${format6(value6)}>`,
    pretty: optionPretty,
    arbitrary: optionArbitrary,
    equivalence: getEquivalence2
  });
};
var makeNoneEncoded = {
  _tag: "None"
};
var makeSomeEncoded = (value6) => ({
  _tag: "Some",
  value: value6
});
var Option = (value6) => {
  const value_ = asSchema(value6);
  return transform6(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: optionDecode,
    encode: match2({
      onNone: () => makeNoneEncoded,
      onSome: makeSomeEncoded
    })
  });
};
var OptionFromNullOr = (value6) => {
  const value_ = asSchema(value6);
  return transform6(NullOr(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: fromNullable,
    encode: getOrNull
  });
};
var OptionFromNullishOr = (value6, onNoneEncoding) => {
  const value_ = asSchema(value6);
  return transform6(NullishOr(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: fromNullable,
    encode: onNoneEncoding === null ? getOrNull : getOrUndefined
  });
};
var OptionFromUndefinedOr = (value6) => {
  const value_ = asSchema(value6);
  return transform6(UndefinedOr(value_), OptionFromSelf(typeSchema(value_)), {
    strict: true,
    decode: fromNullable,
    encode: getOrUndefined
  });
};
var rightEncoded = (right3) => Struct({
  _tag: Literal4("Right"),
  right: right3
}).annotations({
  description: `RightEncoded<${format6(right3)}>`
});
var leftEncoded = (left3) => Struct({
  _tag: Literal4("Left"),
  left: left3
}).annotations({
  description: `LeftEncoded<${format6(left3)}>`
});
var eitherEncoded = (right3, left3) => Union5(rightEncoded(right3), leftEncoded(left3)).annotations({
  description: `EitherEncoded<${format6(left3)}, ${format6(right3)}>`
});
var eitherDecode = (input) => input._tag === "Left" ? left2(input.left) : right2(input.right);
var eitherArbitrary = (right3, left3) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Left"),
  left: left3(fc)
}), fc.record({
  _tag: fc.constant("Right"),
  right: right3(fc)
})).map(eitherDecode);
var eitherPretty = (right3, left3) => match({
  onLeft: (e) => `left(${left3(e)})`,
  onRight: (a) => `right(${right3(a)})`
});
var eitherParse = (parseRight, decodeUnknownLeft) => (u, options, ast) => isEither2(u) ? match(u, {
  onLeft: (left3) => toComposite(decodeUnknownLeft(left3, options), left2, ast, u),
  onRight: (right3) => toComposite(parseRight(right3, options), right2, ast, u)
}) : fail20(new Type5(ast, u));
var EitherFromSelf = ({
  left: left3,
  right: right3
}) => {
  return declare2([right3, left3], {
    decode: (right4, left4) => eitherParse(decodeUnknown3(right4), decodeUnknown3(left4)),
    encode: (right4, left4) => eitherParse(encodeUnknown2(right4), encodeUnknown2(left4))
  }, {
    description: `Either<${format6(right3)}, ${format6(left3)}>`,
    pretty: eitherPretty,
    arbitrary: eitherArbitrary,
    equivalence: (right4, left4) => getEquivalence({
      left: left4,
      right: right4
    })
  });
};
var makeLeftEncoded = (left3) => ({
  _tag: "Left",
  left: left3
});
var makeRightEncoded = (right3) => ({
  _tag: "Right",
  right: right3
});
var Either2 = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  return transform6(eitherEncoded(right_, left_), EitherFromSelf({
    left: typeSchema(left_),
    right: typeSchema(right_)
  }), {
    strict: true,
    decode: eitherDecode,
    encode: match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
var EitherFromUnion = ({
  left: left3,
  right: right3
}) => {
  const right_ = asSchema(right3);
  const left_ = asSchema(left3);
  const toright = typeSchema(right_);
  const toleft = typeSchema(left_);
  const fromRight = transform6(right_, rightEncoded(toright), {
    strict: true,
    decode: makeRightEncoded,
    encode: (r) => r.right
  });
  const fromLeft = transform6(left_, leftEncoded(toleft), {
    strict: true,
    decode: makeLeftEncoded,
    encode: (l) => l.left
  });
  return transform6(Union5(fromRight, fromLeft), EitherFromSelf({
    left: toleft,
    right: toright
  }), {
    strict: true,
    decode: (from) => from._tag === "Left" ? left2(from.left) : right2(from.right),
    encode: match({
      onLeft: makeLeftEncoded,
      onRight: makeRightEncoded
    })
  });
};
var mapArbitrary = (key, value6) => (fc) => fc.array(fc.tuple(key(fc), value6(fc))).map((as10) => new Map(as10));
var readonlyMapPretty = (key, value6) => (map34) => `new Map([${Array.from(map34.entries()).map(([k2, v]) => `[${key(k2)}, ${value6(v)}]`).join(", ")}])`;
var readonlyMapEquivalence = (key, value6) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a.entries()), Array.from(b.entries())));
};
var readonlyMapParse = (decodeUnknown5) => (u, options, ast) => isMap(u) ? toComposite(decodeUnknown5(Array.from(u.entries()), options), (as10) => new Map(as10), ast, u) : fail20(new Type5(ast, u));
var mapFromSelf_ = (key, value6, description) => declare2([key, value6], {
  decode: (Key2, Value2) => readonlyMapParse(decodeUnknown3(Array$(Tuple2(Key2, Value2)))),
  encode: (Key2, Value2) => readonlyMapParse(encodeUnknown2(Array$(Tuple2(Key2, Value2))))
}, {
  description,
  pretty: readonlyMapPretty,
  arbitrary: mapArbitrary,
  equivalence: readonlyMapEquivalence
});
var ReadonlyMapFromSelf = ({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `ReadonlyMap<${format6(key)}, ${format6(value6)}>`);
var MapFromSelf = ({
  key,
  value: value6
}) => mapFromSelf_(key, value6, `Map<${format6(key)}, ${format6(value6)}>`);
var ReadonlyMap = ({
  key,
  value: value6
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value6);
  return transform6(Array$(Tuple2(key_, value_)), ReadonlyMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    strict: true,
    decode: (as10) => new Map(as10),
    encode: (map34) => Array.from(map34.entries())
  });
};
var map34 = ({
  key,
  value: value6
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value6);
  return transform6(Array$(Tuple2(key_, value_)), MapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    strict: true,
    decode: (as10) => new Map(as10),
    encode: (map35) => Array.from(map35.entries())
  });
};
var ReadonlyMapFromRecord = ({
  key,
  value: value6
}) => transform6(Record2(encodedBoundSchema(key), value6), ReadonlyMapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (record3) => new Map(Object.entries(record3)),
  encode: fromEntries
});
var MapFromRecord = ({
  key,
  value: value6
}) => transform6(Record2(encodedBoundSchema(key), value6), MapFromSelf({
  key,
  value: typeSchema(value6)
}), {
  strict: true,
  decode: (record3) => new Map(Object.entries(record3)),
  encode: fromEntries
});
var setArbitrary = (item) => (fc) => fc.array(item(fc)).map((as10) => new Set(as10));
var readonlySetPretty = (item) => (set16) => `new Set([${Array.from(set16.values()).map((a) => item(a)).join(", ")}])`;
var readonlySetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
};
var readonlySetParse = (decodeUnknown5) => (u, options, ast) => isSet(u) ? toComposite(decodeUnknown5(Array.from(u.values()), options), (as10) => new Set(as10), ast, u) : fail20(new Type5(ast, u));
var setFromSelf_ = (value6, description) => declare2([value6], {
  decode: (item) => readonlySetParse(decodeUnknown3(Array$(item))),
  encode: (item) => readonlySetParse(encodeUnknown2(Array$(item)))
}, {
  description,
  pretty: readonlySetPretty,
  arbitrary: setArbitrary,
  equivalence: readonlySetEquivalence
});
var ReadonlySetFromSelf = (value6) => setFromSelf_(value6, `ReadonlySet<${format6(value6)}>`);
var SetFromSelf = (value6) => setFromSelf_(value6, `Set<${format6(value6)}>`);
var ReadonlySet = (value6) => {
  const value_ = asSchema(value6);
  return transform6(Array$(value_), ReadonlySetFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (as10) => new Set(as10),
    encode: (set16) => Array.from(set16)
  });
};
var set16 = (value6) => {
  const value_ = asSchema(value6);
  return transform6(Array$(value_), SetFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (as10) => new Set(as10),
    encode: (set17) => Array.from(set17)
  });
};
var bigDecimalPretty = () => (val) => `BigDecimal(${format2(normalize(val))})`;
var bigDecimalArbitrary = () => (fc) => fc.tuple(fc.bigInt(), fc.integer()).map(([value6, scale2]) => make4(value6, scale2));

class BigDecimalFromSelf extends (/* @__PURE__ */ declare2(isBigDecimal, {
  identifier: "BigDecimalFromSelf",
  pretty: bigDecimalPretty,
  arbitrary: bigDecimalArbitrary,
  equivalence: () => Equivalence
})) {
}

class BigDecimal extends (/* @__PURE__ */ transformOrFail(String$2, BigDecimalFromSelf, {
  strict: true,
  decode: (num, _2, ast) => fromString(num).pipe(match2({
    onNone: () => fail20(new Type5(ast, num)),
    onSome: (val) => succeed22(normalize(val))
  })),
  encode: (val) => succeed22(format2(normalize(val)))
}).annotations({
  identifier: "BigDecimal"
})) {
}

class BigDecimalFromNumber extends (/* @__PURE__ */ transformOrFail(Number$, BigDecimalFromSelf, {
  strict: true,
  decode: (num) => succeed22(fromNumber(num)),
  encode: (val) => succeed22(unsafeToNumber(val))
}).annotations({
  identifier: "BigDecimalFromNumber"
})) {
}
var GreaterThanBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanBigDecimal");
var greaterThanBigDecimal = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => greaterThan2(a, min4), {
  typeId: {
    id: GreaterThanBigDecimalTypeId,
    annotation: {
      min: min4
    }
  },
  description: `a BigDecimal greater than ${format2(min4)}`,
  ...annotations4
}));
var GreaterThanOrEqualToBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/GreaterThanOrEqualToBigDecimal");
var greaterThanOrEqualToBigDecimal = (min4, annotations4) => (self2) => self2.pipe(filter16((a) => greaterThanOrEqualTo2(a, min4), {
  typeId: {
    id: GreaterThanOrEqualToBigDecimalTypeId,
    annotation: {
      min: min4
    }
  },
  description: `a BigDecimal greater than or equal to ${format2(min4)}`,
  ...annotations4
}));
var LessThanBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanBigDecimal");
var lessThanBigDecimal = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => lessThan2(a, max7), {
  typeId: {
    id: LessThanBigDecimalTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a BigDecimal less than ${format2(max7)}`,
  ...annotations4
}));
var LessThanOrEqualToBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/LessThanOrEqualToBigDecimal");
var lessThanOrEqualToBigDecimal = (max7, annotations4) => (self2) => self2.pipe(filter16((a) => lessThanOrEqualTo2(a, max7), {
  typeId: {
    id: LessThanOrEqualToBigDecimalTypeId,
    annotation: {
      max: max7
    }
  },
  description: `a BigDecimal less than or equal to ${format2(max7)}`,
  ...annotations4
}));
var PositiveBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/PositiveBigDecimal");
var positiveBigDecimal = (annotations4) => (self2) => self2.pipe(filter16((a) => isPositive(a), {
  typeId: {
    id: PositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a positive BigDecimal`,
  ...annotations4
}));
var PositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ positiveBigDecimal({
  identifier: "PositiveBigDecimalFromSelf",
  title: "PositiveBigDecimalFromSelf"
}));
var NonNegativeBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonNegativeBigDecimal");
var nonNegativeBigDecimal = (annotations4) => (self2) => self2.pipe(filter16((a) => a.value >= 0n, {
  typeId: {
    id: NonNegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-negative BigDecimal`,
  ...annotations4
}));
var NonNegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonNegativeBigDecimal({
  identifier: "NonNegativeBigDecimalFromSelf",
  title: "NonNegativeBigDecimalFromSelf"
}));
var NegativeBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NegativeBigDecimal");
var negativeBigDecimal = (annotations4) => (self2) => self2.pipe(filter16((a) => isNegative(a), {
  typeId: {
    id: NegativeBigDecimalTypeId,
    annotation: {}
  },
  description: `a negative BigDecimal`,
  ...annotations4
}));
var NegativeBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ negativeBigDecimal({
  identifier: "NegativeBigDecimalFromSelf",
  title: "NegativeBigDecimalFromSelf"
}));
var NonPositiveBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/NonPositiveBigDecimal");
var nonPositiveBigDecimal = (annotations4) => (self2) => self2.pipe(filter16((a) => a.value <= 0n, {
  typeId: {
    id: NonPositiveBigDecimalTypeId,
    annotation: {}
  },
  description: `a non-positive BigDecimal`,
  ...annotations4
}));
var NonPositiveBigDecimalFromSelf = /* @__PURE__ */ BigDecimalFromSelf.pipe(/* @__PURE__ */ nonPositiveBigDecimal({
  identifier: "NonPositiveBigDecimalFromSelf",
  title: "NonPositiveBigDecimalFromSelf"
}));
var BetweenBigDecimalTypeId = /* @__PURE__ */ Symbol.for("@effect/schema/TypeId/BetweenBigDecimal");
var betweenBigDecimal = (minimum, maximum, annotations4) => (self2) => self2.pipe(filter16((a) => between2(a, {
  minimum,
  maximum
}), {
  typeId: {
    id: BetweenBigDecimalTypeId,
    annotation: {
      maximum,
      minimum
    }
  },
  description: `a BigDecimal between ${format2(minimum)} and ${format2(maximum)}`,
  ...annotations4
}));
var clampBigDecimal = (minimum, maximum) => (self2) => transform6(self2, self2.pipe(typeSchema, betweenBigDecimal(minimum, maximum)), {
  strict: false,
  decode: (self3) => clamp4(self3, {
    minimum,
    maximum
  }),
  encode: identity
});
var chunkArbitrary = (item) => (fc) => fc.array(item(fc)).map(fromIterable2);
var chunkPretty = (item) => (c) => `Chunk(${toReadonlyArray(c).map(item).join(", ")})`;
var chunkParse = (decodeUnknown5) => (u, options, ast) => isChunk(u) ? isEmpty(u) ? succeed22(empty5()) : toComposite(decodeUnknown5(toReadonlyArray(u), options), fromIterable2, ast, u) : fail20(new Type5(ast, u));
var ChunkFromSelf = (value6) => {
  return declare2([value6], {
    decode: (item) => chunkParse(decodeUnknown3(Array$(item))),
    encode: (item) => chunkParse(encodeUnknown2(Array$(item)))
  }, {
    description: `Chunk<${format6(value6)}>`,
    pretty: chunkPretty,
    arbitrary: chunkArbitrary,
    equivalence: getEquivalence4
  });
};
var Chunk = (value6) => {
  const value_ = asSchema(value6);
  return transform6(Array$(value_), ChunkFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (as10) => as10.length === 0 ? empty5() : fromIterable2(as10),
    encode: toReadonlyArray
  });
};
var nonEmptyChunkArbitrary = (item) => (fc) => array4(item(fc), {
  minLength: 1
}).map((as10) => unsafeFromNonEmptyArray(as10));
var nonEmptyChunkPretty = (item) => (c) => `NonEmptyChunk(${toReadonlyArray(c).map(item).join(", ")})`;
var nonEmptyChunkParse = (decodeUnknown5) => (u, options, ast) => isChunk(u) && isNonEmpty2(u) ? toComposite(decodeUnknown5(toReadonlyArray(u), options), unsafeFromNonEmptyArray, ast, u) : fail20(new Type5(ast, u));
var NonEmptyChunkFromSelf = (value6) => {
  return declare2([value6], {
    decode: (item) => nonEmptyChunkParse(decodeUnknown3(NonEmptyArray(item))),
    encode: (item) => nonEmptyChunkParse(encodeUnknown2(NonEmptyArray(item)))
  }, {
    description: `NonEmptyChunk<${format6(value6)}>`,
    pretty: nonEmptyChunkPretty,
    arbitrary: nonEmptyChunkArbitrary,
    equivalence: getEquivalence4
  });
};
var NonEmptyChunk = (value6) => {
  const value_ = asSchema(value6);
  return transform6(NonEmptyArray(value_), NonEmptyChunkFromSelf(typeSchema(value_)), {
    strict: true,
    decode: unsafeFromNonEmptyArray,
    encode: toReadonlyArray
  });
};
var toData = (a) => Array.isArray(a) ? array5(a) : struct2(a);
var dataArbitrary = (item) => (fc) => item(fc).map(toData);
var dataPretty = (item) => (d) => `Data(${item(d)})`;
var dataParse = (decodeUnknown5) => (u, options, ast) => isEqual(u) ? toComposite(decodeUnknown5(u, options), toData, ast, u) : fail20(new Type5(ast, u));
var DataFromSelf = (item) => declare2([item], {
  decode: (item2) => dataParse(decodeUnknown3(item2)),
  encode: (item2) => dataParse(encodeUnknown2(item2))
}, {
  description: `Data<${format6(item)}>`,
  pretty: dataPretty,
  arbitrary: dataArbitrary
});
var Data = (item) => transform6(item, DataFromSelf(typeSchema(item)), {
  strict: false,
  decode: toData,
  encode: (a) => Array.isArray(a) ? Array.from(a) : Object.assign({}, a)
});
var isField = (u) => isSchema(u) || isPropertySignature(u);
var isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
var getFields = (hasFields) => ("fields" in hasFields) ? hasFields.fields : getFields(hasFields[refineTypeId]);
var getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
var getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
var Class5 = (identifier2) => (fieldsOr, annotations4) => makeClass({
  kind: "Class",
  identifier: identifier2,
  schema: getSchemaFromFieldsOr(fieldsOr),
  fields: getFieldsFromFieldsOr(fieldsOr),
  Base: Class3,
  annotations: annotations4
});
var getClassTag = (tag3) => withConstructorDefault(propertySignature(Literal4(tag3)), () => tag3);
var TaggedClass2 = (identifier2) => (tag3, fieldsOr, annotations4) => {
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedClass3 extends makeClass({
    kind: "TaggedClass",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Class3,
    annotations: annotations4
  }) {
    static _tag = tag3;
  };
};
var TaggedError2 = (identifier2) => (tag3, fieldsOr, annotations4) => {

  class Base3 extends Error3 {
  }
  Base3.prototype.name = tag3;
  const fields = getFieldsFromFieldsOr(fieldsOr);
  const schema = getSchemaFromFieldsOr(fieldsOr);
  const newFields = {
    _tag: getClassTag(tag3)
  };
  const taggedFields = extendFields(newFields, fields);
  return class TaggedErrorClass extends makeClass({
    kind: "TaggedError",
    identifier: identifier2 ?? tag3,
    schema: extend3(schema, Struct(newFields)),
    fields: taggedFields,
    Base: Base3,
    annotations: annotations4,
    disableToString: true
  }) {
    static _tag = tag3;
    get message() {
      return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey2(p)}: ${formatUnknown2(this[p])}`).join(", ")} }`;
    }
  };
};
var TaggedRequest = (identifier2) => (tag3, Failure, Success, fields, annotations4) => {
  const taggedFields = extendFields({
    _tag: getClassTag(tag3)
  }, fields);
  return class TaggedRequestClass extends makeClass({
    kind: "TaggedRequest",
    identifier: identifier2 ?? tag3,
    schema: Struct(taggedFields),
    fields: taggedFields,
    Base: Class4,
    annotations: annotations4
  }) {
    static _tag = tag3;
    get [symbol4]() {
      return this.constructor;
    }
    get [symbolResult]() {
      return {
        Failure,
        Success
      };
    }
  };
};
var extendFields = (a, b) => {
  const out = {
    ...a
  };
  for (const key of ownKeys(b)) {
    if (key in a) {
      throw new Error(getASTDuplicatePropertySignatureErrorMessage2(key));
    }
    out[key] = b[key];
  }
  return out;
};
var orElseTitleAnnotation = (schema, title) => {
  const annotation = getTitleAnnotation2(schema.ast);
  if (isNone2(annotation)) {
    return schema.annotations({
      title
    });
  }
  return schema;
};
var getDisableValidationMakeOption2 = (options) => isBoolean(options) ? options : options?.disableValidation ?? false;
var makeClass = ({
  Base: Base3,
  annotations: annotations4,
  disableToString,
  fields,
  identifier: identifier2,
  kind,
  schema
}) => {
  const classSymbol = Symbol.for(`@effect/schema/${kind}/${identifier2}`);
  const validateSchema = orElseTitleAnnotation(schema, `${identifier2} (Constructor)`);
  const encodedSide = orElseTitleAnnotation(schema, `${identifier2} (Encoded side)`);
  const typeSide = orElseTitleAnnotation(typeSchema(schema), `${identifier2} (Type side)`);
  const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is3(typeSide)(u);
  const klass = class extends Base3 {
    constructor(props = {}, options = false) {
      props = {
        ...props
      };
      if (kind !== "Class") {
        delete props["_tag"];
      }
      props = lazilyMergeDefaults(fields, props);
      if (!getDisableValidationMakeOption2(options)) {
        props = validateSync2(validateSchema)(props);
      }
      super(props, true);
    }
    static [TypeId32] = variance10;
    static get ast() {
      const declaration = declare2([typeSide], {
        decode: () => (input, _2, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed22(input) : fail20(new Type5(ast, input)),
        encode: () => (input, options) => input instanceof this ? succeed22(input) : map33(encodeUnknown2(typeSide)(input, options), (props) => new this(props, true))
      }, {
        identifier: identifier2,
        title: identifier2,
        description: `an instance of ${identifier2}`,
        pretty: (pretty4) => (self2) => `${identifier2}(${pretty4(self2)})`,
        arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
        equivalence: identity,
        [SurrogateAnnotationId2]: typeSide.ast,
        ...annotations4
      });
      const transformation = transform6(encodedSide, declaration, {
        strict: true,
        decode: (input) => new this(input, true),
        encode: identity
      }).annotations({
        [SurrogateAnnotationId2]: schema.ast
      });
      return transformation.ast;
    }
    static pipe() {
      return pipeArguments(this, arguments);
    }
    static annotations(annotations5) {
      return make90(this.ast).annotations(annotations5);
    }
    static toString() {
      return `(${String(encodedSide)} <-> ${identifier2})`;
    }
    static make(...args2) {
      return new this(...args2);
    }
    static fields = {
      ...fields
    };
    static identifier = identifier2;
    static extend(identifier3) {
      return (newFieldsOr, annotations5) => {
        const newFields = getFieldsFromFieldsOr(newFieldsOr);
        const newSchema = getSchemaFromFieldsOr(newFieldsOr);
        const extendedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: extend3(schema, newSchema),
          fields: extendedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFail(identifier3) {
      return (newFields, options, annotations5) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(schema, typeSchema(Struct(transformedFields)), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    static transformOrFailFrom(identifier3) {
      return (newFields, options, annotations5) => {
        const transformedFields = extendFields(fields, newFields);
        return makeClass({
          kind,
          identifier: identifier3,
          schema: transformOrFail(encodedSchema(schema), Struct(transformedFields), options),
          fields: transformedFields,
          Base: this,
          annotations: annotations5
        });
      };
    }
    get [classSymbol]() {
      return classSymbol;
    }
  };
  if (disableToString !== true) {
    Object.defineProperty(klass.prototype, "toString", {
      value() {
        return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey2(p)}: ${formatUnknown2(this[p])}`).join(", ")} })`;
      },
      configurable: true
    });
  }
  return klass;
};
var FiberIdNoneEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("None")
}).annotations({
  identifier: "FiberIdNoneEncoded"
});
var FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("Runtime"),
  id: Int.annotations({
    title: "id",
    description: "id"
  }),
  startTimeMillis: Int.annotations({
    title: "startTimeMillis",
    description: "startTimeMillis"
  })
}).annotations({
  identifier: "FiberIdRuntimeEncoded"
});
var FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
  _tag: Literal4("Composite"),
  left: suspend11(() => FiberIdEncoded),
  right: suspend11(() => FiberIdEncoded)
}).annotations({
  identifier: "FiberIdCompositeEncoded"
});
var FiberIdEncoded = /* @__PURE__ */ Union5(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
  identifier: "FiberIdEncoded"
});
var fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
  None: fc.record({
    _tag: fc.constant("None")
  }),
  Runtime: fc.record({
    _tag: fc.constant("Runtime"),
    id: fc.integer(),
    startTimeMillis: fc.integer()
  }),
  Composite: fc.record({
    _tag: fc.constant("Composite"),
    left: tie("FiberId"),
    right: tie("FiberId")
  }),
  FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
})).FiberId.map(fiberIdDecode);
var fiberIdPretty = (fiberId4) => {
  switch (fiberId4._tag) {
    case "None":
      return "FiberId.none";
    case "Runtime":
      return `FiberId.runtime(${fiberId4.id}, ${fiberId4.startTimeMillis})`;
    case "Composite":
      return `FiberId.composite(${fiberIdPretty(fiberId4.right)}, ${fiberIdPretty(fiberId4.left)})`;
  }
};

class FiberIdFromSelf extends (/* @__PURE__ */ declare2(isFiberId2, {
  identifier: "FiberIdFromSelf",
  pretty: () => fiberIdPretty,
  arbitrary: () => fiberIdArbitrary
})) {
}
var fiberIdDecode = (input) => {
  switch (input._tag) {
    case "None":
      return none4;
    case "Runtime":
      return runtime2(input.id, input.startTimeMillis);
    case "Composite":
      return composite2(fiberIdDecode(input.left), fiberIdDecode(input.right));
  }
};
var fiberIdEncode = (input) => {
  switch (input._tag) {
    case "None":
      return {
        _tag: "None"
      };
    case "Runtime":
      return {
        _tag: "Runtime",
        id: input.id,
        startTimeMillis: input.startTimeMillis
      };
    case "Composite":
      return {
        _tag: "Composite",
        left: fiberIdEncode(input.left),
        right: fiberIdEncode(input.right)
      };
  }
};

class FiberId extends (/* @__PURE__ */ transform6(FiberIdEncoded, FiberIdFromSelf, {
  strict: true,
  decode: fiberIdDecode,
  encode: fiberIdEncode
}).annotations({
  identifier: "FiberId"
})) {
}
var causeDieEncoded = (defect) => Struct({
  _tag: Literal4("Die"),
  defect
});
var CauseEmptyEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal4("Empty")
});
var causeFailEncoded = (error2) => Struct({
  _tag: Literal4("Fail"),
  error: error2
});
var CauseInterruptEncoded = /* @__PURE__ */ Struct({
  _tag: /* @__PURE__ */ Literal4("Interrupt"),
  fiberId: FiberIdEncoded
});
var causeParallelEncoded = (causeEncoded) => Struct({
  _tag: Literal4("Parallel"),
  left: causeEncoded,
  right: causeEncoded
});
var causeSequentialEncoded = (causeEncoded) => Struct({
  _tag: Literal4("Sequential"),
  left: causeEncoded,
  right: causeEncoded
});
var causeEncoded = (error2, defect) => {
  const recur = suspend11(() => out);
  const out = Union5(CauseEmptyEncoded, causeFailEncoded(error2), causeDieEncoded(defect), CauseInterruptEncoded, causeSequentialEncoded(recur), causeParallelEncoded(recur)).annotations({
    description: `CauseEncoded<${format6(error2)}>`
  });
  return out;
};
var causeArbitrary = (error2, defect) => (fc) => fc.letrec((tie) => ({
  Empty: fc.record({
    _tag: fc.constant("Empty")
  }),
  Fail: fc.record({
    _tag: fc.constant("Fail"),
    error: error2(fc)
  }),
  Die: fc.record({
    _tag: fc.constant("Die"),
    defect: defect(fc)
  }),
  Interrupt: fc.record({
    _tag: fc.constant("Interrupt"),
    fiberId: fiberIdArbitrary(fc)
  }),
  Sequential: fc.record({
    _tag: fc.constant("Sequential"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Parallel: fc.record({
    _tag: fc.constant("Parallel"),
    left: tie("Cause"),
    right: tie("Cause")
  }),
  Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
})).Cause.map(causeDecode);
var causePretty = (error2) => (cause3) => {
  const f = (cause4) => {
    switch (cause4._tag) {
      case "Empty":
        return "Cause.empty";
      case "Fail":
        return `Cause.fail(${error2(cause4.error)})`;
      case "Die":
        return `Cause.die(${pretty2(cause4)})`;
      case "Interrupt":
        return `Cause.interrupt(${fiberIdPretty(cause4.fiberId)})`;
      case "Sequential":
        return `Cause.sequential(${f(cause4.left)}, ${f(cause4.right)})`;
      case "Parallel":
        return `Cause.parallel(${f(cause4.left)}, ${f(cause4.right)})`;
    }
  };
  return f(cause3);
};
var causeParse = (decodeUnknown5) => (u, options, ast) => isCause2(u) ? toComposite(decodeUnknown5(causeEncode(u), options), causeDecode, ast, u) : fail20(new Type5(ast, u));
var CauseFromSelf = ({
  defect = Unknown2,
  error: error2
}) => {
  return declare2([error2, defect], {
    decode: (error3, defect2) => causeParse(decodeUnknown3(causeEncoded(error3, defect2))),
    encode: (error3, defect2) => causeParse(encodeUnknown2(causeEncoded(error3, defect2)))
  }, {
    description: `Cause<${format6(error2)}>`,
    pretty: causePretty,
    arbitrary: causeArbitrary
  });
};
var CauseDefectUnknown = /* @__PURE__ */ transform6(Unknown2, Unknown2, {
  strict: true,
  decode: (u) => {
    if (isObject(u) && "message" in u && typeof u.message === "string") {
      const err2 = new Error(u.message, {
        cause: u
      });
      if ("name" in u && typeof u.name === "string") {
        err2.name = u.name;
      }
      err2.stack = "stack" in u && typeof u.stack === "string" ? u.stack : "";
      return err2;
    }
    return String(u);
  },
  encode: (defect) => {
    if (defect instanceof Error) {
      return {
        name: defect.name,
        message: defect.message
      };
    }
    return String(defect);
  }
});
var Cause = ({
  defect = CauseDefectUnknown,
  error: error2
}) => {
  const error_ = asSchema(error2);
  return transform6(causeEncoded(error_, defect), CauseFromSelf({
    error: typeSchema(error_),
    defect: typeSchema(defect)
  }), {
    strict: true,
    decode: causeDecode,
    encode: causeEncode
  });
};
var exitFailureEncoded = (error2, defect) => Struct({
  _tag: Literal4("Failure"),
  cause: causeEncoded(error2, defect)
}).annotations({
  description: `FailureEncoded<${format6(error2)}>`
});
var exitSuccessEncoded = (value6) => Struct({
  _tag: Literal4("Success"),
  value: value6
}).annotations({
  description: `SuccessEncoded<${format6(value6)}>`
});
var exitEncoded = (value6, error2, defect) => Union5(exitFailureEncoded(error2, defect), exitSuccessEncoded(value6)).annotations({
  description: `ExitEncoded<${format6(value6)}, ${format6(error2)}>`
});
var exitDecode = (input) => {
  switch (input._tag) {
    case "Failure":
      return failCause2(causeDecode(input.cause));
    case "Success":
      return succeed2(input.value);
  }
};
var exitArbitrary = (value6, error2, defect) => (fc) => fc.oneof(fc.record({
  _tag: fc.constant("Failure"),
  cause: causeArbitrary(error2, defect)(fc)
}), fc.record({
  _tag: fc.constant("Success"),
  value: value6(fc)
})).map(exitDecode);
var exitPretty = (value6, error2) => (exit3) => exit3._tag === "Failure" ? `Exit.failCause(${causePretty(error2)(exit3.cause)})` : `Exit.succeed(${value6(exit3.value)})`;
var exitParse = (decodeUnknownValue, decodeUnknownCause) => (u, options, ast) => isExit(u) ? match6(u, {
  onFailure: (cause3) => toComposite(decodeUnknownCause(cause3, options), failCause2, ast, u),
  onSuccess: (value6) => toComposite(decodeUnknownValue(value6, options), succeed2, ast, u)
}) : fail20(new Type5(ast, u));
var ExitFromSelf = ({
  defect = Unknown2,
  failure,
  success
}) => declare2([success, failure, defect], {
  decode: (success2, failure2, defect2) => exitParse(decodeUnknown3(success2), decodeUnknown3(CauseFromSelf({
    error: failure2,
    defect: defect2
  }))),
  encode: (success2, failure2, defect2) => exitParse(encodeUnknown2(success2), encodeUnknown2(CauseFromSelf({
    error: failure2,
    defect: defect2
  })))
}, {
  description: `Exit<${format6(success)}, ${format6(failure)}>`,
  pretty: exitPretty,
  arbitrary: exitArbitrary
});
var Exit = ({
  defect = CauseDefectUnknown,
  failure,
  success
}) => {
  const success_ = asSchema(success);
  const failure_ = asSchema(failure);
  return transform6(exitEncoded(success_, failure_, defect), ExitFromSelf({
    failure: typeSchema(failure_),
    success: typeSchema(success_),
    defect: typeSchema(defect)
  }), {
    strict: true,
    decode: exitDecode,
    encode: (exit3) => exit3._tag === "Failure" ? {
      _tag: "Failure",
      cause: exit3.cause
    } : {
      _tag: "Success",
      value: exit3.value
    }
  });
};
var hashSetArbitrary = (item) => (fc) => fc.array(item(fc)).map((as10) => fromIterable5(as10));
var hashSetPretty = (item) => (set17) => `HashSet(${Array.from(set17).map((a) => item(a)).join(", ")})`;
var hashSetEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashSetParse = (decodeUnknown5) => (u, options, ast) => isHashSet2(u) ? toComposite(decodeUnknown5(Array.from(u), options), fromIterable5, ast, u) : fail20(new Type5(ast, u));
var HashSetFromSelf = (value6) => {
  return declare2([value6], {
    decode: (item) => hashSetParse(decodeUnknown3(Array$(item))),
    encode: (item) => hashSetParse(encodeUnknown2(Array$(item)))
  }, {
    description: `HashSet<${format6(value6)}>`,
    pretty: hashSetPretty,
    arbitrary: hashSetArbitrary,
    equivalence: hashSetEquivalence
  });
};
var HashSet = (value6) => {
  const value_ = asSchema(value6);
  return transform6(Array$(value_), HashSetFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (as10) => fromIterable5(as10),
    encode: (set17) => Array.from(set17)
  });
};
var hashMapArbitrary = (key, value6) => (fc) => fc.array(fc.tuple(key(fc), value6(fc))).map((as10) => fromIterable6(as10));
var hashMapPretty = (key, value6) => (map35) => `HashMap([${Array.from(map35).map(([k2, v]) => `[${key(k2)}, ${value6(v)}]`).join(", ")}])`;
var hashMapEquivalence = (key, value6) => {
  const arrayEquivalence = getEquivalence3(make(([ka, va], [kb, vb]) => key(ka, kb) && value6(va, vb)));
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var hashMapParse = (decodeUnknown5) => (u, options, ast) => isHashMap2(u) ? toComposite(decodeUnknown5(Array.from(u), options), fromIterable6, ast, u) : fail20(new Type5(ast, u));
var HashMapFromSelf = ({
  key,
  value: value6
}) => {
  return declare2([key, value6], {
    decode: (key2, value7) => hashMapParse(decodeUnknown3(Array$(Tuple2(key2, value7)))),
    encode: (key2, value7) => hashMapParse(encodeUnknown2(Array$(Tuple2(key2, value7))))
  }, {
    description: `HashMap<${format6(key)}, ${format6(value6)}>`,
    pretty: hashMapPretty,
    arbitrary: hashMapArbitrary,
    equivalence: hashMapEquivalence
  });
};
var HashMap = ({
  key,
  value: value6
}) => {
  const key_ = asSchema(key);
  const value_ = asSchema(value6);
  return transform6(Array$(Tuple2(key_, value_)), HashMapFromSelf({
    key: typeSchema(key_),
    value: typeSchema(value_)
  }), {
    strict: true,
    decode: (as10) => fromIterable6(as10),
    encode: (map35) => Array.from(map35)
  });
};
var listArbitrary = (item) => (fc) => fc.array(item(fc)).map((as10) => fromIterable7(as10));
var listPretty = (item) => (set17) => `List(${Array.from(set17).map((a) => item(a)).join(", ")})`;
var listEquivalence = (item) => {
  const arrayEquivalence = getEquivalence3(item);
  return make((a, b) => arrayEquivalence(Array.from(a), Array.from(b)));
};
var listParse = (decodeUnknown5) => (u, options, ast) => isList(u) ? toComposite(decodeUnknown5(Array.from(u), options), fromIterable7, ast, u) : fail20(new Type5(ast, u));
var ListFromSelf = (value6) => {
  return declare2([value6], {
    decode: (item) => listParse(decodeUnknown3(Array$(item))),
    encode: (item) => listParse(encodeUnknown2(Array$(item)))
  }, {
    description: `List<${format6(value6)}>`,
    pretty: listPretty,
    arbitrary: listArbitrary,
    equivalence: listEquivalence
  });
};
var List = (value6) => {
  const value_ = asSchema(value6);
  return transform6(Array$(value_), ListFromSelf(typeSchema(value_)), {
    strict: true,
    decode: (as10) => fromIterable7(as10),
    encode: (set17) => Array.from(set17)
  });
};
var sortedSetArbitrary = (item, ord) => (fc) => fc.array(item(fc)).map((as10) => fromIterable11(as10, ord));
var sortedSetPretty = (item) => (set17) => `new SortedSet([${Array.from(values3(set17)).map((a) => item(a)).join(", ")}])`;
var sortedSetParse = (decodeUnknown5, ord) => (u, options, ast) => isSortedSet(u) ? toComposite(decodeUnknown5(Array.from(values3(u)), options), (as10) => fromIterable11(as10, ord), ast, u) : fail20(new Type5(ast, u));
var SortedSetFromSelf = (value6, ordA, ordI) => {
  return declare2([value6], {
    decode: (item) => sortedSetParse(decodeUnknown3(Array$(item)), ordA),
    encode: (item) => sortedSetParse(encodeUnknown2(Array$(item)), ordI)
  }, {
    description: `SortedSet<${format6(value6)}>`,
    pretty: sortedSetPretty,
    arbitrary: (arb) => sortedSetArbitrary(arb, ordA),
    equivalence: () => getEquivalence6()
  });
};
var SortedSet = (value6, ordA) => {
  const value_ = asSchema(value6);
  const to = typeSchema(value_);
  return transform6(Array$(value_), SortedSetFromSelf(to, ordA, ordA), {
    strict: true,
    decode: (as10) => fromIterable11(as10, ordA),
    encode: (set17) => Array.from(values3(set17))
  });
};

class BooleanFromUnknown extends (/* @__PURE__ */ transform6(Unknown2, Boolean$, {
  strict: true,
  decode: isTruthy,
  encode: identity
}).annotations({
  identifier: "BooleanFromUnknown"
})) {
}
var Config = (name, schema) => {
  const decodeEither_ = decodeEither(schema);
  return string5(name).pipe(mapOrFail2((a) => decodeEither_(a).pipe(mapLeft((error2) => InvalidData2([], formatErrorSync(error2))))));
};
// src/policy/rate-limits.ts
function createBucket(limit, window_duration_ms) {
  return {
    window_start: new Date,
    window_duration_ms,
    limit,
    count: 0
  };
}
function shouldResetBucket(bucket, now2) {
  return now2.getTime() - bucket.window_start.getTime() >= bucket.window_duration_ms;
}
function resetBucket(bucket, now2) {
  bucket.window_start = now2;
  bucket.count = 0;
}
function checkBucketLimit(bucket, violationType, now2 = new Date) {
  if (shouldResetBucket(bucket, now2)) {
    resetBucket(bucket, now2);
  }
  if (bucket.count >= bucket.limit) {
    const window_reset_at = new Date(bucket.window_start.getTime() + bucket.window_duration_ms);
    const retry_after_ms = window_reset_at.getTime() - now2.getTime();
    return {
      allowed: false,
      violation_type: violationType,
      retry_after_ms: Math.max(0, retry_after_ms),
      current_count: bucket.count,
      limit: bucket.limit,
      window_reset_at
    };
  }
  bucket.count += 1;
  return {
    allowed: true,
    current_count: bucket.count,
    limit: bucket.limit,
    window_reset_at: new Date(bucket.window_start.getTime() + bucket.window_duration_ms)
  };
}
function createSessionRateLimiter(session_id) {
  return {
    session_id,
    query_burst_bucket: createBucket(RATE_LIMIT_POLICY.QUERIES.BURST_QPS, RATE_LIMIT_POLICY.QUERIES.BURST_WINDOW_MS),
    query_sustained_bucket: createBucket(RATE_LIMIT_POLICY.QUERIES.SUSTAINED_PER_MINUTE, RATE_LIMIT_POLICY.QUERIES.SUSTAINED_WINDOW_MS),
    mutation_burst_bucket: createBucket(RATE_LIMIT_POLICY.MUTATIONS.BURST_PER_5S, RATE_LIMIT_POLICY.MUTATIONS.BURST_WINDOW_MS),
    mutation_sustained_bucket: createBucket(RATE_LIMIT_POLICY.MUTATIONS.SUSTAINED_PER_MINUTE, RATE_LIMIT_POLICY.MUTATIONS.SUSTAINED_WINDOW_MS),
    draft_burst_bucket: createBucket(RATE_LIMIT_POLICY.DRAFT_SAVES.BURST_PPS, RATE_LIMIT_POLICY.DRAFT_SAVES.BURST_WINDOW_MS),
    draft_sustained_bucket: createBucket(RATE_LIMIT_POLICY.DRAFT_SAVES.SUSTAINED_PER_MINUTE, RATE_LIMIT_POLICY.DRAFT_SAVES.SUSTAINED_WINDOW_MS)
  };
}
function checkQueryRateLimit(limiter) {
  const burstResult = checkBucketLimit(limiter.query_burst_bucket, "query_burst_exceeded");
  if (!burstResult.allowed) {
    return burstResult;
  }
  const sustainedResult = checkBucketLimit(limiter.query_sustained_bucket, "query_sustained_exceeded");
  if (!sustainedResult.allowed) {
    limiter.query_burst_bucket.count -= 1;
    return sustainedResult;
  }
  return sustainedResult;
}
function checkMutationRateLimit(limiter) {
  const burstResult = checkBucketLimit(limiter.mutation_burst_bucket, "mutation_burst_exceeded");
  if (!burstResult.allowed) {
    return burstResult;
  }
  const sustainedResult = checkBucketLimit(limiter.mutation_sustained_bucket, "mutation_sustained_exceeded");
  if (!sustainedResult.allowed) {
    limiter.mutation_burst_bucket.count -= 1;
    return sustainedResult;
  }
  return sustainedResult;
}
function checkDraftSaveRateLimit(limiter) {
  const burstResult = checkBucketLimit(limiter.draft_burst_bucket, "draft_burst_exceeded");
  if (!burstResult.allowed) {
    return burstResult;
  }
  const sustainedResult = checkBucketLimit(limiter.draft_sustained_bucket, "draft_sustained_exceeded");
  if (!sustainedResult.allowed) {
    limiter.draft_burst_bucket.count -= 1;
    return sustainedResult;
  }
  return sustainedResult;
}
var RATE_LIMIT_POLICY = {
  QUERIES: {
    BURST_QPS: 5,
    SUSTAINED_PER_MINUTE: 60,
    BURST_WINDOW_MS: 1000,
    SUSTAINED_WINDOW_MS: 60000
  },
  MUTATIONS: {
    BURST_PER_5S: 1,
    SUSTAINED_PER_MINUTE: 12,
    BURST_WINDOW_MS: 5000,
    SUSTAINED_WINDOW_MS: 60000
  },
  DRAFT_SAVES: {
    BURST_PPS: 10,
    SUSTAINED_PER_MINUTE: 300,
    BURST_WINDOW_MS: 1000,
    SUSTAINED_WINDOW_MS: 60000
  }
};
var RateLimitViolationType = exports_Schema2.Literal("query_burst_exceeded", "query_sustained_exceeded", "mutation_burst_exceeded", "mutation_sustained_exceeded", "draft_burst_exceeded", "draft_sustained_exceeded");
var RateLimitResult = exports_Schema2.Struct({
  allowed: exports_Schema2.Boolean,
  violation_type: exports_Schema2.optional(RateLimitViolationType),
  retry_after_ms: exports_Schema2.optional(exports_Schema2.Number.pipe(exports_Schema2.int(), exports_Schema2.greaterThan(0))),
  current_count: exports_Schema2.Number.pipe(exports_Schema2.int(), exports_Schema2.greaterThanOrEqualTo(0)),
  limit: exports_Schema2.Number.pipe(exports_Schema2.int(), exports_Schema2.greaterThan(0)),
  window_reset_at: exports_Schema2.Date
});

// src/adapters/api/elysia.adapter.ts
function mapToApiError(error2) {
  if (typeof error2 === "object" && error2 !== null && "_tag" in error2) {
    const taggedError = error2;
    switch (taggedError._tag) {
      case "NotFound":
        return {
          error: {
            type: "NotFound",
            message: `${taggedError.entity} not found: ${taggedError.id}`
          }
        };
      case "ValidationError":
        return {
          error: {
            type: "ValidationError",
            message: "Validation failed",
            details: taggedError.errors?.map((err2) => ({
              field: "unknown",
              message: err2,
              code: "VALIDATION_ERROR"
            }))
          }
        };
      case "ConflictError":
        return {
          error: {
            type: "ConflictError",
            message: taggedError.message || "Operation conflict"
          }
        };
      case "IndexingFailure":
        return {
          error: {
            type: "IndexingFailure",
            message: taggedError.reason || "Indexing operation failed"
          }
        };
      default:
        return {
          error: {
            type: "StorageIO",
            message: "Internal server error"
          }
        };
    }
  }
  return {
    error: {
      type: "StorageIO",
      message: error2 instanceof Error ? error2.message : "Unknown error"
    }
  };
}
function checkRateLimit(rateLimiter, operation) {
  const checkFunction = {
    query: checkQueryRateLimit,
    mutation: checkMutationRateLimit,
    draft: checkDraftSaveRateLimit
  }[operation];
  const result = checkFunction(rateLimiter);
  if (!result.allowed) {
    throw new Error(JSON.stringify({
      error: {
        type: "RateLimitExceeded",
        message: `Rate limit exceeded for ${operation} operations`,
        retry_after: Math.ceil((result.retry_after_ms || 0) / 1000)
      }
    }));
  }
}
function createApiAdapter(deps) {
  const sessions = new Map;
  const getOrCreateSession = (sessionId) => {
    if (sessionId && sessions.has(sessionId)) {
      return sessions.get(sessionId);
    }
    const newSessionId = sessionId || `ses_${Date.now()}`;
    const context9 = {
      session_id: newSessionId,
      rate_limiter: createSessionRateLimiter(newSessionId),
      created_at: new Date
    };
    sessions.set(newSessionId, context9);
    return context9;
  };
  return new Elysia({ name: "knowledge-api" }).get("/healthz", () => ({ status: "ok" })).get("/health", async () => {
    const healthResult = await exports_Effect.runPromise(deps.storage.getStorageHealth());
    return healthResult;
  }).post("/drafts", async ({ body, headers }) => {
    const sessionContext = getOrCreateSession(headers["x-session-id"]);
    checkRateLimit(sessionContext.rate_limiter, "draft");
    try {
      const request2 = exports_Schema2.decodeUnknownSync(SaveDraftRequest)(body);
      const response = await exports_Effect.runPromise(deps.storage.saveDraft(request2));
      return response;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }, {
    body: t.Object({
      note_id: t.String(),
      body_md: t.String(),
      metadata: t.Object({
        tags: t.Optional(t.Array(t.String()))
      }),
      client_token: t.Optional(t.String())
    })
  }).get("/drafts/:note_id", async ({ params }) => {
    try {
      const draft = await exports_Effect.runPromise(deps.storage.getDraft(params.note_id));
      return draft;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).post("/publish", async ({ body, headers }) => {
    const sessionContext = getOrCreateSession(headers["x-session-id"]);
    checkRateLimit(sessionContext.rate_limiter, "mutation");
    try {
      const request2 = exports_Schema2.decodeUnknownSync(PublishRequest)(body);
      const response = await exports_Effect.runPromise(deps.storage.publishVersion(request2));
      return response;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }, {
    body: t.Object({
      note_id: t.String(),
      collections: t.Array(t.String()),
      label: t.Optional(t.Union([t.Literal("minor"), t.Literal("major")])),
      client_token: t.String()
    })
  }).post("/rollback", async ({ body, headers }) => {
    const sessionContext = getOrCreateSession(headers["x-session-id"]);
    checkRateLimit(sessionContext.rate_limiter, "mutation");
    try {
      const request2 = exports_Schema2.decodeUnknownSync(RollbackRequest)(body);
      const response = await exports_Effect.runPromise(deps.storage.rollbackToVersion(request2));
      return response;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }, {
    body: t.Object({
      note_id: t.String(),
      target_version_id: t.String(),
      client_token: t.String()
    })
  }).get("/search", async ({ query, headers }) => {
    const sessionContext = getOrCreateSession(headers["x-session-id"]);
    checkRateLimit(sessionContext.rate_limiter, "query");
    try {
      const request2 = {
        q: query.q,
        collections: query.collections ? Array.isArray(query.collections) ? query.collections : [query.collections] : undefined,
        page: query.page ? Number.parseInt(query.page, 10) : undefined,
        page_size: query.page_size ? Number.parseInt(query.page_size, 10) : undefined
      };
      const response = await exports_Effect.runPromise(deps.indexing.search(request2));
      return response;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).get("/notes/:note_id/versions", async ({ params, query }) => {
    try {
      const request2 = {
        note_id: params.note_id,
        page: query.page ? Number.parseInt(query.page, 10) : undefined,
        page_size: query.page_size ? Number.parseInt(query.page_size, 10) : undefined
      };
      const versions = await exports_Effect.runPromise(deps.storage.listVersions(request2.note_id, {
        offset: (request2.page || 0) * (request2.page_size || 10),
        limit: request2.page_size || 10
      }));
      return {
        versions,
        page: request2.page || 0,
        page_size: request2.page_size || 10,
        total_count: versions.length,
        has_more: false
      };
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).get("/versions/:version_id", async ({ params }) => {
    try {
      const version = await exports_Effect.runPromise(deps.storage.getVersion(params.version_id));
      return version;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).get("/collections", async ({ query }) => {
    try {
      const collections = await exports_Effect.runPromise(deps.storage.listCollections({
        offset: query.offset ? Number.parseInt(query.offset, 10) : undefined,
        limit: query.limit ? Number.parseInt(query.limit, 10) : undefined
      }));
      return { collections };
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).post("/collections", async ({ body }) => {
    try {
      const collection = await exports_Effect.runPromise(deps.storage.createCollection(body.name, body.description));
      return collection;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }, {
    body: t.Object({
      name: t.String(),
      description: t.Optional(t.String())
    })
  }).get("/collections/:collection_id", async ({ params }) => {
    try {
      const collection = await exports_Effect.runPromise(deps.storage.getCollection(params.collection_id));
      return collection;
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).get("/sessions", async ({ query }) => {
    try {
      const sessions2 = await exports_Effect.runPromise(deps.storage.listSessions({
        offset: query.offset ? Number.parseInt(query.offset, 10) : undefined,
        limit: query.limit ? Number.parseInt(query.limit, 10) : undefined
      }));
      return { sessions: sessions2 };
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).get("/sessions/:session_id", async ({ params }) => {
    try {
      const session = await exports_Effect.runPromise(deps.storage.getSession(params.session_id));
      return { session };
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }).post("/resolve-anchor", async ({ body }) => {
    try {
      const request2 = exports_Schema2.decodeUnknownSync(ResolveAnchorRequest)(body);
      const version = await exports_Effect.runPromise(deps.storage.getVersion(request2.version_id));
      const resolution = await exports_Effect.runPromise(deps.parsing.resolveAnchor(request2.anchor, version.content_md));
      return {
        resolved: resolution.resolved,
        content: resolution.resolved ? await exports_Effect.runPromise(deps.parsing.extractAnchorContent(request2.anchor, version.content_md)) : undefined,
        error: resolution.error
      };
    } catch (error2) {
      throw new Error(JSON.stringify(mapToApiError(error2)));
    }
  }, {
    body: t.Object({
      version_id: t.String(),
      anchor: t.Object({
        structure_path: t.String(),
        token_offset: t.Number(),
        token_length: t.Number(),
        fingerprint: t.String()
      })
    })
  }).onError(({ error: error2, set: set17 }) => {
    try {
      const errorResponse = JSON.parse(error2.message);
      if (errorResponse.error) {
        set17.status = getHttpStatusForError(errorResponse.error.type);
        return errorResponse;
      }
    } catch {
    }
    set17.status = 500;
    return {
      error: {
        type: "StorageIO",
        message: error2.message || "Internal server error"
      }
    };
  });
}
function getHttpStatusForError(errorType) {
  switch (errorType) {
    case "NotFound":
      return 404;
    case "ValidationError":
      return 400;
    case "ConflictError":
      return 409;
    case "RateLimitExceeded":
      return 429;
    case "VisibilityTimeout":
    case "IndexingFailure":
      return 503;
    case "SchemaVersionMismatch":
      return 422;
    default:
      return 500;
  }
}
function createKnowledgeApiApp(deps) {
  const apiAdapter = createApiAdapter(deps);
  return new Elysia({ name: "knowledge-repository-api" }).use(apiAdapter).onRequest(({ set: set17 }) => {
    set17.headers["Access-Control-Allow-Origin"] = "*";
    set17.headers["Access-Control-Allow-Methods"] = "GET, POST, PUT, DELETE, OPTIONS";
    set17.headers["Access-Control-Allow-Headers"] = "Content-Type, Authorization, X-Session-ID";
  }).onBeforeHandle(({ request: request2, set: set17 }) => {
    console.log(`${request2.method} ${new URL(request2.url).pathname}`);
    set17.headers["X-Request-ID"] = `req_${Date.now()}`;
  }).onAfterHandle(({ response, set: set17 }) => {
    console.log(`Response: ${set17.status || 200}`);
  });
}
var ApiAdapterPort = Symbol("ApiAdapterPort");

// node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib2(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;

// src/adapters/storage/database.ts
import { readFileSync } from "fs";
import { join as join4 } from "path";
function createDatabasePool(config2) {
  const fullConfig = { ...DEFAULT_DATABASE_CONFIG, ...config2 };
  return new DatabasePool(fullConfig);
}
function createMigrationManager(db) {
  return new MigrationManager(db);
}
function getDatabaseConfigFromEnv() {
  return {
    host: process.env.DB_HOST || DEFAULT_DATABASE_CONFIG.host,
    port: Number.parseInt(process.env.DB_PORT || String(DEFAULT_DATABASE_CONFIG.port), 10),
    database: process.env.DB_NAME || DEFAULT_DATABASE_CONFIG.database,
    user: process.env.DB_USER || DEFAULT_DATABASE_CONFIG.user,
    password: process.env.DB_PASSWORD || DEFAULT_DATABASE_CONFIG.password,
    ssl: process.env.DB_SSL === "true",
    maxConnections: Number.parseInt(process.env.DB_MAX_CONNECTIONS || "10", 10)
  };
}
var __dirname = "/Users/sayertindall/Dev/Obscura/Projects/Current/knowledge-repository/src/adapters/storage";
var DEFAULT_DATABASE_CONFIG = {
  host: "localhost",
  port: 54321,
  database: "electric",
  user: "postgres",
  password: "password",
  ssl: false,
  maxConnections: 10
};

class DatabasePool {
  pool;
  constructor(config2 = DEFAULT_DATABASE_CONFIG) {
    const poolConfig = {
      host: config2.host,
      port: config2.port,
      database: config2.database,
      user: config2.user,
      password: config2.password,
      ssl: config2.ssl,
      max: config2.maxConnections || 10,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 5000
    };
    this.pool = new Pool(poolConfig);
  }
  testConnection = () => exports_Effect.promise(async () => {
    try {
      const client = await this.pool.connect();
      await client.query("SELECT 1");
      client.release();
    } catch (error2) {
      throw {
        _tag: "ConnectionFailed",
        reason: error2 instanceof Error ? error2.message : "Unknown connection error"
      };
    }
  });
  query = (text, params) => exports_Effect.promise(async () => {
    try {
      const result = await this.pool.query(text, params);
      return result.rows;
    } catch (error2) {
      throw {
        _tag: "QueryFailed",
        query: text,
        reason: error2 instanceof Error ? error2.message : "Unknown query error"
      };
    }
  });
  transaction = (operations) => exports_Effect.promise(async () => {
    const client = await this.pool.connect();
    try {
      await client.query("BEGIN");
      const transactionQuery = (text, params) => exports_Effect.promise(async () => {
        try {
          const result2 = await client.query(text, params);
          return result2.rows;
        } catch (error2) {
          throw {
            _tag: "QueryFailed",
            query: text,
            reason: error2 instanceof Error ? error2.message : "Transaction query failed"
          };
        }
      });
      const result = await exports_Effect.runPromise(operations(transactionQuery));
      await client.query("COMMIT");
      return result;
    } catch (error2) {
      await client.query("ROLLBACK");
      throw {
        _tag: "TransactionFailed",
        reason: error2 instanceof Error ? error2.message : "Transaction failed"
      };
    } finally {
      client.release();
    }
  });
  close = () => exports_Effect.promise(async () => {
    await this.pool.end();
  });
  getStatus = () => exports_Effect.sync(() => ({
    totalCount: this.pool.totalCount,
    idleCount: this.pool.idleCount,
    waitingCount: this.pool.waitingCount
  }));
}

class MigrationManager {
  db;
  constructor(db) {
    this.db = db;
  }
  initializeMigrations = () => this.db.query(`
			CREATE TABLE IF NOT EXISTS schema_migrations (
				id SERIAL PRIMARY KEY,
				name TEXT NOT NULL UNIQUE,
				applied_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
			)
		`).pipe(exports_Effect.asVoid);
  getAppliedMigrations = () => this.db.query(`
			SELECT id, name, applied_at 
			FROM schema_migrations 
			ORDER BY id ASC
		`);
  applyMigration = (name, sql) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const existing = yield* query("SELECT COUNT(*) as count FROM schema_migrations WHERE name = $1", [name]);
    if (existing[0].count !== "0") {
      return;
    }
    yield* query(sql);
    yield* query("INSERT INTO schema_migrations (name) VALUES ($1)", [name]);
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail({
    _tag: "MigrationFailed",
    migration: name,
    reason: error2 instanceof Error ? error2.message : "Migration failed"
  }))));
  runMigrations = () => exports_Effect.gen(this, function* () {
    yield* this.initializeMigrations();
    const appliedMigrations = yield* this.getAppliedMigrations();
    const appliedNames = new Set(appliedMigrations.map((m) => m.name));
    const migrationDir = join4(__dirname, "migrations");
    const migrationFiles = ["001_initial_schema.sql"];
    const appliedNames_ = [];
    for (const file of migrationFiles) {
      const migrationName = file.replace(".sql", "");
      if (!appliedNames.has(migrationName)) {
        try {
          const sql = readFileSync(join4(migrationDir, file), "utf-8");
          yield* this.applyMigration(migrationName, sql);
          appliedNames_.push(migrationName);
        } catch (error2) {
          yield* exports_Effect.fail({
            _tag: "MigrationFailed",
            migration: migrationName,
            reason: error2 instanceof Error ? error2.message : "Failed to read migration file"
          });
        }
      }
    }
    return { applied: appliedNames_ };
  });
}

// node_modules/ulid/dist/node/index.js
import crypto2 from "crypto";
function randomChar(prng) {
  const randomPosition = Math.floor(prng() * ENCODING_LEN) % ENCODING_LEN;
  return ENCODING.charAt(randomPosition);
}
function detectPRNG(root) {
  const rootLookup = detectRoot();
  const globalCrypto = rootLookup && (rootLookup.crypto || rootLookup.msCrypto) || (typeof crypto2 !== "undefined" ? crypto2 : null);
  if (typeof globalCrypto?.getRandomValues === "function") {
    return () => {
      const buffer3 = new Uint8Array(1);
      globalCrypto.getRandomValues(buffer3);
      return buffer3[0] / 255;
    };
  } else if (typeof globalCrypto?.randomBytes === "function") {
    return () => globalCrypto.randomBytes(1).readUInt8() / 255;
  } else if (crypto2?.randomBytes) {
    return () => crypto2.randomBytes(1).readUInt8() / 255;
  }
  throw new ULIDError(ULIDErrorCode.PRNGDetectFailure, "Failed to find a reliable PRNG");
}
function detectRoot() {
  if (inWebWorker())
    return self;
  if (typeof window !== "undefined") {
    return window;
  }
  if (typeof global !== "undefined") {
    return global;
  }
  if (typeof globalThis !== "undefined") {
    return globalThis;
  }
  return null;
}
function encodeRandom(len, prng) {
  let str = "";
  for (;len > 0; len--) {
    str = randomChar(prng) + str;
  }
  return str;
}
function encodeTime(now2, len = TIME_LEN) {
  if (isNaN(now2)) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be a number: ${now2}`);
  } else if (now2 > TIME_MAX) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${TIME_MAX}: ${now2}`);
  } else if (now2 < 0) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeNegative, `Time must be positive: ${now2}`);
  } else if (Number.isInteger(now2) === false) {
    throw new ULIDError(ULIDErrorCode.EncodeTimeValueMalformed, `Time must be an integer: ${now2}`);
  }
  let mod, str = "";
  for (let currentLen = len;currentLen > 0; currentLen--) {
    mod = now2 % ENCODING_LEN;
    str = ENCODING.charAt(mod) + str;
    now2 = (now2 - mod) / ENCODING_LEN;
  }
  return str;
}
function inWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
function ulid(seedTime, prng) {
  const currentPRNG = prng || detectPRNG();
  const seed = !seedTime || isNaN(seedTime) ? Date.now() : seedTime;
  return encodeTime(seed, TIME_LEN) + encodeRandom(RANDOM_LEN, currentPRNG);
}
var ENCODING = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
var ENCODING_LEN = 32;
var RANDOM_LEN = 16;
var TIME_LEN = 10;
var TIME_MAX = 281474976710655;
var ULIDErrorCode;
(function(ULIDErrorCode2) {
  ULIDErrorCode2["Base32IncorrectEncoding"] = "B32_ENC_INVALID";
  ULIDErrorCode2["DecodeTimeInvalidCharacter"] = "DEC_TIME_CHAR";
  ULIDErrorCode2["DecodeTimeValueMalformed"] = "DEC_TIME_MALFORMED";
  ULIDErrorCode2["EncodeTimeNegative"] = "ENC_TIME_NEG";
  ULIDErrorCode2["EncodeTimeSizeExceeded"] = "ENC_TIME_SIZE_EXCEED";
  ULIDErrorCode2["EncodeTimeValueMalformed"] = "ENC_TIME_MALFORMED";
  ULIDErrorCode2["PRNGDetectFailure"] = "PRNG_DETECT";
  ULIDErrorCode2["ULIDInvalid"] = "ULID_INVALID";
  ULIDErrorCode2["Unexpected"] = "UNEXPECTED";
  ULIDErrorCode2["UUIDInvalid"] = "UUID_INVALID";
})(ULIDErrorCode || (ULIDErrorCode = {}));

class ULIDError extends Error {
  constructor(errorCode, message) {
    super(`${message} (${errorCode})`);
    this.name = "ULIDError";
    this.code = errorCode;
  }
}

// src/adapters/storage/postgres.adapter.ts
function mapDatabaseError(error2) {
  switch (error2._tag) {
    case "ConnectionFailed":
      return { _tag: "StorageIOError", cause: error2 };
    case "QueryFailed":
      if (error2.reason.includes("not found") || error2.reason.includes("does not exist")) {
        return { _tag: "NotFound", entity: "Unknown", id: "unknown" };
      }
      if (error2.reason.includes("duplicate") || error2.reason.includes("unique")) {
        return { _tag: "ConflictError", message: error2.reason };
      }
      return { _tag: "StorageIOError", cause: error2 };
    case "TransactionFailed":
      return { _tag: "StorageIOError", cause: error2 };
    default:
      return { _tag: "StorageIOError", cause: error2 };
  }
}
function mapNoteRow(row) {
  return {
    id: row.id,
    title: row.title,
    metadata: row.metadata || {},
    created_at: row.created_at,
    updated_at: row.updated_at,
    current_version_id: row.current_version_id
  };
}
function mapDraftRow(row) {
  return {
    note_id: row.note_id,
    body_md: row.body_md,
    metadata: row.metadata || {},
    autosave_ts: row.autosave_ts
  };
}
function mapVersionRow(row) {
  return {
    id: row.id,
    note_id: row.note_id,
    content_md: row.content_md,
    metadata: row.metadata || {},
    content_hash: row.content_hash,
    created_at: row.created_at,
    parent_version_id: row.parent_version_id,
    label: row.label
  };
}
function mapCollectionRow(row) {
  return {
    id: row.id,
    name: row.name,
    description: row.description || undefined,
    created_at: row.created_at
  };
}
async function computeContentHash(content) {
  const encoder3 = new TextEncoder;
  const data = encoder3.encode(content);
  const hashBuffer = await crypto.subtle.digest("SHA-256", data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
function createPostgresStorageAdapter(db) {
  return new PostgresStorageAdapter(db);
}

class PostgresStorageAdapter {
  db;
  constructor(db) {
    this.db = db;
  }
  initializeWorkspace = () => this.db.query("SELECT 1 FROM workspace_config WHERE initialized_at IS NOT NULL LIMIT 1").pipe(exports_Effect.asVoid, exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  isWorkspaceInitialized = () => this.db.query("SELECT COUNT(*) as count FROM workspace_config").pipe(exports_Effect.map((rows) => Number.parseInt(rows[0].count, 10) > 0), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  createNote = (title, initialContent, metadata) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const id2 = `note_${ulid()}`;
    const now2 = new Date;
    yield* query(`INSERT INTO notes (id, title, metadata, created_at, updated_at) 
					 VALUES (\$1, \$2, \$3, \$4, \$5)`, [id2, title, JSON.stringify(metadata), now2, now2]);
    yield* query(`INSERT INTO drafts (note_id, body_md, metadata, autosave_ts) 
					 VALUES (\$1, \$2, \$3, \$4)`, [id2, initialContent, JSON.stringify(metadata), now2]);
    return {
      id: id2,
      title,
      metadata,
      created_at: now2,
      updated_at: now2
    };
  })).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getNote = (id2) => this.db.query("SELECT * FROM notes WHERE id = $1", [id2]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "Note", id: id2 });
    }
    return exports_Effect.succeed(mapNoteRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  listNotes = (filter17, options) => exports_Effect.gen(this, function* () {
    let query = "SELECT n.* FROM notes n";
    const params = [];
    let paramIndex = 1;
    if (filter17?.collection_ids?.length) {
      query += ` INNER JOIN collection_memberships cm ON n.id = cm.note_id 
						   WHERE cm.collection_id = ANY(\$${paramIndex})`;
      params.push(filter17.collection_ids);
      paramIndex++;
    }
    query += " ORDER BY n.updated_at DESC";
    if (options?.limit) {
      query += ` LIMIT \$${paramIndex}`;
      params.push(options.limit);
      paramIndex++;
    }
    if (options?.offset) {
      query += ` OFFSET \$${paramIndex}`;
      params.push(options.offset);
    }
    const rows = yield* this.db.query(query, params);
    return rows.map(mapNoteRow);
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  updateNoteMetadata = (id2, metadata) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const now2 = new Date;
    yield* query("UPDATE notes SET metadata = $1, updated_at = $2 WHERE id = $3", [JSON.stringify(metadata), now2, id2]);
    const updated = yield* query("SELECT * FROM notes WHERE id = $1", [id2]);
    if (updated.length === 0) {
      yield* exports_Effect.fail({ _tag: "NotFound", entity: "Note", id: id2 });
    }
    return mapNoteRow(updated[0]);
  })).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  deleteNote = (id2) => this.db.query("DELETE FROM notes WHERE id = $1", [id2]).pipe(exports_Effect.asVoid, exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  saveDraft = (request2) => exports_Effect.gen(this, function* () {
    const now2 = new Date;
    yield* this.db.query(`INSERT INTO drafts (note_id, body_md, metadata, autosave_ts) 
				 VALUES (\$1, \$2, \$3, \$4)
				 ON CONFLICT (note_id) 
				 DO UPDATE SET body_md = \$2, metadata = \$3, autosave_ts = \$4`, [request2.note_id, request2.body_md, JSON.stringify(request2.metadata), now2]);
    return {
      note_id: request2.note_id,
      autosave_ts: now2,
      status: "saved"
    };
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getDraft = (note_id) => this.db.query("SELECT * FROM drafts WHERE note_id = $1", [note_id]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "Draft", id: note_id });
    }
    return exports_Effect.succeed(mapDraftRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  hasDraft = (note_id) => this.db.query("SELECT COUNT(*) as count FROM drafts WHERE note_id = $1", [note_id]).pipe(exports_Effect.map((rows) => Number.parseInt(rows[0].count, 10) > 0), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  deleteDraft = (note_id) => this.db.query("DELETE FROM drafts WHERE note_id = $1", [note_id]).pipe(exports_Effect.asVoid, exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  createVersion = (note_id, content_md, metadata, label, parent_version_id) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const id2 = `ver_${ulid()}`;
    const now2 = new Date;
    const content_hash = yield* exports_Effect.promise(() => computeContentHash(content_md));
    yield* query(`INSERT INTO versions (id, note_id, content_md, metadata, content_hash, created_at, parent_version_id, label) 
					 VALUES (\$1, \$2, \$3, \$4, \$5, \$6, \$7, \$8)`, [id2, note_id, content_md, JSON.stringify(metadata), content_hash, now2, parent_version_id, label]);
    yield* query("UPDATE notes SET current_version_id = $1, updated_at = $2 WHERE id = $3", [id2, now2, note_id]);
    return {
      id: id2,
      note_id,
      content_md,
      metadata,
      content_hash,
      created_at: now2,
      parent_version_id,
      label
    };
  })).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getVersion = (id2) => this.db.query("SELECT * FROM versions WHERE id = $1", [id2]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "Version", id: id2 });
    }
    return exports_Effect.succeed(mapVersionRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  listVersions = (note_id, options) => exports_Effect.gen(this, function* () {
    let query = "SELECT * FROM versions WHERE note_id = $1 ORDER BY created_at DESC";
    const params = [note_id];
    if (options?.limit) {
      query += ` LIMIT \$2`;
      params.push(options.limit);
      if (options?.offset) {
        query += ` OFFSET \$3`;
        params.push(options.offset);
      }
    }
    const rows = yield* this.db.query(query, params);
    return rows.map(mapVersionRow);
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getCurrentVersion = (note_id) => this.db.query(`SELECT v.* FROM versions v 
			 INNER JOIN notes n ON v.id = n.current_version_id 
			 WHERE n.id = \$1`, [note_id]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "CurrentVersion", id: note_id });
    }
    return exports_Effect.succeed(mapVersionRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  publishVersion = (request2) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const draftRows = yield* query("SELECT * FROM drafts WHERE note_id = $1", [request2.note_id]);
    if (draftRows.length === 0) {
      yield* exports_Effect.fail({ _tag: "NotFound", entity: "Draft", id: request2.note_id });
    }
    const draft = mapDraftRow(draftRows[0]);
    const version = yield* this.createVersion(request2.note_id, draft.body_md, draft.metadata, request2.label || "minor");
    const publicationId = `pub_${ulid()}`;
    yield* query(`INSERT INTO publications (id, note_id, version_id, published_at, label) 
					 VALUES (\$1, \$2, \$3, \$4, \$5)`, [publicationId, request2.note_id, version.id, new Date, request2.label]);
    for (const collectionId of request2.collections) {
      yield* query(`INSERT INTO publication_collections (publication_id, collection_id) 
						 VALUES (\$1, \$2)`, [publicationId, collectionId]);
    }
    return {
      version_id: version.id,
      note_id: request2.note_id,
      status: "version_created",
      estimated_searchable_in: 5000
    };
  })).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  rollbackToVersion = (request2) => this.db.transaction((query) => exports_Effect.gen(this, function* () {
    const targetRows = yield* query("SELECT * FROM versions WHERE id = $1", [request2.target_version_id]);
    if (targetRows.length === 0) {
      yield* exports_Effect.fail({ _tag: "NotFound", entity: "Version", id: request2.target_version_id });
    }
    const targetVersion = mapVersionRow(targetRows[0]);
    const newVersion = yield* this.createVersion(request2.note_id, targetVersion.content_md, targetVersion.metadata, "major", request2.target_version_id);
    return {
      new_version_id: newVersion.id,
      note_id: request2.note_id,
      target_version_id: request2.target_version_id,
      status: "version_created"
    };
  })).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  createCollection = (name, description) => exports_Effect.gen(this, function* () {
    const id2 = `col_${ulid()}`;
    const now2 = new Date;
    yield* this.db.query(`INSERT INTO collections (id, name, description, created_at) 
				 VALUES (\$1, \$2, \$3, \$4)`, [id2, name, description, now2]);
    return {
      id: id2,
      name,
      description,
      created_at: now2
    };
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getCollection = (id2) => this.db.query("SELECT * FROM collections WHERE id = $1", [id2]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "Collection", id: id2 });
    }
    return exports_Effect.succeed(mapCollectionRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  getCollectionByName = (name) => this.db.query("SELECT * FROM collections WHERE LOWER(name) = LOWER($1)", [name]).pipe(exports_Effect.flatMap((rows) => {
    if (rows.length === 0) {
      return exports_Effect.fail({ _tag: "NotFound", entity: "Collection", id: name });
    }
    return exports_Effect.succeed(mapCollectionRow(rows[0]));
  }), exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  listCollections = (options) => exports_Effect.gen(this, function* () {
    let query = "SELECT * FROM collections ORDER BY name";
    const params = [];
    if (options?.limit) {
      query += " LIMIT $1";
      params.push(options.limit);
      if (options?.offset) {
        query += " OFFSET $2";
        params.push(options.offset);
      }
    }
    const rows = yield* this.db.query(query, params);
    return rows.map(mapCollectionRow);
  }).pipe(exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
  updateCollection = () => exports_Effect.succeed({});
  deleteCollection = () => exports_Effect.succeed(undefined);
  addToCollections = () => exports_Effect.succeed(undefined);
  removeFromCollections = () => exports_Effect.succeed(undefined);
  getNoteCollections = () => exports_Effect.succeed([]);
  getCollectionNotes = () => exports_Effect.succeed([]);
  createSession = () => exports_Effect.succeed({});
  getSession = () => exports_Effect.succeed({});
  updateSession = () => exports_Effect.succeed({});
  listSessions = () => exports_Effect.succeed([]);
  pinSession = () => exports_Effect.succeed(undefined);
  createSnapshot = () => exports_Effect.succeed({});
  getSnapshot = () => exports_Effect.succeed({});
  listSnapshots = () => exports_Effect.succeed([]);
  restoreSnapshot = () => exports_Effect.succeed(undefined);
  deleteSnapshot = () => exports_Effect.succeed(undefined);
  getPublication = () => exports_Effect.succeed({});
  listPublications = () => exports_Effect.succeed([]);
  withTransaction = (operation) => this.db.transaction(() => operation);
  getStorageHealth = () => this.db.testConnection().pipe(exports_Effect.map(() => ({ status: "healthy", details: "PostgreSQL connection active" })), exports_Effect.catchAll((error2) => exports_Effect.succeed({
    status: "unhealthy",
    details: `Database connection failed: ${error2}`
  })));
  performMaintenance = () => this.db.query("VACUUM ANALYZE").pipe(exports_Effect.asVoid, exports_Effect.catchAll((error2) => exports_Effect.fail(mapDatabaseError(error2))));
}

// src/adapters/storage/memory.adapter.ts
var storageError = (error2) => exports_Effect.fail(error2);
var notFound = (entity, id2) => ({
  _tag: "NotFound",
  entity,
  id: id2
});

class MemoryStorageAdapter {
  state = {
    notes: new Map,
    drafts: new Map,
    versions: new Map,
    collections: new Map,
    publications: new Map,
    sessions: new Map,
    snapshots: new Map,
    collectionMemberships: new Map,
    initialized: false
  };
  initializeWorkspace = () => exports_Effect.sync(() => {
    this.state.initialized = true;
  });
  isWorkspaceInitialized = () => exports_Effect.succeed(this.state.initialized);
  createNote = (title, initialContent, metadata) => exports_Effect.sync(() => {
    const id2 = `note_${ulid()}`;
    const now2 = new Date;
    const note = {
      id: id2,
      title,
      metadata,
      created_at: now2,
      updated_at: now2
    };
    this.state.notes.set(id2, note);
    const draft = {
      note_id: id2,
      body_md: initialContent,
      metadata,
      autosave_ts: now2
    };
    this.state.drafts.set(id2, draft);
    return note;
  });
  getNote = (id2) => exports_Effect.sync(() => {
    const note = this.state.notes.get(id2);
    if (!note) {
      throw new Error("Note not found");
    }
    return note;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Note", id2))));
  listNotes = (filter17, options) => exports_Effect.sync(() => {
    let notes = Array.from(this.state.notes.values());
    if (filter17?.collection_ids) {
      const collectionIds = new Set(filter17.collection_ids);
      notes = notes.filter((note) => {
        return Array.from(this.state.collectionMemberships.values()).some((membership) => membership.note_id === note.id && collectionIds.has(membership.collection_id));
      });
    }
    if (options?.offset || options?.limit) {
      const offset = options?.offset || 0;
      const limit = options?.limit || notes.length;
      notes = notes.slice(offset, offset + limit);
    }
    return notes;
  });
  updateNoteMetadata = (id2, metadata) => exports_Effect.sync(() => {
    const note = this.state.notes.get(id2);
    if (!note) {
      throw new Error("Note not found");
    }
    const updatedNote = {
      ...note,
      metadata,
      updated_at: new Date
    };
    this.state.notes.set(id2, updatedNote);
    return updatedNote;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Note", id2))));
  deleteNote = (id2) => exports_Effect.sync(() => {
    if (!this.state.notes.has(id2)) {
      throw new Error("Note not found");
    }
    this.state.notes.delete(id2);
    this.state.drafts.delete(id2);
    for (const [versionId, version] of this.state.versions) {
      if (version.note_id === id2) {
        this.state.versions.delete(versionId);
      }
    }
    for (const [pubId, publication] of this.state.publications) {
      if (publication.note_id === id2) {
        this.state.publications.delete(pubId);
      }
    }
    for (const [key, membership] of this.state.collectionMemberships) {
      if (membership.note_id === id2) {
        this.state.collectionMemberships.delete(key);
      }
    }
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Note", id2))));
  saveDraft = (request2) => exports_Effect.sync(() => {
    if (!this.state.notes.has(request2.note_id)) {
      throw new Error("Note not found");
    }
    const now2 = new Date;
    const draft = {
      note_id: request2.note_id,
      body_md: request2.body_md,
      metadata: request2.metadata,
      autosave_ts: now2
    };
    this.state.drafts.set(request2.note_id, draft);
    return {
      note_id: request2.note_id,
      autosave_ts: now2,
      status: "saved"
    };
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Note", request2.note_id))));
  getDraft = (note_id) => exports_Effect.sync(() => {
    const draft = this.state.drafts.get(note_id);
    if (!draft) {
      throw new Error("Draft not found");
    }
    return draft;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Draft", note_id))));
  hasDraft = (note_id) => exports_Effect.succeed(this.state.drafts.has(note_id));
  deleteDraft = (note_id) => exports_Effect.sync(() => {
    this.state.drafts.delete(note_id);
  });
  createVersion = (note_id, content_md, metadata, label, parent_version_id) => exports_Effect.sync(() => {
    if (!this.state.notes.has(note_id)) {
      throw new Error("Note not found");
    }
    const id2 = `ver_${ulid()}`;
    const content_hash = this.computeContentHash(content_md);
    const version = {
      id: id2,
      note_id,
      content_md,
      metadata,
      content_hash,
      created_at: new Date,
      parent_version_id,
      label
    };
    this.state.versions.set(id2, version);
    const note = this.state.notes.get(note_id);
    this.state.notes.set(note_id, {
      ...note,
      current_version_id: id2,
      updated_at: new Date
    });
    return version;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Note", note_id))));
  getVersion = (id2) => exports_Effect.sync(() => {
    const version = this.state.versions.get(id2);
    if (!version) {
      throw new Error("Version not found");
    }
    return version;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Version", id2))));
  listVersions = (note_id, options) => exports_Effect.sync(() => {
    let versions = Array.from(this.state.versions.values()).filter((v) => v.note_id === note_id);
    versions.sort((a, b) => b.created_at.getTime() - a.created_at.getTime());
    if (options?.offset || options?.limit) {
      const offset = options?.offset || 0;
      const limit = options?.limit || versions.length;
      versions = versions.slice(offset, offset + limit);
    }
    return versions;
  });
  getCurrentVersion = (note_id) => exports_Effect.sync(() => {
    const note = this.state.notes.get(note_id);
    if (!note?.current_version_id) {
      throw new Error("No current version");
    }
    const version = this.state.versions.get(note.current_version_id);
    if (!version) {
      throw new Error("Current version not found");
    }
    return version;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("CurrentVersion", note_id))));
  publishVersion = (request2) => exports_Effect.gen(this, function* () {
    if (!this.state.notes.has(request2.note_id)) {
      yield* exports_Effect.fail(notFound("Note", request2.note_id));
    }
    const draft = this.state.drafts.get(request2.note_id);
    if (!draft) {
      yield* exports_Effect.fail(notFound("Draft", request2.note_id));
    }
    const version = yield* this.createVersion(request2.note_id, draft.body_md, draft.metadata, request2.label || "minor");
    const publicationId = `pub_${ulid()}`;
    const publication = {
      id: publicationId,
      note_id: request2.note_id,
      version_id: version.id,
      collections: request2.collections,
      published_at: new Date,
      label: request2.label
    };
    this.state.publications.set(publicationId, publication);
    return {
      version_id: version.id,
      note_id: request2.note_id,
      status: "version_created",
      estimated_searchable_in: 5000
    };
  });
  rollbackToVersion = (request2) => exports_Effect.gen(this, function* () {
    if (!this.state.notes.has(request2.note_id)) {
      yield* exports_Effect.fail(notFound("Note", request2.note_id));
    }
    const targetVersion = this.state.versions.get(request2.target_version_id);
    if (!targetVersion) {
      yield* exports_Effect.fail(notFound("Version", request2.target_version_id));
    }
    const newVersion = yield* this.createVersion(request2.note_id, targetVersion.content_md, targetVersion.metadata, "major", request2.target_version_id);
    return {
      new_version_id: newVersion.id,
      note_id: request2.note_id,
      target_version_id: request2.target_version_id,
      status: "version_created"
    };
  });
  createCollection = (name, description) => exports_Effect.sync(() => {
    for (const collection2 of this.state.collections.values()) {
      if (collection2.name.toLowerCase() === name.toLowerCase()) {
        throw new Error("Collection name already exists");
      }
    }
    const id2 = `col_${ulid()}`;
    const collection = {
      id: id2,
      name,
      description,
      created_at: new Date
    };
    this.state.collections.set(id2, collection);
    return collection;
  }).pipe(exports_Effect.catchAll(() => storageError({
    _tag: "ConflictError",
    message: "Collection name already exists"
  })));
  getCollection = (id2) => exports_Effect.sync(() => {
    const collection = this.state.collections.get(id2);
    if (!collection) {
      throw new Error("Collection not found");
    }
    return collection;
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Collection", id2))));
  getCollectionByName = (name) => exports_Effect.sync(() => {
    for (const collection of this.state.collections.values()) {
      if (collection.name.toLowerCase() === name.toLowerCase()) {
        return collection;
      }
    }
    throw new Error("Collection not found");
  }).pipe(exports_Effect.catchAll(() => storageError(notFound("Collection", name))));
  listCollections = (options) => exports_Effect.sync(() => {
    let collections = Array.from(this.state.collections.values());
    collections.sort((a, b) => a.name.localeCompare(b.name));
    if (options?.offset || options?.limit) {
      const offset = options?.offset || 0;
      const limit = options?.limit || collections.length;
      collections = collections.slice(offset, offset + limit);
    }
    return collections;
  });
  updateCollection = () => exports_Effect.succeed({});
  deleteCollection = () => exports_Effect.succeed(undefined);
  addToCollections = () => exports_Effect.succeed(undefined);
  removeFromCollections = () => exports_Effect.succeed(undefined);
  getNoteCollections = () => exports_Effect.succeed([]);
  getCollectionNotes = () => exports_Effect.succeed([]);
  createSession = () => exports_Effect.succeed({});
  getSession = () => exports_Effect.succeed({});
  updateSession = () => exports_Effect.succeed({});
  listSessions = () => exports_Effect.succeed([]);
  pinSession = () => exports_Effect.succeed(undefined);
  createSnapshot = () => exports_Effect.succeed({});
  getSnapshot = () => exports_Effect.succeed({});
  listSnapshots = () => exports_Effect.succeed([]);
  restoreSnapshot = () => exports_Effect.succeed(undefined);
  deleteSnapshot = () => exports_Effect.succeed(undefined);
  getPublication = () => exports_Effect.succeed({});
  listPublications = () => exports_Effect.succeed([]);
  withTransaction = (op) => op;
  getStorageHealth = () => exports_Effect.succeed({ status: "healthy", details: "In-memory storage" });
  performMaintenance = () => exports_Effect.succeed(undefined);
  computeContentHash(content) {
    let hash3 = 0;
    for (let i = 0;i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash3 = (hash3 << 5) - hash3 + char;
      hash3 = hash3 & hash3;
    }
    return Math.abs(hash3).toString(16).padStart(16, "0").repeat(4);
  }
}
var createMemoryStorageAdapter = () => new MemoryStorageAdapter;

// node_modules/@orama/orama/dist/esm/components/tokenizer/languages.js
function getLocale(language) {
  return language !== undefined && SUPPORTED_LANGUAGES.includes(language) ? STEMMERS[language] : undefined;
}
var STEMMERS = {
  arabic: "ar",
  armenian: "am",
  bulgarian: "bg",
  czech: "cz",
  danish: "dk",
  dutch: "nl",
  english: "en",
  finnish: "fi",
  french: "fr",
  german: "de",
  greek: "gr",
  hungarian: "hu",
  indian: "in",
  indonesian: "id",
  irish: "ie",
  italian: "it",
  lithuanian: "lt",
  nepali: "np",
  norwegian: "no",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "rs",
  slovenian: "ru",
  spanish: "es",
  swedish: "se",
  tamil: "ta",
  turkish: "tr",
  ukrainian: "uk",
  sanskrit: "sk"
};
var SPLITTERS = {
  dutch: /[^A-Za-z\u00E0\u00E8\u00E9\u00EC\u00F2\u00F3\u00F90-9_'-]+/gim,
  english: /[^A-Za-z\u00E0\u00E8\u00E9\u00EC\u00F2\u00F3\u00F90-9_'-]+/gim,
  french: /[^a-z0-9\u00E4\u00E2\u00E0\u00E9\u00E8\u00EB\u00EA\u00EF\u00EE\u00F6\u00F4\u00F9\u00FC\u00FB\u0153\u00E7-]+/gim,
  italian: /[^A-Za-z\u00E0\u00E8\u00E9\u00EC\u00F2\u00F3\u00F90-9_'-]+/gim,
  norwegian: /[^a-z0-9_\u00E6\u00F8\u00E5\u00C6\u00D8\u00C5\u00E4\u00C4\u00F6\u00D6\u00FC\u00DC]+/gim,
  portuguese: /[^a-z0-9\u00E0-\u00FA\u00C0-\u00DA]/gim,
  russian: /[^a-z0-9\u0430-\u044F\u0410-\u042F\u0451\u0401]+/gim,
  spanish: /[^a-z0-9A-Z\u00E1-\u00FA\u00C1-\u00DA\u00F1\u00D1\u00FC\u00DC]+/gim,
  swedish: /[^a-z0-9_\u00E5\u00C5\u00E4\u00C4\u00F6\u00D6\u00FC\u00DC-]+/gim,
  german: /[^a-z0-9A-Z\u00E4\u00F6\u00FC\u00C4\u00D6\u00DC\u00DF]+/gim,
  finnish: /[^a-z0-9\u00E4\u00F6\u00C4\u00D6]+/gim,
  danish: /[^a-z0-9\u00E6\u00F8\u00E5\u00C6\u00D8\u00C5]+/gim,
  hungarian: /[^a-z0-9\u00E1\u00E9\u00ED\u00F3\u00F6\u0151\u00FA\u00FC\u0171\u00C1\u00C9\u00CD\u00D3\u00D6\u0150\u00DA\u00DC\u0170]+/gim,
  romanian: /[^a-z0-9\u0103\u00E2\u00EE\u0219\u021B\u0102\u00C2\u00CE\u0218\u021A]+/gim,
  serbian: /[^a-z0-9\u010D\u0107\u017E\u0161\u0111\u010C\u0106\u017D\u0160\u0110]+/gim,
  turkish: /[^a-z0-9\u00E7\u00C7\u011F\u011E\u0131\u0130\u00F6\u00D6\u015F\u015E\u00FC\u00DC]+/gim,
  lithuanian: /[^a-z0-9\u0105\u010D\u0119\u0117\u012F\u0161\u0173\u016B\u017E\u0104\u010C\u0118\u0116\u012E\u0160\u0172\u016A\u017D]+/gim,
  arabic: /[^a-z0-9\u0623-\u064A]+/gim,
  nepali: /[^a-z0-9\u0905-\u0939]+/gim,
  irish: /[^a-z0-9\u00E1\u00E9\u00ED\u00F3\u00FA\u00C1\u00C9\u00CD\u00D3\u00DA]+/gim,
  indian: /[^a-z0-9\u0905-\u0939]+/gim,
  armenian: /[^a-z0-9\u0561-\u0586]+/gim,
  greek: /[^a-z0-9\u03B1-\u03C9\u03AC-\u03CE]+/gim,
  indonesian: /[^a-z0-9]+/gim,
  ukrainian: /[^a-z0-9\u0430-\u044F\u0410-\u042F\u0456\u0457\u0454\u0406\u0407\u0404]+/gim,
  slovenian: /[^a-z0-9\u010D\u017E\u0161\u010C\u017D\u0160]+/gim,
  bulgarian: /[^a-z0-9\u0430-\u044F\u0410-\u042F]+/gim,
  tamil: /[^a-z0-9\u0B85-\u0BB9]+/gim,
  sanskrit: /[^a-z0-9A-Z\u0101\u012B\u016B\u1E5B\u1E37\u1E43\u1E41\u1E25\u015B\u1E63\u1E6D\u1E0D\u1E47\u1E45\u00F1\u1E3B\u1E39\u1E5D]+/gim,
  czech: /[^A-Z0-9a-z\u011B\u0161\u010D\u0159\u017E\u00FD\u00E1\u00ED\u00E9\u00FA\u016F\u00F3\u0165\u010F\u011A\u0160\u010C\u0158\u017D\u00DD\u00C1\u00CD\u00C9\u00D3\u00DA\u016E\u0164\u010E-]+/gim
};
var SUPPORTED_LANGUAGES = Object.keys(STEMMERS);

// node_modules/@orama/orama/dist/esm/utils.js
function safeArrayPush(arr, newArr) {
  if (newArr.length < MAX_ARGUMENT_FOR_STACK) {
    Array.prototype.push.apply(arr, newArr);
  } else {
    const newArrLength = newArr.length;
    for (let i = 0;i < newArrLength; i += MAX_ARGUMENT_FOR_STACK) {
      Array.prototype.push.apply(arr, newArr.slice(i, i + MAX_ARGUMENT_FOR_STACK));
    }
  }
}
function sprintf(template, ...args2) {
  return template.replace(/%(?:(?<position>\d+)\$)?(?<width>-?\d*\.?\d*)(?<type>[dfs])/g, function(...replaceArgs) {
    const groups = replaceArgs[replaceArgs.length - 1];
    const { width: rawWidth, type: type2, position } = groups;
    const replacement = position ? args2[Number.parseInt(position) - 1] : args2.shift();
    const width = rawWidth === "" ? 0 : Number.parseInt(rawWidth);
    switch (type2) {
      case "d":
        return replacement.toString().padStart(width, "0");
      case "f": {
        let value6 = replacement;
        const [padding, precision] = rawWidth.split(".").map((w) => Number.parseFloat(w));
        if (typeof precision === "number" && precision >= 0) {
          value6 = value6.toFixed(precision);
        }
        return typeof padding === "number" && padding >= 0 ? value6.toString().padStart(width, "0") : value6.toString();
      }
      case "s":
        return width < 0 ? replacement.toString().padEnd(-width, " ") : replacement.toString().padStart(width, " ");
      default:
        return replacement;
    }
  });
}
function isInsideWebWorker() {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
}
function isInsideNode() {
  return typeof process !== "undefined" && process.release && process.release.name === "node";
}
function getNanosecondTimeViaPerformance() {
  return BigInt(Math.floor(performance.now() * 1e6));
}
function formatNanoseconds(value6) {
  if (typeof value6 === "number") {
    value6 = BigInt(value6);
  }
  if (value6 < nano) {
    return `${value6}ns`;
  } else if (value6 < milli) {
    return `${value6 / nano}\u03BCs`;
  } else if (value6 < second) {
    return `${value6 / milli}ms`;
  }
  return `${value6 / second}s`;
}
function getNanosecondsTime() {
  if (isInsideWebWorker()) {
    return getNanosecondTimeViaPerformance();
  }
  if (isInsideNode()) {
    return process.hrtime.bigint();
  }
  if (typeof process !== "undefined" && typeof process?.hrtime?.bigint === "function") {
    return process.hrtime.bigint();
  }
  if (typeof performance !== "undefined") {
    return getNanosecondTimeViaPerformance();
  }
  return BigInt(0);
}
function uniqueId() {
  return `${baseId}-${lastId++}`;
}
function getOwnProperty(object, property) {
  if (Object.hasOwn === undefined) {
    return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : undefined;
  }
  return Object.hasOwn(object, property) ? object[property] : undefined;
}
function sortTokenScorePredicate(a, b) {
  if (b[1] === a[1]) {
    return a[0] - b[0];
  }
  return b[1] - a[1];
}
function intersect6(arrays) {
  if (arrays.length === 0) {
    return [];
  } else if (arrays.length === 1) {
    return arrays[0];
  }
  for (let i = 1;i < arrays.length; i++) {
    if (arrays[i].length < arrays[0].length) {
      const tmp = arrays[0];
      arrays[0] = arrays[i];
      arrays[i] = tmp;
    }
  }
  const set17 = new Map;
  for (const elem of arrays[0]) {
    set17.set(elem, 1);
  }
  for (let i = 1;i < arrays.length; i++) {
    let found = 0;
    for (const elem of arrays[i]) {
      const count5 = set17.get(elem);
      if (count5 === i) {
        set17.set(elem, count5 + 1);
        found++;
      }
    }
    if (found === 0)
      return [];
  }
  return arrays[0].filter((e) => {
    const count5 = set17.get(e);
    if (count5 !== undefined)
      set17.set(e, 0);
    return count5 === arrays.length;
  });
}
function getDocumentProperties(doc, paths) {
  const properties = {};
  const pathsLength = paths.length;
  for (let i = 0;i < pathsLength; i++) {
    const path = paths[i];
    const pathTokens = path.split(".");
    let current2 = doc;
    const pathTokensLength = pathTokens.length;
    for (let j = 0;j < pathTokensLength; j++) {
      current2 = current2[pathTokens[j]];
      if (typeof current2 === "object") {
        if (current2 !== null && "lat" in current2 && "lon" in current2 && typeof current2.lat === "number" && typeof current2.lon === "number") {
          current2 = properties[path] = current2;
          break;
        } else if (!Array.isArray(current2) && current2 !== null && j === pathTokensLength - 1) {
          current2 = undefined;
          break;
        }
      } else if ((current2 === null || typeof current2 !== "object") && j < pathTokensLength - 1) {
        current2 = undefined;
        break;
      }
    }
    if (typeof current2 !== "undefined") {
      properties[path] = current2;
    }
  }
  return properties;
}
function getNested(obj, path) {
  const props = getDocumentProperties(obj, [path]);
  return props[path];
}
function convertDistanceToMeters(distance2, unit) {
  const ratio = mapDistanceToMeters[unit];
  if (ratio === undefined) {
    throw new Error(createError("INVALID_DISTANCE_SUFFIX", distance2).message);
  }
  return distance2 * ratio;
}
function removeVectorsFromHits(searchResult, vectorProperties) {
  searchResult.hits = searchResult.hits.map((result) => ({
    ...result,
    document: {
      ...result.document,
      ...vectorProperties.reduce((acc, prop) => {
        const path = prop.split(".");
        const lastKey = path.pop();
        let obj = acc;
        for (const key of path) {
          obj[key] = obj[key] ?? {};
          obj = obj[key];
        }
        obj[lastKey] = null;
        return acc;
      }, result.document)
    }
  }));
}
function isAsyncFunction(func) {
  if (Array.isArray(func)) {
    return func.some((item) => isAsyncFunction(item));
  }
  return func?.constructor?.name === "AsyncFunction";
}
function setIntersection(...sets) {
  if (sets.length === 0) {
    return new Set;
  }
  if (sets.length === 1) {
    return sets[0];
  }
  if (sets.length === 2) {
    const set1 = sets[0];
    const set22 = sets[1];
    if (withIntersection) {
      return set1.intersection(set22);
    }
    const result = new Set;
    const base2 = set1.size < set22.size ? set1 : set22;
    const other = base2 === set1 ? set22 : set1;
    for (const value6 of base2) {
      if (other.has(value6)) {
        result.add(value6);
      }
    }
    return result;
  }
  const min4 = {
    index: 0,
    size: sets[0].size
  };
  for (let i = 1;i < sets.length; i++) {
    if (sets[i].size < min4.size) {
      min4.index = i;
      min4.size = sets[i].size;
    }
  }
  if (withIntersection) {
    let base2 = sets[min4.index];
    for (let i = 0;i < sets.length; i++) {
      if (i === min4.index) {
        continue;
      }
      base2 = base2.intersection(sets[i]);
    }
    return base2;
  }
  const base = sets[min4.index];
  for (let i = 0;i < sets.length; i++) {
    if (i === min4.index) {
      continue;
    }
    const other = sets[i];
    for (const value6 of base) {
      if (!other.has(value6)) {
        base.delete(value6);
      }
    }
  }
  return base;
}
function setUnion(set1, set22) {
  if (withUnion) {
    if (set1) {
      return set1.union(set22);
    }
    return set22;
  }
  if (!set1) {
    return new Set(set22);
  }
  return new Set([...set1, ...set22]);
}
function setDifference(set1, set22) {
  const result = new Set;
  for (const value6 of set1) {
    if (!set22.has(value6)) {
      result.add(value6);
    }
  }
  return result;
}
var baseId = Date.now().toString().slice(5);
var lastId = 0;
var nano = BigInt(1000);
var milli = BigInt(1e6);
var second = BigInt(1e9);
var MAX_ARGUMENT_FOR_STACK = 65535;
var mapDistanceToMeters = {
  cm: 0.01,
  m: 1,
  km: 1000,
  ft: 0.3048,
  yd: 0.9144,
  mi: 1609.344
};
var withIntersection = "intersection" in new Set;
var withUnion = "union" in new Set;

// node_modules/@orama/orama/dist/esm/errors.js
function createError(code, ...args2) {
  const error2 = new Error(sprintf(errors[code] ?? `Unsupported Orama Error code: ${code}`, ...args2));
  error2.code = code;
  if ("captureStackTrace" in Error.prototype) {
    Error.captureStackTrace(error2);
  }
  return error2;
}
var allLanguages = SUPPORTED_LANGUAGES.join("\n - ");
var errors = {
  NO_LANGUAGE_WITH_CUSTOM_TOKENIZER: "Do not pass the language option to create when using a custom tokenizer.",
  LANGUAGE_NOT_SUPPORTED: `Language "%s" is not supported.\nSupported languages are:\n - ${allLanguages}`,
  INVALID_STEMMER_FUNCTION_TYPE: `config.stemmer property must be a function.`,
  MISSING_STEMMER: `As of version 1.0.0 @orama/orama does not ship non English stemmers by default. To solve this, please explicitly import and specify the "%s" stemmer from the package @orama/stemmers. See https://docs.orama.com/docs/orama-js/text-analysis/stemming for more information.`,
  CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY: "Custom stop words array must only contain strings.",
  UNSUPPORTED_COMPONENT: `Unsupported component "%s".`,
  COMPONENT_MUST_BE_FUNCTION: `The component "%s" must be a function.`,
  COMPONENT_MUST_BE_FUNCTION_OR_ARRAY_FUNCTIONS: `The component "%s" must be a function or an array of functions.`,
  INVALID_SCHEMA_TYPE: `Unsupported schema type "%s" at "%s". Expected "string", "boolean" or "number" or array of them.`,
  DOCUMENT_ID_MUST_BE_STRING: `Document id must be of type "string". Got "%s" instead.`,
  DOCUMENT_ALREADY_EXISTS: `A document with id "%s" already exists.`,
  DOCUMENT_DOES_NOT_EXIST: `A document with id "%s" does not exists.`,
  MISSING_DOCUMENT_PROPERTY: `Missing searchable property "%s".`,
  INVALID_DOCUMENT_PROPERTY: `Invalid document property "%s": expected "%s", got "%s"`,
  UNKNOWN_INDEX: `Invalid property name "%s". Expected a wildcard string ("*") or array containing one of the following properties: %s`,
  INVALID_BOOST_VALUE: `Boost value must be a number greater than, or less than 0.`,
  INVALID_FILTER_OPERATION: `You can only use one operation per filter, you requested %d.`,
  SCHEMA_VALIDATION_FAILURE: `Cannot insert document due schema validation failure on "%s" property.`,
  INVALID_SORT_SCHEMA_TYPE: `Unsupported sort schema type "%s" at "%s". Expected "string" or "number".`,
  CANNOT_SORT_BY_ARRAY: `Cannot configure sort for "%s" because it is an array (%s).`,
  UNABLE_TO_SORT_ON_UNKNOWN_FIELD: `Unable to sort on unknown field "%s". Allowed fields: %s`,
  SORT_DISABLED: `Sort is disabled. Please read the documentation at https://docs.orama.com/docs/orama-js for more information.`,
  UNKNOWN_GROUP_BY_PROPERTY: `Unknown groupBy property "%s".`,
  INVALID_GROUP_BY_PROPERTY: `Invalid groupBy property "%s". Allowed types: "%s", but given "%s".`,
  UNKNOWN_FILTER_PROPERTY: `Unknown filter property "%s".`,
  UNKNOWN_VECTOR_PROPERTY: `Unknown vector property "%s". Make sure the property exists in the schema and is configured as a vector.`,
  INVALID_VECTOR_SIZE: `Vector size must be a number greater than 0. Got "%s" instead.`,
  INVALID_VECTOR_VALUE: `Vector value must be a number greater than 0. Got "%s" instead.`,
  INVALID_INPUT_VECTOR: `Property "%s" was declared as a %s-dimensional vector, but got a %s-dimensional vector instead.\nInput vectors must be of the size declared in the schema, as calculating similarity between vectors of different sizes can lead to unexpected results.`,
  WRONG_SEARCH_PROPERTY_TYPE: `Property "%s" is not searchable. Only "string" properties are searchable.`,
  FACET_NOT_SUPPORTED: `Facet doens't support the type "%s".`,
  INVALID_DISTANCE_SUFFIX: `Invalid distance suffix "%s". Valid suffixes are: cm, m, km, mi, yd, ft.`,
  INVALID_SEARCH_MODE: `Invalid search mode "%s". Valid modes are: "fulltext", "vector", "hybrid".`,
  MISSING_VECTOR_AND_SECURE_PROXY: `No vector was provided and no secure proxy was configured. Please provide a vector or configure an Orama Secure Proxy to perform hybrid search.`,
  MISSING_TERM: `"term" is a required parameter when performing hybrid search. Please provide a search term.`,
  INVALID_VECTOR_INPUT: `Invalid "vector" property. Expected an object with "value" and "property" properties, but got "%s" instead.`,
  PLUGIN_CRASHED: `A plugin crashed during initialization. Please check the error message for more information:`,
  PLUGIN_SECURE_PROXY_NOT_FOUND: `Could not find '@orama/secure-proxy-plugin' installed in your Orama instance.\nPlease install it before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
  PLUGIN_SECURE_PROXY_MISSING_CHAT_MODEL: `Could not find a chat model defined in the secure proxy plugin configuration.\nPlease provide a chat model before proceeding with creating an answer session.\nRead more at https://docs.orama.com/docs/orama-js/plugins/plugin-secure-proxy#plugin-secure-proxy\n`,
  ANSWER_SESSION_LAST_MESSAGE_IS_NOT_ASSISTANT: `The last message in the session is not an assistant message. Cannot regenerate non-assistant messages.`,
  PLUGIN_COMPONENT_CONFLICT: `The component "%s" is already defined. The plugin "%s" is trying to redefine it.`
};

// node_modules/@orama/orama/dist/esm/components/defaults.js
function formatElapsedTime(n) {
  return {
    raw: Number(n),
    formatted: formatNanoseconds(n)
  };
}
function getDocumentIndexId(doc) {
  if (doc.id) {
    if (typeof doc.id !== "string") {
      throw createError("DOCUMENT_ID_MUST_BE_STRING", typeof doc.id);
    }
    return doc.id;
  }
  return uniqueId();
}
function validateSchema(doc, schema) {
  for (const [prop, type2] of Object.entries(schema)) {
    const value6 = doc[prop];
    if (typeof value6 === "undefined") {
      continue;
    }
    if (type2 === "geopoint" && typeof value6 === "object" && typeof value6.lon === "number" && typeof value6.lat === "number") {
      continue;
    }
    if (type2 === "enum" && (typeof value6 === "string" || typeof value6 === "number")) {
      continue;
    }
    if (type2 === "enum[]" && Array.isArray(value6)) {
      const valueLength = value6.length;
      for (let i = 0;i < valueLength; i++) {
        if (typeof value6[i] !== "string" && typeof value6[i] !== "number") {
          return prop + "." + i;
        }
      }
      continue;
    }
    if (isVectorType(type2)) {
      const vectorSize = getVectorSize(type2);
      if (!Array.isArray(value6) || value6.length !== vectorSize) {
        throw createError("INVALID_INPUT_VECTOR", prop, vectorSize, value6.length);
      }
      continue;
    }
    if (isArrayType(type2)) {
      if (!Array.isArray(value6)) {
        return prop;
      }
      const expectedType = getInnerType(type2);
      const valueLength = value6.length;
      for (let i = 0;i < valueLength; i++) {
        if (typeof value6[i] !== expectedType) {
          return prop + "." + i;
        }
      }
      continue;
    }
    if (typeof type2 === "object") {
      if (!value6 || typeof value6 !== "object") {
        return prop;
      }
      const subProp = validateSchema(value6, type2);
      if (subProp) {
        return prop + "." + subProp;
      }
      continue;
    }
    if (typeof value6 !== type2) {
      return prop;
    }
  }
  return;
}
function isVectorType(type2) {
  return typeof type2 === "string" && /^vector\[\d+\]$/.test(type2);
}
function isArrayType(type2) {
  return typeof type2 === "string" && IS_ARRAY_TYPE[type2];
}
function getInnerType(type2) {
  return INNER_TYPE[type2];
}
function getVectorSize(type2) {
  const size21 = Number(type2.slice(7, -1));
  switch (true) {
    case isNaN(size21):
      throw createError("INVALID_VECTOR_VALUE", type2);
    case size21 <= 0:
      throw createError("INVALID_VECTOR_SIZE", type2);
    default:
      return size21;
  }
}
var IS_ARRAY_TYPE = {
  string: false,
  number: false,
  boolean: false,
  enum: false,
  geopoint: false,
  "string[]": true,
  "number[]": true,
  "boolean[]": true,
  "enum[]": true
};
var INNER_TYPE = {
  "string[]": "string",
  "number[]": "number",
  "boolean[]": "boolean",
  "enum[]": "enum"
};

// node_modules/@orama/orama/dist/esm/components/internal-document-id-store.js
function createInternalDocumentIDStore() {
  return {
    idToInternalId: new Map,
    internalIdToId: [],
    save,
    load
  };
}
function save(store) {
  return {
    internalIdToId: store.internalIdToId
  };
}
function load(orama, raw) {
  const { internalIdToId } = raw;
  orama.internalDocumentIDStore.idToInternalId.clear();
  orama.internalDocumentIDStore.internalIdToId = [];
  const internalIdToIdLength = internalIdToId.length;
  for (let i = 0;i < internalIdToIdLength; i++) {
    const internalIdItem = internalIdToId[i];
    orama.internalDocumentIDStore.idToInternalId.set(internalIdItem, i + 1);
    orama.internalDocumentIDStore.internalIdToId.push(internalIdItem);
  }
}
function getInternalDocumentId(store, id2) {
  if (typeof id2 === "string") {
    const internalId = store.idToInternalId.get(id2);
    if (internalId) {
      return internalId;
    }
    const currentId = store.idToInternalId.size + 1;
    store.idToInternalId.set(id2, currentId);
    store.internalIdToId.push(id2);
    return currentId;
  }
  if (id2 > store.internalIdToId.length) {
    return getInternalDocumentId(store, id2.toString());
  }
  return id2;
}
function getDocumentIdFromInternalId(store, internalId) {
  if (store.internalIdToId.length < internalId) {
    throw new Error(`Invalid internalId ${internalId}`);
  }
  return store.internalIdToId[internalId - 1];
}

// node_modules/@orama/orama/dist/esm/components/documents-store.js
function create2(_2, sharedInternalDocumentStore) {
  return {
    sharedInternalDocumentStore,
    docs: {},
    count: 0
  };
}
function get32(store, id2) {
  const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, id2);
  return store.docs[internalId];
}
function getMultiple(store, ids3) {
  const idsLength = ids3.length;
  const found = Array.from({ length: idsLength });
  for (let i = 0;i < idsLength; i++) {
    const internalId = getInternalDocumentId(store.sharedInternalDocumentStore, ids3[i]);
    found[i] = store.docs[internalId];
  }
  return found;
}
function getAll(store) {
  return store.docs;
}
function store(store2, id2, internalId, doc) {
  if (typeof store2.docs[internalId] !== "undefined") {
    return false;
  }
  store2.docs[internalId] = doc;
  store2.count++;
  return true;
}
function remove13(store2, id2) {
  const internalId = getInternalDocumentId(store2.sharedInternalDocumentStore, id2);
  if (typeof store2.docs[internalId] === "undefined") {
    return false;
  }
  delete store2.docs[internalId];
  store2.count--;
  return true;
}
function count5(store2) {
  return store2.count;
}
function load2(sharedInternalDocumentStore, raw) {
  const rawDocument = raw;
  return {
    docs: rawDocument.docs,
    count: rawDocument.count,
    sharedInternalDocumentStore
  };
}
function save2(store2) {
  return {
    docs: store2.docs,
    count: store2.count
  };
}
function createDocumentsStore() {
  return {
    create: create2,
    get: get32,
    getMultiple,
    getAll,
    store,
    remove: remove13,
    count: count5,
    load: load2,
    save: save2
  };
}

// node_modules/@orama/orama/dist/esm/components/plugins.js
function getAllPluginsByHook(orama, hook) {
  const pluginsToRun = [];
  const pluginsLength = orama.plugins?.length;
  if (!pluginsLength) {
    return pluginsToRun;
  }
  for (let i = 0;i < pluginsLength; i++) {
    try {
      const plugin = orama.plugins[i];
      if (typeof plugin[hook] === "function") {
        pluginsToRun.push(plugin[hook]);
      }
    } catch (error2) {
      console.error("Caught error in getAllPluginsByHook:", error2);
      throw createError("PLUGIN_CRASHED");
    }
  }
  return pluginsToRun;
}
var AVAILABLE_PLUGIN_HOOKS = [
  "beforeInsert",
  "afterInsert",
  "beforeRemove",
  "afterRemove",
  "beforeUpdate",
  "afterUpdate",
  "beforeUpsert",
  "afterUpsert",
  "beforeSearch",
  "afterSearch",
  "beforeInsertMultiple",
  "afterInsertMultiple",
  "beforeRemoveMultiple",
  "afterRemoveMultiple",
  "beforeUpdateMultiple",
  "afterUpdateMultiple",
  "beforeUpsertMultiple",
  "afterUpsertMultiple",
  "beforeLoad",
  "afterLoad",
  "afterCreate"
];

// node_modules/@orama/orama/dist/esm/components/hooks.js
function runAfterSearch(hooks, db, params, language, results) {
  const needAsync = hooks.some(isAsyncFunction);
  if (needAsync) {
    return (async () => {
      for (const hook of hooks) {
        await hook(db, params, language, results);
      }
    })();
  } else {
    for (const hook of hooks) {
      hook(db, params, language, results);
    }
  }
}
function runBeforeSearch(hooks, db, params, language) {
  const needAsync = hooks.some(isAsyncFunction);
  if (needAsync) {
    return (async () => {
      for (const hook of hooks) {
        await hook(db, params, language);
      }
    })();
  } else {
    for (const hook of hooks) {
      hook(db, params, language);
    }
  }
}
function runAfterCreate(hooks, db) {
  const needAsync = hooks.some(isAsyncFunction);
  if (needAsync) {
    return (async () => {
      for (const hook of hooks) {
        await hook(db);
      }
    })();
  } else {
    for (const hook of hooks) {
      hook(db);
    }
  }
}
var OBJECT_COMPONENTS = ["tokenizer", "index", "documentsStore", "sorter"];
var FUNCTION_COMPONENTS = [
  "validateSchema",
  "getDocumentIndexId",
  "getDocumentProperties",
  "formatElapsedTime"
];

// node_modules/@orama/orama/dist/esm/trees/avl.js
class AVLNode {
  k;
  v;
  l = null;
  r = null;
  h = 1;
  constructor(key, value6) {
    this.k = key;
    this.v = new Set(value6);
  }
  updateHeight() {
    this.h = Math.max(AVLNode.getHeight(this.l), AVLNode.getHeight(this.r)) + 1;
  }
  static getHeight(node) {
    return node ? node.h : 0;
  }
  getBalanceFactor() {
    return AVLNode.getHeight(this.l) - AVLNode.getHeight(this.r);
  }
  rotateLeft() {
    const newRoot = this.r;
    this.r = newRoot.l;
    newRoot.l = this;
    this.updateHeight();
    newRoot.updateHeight();
    return newRoot;
  }
  rotateRight() {
    const newRoot = this.l;
    this.l = newRoot.r;
    newRoot.r = this;
    this.updateHeight();
    newRoot.updateHeight();
    return newRoot;
  }
  toJSON() {
    return {
      k: this.k,
      v: Array.from(this.v),
      l: this.l ? this.l.toJSON() : null,
      r: this.r ? this.r.toJSON() : null,
      h: this.h
    };
  }
  static fromJSON(json) {
    const node = new AVLNode(json.k, json.v);
    node.l = json.l ? AVLNode.fromJSON(json.l) : null;
    node.r = json.r ? AVLNode.fromJSON(json.r) : null;
    node.h = json.h;
    return node;
  }
}

class AVLTree {
  root = null;
  insertCount = 0;
  constructor(key, value6) {
    if (key !== undefined && value6 !== undefined) {
      this.root = new AVLNode(key, value6);
    }
  }
  insert(key, value6, rebalanceThreshold = 1000) {
    this.root = this.insertNode(this.root, key, value6, rebalanceThreshold);
  }
  insertMultiple(key, value6, rebalanceThreshold = 1000) {
    for (const v of value6) {
      this.insert(key, v, rebalanceThreshold);
    }
  }
  rebalance() {
    if (this.root) {
      this.root = this.rebalanceNode(this.root);
    }
  }
  toJSON() {
    return {
      root: this.root ? this.root.toJSON() : null,
      insertCount: this.insertCount
    };
  }
  static fromJSON(json) {
    const tree = new AVLTree;
    tree.root = json.root ? AVLNode.fromJSON(json.root) : null;
    tree.insertCount = json.insertCount || 0;
    return tree;
  }
  insertNode(node, key, value6, rebalanceThreshold) {
    if (node === null) {
      return new AVLNode(key, [value6]);
    }
    const path = [];
    let current2 = node;
    let parent = null;
    while (current2 !== null) {
      path.push({ parent, node: current2 });
      if (key < current2.k) {
        if (current2.l === null) {
          current2.l = new AVLNode(key, [value6]);
          path.push({ parent: current2, node: current2.l });
          break;
        } else {
          parent = current2;
          current2 = current2.l;
        }
      } else if (key > current2.k) {
        if (current2.r === null) {
          current2.r = new AVLNode(key, [value6]);
          path.push({ parent: current2, node: current2.r });
          break;
        } else {
          parent = current2;
          current2 = current2.r;
        }
      } else {
        current2.v.add(value6);
        return node;
      }
    }
    let needRebalance = false;
    if (this.insertCount++ % rebalanceThreshold === 0) {
      needRebalance = true;
    }
    for (let i = path.length - 1;i >= 0; i--) {
      const { parent: parent2, node: currentNode } = path[i];
      currentNode.updateHeight();
      if (needRebalance) {
        const rebalancedNode = this.rebalanceNode(currentNode);
        if (parent2) {
          if (parent2.l === currentNode) {
            parent2.l = rebalancedNode;
          } else if (parent2.r === currentNode) {
            parent2.r = rebalancedNode;
          }
        } else {
          node = rebalancedNode;
        }
      }
    }
    return node;
  }
  rebalanceNode(node) {
    const balanceFactor = node.getBalanceFactor();
    if (balanceFactor > 1) {
      if (node.l && node.l.getBalanceFactor() >= 0) {
        return node.rotateRight();
      } else if (node.l) {
        node.l = node.l.rotateLeft();
        return node.rotateRight();
      }
    }
    if (balanceFactor < -1) {
      if (node.r && node.r.getBalanceFactor() <= 0) {
        return node.rotateLeft();
      } else if (node.r) {
        node.r = node.r.rotateRight();
        return node.rotateLeft();
      }
    }
    return node;
  }
  find(key) {
    const node = this.findNodeByKey(key);
    return node ? node.v : null;
  }
  contains(key) {
    return this.find(key) !== null;
  }
  getSize() {
    let count6 = 0;
    const stack = [];
    let current2 = this.root;
    while (current2 || stack.length > 0) {
      while (current2) {
        stack.push(current2);
        current2 = current2.l;
      }
      current2 = stack.pop();
      count6++;
      current2 = current2.r;
    }
    return count6;
  }
  isBalanced() {
    if (!this.root)
      return true;
    const stack = [this.root];
    while (stack.length > 0) {
      const node = stack.pop();
      const balanceFactor = node.getBalanceFactor();
      if (Math.abs(balanceFactor) > 1) {
        return false;
      }
      if (node.l)
        stack.push(node.l);
      if (node.r)
        stack.push(node.r);
    }
    return true;
  }
  remove(key) {
    this.root = this.removeNode(this.root, key);
  }
  removeDocument(key, id2) {
    const node = this.findNodeByKey(key);
    if (!node) {
      return;
    }
    if (node.v.size === 1) {
      this.root = this.removeNode(this.root, key);
    } else {
      node.v = new Set([...node.v.values()].filter((v) => v !== id2));
    }
  }
  findNodeByKey(key) {
    let node = this.root;
    while (node) {
      if (key < node.k) {
        node = node.l;
      } else if (key > node.k) {
        node = node.r;
      } else {
        return node;
      }
    }
    return null;
  }
  removeNode(node, key) {
    if (node === null)
      return null;
    const path = [];
    let current2 = node;
    while (current2 !== null && current2.k !== key) {
      path.push(current2);
      if (key < current2.k) {
        current2 = current2.l;
      } else {
        current2 = current2.r;
      }
    }
    if (current2 === null) {
      return node;
    }
    if (current2.l === null || current2.r === null) {
      const child = current2.l ? current2.l : current2.r;
      if (path.length === 0) {
        node = child;
      } else {
        const parent = path[path.length - 1];
        if (parent.l === current2) {
          parent.l = child;
        } else {
          parent.r = child;
        }
      }
    } else {
      let successorParent = current2;
      let successor = current2.r;
      while (successor.l !== null) {
        successorParent = successor;
        successor = successor.l;
      }
      current2.k = successor.k;
      current2.v = successor.v;
      if (successorParent.l === successor) {
        successorParent.l = successor.r;
      } else {
        successorParent.r = successor.r;
      }
      current2 = successorParent;
    }
    path.push(current2);
    for (let i = path.length - 1;i >= 0; i--) {
      const currentNode = path[i];
      currentNode.updateHeight();
      const rebalancedNode = this.rebalanceNode(currentNode);
      if (i > 0) {
        const parent = path[i - 1];
        if (parent.l === currentNode) {
          parent.l = rebalancedNode;
        } else if (parent.r === currentNode) {
          parent.r = rebalancedNode;
        }
      } else {
        node = rebalancedNode;
      }
    }
    return node;
  }
  rangeSearch(min4, max7) {
    const result = new Set;
    const stack = [];
    let current2 = this.root;
    while (current2 || stack.length > 0) {
      while (current2) {
        stack.push(current2);
        current2 = current2.l;
      }
      current2 = stack.pop();
      if (current2.k >= min4 && current2.k <= max7) {
        for (const value6 of current2.v) {
          result.add(value6);
        }
      }
      if (current2.k > max7) {
        break;
      }
      current2 = current2.r;
    }
    return result;
  }
  greaterThan(key, inclusive = false) {
    const result = new Set;
    const stack = [];
    let current2 = this.root;
    while (current2 || stack.length > 0) {
      while (current2) {
        stack.push(current2);
        current2 = current2.r;
      }
      current2 = stack.pop();
      if (inclusive && current2.k >= key || !inclusive && current2.k > key) {
        for (const value6 of current2.v) {
          result.add(value6);
        }
      } else if (current2.k <= key) {
        break;
      }
      current2 = current2.l;
    }
    return result;
  }
  lessThan(key, inclusive = false) {
    const result = new Set;
    const stack = [];
    let current2 = this.root;
    while (current2 || stack.length > 0) {
      while (current2) {
        stack.push(current2);
        current2 = current2.l;
      }
      current2 = stack.pop();
      if (inclusive && current2.k <= key || !inclusive && current2.k < key) {
        for (const value6 of current2.v) {
          result.add(value6);
        }
      } else if (current2.k > key) {
        break;
      }
      current2 = current2.r;
    }
    return result;
  }
}

// node_modules/@orama/orama/dist/esm/trees/flat.js
class FlatTree {
  numberToDocumentId;
  constructor() {
    this.numberToDocumentId = new Map;
  }
  insert(key, value6) {
    if (this.numberToDocumentId.has(key)) {
      this.numberToDocumentId.get(key).add(value6);
    } else {
      this.numberToDocumentId.set(key, new Set([value6]));
    }
  }
  find(key) {
    const idSet = this.numberToDocumentId.get(key);
    return idSet ? Array.from(idSet) : null;
  }
  remove(key) {
    this.numberToDocumentId.delete(key);
  }
  removeDocument(id2, key) {
    const idSet = this.numberToDocumentId.get(key);
    if (idSet) {
      idSet.delete(id2);
      if (idSet.size === 0) {
        this.numberToDocumentId.delete(key);
      }
    }
  }
  contains(key) {
    return this.numberToDocumentId.has(key);
  }
  getSize() {
    let size21 = 0;
    for (const idSet of this.numberToDocumentId.values()) {
      size21 += idSet.size;
    }
    return size21;
  }
  filter(operation) {
    const operationKeys = Object.keys(operation);
    if (operationKeys.length !== 1) {
      throw new Error("Invalid operation");
    }
    const operationType = operationKeys[0];
    switch (operationType) {
      case "eq": {
        const value6 = operation[operationType];
        const idSet = this.numberToDocumentId.get(value6);
        return idSet ? Array.from(idSet) : [];
      }
      case "in": {
        const values7 = operation[operationType];
        const resultSet = new Set;
        for (const value6 of values7) {
          const idSet = this.numberToDocumentId.get(value6);
          if (idSet) {
            for (const id2 of idSet) {
              resultSet.add(id2);
            }
          }
        }
        return Array.from(resultSet);
      }
      case "nin": {
        const excludeValues = new Set(operation[operationType]);
        const resultSet = new Set;
        for (const [key, idSet] of this.numberToDocumentId.entries()) {
          if (!excludeValues.has(key)) {
            for (const id2 of idSet) {
              resultSet.add(id2);
            }
          }
        }
        return Array.from(resultSet);
      }
      default:
        throw new Error("Invalid operation");
    }
  }
  filterArr(operation) {
    const operationKeys = Object.keys(operation);
    if (operationKeys.length !== 1) {
      throw new Error("Invalid operation");
    }
    const operationType = operationKeys[0];
    switch (operationType) {
      case "containsAll": {
        const values7 = operation[operationType];
        const idSets = values7.map((value6) => this.numberToDocumentId.get(value6) ?? new Set);
        if (idSets.length === 0)
          return [];
        const intersection5 = idSets.reduce((prev, curr) => {
          return new Set([...prev].filter((id2) => curr.has(id2)));
        });
        return Array.from(intersection5);
      }
      case "containsAny": {
        const values7 = operation[operationType];
        const idSets = values7.map((value6) => this.numberToDocumentId.get(value6) ?? new Set);
        if (idSets.length === 0)
          return [];
        const union11 = idSets.reduce((prev, curr) => {
          return new Set([...prev, ...curr]);
        });
        return Array.from(union11);
      }
      default:
        throw new Error("Invalid operation");
    }
  }
  static fromJSON(json) {
    if (!json.numberToDocumentId) {
      throw new Error("Invalid Flat Tree JSON");
    }
    const tree = new FlatTree;
    for (const [key, ids3] of json.numberToDocumentId) {
      tree.numberToDocumentId.set(key, new Set(ids3));
    }
    return tree;
  }
  toJSON() {
    return {
      numberToDocumentId: Array.from(this.numberToDocumentId.entries()).map(([key, idSet]) => [key, Array.from(idSet)])
    };
  }
}

// node_modules/@orama/orama/dist/esm/components/levenshtein.js
function _boundedLevenshtein(term, word, tolerance) {
  if (tolerance < 0)
    return -1;
  if (term === word)
    return 0;
  const m = term.length;
  const n = word.length;
  if (m === 0)
    return n <= tolerance ? n : -1;
  if (n === 0)
    return m <= tolerance ? m : -1;
  const diff11 = Math.abs(m - n);
  if (term.startsWith(word)) {
    return diff11 <= tolerance ? diff11 : -1;
  }
  if (word.startsWith(term)) {
    return 0;
  }
  if (diff11 > tolerance)
    return -1;
  const matrix = [];
  for (let i = 0;i <= m; i++) {
    matrix[i] = [i];
    for (let j = 1;j <= n; j++) {
      matrix[i][j] = i === 0 ? j : 0;
    }
  }
  for (let i = 1;i <= m; i++) {
    let rowMin = Infinity;
    for (let j = 1;j <= n; j++) {
      if (term[i - 1] === word[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(matrix[i - 1][j] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j - 1] + 1);
      }
      rowMin = Math.min(rowMin, matrix[i][j]);
    }
    if (rowMin > tolerance) {
      return -1;
    }
  }
  return matrix[m][n] <= tolerance ? matrix[m][n] : -1;
}
function syncBoundedLevenshtein(term, w, tolerance) {
  const distance2 = _boundedLevenshtein(term, w, tolerance);
  return {
    distance: distance2,
    isBounded: distance2 >= 0
  };
}

// node_modules/@orama/orama/dist/esm/trees/radix.js
class RadixNode {
  k;
  s;
  c = new Map;
  d = new Set;
  e;
  w = "";
  constructor(key, subWord, end6) {
    this.k = key;
    this.s = subWord;
    this.e = end6;
  }
  updateParent(parent) {
    this.w = parent.w + this.s;
  }
  addDocument(docID) {
    this.d.add(docID);
  }
  removeDocument(docID) {
    return this.d.delete(docID);
  }
  findAllWords(output, term, exact, tolerance) {
    const stack = [this];
    while (stack.length > 0) {
      const node = stack.pop();
      if (node.e) {
        const { w, d: docIDs } = node;
        if (exact && w !== term) {
          continue;
        }
        if (getOwnProperty(output, w) !== null) {
          if (tolerance) {
            const difference5 = Math.abs(term.length - w.length);
            if (difference5 <= tolerance && syncBoundedLevenshtein(term, w, tolerance).isBounded) {
              output[w] = [];
            } else {
              continue;
            }
          } else {
            output[w] = [];
          }
        }
        if (getOwnProperty(output, w) != null && docIDs.size > 0) {
          const docs = output[w];
          for (const docID of docIDs) {
            if (!docs.includes(docID)) {
              docs.push(docID);
            }
          }
        }
      }
      if (node.c.size > 0) {
        stack.push(...node.c.values());
      }
    }
    return output;
  }
  insert(word, docId) {
    let node = this;
    let i = 0;
    const wordLength = word.length;
    while (i < wordLength) {
      const currentCharacter = word[i];
      const childNode = node.c.get(currentCharacter);
      if (childNode) {
        const edgeLabel = childNode.s;
        const edgeLabelLength = edgeLabel.length;
        let j = 0;
        while (j < edgeLabelLength && i + j < wordLength && edgeLabel[j] === word[i + j]) {
          j++;
        }
        if (j === edgeLabelLength) {
          node = childNode;
          i += j;
          if (i === wordLength) {
            if (!childNode.e) {
              childNode.e = true;
            }
            childNode.addDocument(docId);
            return;
          }
          continue;
        }
        const commonPrefix = edgeLabel.slice(0, j);
        const newEdgeLabel = edgeLabel.slice(j);
        const newWordLabel = word.slice(i + j);
        const inbetweenNode = new RadixNode(commonPrefix[0], commonPrefix, false);
        node.c.set(commonPrefix[0], inbetweenNode);
        inbetweenNode.updateParent(node);
        childNode.s = newEdgeLabel;
        childNode.k = newEdgeLabel[0];
        inbetweenNode.c.set(newEdgeLabel[0], childNode);
        childNode.updateParent(inbetweenNode);
        if (newWordLabel) {
          const newNode = new RadixNode(newWordLabel[0], newWordLabel, true);
          newNode.addDocument(docId);
          inbetweenNode.c.set(newWordLabel[0], newNode);
          newNode.updateParent(inbetweenNode);
        } else {
          inbetweenNode.e = true;
          inbetweenNode.addDocument(docId);
        }
        return;
      } else {
        const newNode = new RadixNode(currentCharacter, word.slice(i), true);
        newNode.addDocument(docId);
        node.c.set(currentCharacter, newNode);
        newNode.updateParent(node);
        return;
      }
    }
    if (!node.e) {
      node.e = true;
    }
    node.addDocument(docId);
  }
  _findLevenshtein(term, index, tolerance, originalTolerance, output) {
    const stack = [{ node: this, index, tolerance }];
    while (stack.length > 0) {
      const { node, index: index2, tolerance: tolerance2 } = stack.pop();
      if (node.w.startsWith(term)) {
        node.findAllWords(output, term, false, 0);
        continue;
      }
      if (tolerance2 < 0) {
        continue;
      }
      if (node.e) {
        const { w, d: docIDs } = node;
        if (w) {
          if (syncBoundedLevenshtein(term, w, originalTolerance).isBounded) {
            output[w] = [];
          }
          if (getOwnProperty(output, w) !== undefined && docIDs.size > 0) {
            const docs = new Set(output[w]);
            for (const docID of docIDs) {
              docs.add(docID);
            }
            output[w] = Array.from(docs);
          }
        }
      }
      if (index2 >= term.length) {
        continue;
      }
      const currentChar = term[index2];
      if (node.c.has(currentChar)) {
        const childNode = node.c.get(currentChar);
        stack.push({ node: childNode, index: index2 + 1, tolerance: tolerance2 });
      }
      stack.push({ node, index: index2 + 1, tolerance: tolerance2 - 1 });
      for (const [character, childNode] of node.c) {
        stack.push({ node: childNode, index: index2, tolerance: tolerance2 - 1 });
        if (character !== currentChar) {
          stack.push({ node: childNode, index: index2 + 1, tolerance: tolerance2 - 1 });
        }
      }
    }
  }
  find(params) {
    const { term, exact, tolerance } = params;
    if (tolerance && !exact) {
      const output = {};
      this._findLevenshtein(term, 0, tolerance, tolerance, output);
      return output;
    } else {
      let node = this;
      let i = 0;
      const termLength = term.length;
      while (i < termLength) {
        const character = term[i];
        const childNode = node.c.get(character);
        if (childNode) {
          const edgeLabel = childNode.s;
          const edgeLabelLength = edgeLabel.length;
          let j = 0;
          while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
            j++;
          }
          if (j === edgeLabelLength) {
            node = childNode;
            i += j;
          } else if (i + j === termLength) {
            if (j === termLength - i) {
              if (exact) {
                return {};
              } else {
                const output2 = {};
                childNode.findAllWords(output2, term, exact, tolerance);
                return output2;
              }
            } else {
              return {};
            }
          } else {
            return {};
          }
        } else {
          return {};
        }
      }
      const output = {};
      node.findAllWords(output, term, exact, tolerance);
      return output;
    }
  }
  contains(term) {
    let node = this;
    let i = 0;
    const termLength = term.length;
    while (i < termLength) {
      const character = term[i];
      const childNode = node.c.get(character);
      if (childNode) {
        const edgeLabel = childNode.s;
        const edgeLabelLength = edgeLabel.length;
        let j = 0;
        while (j < edgeLabelLength && i + j < termLength && edgeLabel[j] === term[i + j]) {
          j++;
        }
        if (j < edgeLabelLength) {
          return false;
        }
        i += edgeLabelLength;
        node = childNode;
      } else {
        return false;
      }
    }
    return true;
  }
  removeWord(term) {
    if (!term) {
      return false;
    }
    let node = this;
    const termLength = term.length;
    const stack = [];
    for (let i = 0;i < termLength; i++) {
      const character = term[i];
      if (node.c.has(character)) {
        const childNode = node.c.get(character);
        stack.push({ parent: node, character });
        i += childNode.s.length - 1;
        node = childNode;
      } else {
        return false;
      }
    }
    node.d.clear();
    node.e = false;
    while (stack.length > 0 && node.c.size === 0 && !node.e && node.d.size === 0) {
      const { parent, character } = stack.pop();
      parent.c.delete(character);
      node = parent;
    }
    return true;
  }
  removeDocumentByWord(term, docID, exact = true) {
    if (!term) {
      return true;
    }
    let node = this;
    const termLength = term.length;
    for (let i = 0;i < termLength; i++) {
      const character = term[i];
      if (node.c.has(character)) {
        const childNode = node.c.get(character);
        i += childNode.s.length - 1;
        node = childNode;
        if (exact && node.w !== term) {
        } else {
          node.removeDocument(docID);
        }
      } else {
        return false;
      }
    }
    return true;
  }
  static getCommonPrefix(a, b) {
    const len = Math.min(a.length, b.length);
    let i = 0;
    while (i < len && a.charCodeAt(i) === b.charCodeAt(i)) {
      i++;
    }
    return a.slice(0, i);
  }
  toJSON() {
    return {
      w: this.w,
      s: this.s,
      e: this.e,
      k: this.k,
      d: Array.from(this.d),
      c: Array.from(this.c?.entries())?.map(([key, node]) => [key, node.toJSON()])
    };
  }
  static fromJSON(json) {
    const node = new RadixNode(json.k, json.s, json.e);
    node.w = json.w;
    node.d = new Set(json.d);
    node.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
    return node;
  }
}

class RadixTree extends RadixNode {
  constructor() {
    super("", "", false);
  }
  static fromJSON(json) {
    const tree = new RadixTree;
    tree.w = json.w;
    tree.s = json.s;
    tree.e = json.e;
    tree.k = json.k;
    tree.d = new Set(json.d);
    tree.c = new Map(json?.c?.map(([key, nodeJson]) => [key, RadixNode.fromJSON(nodeJson)]) || []);
    return tree;
  }
  toJSON() {
    return super.toJSON();
  }
}

// node_modules/@orama/orama/dist/esm/trees/bkd.js
var K = 2;
var EARTH_RADIUS = 6371000;

class BKDNode {
  point;
  docIDs;
  left;
  right;
  parent;
  constructor(point, docIDs) {
    this.point = point;
    this.docIDs = new Set(docIDs);
    this.left = null;
    this.right = null;
    this.parent = null;
  }
  toJSON() {
    return {
      point: this.point,
      docIDs: Array.from(this.docIDs),
      left: this.left ? this.left.toJSON() : null,
      right: this.right ? this.right.toJSON() : null
    };
  }
  static fromJSON(json, parent = null) {
    const node = new BKDNode(json.point, json.docIDs);
    node.parent = parent;
    if (json.left) {
      node.left = BKDNode.fromJSON(json.left, node);
    }
    if (json.right) {
      node.right = BKDNode.fromJSON(json.right, node);
    }
    return node;
  }
}

class BKDTree {
  root;
  nodeMap;
  constructor() {
    this.root = null;
    this.nodeMap = new Map;
  }
  getPointKey(point) {
    return `${point.lon},${point.lat}`;
  }
  insert(point, docIDs) {
    const pointKey = this.getPointKey(point);
    const existingNode = this.nodeMap.get(pointKey);
    if (existingNode) {
      docIDs.forEach((id2) => existingNode.docIDs.add(id2));
      return;
    }
    const newNode = new BKDNode(point, docIDs);
    this.nodeMap.set(pointKey, newNode);
    if (this.root == null) {
      this.root = newNode;
      return;
    }
    let node = this.root;
    let depth = 0;
    while (true) {
      const axis = depth % K;
      if (axis === 0) {
        if (point.lon < node.point.lon) {
          if (node.left == null) {
            node.left = newNode;
            newNode.parent = node;
            return;
          }
          node = node.left;
        } else {
          if (node.right == null) {
            node.right = newNode;
            newNode.parent = node;
            return;
          }
          node = node.right;
        }
      } else {
        if (point.lat < node.point.lat) {
          if (node.left == null) {
            node.left = newNode;
            newNode.parent = node;
            return;
          }
          node = node.left;
        } else {
          if (node.right == null) {
            node.right = newNode;
            newNode.parent = node;
            return;
          }
          node = node.right;
        }
      }
      depth++;
    }
  }
  contains(point) {
    const pointKey = this.getPointKey(point);
    return this.nodeMap.has(pointKey);
  }
  getDocIDsByCoordinates(point) {
    const pointKey = this.getPointKey(point);
    const node = this.nodeMap.get(pointKey);
    if (node) {
      return Array.from(node.docIDs);
    }
    return null;
  }
  removeDocByID(point, docID) {
    const pointKey = this.getPointKey(point);
    const node = this.nodeMap.get(pointKey);
    if (node) {
      node.docIDs.delete(docID);
      if (node.docIDs.size === 0) {
        this.nodeMap.delete(pointKey);
        this.deleteNode(node);
      }
    }
  }
  deleteNode(node) {
    const parent = node.parent;
    const child = node.left ? node.left : node.right;
    if (child) {
      child.parent = parent;
    }
    if (parent) {
      if (parent.left === node) {
        parent.left = child;
      } else if (parent.right === node) {
        parent.right = child;
      }
    } else {
      this.root = child;
      if (this.root) {
        this.root.parent = null;
      }
    }
  }
  searchByRadius(center, radius, inclusive = true, sort3 = "asc", highPrecision = false) {
    const distanceFn = highPrecision ? BKDTree.vincentyDistance : BKDTree.haversineDistance;
    const stack = [{ node: this.root, depth: 0 }];
    const result = [];
    while (stack.length > 0) {
      const { node, depth } = stack.pop();
      if (node == null)
        continue;
      const dist = distanceFn(center, node.point);
      if (inclusive ? dist <= radius : dist > radius) {
        result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
      }
      if (node.left != null) {
        stack.push({ node: node.left, depth: depth + 1 });
      }
      if (node.right != null) {
        stack.push({ node: node.right, depth: depth + 1 });
      }
    }
    if (sort3) {
      result.sort((a, b) => {
        const distA = distanceFn(center, a.point);
        const distB = distanceFn(center, b.point);
        return sort3.toLowerCase() === "asc" ? distA - distB : distB - distA;
      });
    }
    return result;
  }
  searchByPolygon(polygon, inclusive = true, sort3 = null, highPrecision = false) {
    const stack = [{ node: this.root, depth: 0 }];
    const result = [];
    while (stack.length > 0) {
      const { node, depth } = stack.pop();
      if (node == null)
        continue;
      if (node.left != null) {
        stack.push({ node: node.left, depth: depth + 1 });
      }
      if (node.right != null) {
        stack.push({ node: node.right, depth: depth + 1 });
      }
      const isInsidePolygon = BKDTree.isPointInPolygon(polygon, node.point);
      if (isInsidePolygon && inclusive || !isInsidePolygon && !inclusive) {
        result.push({ point: node.point, docIDs: Array.from(node.docIDs) });
      }
    }
    const centroid = BKDTree.calculatePolygonCentroid(polygon);
    if (sort3) {
      const distanceFn = highPrecision ? BKDTree.vincentyDistance : BKDTree.haversineDistance;
      result.sort((a, b) => {
        const distA = distanceFn(centroid, a.point);
        const distB = distanceFn(centroid, b.point);
        return sort3.toLowerCase() === "asc" ? distA - distB : distB - distA;
      });
    }
    return result;
  }
  toJSON() {
    return {
      root: this.root ? this.root.toJSON() : null
    };
  }
  static fromJSON(json) {
    const tree = new BKDTree;
    if (json.root) {
      tree.root = BKDNode.fromJSON(json.root);
      tree.buildNodeMap(tree.root);
    }
    return tree;
  }
  buildNodeMap(node) {
    if (node == null)
      return;
    const pointKey = this.getPointKey(node.point);
    this.nodeMap.set(pointKey, node);
    if (node.left) {
      this.buildNodeMap(node.left);
    }
    if (node.right) {
      this.buildNodeMap(node.right);
    }
  }
  static calculatePolygonCentroid(polygon) {
    let totalArea = 0;
    let centroidX = 0;
    let centroidY = 0;
    const polygonLength = polygon.length;
    for (let i = 0, j = polygonLength - 1;i < polygonLength; j = i++) {
      const xi = polygon[i].lon;
      const yi = polygon[i].lat;
      const xj = polygon[j].lon;
      const yj = polygon[j].lat;
      const areaSegment = xi * yj - xj * yi;
      totalArea += areaSegment;
      centroidX += (xi + xj) * areaSegment;
      centroidY += (yi + yj) * areaSegment;
    }
    totalArea /= 2;
    const centroidCoordinate = 6 * totalArea;
    centroidX /= centroidCoordinate;
    centroidY /= centroidCoordinate;
    return { lon: centroidX, lat: centroidY };
  }
  static isPointInPolygon(polygon, point) {
    let isInside = false;
    const x = point.lon;
    const y = point.lat;
    const polygonLength = polygon.length;
    for (let i = 0, j = polygonLength - 1;i < polygonLength; j = i++) {
      const xi = polygon[i].lon;
      const yi = polygon[i].lat;
      const xj = polygon[j].lon;
      const yj = polygon[j].lat;
      const intersect7 = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect7)
        isInside = !isInside;
    }
    return isInside;
  }
  static haversineDistance(coord1, coord2) {
    const P = Math.PI / 180;
    const lat1 = coord1.lat * P;
    const lat2 = coord2.lat * P;
    const deltaLat = (coord2.lat - coord1.lat) * P;
    const deltaLon = (coord2.lon - coord1.lon) * P;
    const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return EARTH_RADIUS * c;
  }
  static vincentyDistance(coord1, coord2) {
    const a = 6378137;
    const f = 1 / 298.257223563;
    const b = (1 - f) * a;
    const P = Math.PI / 180;
    const lat1 = coord1.lat * P;
    const lat2 = coord2.lat * P;
    const deltaLon = (coord2.lon - coord1.lon) * P;
    const U1 = Math.atan((1 - f) * Math.tan(lat1));
    const U2 = Math.atan((1 - f) * Math.tan(lat2));
    const sinU1 = Math.sin(U1);
    const cosU1 = Math.cos(U1);
    const sinU2 = Math.sin(U2);
    const cosU2 = Math.cos(U2);
    let lambda = deltaLon;
    let prevLambda;
    let iterationLimit = 1000;
    let sinSigma;
    let cosSigma;
    let sigma;
    let sinAlpha;
    let cos2Alpha;
    let cos2SigmaM;
    do {
      const sinLambda = Math.sin(lambda);
      const cosLambda = Math.cos(lambda);
      sinSigma = Math.sqrt(cosU2 * sinLambda * (cosU2 * sinLambda) + (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      if (sinSigma === 0)
        return 0;
      cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = Math.atan2(sinSigma, cosSigma);
      sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
      cos2Alpha = 1 - sinAlpha * sinAlpha;
      cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cos2Alpha;
      if (isNaN(cos2SigmaM))
        cos2SigmaM = 0;
      const C = f / 16 * cos2Alpha * (4 + f * (4 - 3 * cos2Alpha));
      prevLambda = lambda;
      lambda = deltaLon + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));
    } while (Math.abs(lambda - prevLambda) > 0.000000000001 && --iterationLimit > 0);
    if (iterationLimit === 0) {
      return NaN;
    }
    const uSquared = cos2Alpha * (a * a - b * b) / (b * b);
    const A = 1 + uSquared / 16384 * (4096 + uSquared * (-768 + uSquared * (320 - 175 * uSquared)));
    const B = uSquared / 1024 * (256 + uSquared * (-128 + uSquared * (74 - 47 * uSquared)));
    const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));
    const s = b * A * (sigma - deltaSigma);
    return s;
  }
}

// node_modules/@orama/orama/dist/esm/trees/bool.js
class BoolNode {
  true;
  false;
  constructor() {
    this.true = new Set;
    this.false = new Set;
  }
  insert(value6, bool) {
    if (bool) {
      this.true.add(value6);
    } else {
      this.false.add(value6);
    }
  }
  delete(value6, bool) {
    if (bool) {
      this.true.delete(value6);
    } else {
      this.false.delete(value6);
    }
  }
  getSize() {
    return this.true.size + this.false.size;
  }
  toJSON() {
    return {
      true: Array.from(this.true),
      false: Array.from(this.false)
    };
  }
  static fromJSON(json) {
    const node = new BoolNode;
    node.true = new Set(json.true);
    node.false = new Set(json.false);
    return node;
  }
}

// node_modules/@orama/orama/dist/esm/components/algorithms.js
function BM25(tf, matchingCount, docsCount, fieldLength, averageFieldLength, { k: k2, b, d }) {
  const idf = Math.log(1 + (docsCount - matchingCount + 0.5) / (matchingCount + 0.5));
  return idf * (d + tf * (k2 + 1)) / (tf + k2 * (1 - b + b * fieldLength / averageFieldLength));
}

// node_modules/@orama/orama/dist/esm/trees/vector.js
function getMagnitude(vector, vectorLength) {
  let magnitude = 0;
  for (let i = 0;i < vectorLength; i++) {
    magnitude += vector[i] * vector[i];
  }
  return Math.sqrt(magnitude);
}
function findSimilarVectors(targetVector, keys9, vectors, length4, threshold) {
  const targetMagnitude = getMagnitude(targetVector, length4);
  const similarVectors = [];
  const base = keys9 ? keys9 : vectors.keys();
  for (const vectorId of base) {
    const entry = vectors.get(vectorId);
    if (!entry) {
      continue;
    }
    const magnitude = entry[0];
    const vector = entry[1];
    let dotProduct = 0;
    for (let i = 0;i < length4; i++) {
      dotProduct += targetVector[i] * vector[i];
    }
    const similarity = dotProduct / (targetMagnitude * magnitude);
    if (similarity >= threshold) {
      similarVectors.push([vectorId, similarity]);
    }
  }
  return similarVectors;
}
var DEFAULT_SIMILARITY = 0.8;

class VectorIndex {
  size;
  vectors = new Map;
  constructor(size21) {
    this.size = size21;
  }
  add(internalDocumentId, value6) {
    if (!(value6 instanceof Float32Array)) {
      value6 = new Float32Array(value6);
    }
    const magnitude = getMagnitude(value6, this.size);
    this.vectors.set(internalDocumentId, [magnitude, value6]);
  }
  remove(internalDocumentId) {
    this.vectors.delete(internalDocumentId);
  }
  find(vector, similarity, whereFiltersIDs) {
    if (!(vector instanceof Float32Array)) {
      vector = new Float32Array(vector);
    }
    const results = findSimilarVectors(vector, whereFiltersIDs, this.vectors, this.size, similarity);
    return results;
  }
  toJSON() {
    const vectors = [];
    for (const [id2, [magnitude, vector]] of this.vectors) {
      vectors.push([id2, [magnitude, Array.from(vector)]]);
    }
    return {
      size: this.size,
      vectors
    };
  }
  static fromJSON(json) {
    const raw = json;
    const index = new VectorIndex(raw.size);
    for (const [id2, [magnitude, vector]] of raw.vectors) {
      index.vectors.set(id2, [magnitude, new Float32Array(vector)]);
    }
    return index;
  }
}

// node_modules/@orama/orama/dist/esm/components/index.js
function insertDocumentScoreParameters(index, prop, id2, tokens, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id2);
  index.avgFieldLength[prop] = ((index.avgFieldLength[prop] ?? 0) * (docsCount - 1) + tokens.length) / docsCount;
  index.fieldLengths[prop][internalId] = tokens.length;
  index.frequencies[prop][internalId] = {};
}
function insertTokenScoreParameters(index, prop, id2, tokens, token) {
  let tokenFrequency = 0;
  for (const t2 of tokens) {
    if (t2 === token) {
      tokenFrequency++;
    }
  }
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id2);
  const tf = tokenFrequency / tokens.length;
  index.frequencies[prop][internalId][token] = tf;
  if (!(token in index.tokenOccurrences[prop])) {
    index.tokenOccurrences[prop][token] = 0;
  }
  index.tokenOccurrences[prop][token] = (index.tokenOccurrences[prop][token] ?? 0) + 1;
}
function removeDocumentScoreParameters(index, prop, id2, docsCount) {
  const internalId = getInternalDocumentId(index.sharedInternalDocumentStore, id2);
  if (docsCount > 1) {
    index.avgFieldLength[prop] = (index.avgFieldLength[prop] * docsCount - index.fieldLengths[prop][internalId]) / (docsCount - 1);
  } else {
    index.avgFieldLength[prop] = undefined;
  }
  index.fieldLengths[prop][internalId] = undefined;
  index.frequencies[prop][internalId] = undefined;
}
function removeTokenScoreParameters(index, prop, token) {
  index.tokenOccurrences[prop][token]--;
}
function create3(orama, sharedInternalDocumentStore, schema, index, prefix = "") {
  if (!index) {
    index = {
      sharedInternalDocumentStore,
      indexes: {},
      vectorIndexes: {},
      searchableProperties: [],
      searchablePropertiesWithTypes: {},
      frequencies: {},
      tokenOccurrences: {},
      avgFieldLength: {},
      fieldLengths: {}
    };
  }
  for (const [prop, type2] of Object.entries(schema)) {
    const path = `${prefix}${prefix ? "." : ""}${prop}`;
    if (typeof type2 === "object" && !Array.isArray(type2)) {
      create3(orama, sharedInternalDocumentStore, type2, index, path);
      continue;
    }
    if (isVectorType(type2)) {
      index.searchableProperties.push(path);
      index.searchablePropertiesWithTypes[path] = type2;
      index.vectorIndexes[path] = {
        type: "Vector",
        node: new VectorIndex(getVectorSize(type2)),
        isArray: false
      };
    } else {
      const isArray2 = /\[/.test(type2);
      switch (type2) {
        case "boolean":
        case "boolean[]":
          index.indexes[path] = { type: "Bool", node: new BoolNode, isArray: isArray2 };
          break;
        case "number":
        case "number[]":
          index.indexes[path] = { type: "AVL", node: new AVLTree(0, []), isArray: isArray2 };
          break;
        case "string":
        case "string[]":
          index.indexes[path] = { type: "Radix", node: new RadixTree, isArray: isArray2 };
          index.avgFieldLength[path] = 0;
          index.frequencies[path] = {};
          index.tokenOccurrences[path] = {};
          index.fieldLengths[path] = {};
          break;
        case "enum":
        case "enum[]":
          index.indexes[path] = { type: "Flat", node: new FlatTree, isArray: isArray2 };
          break;
        case "geopoint":
          index.indexes[path] = { type: "BKD", node: new BKDTree, isArray: isArray2 };
          break;
        default:
          throw createError("INVALID_SCHEMA_TYPE", Array.isArray(type2) ? "array" : type2, path);
      }
      index.searchableProperties.push(path);
      index.searchablePropertiesWithTypes[path] = type2;
    }
  }
  return index;
}
function insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options) {
  return (value6) => {
    const { type: type2, node } = index.indexes[prop];
    switch (type2) {
      case "Bool": {
        node[value6 ? "true" : "false"].add(internalId);
        break;
      }
      case "AVL": {
        const avlRebalanceThreshold = options?.avlRebalanceThreshold ?? 1;
        node.insert(value6, internalId, avlRebalanceThreshold);
        break;
      }
      case "Radix": {
        const tokens = tokenizer.tokenize(value6, language, prop, false);
        implementation.insertDocumentScoreParameters(index, prop, internalId, tokens, docsCount);
        for (const token of tokens) {
          implementation.insertTokenScoreParameters(index, prop, internalId, tokens, token);
          node.insert(token, internalId);
        }
        break;
      }
      case "Flat": {
        node.insert(value6, internalId);
        break;
      }
      case "BKD": {
        node.insert(value6, [internalId]);
        break;
      }
    }
  };
}
function insert4(implementation, index, prop, id2, internalId, value6, schemaType, language, tokenizer, docsCount, options) {
  if (isVectorType(schemaType)) {
    return insertVector(index, prop, value6, id2, internalId);
  }
  const insertScalar = insertScalarBuilder(implementation, index, prop, internalId, language, tokenizer, docsCount, options);
  if (!isArrayType(schemaType)) {
    return insertScalar(value6);
  }
  const elements = value6;
  const elementsLength = elements.length;
  for (let i = 0;i < elementsLength; i++) {
    insertScalar(elements[i]);
  }
}
function insertVector(index, prop, value6, id2, internalDocumentId) {
  index.vectorIndexes[prop].node.add(internalDocumentId, value6);
}
function removeScalar(implementation, index, prop, id2, internalId, value6, schemaType, language, tokenizer, docsCount) {
  if (isVectorType(schemaType)) {
    index.vectorIndexes[prop].node.remove(internalId);
    return true;
  }
  const { type: type2, node } = index.indexes[prop];
  switch (type2) {
    case "AVL": {
      node.removeDocument(value6, internalId);
      return true;
    }
    case "Bool": {
      node[value6 ? "true" : "false"].delete(internalId);
      return true;
    }
    case "Radix": {
      const tokens = tokenizer.tokenize(value6, language, prop);
      implementation.removeDocumentScoreParameters(index, prop, id2, docsCount);
      for (const token of tokens) {
        implementation.removeTokenScoreParameters(index, prop, token);
        node.removeDocumentByWord(token, internalId);
      }
      return true;
    }
    case "Flat": {
      node.removeDocument(internalId, value6);
      return true;
    }
    case "BKD": {
      node.removeDocByID(value6, internalId);
      return false;
    }
  }
}
function remove14(implementation, index, prop, id2, internalId, value6, schemaType, language, tokenizer, docsCount) {
  if (!isArrayType(schemaType)) {
    return removeScalar(implementation, index, prop, id2, internalId, value6, schemaType, language, tokenizer, docsCount);
  }
  const innerSchemaType = getInnerType(schemaType);
  const elements = value6;
  const elementsLength = elements.length;
  for (let i = 0;i < elementsLength; i++) {
    removeScalar(implementation, index, prop, id2, internalId, elements[i], innerSchemaType, language, tokenizer, docsCount);
  }
  return true;
}
function calculateResultScores(index, prop, term, ids3, docsCount, bm25Relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap) {
  const documentIDs = Array.from(ids3);
  const avgFieldLength = index.avgFieldLength[prop];
  const fieldLengths = index.fieldLengths[prop];
  const oramaOccurrences = index.tokenOccurrences[prop];
  const oramaFrequencies = index.frequencies[prop];
  const termOccurrences = typeof oramaOccurrences[term] === "number" ? oramaOccurrences[term] ?? 0 : 0;
  const documentIDsLength = documentIDs.length;
  for (let k2 = 0;k2 < documentIDsLength; k2++) {
    const internalId = documentIDs[k2];
    if (whereFiltersIDs && !whereFiltersIDs.has(internalId)) {
      continue;
    }
    if (!keywordMatchesMap.has(internalId)) {
      keywordMatchesMap.set(internalId, new Map);
    }
    const propertyMatches = keywordMatchesMap.get(internalId);
    propertyMatches.set(prop, (propertyMatches.get(prop) || 0) + 1);
    const tf = oramaFrequencies?.[internalId]?.[term] ?? 0;
    const bm25 = BM25(tf, termOccurrences, docsCount, fieldLengths[internalId], avgFieldLength, bm25Relevance);
    if (resultsMap.has(internalId)) {
      resultsMap.set(internalId, resultsMap.get(internalId) + bm25 * boostPerProperty);
    } else {
      resultsMap.set(internalId, bm25 * boostPerProperty);
    }
  }
}
function search(index, term, tokenizer, language, propertiesToSearch, exact, tolerance, boost, relevance, docsCount, whereFiltersIDs, threshold = 0) {
  const tokens = tokenizer.tokenize(term, language);
  const keywordsCount = tokens.length || 1;
  const keywordMatchesMap = new Map;
  const tokenFoundMap = new Map;
  const resultsMap = new Map;
  for (const prop of propertiesToSearch) {
    if (!(prop in index.indexes)) {
      continue;
    }
    const tree = index.indexes[prop];
    const { type: type2 } = tree;
    if (type2 !== "Radix") {
      throw createError("WRONG_SEARCH_PROPERTY_TYPE", prop);
    }
    const boostPerProperty = boost[prop] ?? 1;
    if (boostPerProperty <= 0) {
      throw createError("INVALID_BOOST_VALUE", boostPerProperty);
    }
    if (tokens.length === 0 && !term) {
      tokens.push("");
    }
    const tokenLength = tokens.length;
    for (let i = 0;i < tokenLength; i++) {
      const token = tokens[i];
      const searchResult = tree.node.find({ term: token, exact, tolerance });
      const termsFound = Object.keys(searchResult);
      if (termsFound.length > 0) {
        tokenFoundMap.set(token, true);
      }
      const termsFoundLength = termsFound.length;
      for (let j = 0;j < termsFoundLength; j++) {
        const word = termsFound[j];
        const ids3 = searchResult[word];
        calculateResultScores(index, prop, word, ids3, docsCount, relevance, resultsMap, boostPerProperty, whereFiltersIDs, keywordMatchesMap);
      }
    }
  }
  const results = Array.from(resultsMap.entries()).map(([id2, score]) => [id2, score]).sort((a, b) => b[1] - a[1]);
  if (results.length === 0) {
    return [];
  }
  if (threshold === 1) {
    return results;
  }
  if (threshold === 0) {
    if (keywordsCount === 1) {
      return results;
    }
    for (const token of tokens) {
      if (!tokenFoundMap.get(token)) {
        return [];
      }
    }
    const fullMatches2 = results.filter(([id2]) => {
      const propertyMatches = keywordMatchesMap.get(id2);
      if (!propertyMatches)
        return false;
      return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
    });
    return fullMatches2;
  }
  const fullMatches = results.filter(([id2]) => {
    const propertyMatches = keywordMatchesMap.get(id2);
    if (!propertyMatches)
      return false;
    return Array.from(propertyMatches.values()).some((matches) => matches === keywordsCount);
  });
  if (fullMatches.length > 0) {
    const remainingResults = results.filter(([id2]) => !fullMatches.some(([fid]) => fid === id2));
    const additionalResults = Math.ceil(remainingResults.length * threshold);
    return [...fullMatches, ...remainingResults.slice(0, additionalResults)];
  }
  return results;
}
function searchByWhereClause(index, tokenizer, filters, language) {
  if ("and" in filters && filters.and && Array.isArray(filters.and)) {
    const andFilters = filters.and;
    if (andFilters.length === 0) {
      return new Set;
    }
    const results = andFilters.map((filter17) => searchByWhereClause(index, tokenizer, filter17, language));
    return setIntersection(...results);
  }
  if ("or" in filters && filters.or && Array.isArray(filters.or)) {
    const orFilters = filters.or;
    if (orFilters.length === 0) {
      return new Set;
    }
    const results = orFilters.map((filter17) => searchByWhereClause(index, tokenizer, filter17, language));
    return results.reduce((acc, set17) => setUnion(acc, set17), new Set);
  }
  if ("not" in filters && filters.not) {
    const notFilter = filters.not;
    const allDocs = new Set;
    const docsStore = index.sharedInternalDocumentStore;
    for (let i = 1;i <= docsStore.internalIdToId.length; i++) {
      allDocs.add(i);
    }
    const notResult = searchByWhereClause(index, tokenizer, notFilter, language);
    return setDifference(allDocs, notResult);
  }
  const filterKeys = Object.keys(filters);
  const filtersMap = filterKeys.reduce((acc, key) => ({
    [key]: new Set,
    ...acc
  }), {});
  for (const param of filterKeys) {
    const operation = filters[param];
    if (typeof index.indexes[param] === "undefined") {
      throw createError("UNKNOWN_FILTER_PROPERTY", param);
    }
    const { node, type: type2, isArray: isArray2 } = index.indexes[param];
    if (type2 === "Bool") {
      const idx = node;
      const filteredIDs = operation ? idx.true : idx.false;
      filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
      continue;
    }
    if (type2 === "BKD") {
      let reqOperation;
      if ("radius" in operation) {
        reqOperation = "radius";
      } else if ("polygon" in operation) {
        reqOperation = "polygon";
      } else {
        throw new Error(`Invalid operation ${operation}`);
      }
      if (reqOperation === "radius") {
        const { value: value6, coordinates, unit = "m", inside = true, highPrecision = false } = operation[reqOperation];
        const distanceInMeters = convertDistanceToMeters(value6, unit);
        const ids3 = node.searchByRadius(coordinates, distanceInMeters, inside, undefined, highPrecision);
        filtersMap[param] = addGeoResult(filtersMap[param], ids3);
      } else {
        const { coordinates, inside = true, highPrecision = false } = operation[reqOperation];
        const ids3 = node.searchByPolygon(coordinates, inside, undefined, highPrecision);
        filtersMap[param] = addGeoResult(filtersMap[param], ids3);
      }
      continue;
    }
    if (type2 === "Radix" && (typeof operation === "string" || Array.isArray(operation))) {
      for (const raw of [operation].flat()) {
        const term = tokenizer.tokenize(raw, language, param);
        for (const t2 of term) {
          const filteredIDsResults = node.find({ term: t2, exact: true });
          filtersMap[param] = addFindResult(filtersMap[param], filteredIDsResults);
        }
      }
      continue;
    }
    const operationKeys = Object.keys(operation);
    if (operationKeys.length > 1) {
      throw createError("INVALID_FILTER_OPERATION", operationKeys.length);
    }
    if (type2 === "Flat") {
      const results = new Set(isArray2 ? node.filterArr(operation) : node.filter(operation));
      filtersMap[param] = setUnion(filtersMap[param], results);
      continue;
    }
    if (type2 === "AVL") {
      const operationOpt = operationKeys[0];
      const operationValue = operation[operationOpt];
      let filteredIDs;
      switch (operationOpt) {
        case "gt": {
          filteredIDs = node.greaterThan(operationValue, false);
          break;
        }
        case "gte": {
          filteredIDs = node.greaterThan(operationValue, true);
          break;
        }
        case "lt": {
          filteredIDs = node.lessThan(operationValue, false);
          break;
        }
        case "lte": {
          filteredIDs = node.lessThan(operationValue, true);
          break;
        }
        case "eq": {
          const ret = node.find(operationValue);
          filteredIDs = ret ?? new Set;
          break;
        }
        case "between": {
          const [min4, max7] = operationValue;
          filteredIDs = node.rangeSearch(min4, max7);
          break;
        }
        default:
          throw createError("INVALID_FILTER_OPERATION", operationOpt);
      }
      filtersMap[param] = setUnion(filtersMap[param], filteredIDs);
    }
  }
  return setIntersection(...Object.values(filtersMap));
}
function getSearchableProperties(index) {
  return index.searchableProperties;
}
function getSearchablePropertiesWithTypes(index) {
  return index.searchablePropertiesWithTypes;
}
function load3(sharedInternalDocumentStore, raw) {
  const { indexes: rawIndexes, vectorIndexes: rawVectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = raw;
  const indexes = {};
  const vectorIndexes = {};
  for (const prop of Object.keys(rawIndexes)) {
    const { node, type: type2, isArray: isArray2 } = rawIndexes[prop];
    switch (type2) {
      case "Radix":
        indexes[prop] = {
          type: "Radix",
          node: RadixTree.fromJSON(node),
          isArray: isArray2
        };
        break;
      case "Flat":
        indexes[prop] = {
          type: "Flat",
          node: FlatTree.fromJSON(node),
          isArray: isArray2
        };
        break;
      case "AVL":
        indexes[prop] = {
          type: "AVL",
          node: AVLTree.fromJSON(node),
          isArray: isArray2
        };
        break;
      case "BKD":
        indexes[prop] = {
          type: "BKD",
          node: BKDTree.fromJSON(node),
          isArray: isArray2
        };
        break;
      case "Bool":
        indexes[prop] = {
          type: "Bool",
          node: BoolNode.fromJSON(node),
          isArray: isArray2
        };
        break;
      default:
        indexes[prop] = rawIndexes[prop];
    }
  }
  for (const idx of Object.keys(rawVectorIndexes)) {
    vectorIndexes[idx] = {
      type: "Vector",
      isArray: false,
      node: VectorIndex.fromJSON(rawVectorIndexes[idx])
    };
  }
  return {
    sharedInternalDocumentStore,
    indexes,
    vectorIndexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrences,
    avgFieldLength,
    fieldLengths
  };
}
function save3(index) {
  const { indexes, vectorIndexes, searchableProperties, searchablePropertiesWithTypes, frequencies, tokenOccurrences, avgFieldLength, fieldLengths } = index;
  const dumpVectorIndexes = {};
  for (const idx of Object.keys(vectorIndexes)) {
    dumpVectorIndexes[idx] = vectorIndexes[idx].node.toJSON();
  }
  const savedIndexes = {};
  for (const name of Object.keys(indexes)) {
    const { type: type2, node, isArray: isArray2 } = indexes[name];
    if (type2 === "Flat" || type2 === "Radix" || type2 === "AVL" || type2 === "BKD" || type2 === "Bool") {
      savedIndexes[name] = {
        type: type2,
        node: node.toJSON(),
        isArray: isArray2
      };
    } else {
      savedIndexes[name] = indexes[name];
      savedIndexes[name].node = savedIndexes[name].node.toJSON();
    }
  }
  return {
    indexes: savedIndexes,
    vectorIndexes: dumpVectorIndexes,
    searchableProperties,
    searchablePropertiesWithTypes,
    frequencies,
    tokenOccurrences,
    avgFieldLength,
    fieldLengths
  };
}
function createIndex() {
  return {
    create: create3,
    insert: insert4,
    remove: remove14,
    insertDocumentScoreParameters,
    insertTokenScoreParameters,
    removeDocumentScoreParameters,
    removeTokenScoreParameters,
    calculateResultScores,
    search,
    searchByWhereClause,
    getSearchableProperties,
    getSearchablePropertiesWithTypes,
    load: load3,
    save: save3
  };
}
function addGeoResult(set17, ids3) {
  if (!set17) {
    set17 = new Set;
  }
  const idsLength = ids3.length;
  for (let i = 0;i < idsLength; i++) {
    const entry = ids3[i].docIDs;
    const idsLength2 = entry.length;
    for (let j = 0;j < idsLength2; j++) {
      set17.add(entry[j]);
    }
  }
  return set17;
}
function createGeoTokenScores(ids3, centerPoint, highPrecision = false) {
  const distanceFn = highPrecision ? BKDTree.vincentyDistance : BKDTree.haversineDistance;
  const results = [];
  const distances = [];
  for (const { point } of ids3) {
    distances.push(distanceFn(centerPoint, point));
  }
  const maxDistance = Math.max(...distances);
  let index = 0;
  for (const { docIDs } of ids3) {
    const distance2 = distances[index];
    const score = maxDistance - distance2 + 1;
    for (const docID of docIDs) {
      results.push([docID, score]);
    }
    index++;
  }
  results.sort((a, b) => b[1] - a[1]);
  return results;
}
function isGeosearchOnlyQuery(filters, index) {
  const filterKeys = Object.keys(filters);
  if (filterKeys.length !== 1) {
    return { isGeoOnly: false };
  }
  const param = filterKeys[0];
  const operation = filters[param];
  if (typeof index.indexes[param] === "undefined") {
    return { isGeoOnly: false };
  }
  const { type: type2 } = index.indexes[param];
  if (type2 === "BKD" && operation && (("radius" in operation) || ("polygon" in operation))) {
    return { isGeoOnly: true, geoProperty: param, geoOperation: operation };
  }
  return { isGeoOnly: false };
}
function searchByGeoWhereClause(index, filters) {
  const indexTyped = index;
  const geoInfo = isGeosearchOnlyQuery(filters, indexTyped);
  if (!geoInfo.isGeoOnly || !geoInfo.geoProperty || !geoInfo.geoOperation) {
    return null;
  }
  const { node } = indexTyped.indexes[geoInfo.geoProperty];
  const operation = geoInfo.geoOperation;
  const bkdNode = node;
  let results;
  if ("radius" in operation) {
    const { value: value6, coordinates, unit = "m", inside = true, highPrecision = false } = operation.radius;
    const centerPoint = coordinates;
    const distanceInMeters = convertDistanceToMeters(value6, unit);
    results = bkdNode.searchByRadius(centerPoint, distanceInMeters, inside, "asc", highPrecision);
    return createGeoTokenScores(results, centerPoint, highPrecision);
  } else if ("polygon" in operation) {
    const { coordinates, inside = true, highPrecision = false } = operation.polygon;
    results = bkdNode.searchByPolygon(coordinates, inside, "asc", highPrecision);
    const centroid = BKDTree.calculatePolygonCentroid(coordinates);
    return createGeoTokenScores(results, centroid, highPrecision);
  }
  return null;
}
function addFindResult(set17, filteredIDsResults) {
  if (!set17) {
    set17 = new Set;
  }
  const keys9 = Object.keys(filteredIDsResults);
  const keysLength = keys9.length;
  for (let i = 0;i < keysLength; i++) {
    const ids3 = filteredIDsResults[keys9[i]];
    const idsLength = ids3.length;
    for (let j = 0;j < idsLength; j++) {
      set17.add(ids3[j]);
    }
  }
  return set17;
}

// node_modules/@orama/orama/dist/esm/components/sorter.js
function innerCreate(orama, sharedInternalDocumentStore, schema, sortableDeniedProperties, prefix) {
  const sorter = {
    language: orama.tokenizer.language,
    sharedInternalDocumentStore,
    enabled: true,
    isSorted: true,
    sortableProperties: [],
    sortablePropertiesWithTypes: {},
    sorts: {}
  };
  for (const [prop, type2] of Object.entries(schema)) {
    const path = `${prefix}${prefix ? "." : ""}${prop}`;
    if (sortableDeniedProperties.includes(path)) {
      continue;
    }
    if (typeof type2 === "object" && !Array.isArray(type2)) {
      const ret = innerCreate(orama, sharedInternalDocumentStore, type2, sortableDeniedProperties, path);
      safeArrayPush(sorter.sortableProperties, ret.sortableProperties);
      sorter.sorts = {
        ...sorter.sorts,
        ...ret.sorts
      };
      sorter.sortablePropertiesWithTypes = {
        ...sorter.sortablePropertiesWithTypes,
        ...ret.sortablePropertiesWithTypes
      };
      continue;
    }
    if (!isVectorType(type2)) {
      switch (type2) {
        case "boolean":
        case "number":
        case "string":
          sorter.sortableProperties.push(path);
          sorter.sortablePropertiesWithTypes[path] = type2;
          sorter.sorts[path] = {
            docs: new Map,
            orderedDocsToRemove: new Map,
            orderedDocs: [],
            type: type2
          };
          break;
        case "geopoint":
        case "enum":
          continue;
        case "enum[]":
        case "boolean[]":
        case "number[]":
        case "string[]":
          continue;
        default:
          throw createError("INVALID_SORT_SCHEMA_TYPE", Array.isArray(type2) ? "array" : type2, path);
      }
    }
  }
  return sorter;
}
function create4(orama, sharedInternalDocumentStore, schema, config2) {
  const isSortEnabled = config2?.enabled !== false;
  if (!isSortEnabled) {
    return {
      disabled: true
    };
  }
  return innerCreate(orama, sharedInternalDocumentStore, schema, (config2 || {}).unsortableProperties || [], "");
}
function insert5(sorter, prop, id2, value6) {
  if (!sorter.enabled) {
    return;
  }
  sorter.isSorted = false;
  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id2);
  const s = sorter.sorts[prop];
  if (s.orderedDocsToRemove.has(internalId)) {
    ensureOrderedDocsAreDeletedByProperty(sorter, prop);
  }
  s.docs.set(internalId, s.orderedDocs.length);
  s.orderedDocs.push([internalId, value6]);
}
function ensureIsSorted(sorter) {
  if (sorter.isSorted || !sorter.enabled) {
    return;
  }
  const properties = Object.keys(sorter.sorts);
  for (const prop of properties) {
    ensurePropertyIsSorted(sorter, prop);
  }
  sorter.isSorted = true;
}
function stringSort(language, value6, d) {
  return value6[1].localeCompare(d[1], getLocale(language));
}
function numberSort(value6, d) {
  return value6[1] - d[1];
}
function booleanSort(value6, d) {
  return d[1] ? -1 : 1;
}
function ensurePropertyIsSorted(sorter, prop) {
  const s = sorter.sorts[prop];
  let predicate;
  switch (s.type) {
    case "string":
      predicate = stringSort.bind(null, sorter.language);
      break;
    case "number":
      predicate = numberSort.bind(null);
      break;
    case "boolean":
      predicate = booleanSort.bind(null);
      break;
  }
  s.orderedDocs.sort(predicate);
  const orderedDocsLength = s.orderedDocs.length;
  for (let i = 0;i < orderedDocsLength; i++) {
    const docId = s.orderedDocs[i][0];
    s.docs.set(docId, i);
  }
}
function ensureOrderedDocsAreDeleted(sorter) {
  const properties = Object.keys(sorter.sorts);
  for (const prop of properties) {
    ensureOrderedDocsAreDeletedByProperty(sorter, prop);
  }
}
function ensureOrderedDocsAreDeletedByProperty(sorter, prop) {
  const s = sorter.sorts[prop];
  if (!s.orderedDocsToRemove.size)
    return;
  s.orderedDocs = s.orderedDocs.filter((doc) => !s.orderedDocsToRemove.has(doc[0]));
  s.orderedDocsToRemove.clear();
}
function remove15(sorter, prop, id2) {
  if (!sorter.enabled) {
    return;
  }
  const s = sorter.sorts[prop];
  const internalId = getInternalDocumentId(sorter.sharedInternalDocumentStore, id2);
  const index = s.docs.get(internalId);
  if (!index)
    return;
  s.docs.delete(internalId);
  s.orderedDocsToRemove.set(internalId, true);
}
function sortBy(sorter, docIds, by) {
  if (!sorter.enabled) {
    throw createError("SORT_DISABLED");
  }
  const property = by.property;
  const isDesc = by.order === "DESC";
  const s = sorter.sorts[property];
  if (!s) {
    throw createError("UNABLE_TO_SORT_ON_UNKNOWN_FIELD", property, sorter.sortableProperties.join(", "));
  }
  ensureOrderedDocsAreDeletedByProperty(sorter, property);
  ensureIsSorted(sorter);
  docIds.sort((a, b) => {
    const indexOfA = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, a[0]));
    const indexOfB = s.docs.get(getInternalDocumentId(sorter.sharedInternalDocumentStore, b[0]));
    const isAIndexed = typeof indexOfA !== "undefined";
    const isBIndexed = typeof indexOfB !== "undefined";
    if (!isAIndexed && !isBIndexed) {
      return 0;
    }
    if (!isAIndexed) {
      return 1;
    }
    if (!isBIndexed) {
      return -1;
    }
    return isDesc ? indexOfB - indexOfA : indexOfA - indexOfB;
  });
  return docIds;
}
function getSortableProperties(sorter) {
  if (!sorter.enabled) {
    return [];
  }
  return sorter.sortableProperties;
}
function getSortablePropertiesWithTypes(sorter) {
  if (!sorter.enabled) {
    return {};
  }
  return sorter.sortablePropertiesWithTypes;
}
function load4(sharedInternalDocumentStore, raw) {
  const rawDocument = raw;
  if (!rawDocument.enabled) {
    return {
      enabled: false
    };
  }
  const sorts = Object.keys(rawDocument.sorts).reduce((acc, prop) => {
    const { docs, orderedDocs, type: type2 } = rawDocument.sorts[prop];
    acc[prop] = {
      docs: new Map(Object.entries(docs).map(([k2, v]) => [+k2, v])),
      orderedDocsToRemove: new Map,
      orderedDocs,
      type: type2
    };
    return acc;
  }, {});
  return {
    sharedInternalDocumentStore,
    language: rawDocument.language,
    sortableProperties: rawDocument.sortableProperties,
    sortablePropertiesWithTypes: rawDocument.sortablePropertiesWithTypes,
    sorts,
    enabled: true,
    isSorted: rawDocument.isSorted
  };
}
function save4(sorter) {
  if (!sorter.enabled) {
    return {
      enabled: false
    };
  }
  ensureOrderedDocsAreDeleted(sorter);
  ensureIsSorted(sorter);
  const sorts = Object.keys(sorter.sorts).reduce((acc, prop) => {
    const { docs, orderedDocs, type: type2 } = sorter.sorts[prop];
    acc[prop] = {
      docs: Object.fromEntries(docs.entries()),
      orderedDocs,
      type: type2
    };
    return acc;
  }, {});
  return {
    language: sorter.language,
    sortableProperties: sorter.sortableProperties,
    sortablePropertiesWithTypes: sorter.sortablePropertiesWithTypes,
    sorts,
    enabled: sorter.enabled,
    isSorted: sorter.isSorted
  };
}
function createSorter() {
  return {
    create: create4,
    insert: insert5,
    remove: remove15,
    save: save4,
    load: load4,
    sortBy,
    getSortableProperties,
    getSortablePropertiesWithTypes
  };
}

// node_modules/@orama/orama/dist/esm/components/tokenizer/diacritics.js
function replaceChar(charCode) {
  if (charCode < DIACRITICS_CHARCODE_START || charCode > DIACRITICS_CHARCODE_END)
    return charCode;
  return CHARCODE_REPLACE_MAPPING[charCode - DIACRITICS_CHARCODE_START] || charCode;
}
function replaceDiacritics(str) {
  const stringCharCode = [];
  for (let idx = 0;idx < str.length; idx++) {
    stringCharCode[idx] = replaceChar(str.charCodeAt(idx));
  }
  return String.fromCharCode(...stringCharCode);
}
var DIACRITICS_CHARCODE_START = 192;
var DIACRITICS_CHARCODE_END = 383;
var CHARCODE_REPLACE_MAPPING = [
  65,
  65,
  65,
  65,
  65,
  65,
  65,
  67,
  69,
  69,
  69,
  69,
  73,
  73,
  73,
  73,
  69,
  78,
  79,
  79,
  79,
  79,
  79,
  null,
  79,
  85,
  85,
  85,
  85,
  89,
  80,
  115,
  97,
  97,
  97,
  97,
  97,
  97,
  97,
  99,
  101,
  101,
  101,
  101,
  105,
  105,
  105,
  105,
  101,
  110,
  111,
  111,
  111,
  111,
  111,
  null,
  111,
  117,
  117,
  117,
  117,
  121,
  112,
  121,
  65,
  97,
  65,
  97,
  65,
  97,
  67,
  99,
  67,
  99,
  67,
  99,
  67,
  99,
  68,
  100,
  68,
  100,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  69,
  101,
  71,
  103,
  71,
  103,
  71,
  103,
  71,
  103,
  72,
  104,
  72,
  104,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  73,
  105,
  74,
  106,
  75,
  107,
  107,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  76,
  108,
  78,
  110,
  78,
  110,
  78,
  110,
  110,
  78,
  110,
  79,
  111,
  79,
  111,
  79,
  111,
  79,
  111,
  82,
  114,
  82,
  114,
  82,
  114,
  83,
  115,
  83,
  115,
  83,
  115,
  83,
  115,
  84,
  116,
  84,
  116,
  84,
  116,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  85,
  117,
  87,
  119,
  89,
  121,
  89,
  90,
  122,
  90,
  122,
  90,
  122,
  115
];

// node_modules/@orama/orama/dist/esm/components/tokenizer/english-stemmer.js
function stemmer(w) {
  let stem;
  let suffix;
  let re;
  let re2;
  let re3;
  let re4;
  if (w.length < 3) {
    return w;
  }
  const firstch = w.substring(0, 1);
  if (firstch == "y") {
    w = firstch.toUpperCase() + w.substring(1);
  }
  re = /^(.+?)(ss|i)es$/;
  re2 = /^(.+?)([^s])s$/;
  if (re.test(w)) {
    w = w.replace(re, "$1$2");
  } else if (re2.test(w)) {
    w = w.replace(re2, "$1$2");
  }
  re = /^(.+?)eed$/;
  re2 = /^(.+?)(ed|ing)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    re = new RegExp(mgr0);
    if (re.test(fp[1])) {
      re = /.$/;
      w = w.replace(re, "");
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = fp[1];
    re2 = new RegExp(s_v);
    if (re2.test(stem)) {
      w = stem;
      re2 = /(at|bl|iz)$/;
      re3 = new RegExp("([^aeiouylsz])\\1$");
      re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
      if (re2.test(w)) {
        w = w + "e";
      } else if (re3.test(w)) {
        re = /.$/;
        w = w.replace(re, "");
      } else if (re4.test(w)) {
        w = w + "e";
      }
    }
  }
  re = /^(.+?)y$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp?.[1];
    re = new RegExp(s_v);
    if (stem && re.test(stem)) {
      w = stem + "i";
    }
  }
  re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp?.[1];
    suffix = fp?.[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step2List[suffix];
    }
  }
  re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp?.[1];
    suffix = fp?.[2];
    re = new RegExp(mgr0);
    if (stem && re.test(stem)) {
      w = stem + step3List[suffix];
    }
  }
  re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
  re2 = /^(.+?)(s|t)(ion)$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp?.[1];
    re = new RegExp(mgr1);
    if (stem && re.test(stem)) {
      w = stem;
    }
  } else if (re2.test(w)) {
    const fp = re2.exec(w);
    stem = fp?.[1] ?? "" + fp?.[2] ?? "";
    re2 = new RegExp(mgr1);
    if (re2.test(stem)) {
      w = stem;
    }
  }
  re = /^(.+?)e$/;
  if (re.test(w)) {
    const fp = re.exec(w);
    stem = fp?.[1];
    re = new RegExp(mgr1);
    re2 = new RegExp(meq1);
    re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
    if (stem && (re.test(stem) || re2.test(stem) && !re3.test(stem))) {
      w = stem;
    }
  }
  re = /ll$/;
  re2 = new RegExp(mgr1);
  if (re.test(w) && re2.test(w)) {
    re = /.$/;
    w = w.replace(re, "");
  }
  if (firstch == "y") {
    w = firstch.toLowerCase() + w.substring(1);
  }
  return w;
}
var step2List = {
  ational: "ate",
  tional: "tion",
  enci: "ence",
  anci: "ance",
  izer: "ize",
  bli: "ble",
  alli: "al",
  entli: "ent",
  eli: "e",
  ousli: "ous",
  ization: "ize",
  ation: "ate",
  ator: "ate",
  alism: "al",
  iveness: "ive",
  fulness: "ful",
  ousness: "ous",
  aliti: "al",
  iviti: "ive",
  biliti: "ble",
  logi: "log"
};
var step3List = {
  icate: "ic",
  ative: "",
  alize: "al",
  iciti: "ic",
  ical: "ic",
  ful: "",
  ness: ""
};
var c = "[^aeiou]";
var v = "[aeiouy]";
var C = c + "[^aeiouy]*";
var V = v + "[aeiou]*";
var mgr0 = "^(" + C + ")?" + V + C;
var meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$";
var mgr1 = "^(" + C + ")?" + V + C + V + C;
var s_v = "^(" + C + ")?" + v;

// node_modules/@orama/orama/dist/esm/components/tokenizer/index.js
function normalizeToken(prop, token, withCache = true) {
  const key = `${this.language}:${prop}:${token}`;
  if (withCache && this.normalizationCache.has(key)) {
    return this.normalizationCache.get(key);
  }
  if (this.stopWords?.includes(token)) {
    if (withCache) {
      this.normalizationCache.set(key, "");
    }
    return "";
  }
  if (this.stemmer && !this.stemmerSkipProperties.has(prop)) {
    token = this.stemmer(token);
  }
  token = replaceDiacritics(token);
  if (withCache) {
    this.normalizationCache.set(key, token);
  }
  return token;
}
function trim(text) {
  while (text[text.length - 1] === "") {
    text.pop();
  }
  while (text[0] === "") {
    text.shift();
  }
  return text;
}
function tokenize(input, language, prop, withCache = true) {
  if (language && language !== this.language) {
    throw createError("LANGUAGE_NOT_SUPPORTED", language);
  }
  if (typeof input !== "string") {
    return [input];
  }
  const normalizeToken2 = this.normalizeToken.bind(this, prop ?? "");
  let tokens;
  if (prop && this.tokenizeSkipProperties.has(prop)) {
    tokens = [normalizeToken2(input, withCache)];
  } else {
    const splitRule = SPLITTERS[this.language];
    tokens = input.toLowerCase().split(splitRule).map((t2) => normalizeToken2(t2, withCache)).filter(Boolean);
  }
  const trimTokens = trim(tokens);
  if (!this.allowDuplicates) {
    return Array.from(new Set(trimTokens));
  }
  return trimTokens;
}
function createTokenizer(config2 = {}) {
  if (!config2.language) {
    config2.language = "english";
  } else if (!SUPPORTED_LANGUAGES.includes(config2.language)) {
    throw createError("LANGUAGE_NOT_SUPPORTED", config2.language);
  }
  let stemmer2;
  if (config2.stemming || config2.stemmer && !("stemming" in config2)) {
    if (config2.stemmer) {
      if (typeof config2.stemmer !== "function") {
        throw createError("INVALID_STEMMER_FUNCTION_TYPE");
      }
      stemmer2 = config2.stemmer;
    } else {
      if (config2.language === "english") {
        stemmer2 = stemmer;
      } else {
        throw createError("MISSING_STEMMER", config2.language);
      }
    }
  }
  let stopWords;
  if (config2.stopWords !== false) {
    stopWords = [];
    if (Array.isArray(config2.stopWords)) {
      stopWords = config2.stopWords;
    } else if (typeof config2.stopWords === "function") {
      stopWords = config2.stopWords(stopWords);
    } else if (config2.stopWords) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    if (!Array.isArray(stopWords)) {
      throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
    }
    for (const s of stopWords) {
      if (typeof s !== "string") {
        throw createError("CUSTOM_STOP_WORDS_MUST_BE_FUNCTION_OR_ARRAY");
      }
    }
  }
  const tokenizer = {
    tokenize,
    language: config2.language,
    stemmer: stemmer2,
    stemmerSkipProperties: new Set(config2.stemmerSkipProperties ? [config2.stemmerSkipProperties].flat() : []),
    tokenizeSkipProperties: new Set(config2.tokenizeSkipProperties ? [config2.tokenizeSkipProperties].flat() : []),
    stopWords,
    allowDuplicates: Boolean(config2.allowDuplicates),
    normalizeToken,
    normalizationCache: new Map
  };
  tokenizer.tokenize = tokenize.bind(tokenizer);
  tokenizer.normalizeToken = normalizeToken;
  return tokenizer;
}

// node_modules/@orama/orama/dist/esm/methods/create.js
function validateComponents(components) {
  const defaultComponents = {
    formatElapsedTime,
    getDocumentIndexId,
    getDocumentProperties,
    validateSchema
  };
  for (const rawKey of FUNCTION_COMPONENTS) {
    const key = rawKey;
    if (components[key]) {
      if (typeof components[key] !== "function") {
        throw createError("COMPONENT_MUST_BE_FUNCTION", key);
      }
    } else {
      components[key] = defaultComponents[key];
    }
  }
  for (const rawKey of Object.keys(components)) {
    if (!OBJECT_COMPONENTS.includes(rawKey) && !FUNCTION_COMPONENTS.includes(rawKey)) {
      throw createError("UNSUPPORTED_COMPONENT", rawKey);
    }
  }
}
function create5({ schema, sort: sort3, language, components, id: id2, plugins }) {
  if (!components) {
    components = {};
  }
  for (const plugin of plugins ?? []) {
    if (!("getComponents" in plugin)) {
      continue;
    }
    if (typeof plugin.getComponents !== "function") {
      continue;
    }
    const pluginComponents = plugin.getComponents(schema);
    const keys9 = Object.keys(pluginComponents);
    for (const key of keys9) {
      if (components[key]) {
        throw createError("PLUGIN_COMPONENT_CONFLICT", key, plugin.name);
      }
    }
    components = {
      ...components,
      ...pluginComponents
    };
  }
  if (!id2) {
    id2 = uniqueId();
  }
  let tokenizer = components.tokenizer;
  let index = components.index;
  let documentsStore = components.documentsStore;
  let sorter = components.sorter;
  if (!tokenizer) {
    tokenizer = createTokenizer({ language: language ?? "english" });
  } else if (!tokenizer.tokenize) {
    tokenizer = createTokenizer(tokenizer);
  } else {
    const customTokenizer = tokenizer;
    tokenizer = customTokenizer;
  }
  if (components.tokenizer && language) {
    throw createError("NO_LANGUAGE_WITH_CUSTOM_TOKENIZER");
  }
  const internalDocumentStore = createInternalDocumentIDStore();
  index ||= createIndex();
  sorter ||= createSorter();
  documentsStore ||= createDocumentsStore();
  validateComponents(components);
  const { getDocumentProperties: getDocumentProperties2, getDocumentIndexId: getDocumentIndexId2, validateSchema: validateSchema2, formatElapsedTime: formatElapsedTime2 } = components;
  const orama = {
    data: {},
    caches: {},
    schema,
    tokenizer,
    index,
    sorter,
    documentsStore,
    internalDocumentIDStore: internalDocumentStore,
    getDocumentProperties: getDocumentProperties2,
    getDocumentIndexId: getDocumentIndexId2,
    validateSchema: validateSchema2,
    beforeInsert: [],
    afterInsert: [],
    beforeRemove: [],
    afterRemove: [],
    beforeUpdate: [],
    afterUpdate: [],
    beforeUpsert: [],
    afterUpsert: [],
    beforeSearch: [],
    afterSearch: [],
    beforeInsertMultiple: [],
    afterInsertMultiple: [],
    beforeRemoveMultiple: [],
    afterRemoveMultiple: [],
    beforeUpdateMultiple: [],
    afterUpdateMultiple: [],
    beforeUpsertMultiple: [],
    afterUpsertMultiple: [],
    afterCreate: [],
    formatElapsedTime: formatElapsedTime2,
    id: id2,
    plugins,
    version: getVersion()
  };
  orama.data = {
    index: orama.index.create(orama, internalDocumentStore, schema),
    docs: orama.documentsStore.create(orama, internalDocumentStore),
    sorting: orama.sorter.create(orama, internalDocumentStore, schema, sort3)
  };
  for (const hook of AVAILABLE_PLUGIN_HOOKS) {
    orama[hook] = (orama[hook] ?? []).concat(getAllPluginsByHook(orama, hook));
  }
  const afterCreate = orama["afterCreate"];
  if (afterCreate) {
    runAfterCreate(afterCreate, orama);
  }
  return orama;
}
function getVersion() {
  return "{{VERSION}}";
}
// node_modules/@orama/orama/dist/esm/methods/docs.js
function count6(db) {
  return db.documentsStore.count(db.data.docs);
}

// node_modules/@orama/orama/dist/esm/constants.js
var MODE_FULLTEXT_SEARCH = "fulltext";
var MODE_HYBRID_SEARCH = "hybrid";
var MODE_VECTOR_SEARCH = "vector";

// node_modules/@orama/orama/dist/esm/components/facets.js
function sortAsc(a, b) {
  return a[1] - b[1];
}
function sortDesc(a, b) {
  return b[1] - a[1];
}
function sortingPredicateBuilder(order = "desc") {
  return order.toLowerCase() === "asc" ? sortAsc : sortDesc;
}
function getFacets(orama, results, facetsConfig) {
  const facets = {};
  const allIDs = results.map(([id2]) => id2);
  const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
  const facetKeys = Object.keys(facetsConfig);
  const properties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
  for (const facet of facetKeys) {
    let values7;
    if (properties[facet] === "number") {
      const { ranges } = facetsConfig[facet];
      const rangesLength = ranges.length;
      const tmp = Array.from({ length: rangesLength });
      for (let i = 0;i < rangesLength; i++) {
        const range3 = ranges[i];
        tmp[i] = [`${range3.from}-${range3.to}`, 0];
      }
      values7 = Object.fromEntries(tmp);
    }
    facets[facet] = {
      count: 0,
      values: values7 ?? {}
    };
  }
  const allDocsLength = allDocs.length;
  for (let i = 0;i < allDocsLength; i++) {
    const doc = allDocs[i];
    for (const facet of facetKeys) {
      const facetValue = facet.includes(".") ? getNested(doc, facet) : doc[facet];
      const propertyType = properties[facet];
      const facetValues = facets[facet].values;
      switch (propertyType) {
        case "number": {
          const ranges = facetsConfig[facet].ranges;
          calculateNumberFacetBuilder(ranges, facetValues)(facetValue);
          break;
        }
        case "number[]": {
          const alreadyInsertedValues = new Set;
          const ranges = facetsConfig[facet].ranges;
          const calculateNumberFacet = calculateNumberFacetBuilder(ranges, facetValues, alreadyInsertedValues);
          for (const v2 of facetValue) {
            calculateNumberFacet(v2);
          }
          break;
        }
        case "boolean":
        case "enum":
        case "string": {
          calculateBooleanStringOrEnumFacetBuilder(facetValues, propertyType)(facetValue);
          break;
        }
        case "boolean[]":
        case "enum[]":
        case "string[]": {
          const alreadyInsertedValues = new Set;
          const innerType = propertyType === "boolean[]" ? "boolean" : "string";
          const calculateBooleanStringOrEnumFacet = calculateBooleanStringOrEnumFacetBuilder(facetValues, innerType, alreadyInsertedValues);
          for (const v2 of facetValue) {
            calculateBooleanStringOrEnumFacet(v2);
          }
          break;
        }
        default:
          throw createError("FACET_NOT_SUPPORTED", propertyType);
      }
    }
  }
  for (const facet of facetKeys) {
    const currentFacet = facets[facet];
    currentFacet.count = Object.keys(currentFacet.values).length;
    if (properties[facet] === "string") {
      const stringFacetDefinition = facetsConfig[facet];
      const sortingPredicate = sortingPredicateBuilder(stringFacetDefinition.sort);
      currentFacet.values = Object.fromEntries(Object.entries(currentFacet.values).sort(sortingPredicate).slice(stringFacetDefinition.offset ?? 0, stringFacetDefinition.limit ?? 10));
    }
  }
  return facets;
}
function calculateNumberFacetBuilder(ranges, values7, alreadyInsertedValues) {
  return (facetValue) => {
    for (const range3 of ranges) {
      const value6 = `${range3.from}-${range3.to}`;
      if (alreadyInsertedValues?.has(value6)) {
        continue;
      }
      if (facetValue >= range3.from && facetValue <= range3.to) {
        if (values7[value6] === undefined) {
          values7[value6] = 1;
        } else {
          values7[value6]++;
          alreadyInsertedValues?.add(value6);
        }
      }
    }
  };
}
function calculateBooleanStringOrEnumFacetBuilder(values7, propertyType, alreadyInsertedValues) {
  const defaultValue = propertyType === "boolean" ? "false" : "";
  return (facetValue) => {
    const value6 = facetValue?.toString() ?? defaultValue;
    if (alreadyInsertedValues?.has(value6)) {
      return;
    }
    values7[value6] = (values7[value6] ?? 0) + 1;
    alreadyInsertedValues?.add(value6);
  };
}

// node_modules/@orama/orama/dist/esm/components/groups.js
function getGroups(orama, results, groupBy2) {
  const properties = groupBy2.properties;
  const propertiesLength = properties.length;
  const schemaProperties = orama.index.getSearchablePropertiesWithTypes(orama.data.index);
  for (let i = 0;i < propertiesLength; i++) {
    const property = properties[i];
    if (typeof schemaProperties[property] === "undefined") {
      throw createError("UNKNOWN_GROUP_BY_PROPERTY", property);
    }
    if (!ALLOWED_TYPES.includes(schemaProperties[property])) {
      throw createError("INVALID_GROUP_BY_PROPERTY", property, ALLOWED_TYPES.join(", "), schemaProperties[property]);
    }
  }
  const allIDs = results.map(([id2]) => getDocumentIdFromInternalId(orama.internalDocumentIDStore, id2));
  const allDocs = orama.documentsStore.getMultiple(orama.data.docs, allIDs);
  const allDocsLength = allDocs.length;
  const returnedCount = groupBy2.maxResult || Number.MAX_SAFE_INTEGER;
  const listOfValues = [];
  const g = {};
  for (let i = 0;i < propertiesLength; i++) {
    const groupByKey2 = properties[i];
    const group2 = {
      property: groupByKey2,
      perValue: {}
    };
    const values7 = new Set;
    for (let j = 0;j < allDocsLength; j++) {
      const doc = allDocs[j];
      const value6 = getNested(doc, groupByKey2);
      if (typeof value6 === "undefined") {
        continue;
      }
      const keyValue = typeof value6 !== "boolean" ? value6 : "" + value6;
      const perValue = group2.perValue[keyValue] ?? {
        indexes: [],
        count: 0
      };
      if (perValue.count >= returnedCount) {
        continue;
      }
      perValue.indexes.push(j);
      perValue.count++;
      group2.perValue[keyValue] = perValue;
      values7.add(value6);
    }
    listOfValues.push(Array.from(values7));
    g[groupByKey2] = group2;
  }
  const combinations = calculateCombination(listOfValues);
  const combinationsLength = combinations.length;
  const groups = [];
  for (let i = 0;i < combinationsLength; i++) {
    const combination = combinations[i];
    const combinationLength = combination.length;
    const group2 = {
      values: [],
      indexes: []
    };
    const indexes = [];
    for (let j = 0;j < combinationLength; j++) {
      const value6 = combination[j];
      const property = properties[j];
      indexes.push(g[property].perValue[typeof value6 !== "boolean" ? value6 : "" + value6].indexes);
      group2.values.push(value6);
    }
    group2.indexes = intersect6(indexes).sort((a, b) => a - b);
    if (group2.indexes.length === 0) {
      continue;
    }
    groups.push(group2);
  }
  const groupsLength = groups.length;
  const res = Array.from({ length: groupsLength });
  for (let i = 0;i < groupsLength; i++) {
    const group2 = groups[i];
    const reduce22 = groupBy2.reduce || DEFAULT_REDUCE;
    const docs = group2.indexes.map((index) => {
      return {
        id: allIDs[index],
        score: results[index][1],
        document: allDocs[index]
      };
    });
    const func = reduce22.reducer.bind(null, group2.values);
    const initialValue = reduce22.getInitialValue(group2.indexes.length);
    const aggregationValue = docs.reduce(func, initialValue);
    res[i] = {
      values: group2.values,
      result: aggregationValue
    };
  }
  return res;
}
function calculateCombination(arrs, index = 0) {
  if (index + 1 === arrs.length)
    return arrs[index].map((item) => [item]);
  const head9 = arrs[index];
  const c2 = calculateCombination(arrs, index + 1);
  const combinations = [];
  for (const value6 of head9) {
    for (const combination of c2) {
      const result = [value6];
      safeArrayPush(result, combination);
      combinations.push(result);
    }
  }
  return combinations;
}
var DEFAULT_REDUCE = {
  reducer: (_2, acc, res, index) => {
    acc[index] = res;
    return acc;
  },
  getInitialValue: (length4) => Array.from({ length: length4 })
};
var ALLOWED_TYPES = ["string", "number", "boolean"];

// node_modules/@orama/orama/dist/esm/methods/search-fulltext.js
function innerFullTextSearch(orama, params, language) {
  const { term, properties } = params;
  const index = orama.data.index;
  let propertiesToSearch = orama.caches["propertiesToSearch"];
  if (!propertiesToSearch) {
    const propertiesToSearchWithTypes = orama.index.getSearchablePropertiesWithTypes(index);
    propertiesToSearch = orama.index.getSearchableProperties(index);
    propertiesToSearch = propertiesToSearch.filter((prop) => propertiesToSearchWithTypes[prop].startsWith("string"));
    orama.caches["propertiesToSearch"] = propertiesToSearch;
  }
  if (properties && properties !== "*") {
    for (const prop of properties) {
      if (!propertiesToSearch.includes(prop)) {
        throw createError("UNKNOWN_INDEX", prop, propertiesToSearch.join(", "));
      }
    }
    propertiesToSearch = propertiesToSearch.filter((prop) => properties.includes(prop));
  }
  const hasFilters = Object.keys(params.where ?? {}).length > 0;
  let whereFiltersIDs;
  if (hasFilters) {
    whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
  }
  let uniqueDocsIDs;
  const threshold = params.threshold !== undefined && params.threshold !== null ? params.threshold : 1;
  if (term || properties) {
    const docsCount = count6(orama);
    uniqueDocsIDs = orama.index.search(index, term || "", orama.tokenizer, language, propertiesToSearch, params.exact || false, params.tolerance || 0, params.boost || {}, applyDefault(params.relevance), docsCount, whereFiltersIDs, threshold);
  } else {
    if (hasFilters) {
      const geoResults = searchByGeoWhereClause(index, params.where);
      if (geoResults) {
        uniqueDocsIDs = geoResults;
      } else {
        const docIds = whereFiltersIDs ? Array.from(whereFiltersIDs) : [];
        uniqueDocsIDs = docIds.map((k2) => [+k2, 0]);
      }
    } else {
      const docIds = Object.keys(orama.documentsStore.getAll(orama.data.docs));
      uniqueDocsIDs = docIds.map((k2) => [+k2, 0]);
    }
  }
  return uniqueDocsIDs;
}
function fullTextSearch(orama, params, language) {
  const timeStart = getNanosecondsTime();
  function performSearchLogic() {
    const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
    const { limit = 10, offset = 0, distinctOn, includeVectors = false } = params;
    const isPreflight = params.preflight === true;
    let uniqueDocsArray = innerFullTextSearch(orama, params, language);
    if (params.sortBy) {
      if (typeof params.sortBy === "function") {
        const ids3 = uniqueDocsArray.map(([id2]) => id2);
        const docs = orama.documentsStore.getMultiple(orama.data.docs, ids3);
        const docsWithIdAndScore = docs.map((d, i) => [
          uniqueDocsArray[i][0],
          uniqueDocsArray[i][1],
          d
        ]);
        docsWithIdAndScore.sort(params.sortBy);
        uniqueDocsArray = docsWithIdAndScore.map(([id2, score]) => [id2, score]);
      } else {
        uniqueDocsArray = orama.sorter.sortBy(orama.data.sorting, uniqueDocsArray, params.sortBy).map(([id2, score]) => [getInternalDocumentId(orama.internalDocumentIDStore, id2), score]);
      }
    } else {
      uniqueDocsArray = uniqueDocsArray.sort(sortTokenScorePredicate);
    }
    let results;
    if (!isPreflight) {
      results = distinctOn ? fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) : fetchDocuments(orama, uniqueDocsArray, offset, limit);
    }
    const searchResult = {
      elapsed: {
        formatted: "",
        raw: 0
      },
      hits: [],
      count: uniqueDocsArray.length
    };
    if (typeof results !== "undefined") {
      searchResult.hits = results.filter(Boolean);
      if (!includeVectors) {
        removeVectorsFromHits(searchResult, vectorProperties);
      }
    }
    if (shouldCalculateFacets) {
      const facets = getFacets(orama, uniqueDocsArray, params.facets);
      searchResult.facets = facets;
    }
    if (params.groupBy) {
      searchResult.groups = getGroups(orama, uniqueDocsArray, params.groupBy);
    }
    searchResult.elapsed = orama.formatElapsedTime(getNanosecondsTime() - timeStart);
    return searchResult;
  }
  async function executeSearchAsync() {
    if (orama.beforeSearch) {
      await runBeforeSearch(orama.beforeSearch, orama, params, language);
    }
    const searchResult = performSearchLogic();
    if (orama.afterSearch) {
      await runAfterSearch(orama.afterSearch, orama, params, language, searchResult);
    }
    return searchResult;
  }
  const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
  if (asyncNeeded) {
    return executeSearchAsync();
  }
  return performSearchLogic();
}
function applyDefault(bm25Relevance) {
  const r = bm25Relevance ?? {};
  r.k = r.k ?? defaultBM25Params.k;
  r.b = r.b ?? defaultBM25Params.b;
  r.d = r.d ?? defaultBM25Params.d;
  return r;
}
var defaultBM25Params = {
  k: 1.2,
  b: 0.75,
  d: 0.5
};

// node_modules/@orama/orama/dist/esm/methods/search-vector.js
function innerVectorSearch(orama, params, language) {
  const vector = params.vector;
  if (vector && (!("value" in vector) || !("property" in vector))) {
    throw createError("INVALID_VECTOR_INPUT", Object.keys(vector).join(", "));
  }
  const vectorIndex = orama.data.index.vectorIndexes[vector.property];
  if (!vectorIndex) {
    throw createError("UNKNOWN_VECTOR_PROPERTY", vector.property);
  }
  const vectorSize = vectorIndex.node.size;
  if (vector?.value.length !== vectorSize) {
    if (vector?.property === undefined || vector?.value.length === undefined) {
      throw createError("INVALID_INPUT_VECTOR", "undefined", vectorSize, "undefined");
    }
    throw createError("INVALID_INPUT_VECTOR", vector.property, vectorSize, vector.value.length);
  }
  const index = orama.data.index;
  let whereFiltersIDs;
  const hasFilters = Object.keys(params.where ?? {}).length > 0;
  if (hasFilters) {
    whereFiltersIDs = orama.index.searchByWhereClause(index, orama.tokenizer, params.where, language);
  }
  return vectorIndex.node.find(vector.value, params.similarity ?? DEFAULT_SIMILARITY, whereFiltersIDs);
}
function searchVector(orama, params, language = "english") {
  const timeStart = getNanosecondsTime();
  function performSearchLogic() {
    const results = innerVectorSearch(orama, params, language).sort(sortTokenScorePredicate);
    let facetsResults = [];
    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
    if (shouldCalculateFacets) {
      const facets = getFacets(orama, results, params.facets);
      facetsResults = facets;
    }
    const vectorProperty = params.vector.property;
    const includeVectors = params.includeVectors ?? false;
    const limit = params.limit ?? 10;
    const offset = params.offset ?? 0;
    const docs = Array.from({ length: limit });
    for (let i = 0;i < limit; i++) {
      const result = results[i + offset];
      if (!result) {
        break;
      }
      const doc = orama.data.docs.docs[result[0]];
      if (doc) {
        if (!includeVectors) {
          doc[vectorProperty] = null;
        }
        const newDoc = {
          id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, result[0]),
          score: result[1],
          document: doc
        };
        docs[i] = newDoc;
      }
    }
    let groups = [];
    if (params.groupBy) {
      groups = getGroups(orama, results, params.groupBy);
    }
    const timeEnd = getNanosecondsTime();
    const elapsedTime = timeEnd - timeStart;
    return {
      count: results.length,
      hits: docs.filter(Boolean),
      elapsed: {
        raw: Number(elapsedTime),
        formatted: formatNanoseconds(elapsedTime)
      },
      ...facetsResults ? { facets: facetsResults } : {},
      ...groups ? { groups } : {}
    };
  }
  async function executeSearchAsync() {
    if (orama.beforeSearch) {
      await runBeforeSearch(orama.beforeSearch, orama, params, language);
    }
    const results = performSearchLogic();
    if (orama.afterSearch) {
      await runAfterSearch(orama.afterSearch, orama, params, language, results);
    }
    return results;
  }
  const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
  if (asyncNeeded) {
    return executeSearchAsync();
  }
  return performSearchLogic();
}

// node_modules/@orama/orama/dist/esm/methods/search-hybrid.js
function innerHybridSearch(orama, params, language) {
  const fullTextIDs = minMaxScoreNormalization(innerFullTextSearch(orama, params, language));
  const vectorIDs = innerVectorSearch(orama, params, language);
  const hybridWeights = params.hybridWeights;
  return mergeAndRankResults(fullTextIDs, vectorIDs, params.term ?? "", hybridWeights);
}
function hybridSearch(orama, params, language) {
  const timeStart = getNanosecondsTime();
  function performSearchLogic() {
    const uniqueTokenScores = innerHybridSearch(orama, params, language);
    let facetsResults;
    const shouldCalculateFacets = params.facets && Object.keys(params.facets).length > 0;
    if (shouldCalculateFacets) {
      facetsResults = getFacets(orama, uniqueTokenScores, params.facets);
    }
    let groups;
    if (params.groupBy) {
      groups = getGroups(orama, uniqueTokenScores, params.groupBy);
    }
    const offset = params.offset ?? 0;
    const limit = params.limit ?? 10;
    const results = fetchDocuments(orama, uniqueTokenScores, offset, limit).filter(Boolean);
    const timeEnd = getNanosecondsTime();
    const returningResults = {
      count: uniqueTokenScores.length,
      elapsed: {
        raw: Number(timeEnd - timeStart),
        formatted: formatNanoseconds(timeEnd - timeStart)
      },
      hits: results,
      ...facetsResults ? { facets: facetsResults } : {},
      ...groups ? { groups } : {}
    };
    const includeVectors = params.includeVectors ?? false;
    if (!includeVectors) {
      const vectorProperties = Object.keys(orama.data.index.vectorIndexes);
      removeVectorsFromHits(returningResults, vectorProperties);
    }
    return returningResults;
  }
  async function executeSearchAsync() {
    if (orama.beforeSearch) {
      await runBeforeSearch(orama.beforeSearch, orama, params, language);
    }
    const results = performSearchLogic();
    if (orama.afterSearch) {
      await runAfterSearch(orama.afterSearch, orama, params, language, results);
    }
    return results;
  }
  const asyncNeeded = orama.beforeSearch?.length || orama.afterSearch?.length;
  if (asyncNeeded) {
    return executeSearchAsync();
  }
  return performSearchLogic();
}
function extractScore(token) {
  return token[1];
}
function minMaxScoreNormalization(results) {
  const maxScore = Math.max.apply(Math, results.map(extractScore));
  return results.map(([id2, score]) => [id2, score / maxScore]);
}
function normalizeScore(score, maxScore) {
  return score / maxScore;
}
function hybridScoreBuilder(textWeight, vectorWeight) {
  return (textScore, vectorScore) => textScore * textWeight + vectorScore * vectorWeight;
}
function mergeAndRankResults(textResults, vectorResults, query, hybridWeights) {
  const maxTextScore = Math.max.apply(Math, textResults.map(extractScore));
  const maxVectorScore = Math.max.apply(Math, vectorResults.map(extractScore));
  const hasHybridWeights = hybridWeights && hybridWeights.text && hybridWeights.vector;
  const { text: textWeight, vector: vectorWeight } = hasHybridWeights ? hybridWeights : getQueryWeights(query);
  const mergedResults = new Map;
  const textResultsLength = textResults.length;
  const hybridScore = hybridScoreBuilder(textWeight, vectorWeight);
  for (let i = 0;i < textResultsLength; i++) {
    const [id2, score] = textResults[i];
    const normalizedScore = normalizeScore(score, maxTextScore);
    const hybridScoreValue = hybridScore(normalizedScore, 0);
    mergedResults.set(id2, hybridScoreValue);
  }
  const vectorResultsLength = vectorResults.length;
  for (let i = 0;i < vectorResultsLength; i++) {
    const [resultId, score] = vectorResults[i];
    const normalizedScore = normalizeScore(score, maxVectorScore);
    const existingRes = mergedResults.get(resultId) ?? 0;
    mergedResults.set(resultId, existingRes + hybridScore(0, normalizedScore));
  }
  return [...mergedResults].sort((a, b) => b[1] - a[1]);
}
function getQueryWeights(query) {
  return {
    text: 0.5,
    vector: 0.5
  };
}

// node_modules/@orama/orama/dist/esm/methods/search.js
function search2(orama, params, language) {
  const mode = params.mode ?? MODE_FULLTEXT_SEARCH;
  if (mode === MODE_FULLTEXT_SEARCH) {
    return fullTextSearch(orama, params, language);
  }
  if (mode === MODE_VECTOR_SEARCH) {
    return searchVector(orama, params);
  }
  if (mode === MODE_HYBRID_SEARCH) {
    return hybridSearch(orama, params);
  }
  throw createError("INVALID_SEARCH_MODE", mode);
}
function fetchDocumentsWithDistinct(orama, uniqueDocsArray, offset, limit, distinctOn) {
  const docs = orama.data.docs;
  const values7 = new Map;
  const results = [];
  const resultIDs = new Set;
  const uniqueDocsArrayLength = uniqueDocsArray.length;
  let count7 = 0;
  for (let i = 0;i < uniqueDocsArrayLength; i++) {
    const idAndScore = uniqueDocsArray[i];
    if (typeof idAndScore === "undefined") {
      continue;
    }
    const [id2, score] = idAndScore;
    if (resultIDs.has(id2)) {
      continue;
    }
    const doc = orama.documentsStore.get(docs, id2);
    const value6 = getNested(doc, distinctOn);
    if (typeof value6 === "undefined" || values7.has(value6)) {
      continue;
    }
    values7.set(value6, true);
    count7++;
    if (count7 <= offset) {
      continue;
    }
    results.push({ id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id2), score, document: doc });
    resultIDs.add(id2);
    if (count7 >= offset + limit) {
      break;
    }
  }
  return results;
}
function fetchDocuments(orama, uniqueDocsArray, offset, limit) {
  const docs = orama.data.docs;
  const results = Array.from({
    length: limit
  });
  const resultIDs = new Set;
  for (let i = offset;i < limit + offset; i++) {
    const idAndScore = uniqueDocsArray[i];
    if (typeof idAndScore === "undefined") {
      break;
    }
    const [id2, score] = idAndScore;
    if (!resultIDs.has(id2)) {
      const fullDoc = orama.documentsStore.get(docs, id2);
      results[i] = { id: getDocumentIdFromInternalId(orama.internalDocumentIDStore, id2), score, document: fullDoc };
      resultIDs.add(id2);
    }
  }
  return results;
}
// src/adapters/search/orama.adapter.ts
var indexingError = (error2) => exports_Effect.fail(error2);

class OramaSearchAdapter {
  state = {
    currentDb: null,
    processingEvents: new Map
  };
  constructor() {
    this.initializeDatabase();
  }
  async initializeDatabase() {
    const schema = {
      version_id: "string",
      passage_id: "string",
      content: "string",
      snippet: "string",
      structure_path: "string",
      collection_ids: "string[]",
      token_offset: "number",
      token_length: "number",
      created_at: "number"
    };
    this.state.currentDb = await create5({ schema });
  }
  processVisibilityEvent = (event) => exports_Effect.sync(() => {
    this.state.processingEvents.set(event.version_id, "processing");
    return {
      event_id: `evt_${Date.now()}`,
      timestamp: new Date,
      schema_version: "1.0.0",
      type: "IndexUpdateStarted",
      version_id: event.version_id
    };
  });
  getVisibilityEventStatus = (version_id) => exports_Effect.sync(() => {
    const status3 = this.state.processingEvents.get(version_id);
    if (!status3) {
      throw new Error("Event not found");
    }
    if (status3 === "processing") {
      return "processing";
    }
    return {
      event_id: `evt_${Date.now()}`,
      timestamp: new Date,
      schema_version: "1.0.0",
      type: "IndexUpdateCommitted",
      version_id
    };
  }).pipe(exports_Effect.catchAll(() => indexingError({
    _tag: "IndexingFailure",
    reason: "Event status not found",
    version_id
  })));
  getCurrentCorpus = () => exports_Effect.sync(() => {
    if (!this.state.currentCorpus) {
      throw new Error("No current corpus");
    }
    return this.state.currentCorpus;
  }).pipe(exports_Effect.catchAll(() => indexingError({
    _tag: "CorpusNotFound",
    corpus_id: "unknown"
  })));
  createCorpus = (version_ids) => exports_Effect.sync(() => {
    const corpus = {
      id: `cor_${Date.now()}`,
      version_ids: [...version_ids],
      state: "Fresh",
      created_at: new Date
    };
    this.state.currentCorpus = corpus;
    return corpus;
  });
  getCorpusStats = (corpus_id) => exports_Effect.sync(() => ({
    version_count: this.state.currentCorpus?.version_ids.length || 0,
    passage_count: 0,
    total_tokens: 0,
    collection_count: 0,
    last_updated: this.state.currentCorpus?.created_at || new Date
  }));
  getCurrentIndex = () => exports_Effect.sync(() => {
    if (!this.state.currentIndex) {
      throw new Error("No current index");
    }
    return this.state.currentIndex;
  }).pipe(exports_Effect.catchAll(() => indexingError({
    _tag: "IndexNotReady",
    index_id: "unknown"
  })));
  buildIndex = (corpus_id) => exports_Effect.sync(() => {
    const index = {
      id: `idx_${Date.now()}`,
      corpus_id,
      state: "Building"
    };
    this.state.buildingIndex = index;
    setTimeout(() => {
      this.state.buildingIndex = {
        ...index,
        state: "Ready",
        built_at: new Date
      };
    }, 100);
    return index;
  });
  getIndexBuildStatus = (index_id) => exports_Effect.sync(() => ({
    state: this.state.buildingIndex?.state || "Ready",
    progress: this.state.buildingIndex?.state === "Building" ? 0.5 : 1
  }));
  commitIndex = (index_id) => exports_Effect.sync(() => {
    if (this.state.buildingIndex?.id === index_id) {
      this.state.currentIndex = {
        ...this.state.buildingIndex,
        state: "Ready",
        built_at: new Date
      };
      this.state.buildingIndex = undefined;
    }
  });
  search = (request2) => exports_Effect.promise(async () => {
    if (!this.state.currentDb) {
      throw new Error("Database not initialized");
    }
    try {
      const results = await search2(this.state.currentDb, {
        term: request2.q,
        limit: request2.page_size || 10,
        offset: (request2.page || 0) * (request2.page_size || 10)
      });
      const searchResults = results.hits.map((hit) => ({
        note_id: hit.document.version_id.replace("ver_", "note_"),
        version_id: hit.document.version_id,
        title: hit.document.snippet.split(" ").slice(0, 5).join(" "),
        snippet: hit.document.snippet,
        score: hit.score,
        collection_ids: hit.document.collection_ids
      }));
      return {
        results: searchResults,
        citations: [],
        query_id: `qry_${Date.now()}`,
        page: request2.page || 0,
        page_size: request2.page_size || 10,
        total_count: results.count,
        has_more: false
      };
    } catch (error2) {
      throw new Error(`Search failed: ${error2}`);
    }
  }).pipe(exports_Effect.catchAll((error2) => indexingError({
    _tag: "IndexingFailure",
    reason: error2.message,
    version_id: "unknown"
  })));
  retrieveCandidates = (query_text, collection_ids, top_k) => exports_Effect.promise(async () => {
    if (!this.state.currentDb) {
      throw new Error("Database not initialized");
    }
    const results = await search2(this.state.currentDb, {
      term: query_text,
      limit: top_k,
      where: {
        collection_ids: {
          containsAll: collection_ids
        }
      }
    });
    return results.hits.map((hit) => ({
      version_id: hit.document.version_id,
      passage_id: hit.document.passage_id,
      score: hit.score,
      snippet: hit.document.snippet,
      structure_path: hit.document.structure_path,
      collection_ids: hit.document.collection_ids
    }));
  }).pipe(exports_Effect.catchAll((error2) => indexingError({
    _tag: "IndexingFailure",
    reason: error2.message,
    version_id: "unknown"
  })));
  rerankCandidates = (query_text, candidates, top_k) => exports_Effect.sync(() => {
    return [...candidates].sort((a, b) => b.score - a.score).slice(0, top_k);
  });
  getVersionPassages = () => exports_Effect.succeed([]);
  resolvePassageContent = () => exports_Effect.succeed(null);
  performHealthCheck = () => exports_Effect.succeed({
    healthy: true,
    version_coverage: 1,
    missing_versions: [],
    orphaned_passages: [],
    last_checked: new Date
  });
  validateIndexIntegrity = () => exports_Effect.succeed({ valid: true, issues: [] });
  rebuildIndex = () => exports_Effect.succeed({});
  optimizeIndex = () => exports_Effect.succeed(undefined);
  enqueueVisibilityEvent = () => exports_Effect.succeed(undefined);
  getQueueStatus = () => exports_Effect.succeed({
    pending_count: 0,
    processing_count: 0,
    failed_count: 0
  });
  retryFailedEvents = () => exports_Effect.succeed({ retried_count: 0 });
}
var createOramaSearchAdapter = () => new OramaSearchAdapter;

// src/schema/anchors.ts
var TokenizationVersion = exports_Schema2.String.pipe(exports_Schema2.pattern(/^\d+\.\d+\.\d+$/), exports_Schema2.brand("TokenizationVersion"));
var FingerprintAlgorithm = exports_Schema2.Literal("sha256", "blake3");
var StructurePath = exports_Schema2.String.pipe(exports_Schema2.pattern(/^\/(?:[^/\n]+(?:\/[^/\n]*)*)?$/), exports_Schema2.brand("StructurePath"));
var TokenOffset = exports_Schema2.Number.pipe(exports_Schema2.int(), exports_Schema2.greaterThanOrEqualTo(0), exports_Schema2.brand("TokenOffset"));
var TokenLength = exports_Schema2.Number.pipe(exports_Schema2.int(), exports_Schema2.greaterThan(0), exports_Schema2.brand("TokenLength"));
var Fingerprint = exports_Schema2.String.pipe(exports_Schema2.pattern(/^[a-f0-9]{8,}$/), exports_Schema2.brand("Fingerprint"));
var Anchor = exports_Schema2.Struct({
  structure_path: StructurePath,
  token_offset: TokenOffset,
  token_length: TokenLength,
  fingerprint: Fingerprint,
  tokenization_version: TokenizationVersion,
  fingerprint_algo: FingerprintAlgorithm
});
var TokenSpan = exports_Schema2.Struct({
  offset: TokenOffset,
  length: TokenLength
});
var AnchorResolution = exports_Schema2.Struct({
  anchor: Anchor,
  resolved: exports_Schema2.Boolean,
  nearest_offset: exports_Schema2.optional(TokenOffset),
  error: exports_Schema2.optional(exports_Schema2.String)
});
var NormalizationRules = exports_Schema2.Struct({
  unicode_form: exports_Schema2.Literal("NFC"),
  line_endings: exports_Schema2.Literal("LF"),
  collapse_whitespace: exports_Schema2.Boolean,
  preserve_code_content: exports_Schema2.Boolean
});
var TokenBoundaryRules = exports_Schema2.Struct({
  unicode_word_boundaries: exports_Schema2.Boolean,
  underscore_slash_separators: exports_Schema2.Boolean,
  preserve_internal_punctuation: exports_Schema2.Boolean,
  decimal_number_tokens: exports_Schema2.Boolean,
  cjk_segmentation: exports_Schema2.Literal("dictionary", "codepoint", "hybrid")
});
var TokenizationConfig = exports_Schema2.Struct({
  version: TokenizationVersion,
  normalization: NormalizationRules,
  boundaries: TokenBoundaryRules,
  fingerprint_algo: FingerprintAlgorithm
});
var TOKENIZATION_CONFIG_V1 = {
  version: "1.0.0",
  normalization: {
    unicode_form: "NFC",
    line_endings: "LF",
    collapse_whitespace: true,
    preserve_code_content: true
  },
  boundaries: {
    unicode_word_boundaries: true,
    underscore_slash_separators: true,
    preserve_internal_punctuation: true,
    decimal_number_tokens: true,
    cjk_segmentation: "hybrid"
  },
  fingerprint_algo: "sha256"
};
var AnchorDrift = exports_Schema2.Struct({
  original_anchor: Anchor,
  content_changed: exports_Schema2.Boolean,
  structure_changed: exports_Schema2.Boolean,
  fingerprint_mismatch: exports_Schema2.Boolean,
  suggested_reanchor: exports_Schema2.optional(Anchor)
});

// src/domain/anchor.ts
function normalizeText(text, preserveCodeContent = true) {
  let normalized = text.normalize("NFC");
  normalized = normalized.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  if (preserveCodeContent) {
    normalized = normalized.replace(/[ \t]+/g, " ");
  } else {
    normalized = normalized.replace(/\s+/g, " ");
  }
  return normalized.trim();
}
function extractStructurePath(content) {
  const lines = content.split("\n");
  const headings = [];
  for (const line of lines) {
    const trimmed2 = line.trim();
    const match25 = trimmed2.match(/^(#{1,6})\s+(.+)$/);
    if (match25) {
      const level = match25[1].length;
      const heading = match25[2].trim();
      const normalizedHeading = heading.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "-").substring(0, 50);
      headings.splice(level - 1);
      headings[level - 1] = normalizedHeading;
    }
  }
  return `/${headings.filter(Boolean).join("/")}`;
}
function tokenizeText(normalizedText, config2 = TOKENIZATION_CONFIG_V1) {
  const tokens = [];
  const tokenOffsets = [];
  const segmenter = new Intl.Segmenter("en", { granularity: "word" });
  const segments = Array.from(segmenter.segment(normalizedText));
  for (const segment of segments) {
    const { segment: text, index, isWordLike } = segment;
    if (!isWordLike) {
      continue;
    }
    if (config2.boundaries.underscore_slash_separators && /[_/]/.test(text)) {
      const subTokens = text.split(/[_/]+/);
      let currentOffset = 0;
      for (const subToken of subTokens) {
        if (subToken.length > 0) {
          tokens.push(subToken);
          const actualOffset = text.indexOf(subToken, currentOffset);
          tokenOffsets.push(index + actualOffset);
          currentOffset = actualOffset + subToken.length;
        }
      }
    } else {
      tokens.push(text);
      tokenOffsets.push(index);
    }
  }
  return {
    tokens,
    normalizedText,
    tokenOffsets
  };
}
async function computeFingerprint(tokens, offset, length4, algorithm = "sha256") {
  if (offset < 0 || offset + length4 > tokens.length) {
    throw new Error("Token span out of bounds");
  }
  const spanContent = tokens.slice(offset, offset + length4).join(" ");
  const encoder3 = new TextEncoder;
  const data = encoder3.encode(spanContent);
  let hashBytes;
  if (algorithm === "sha256") {
    hashBytes = await crypto.subtle.digest("SHA-256", data);
  } else {
    hashBytes = await crypto.subtle.digest("SHA-256", data);
  }
  const hashArray = Array.from(new Uint8Array(hashBytes));
  const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashHex;
}
async function createAnchor(content, structurePath, tokenOffset, tokenLength, config2 = TOKENIZATION_CONFIG_V1) {
  const normalizedText = normalizeText(content, config2.normalization.preserve_code_content);
  const tokenization = tokenizeText(normalizedText, config2);
  if (tokenOffset < 0 || tokenOffset + tokenLength > tokenization.tokens.length) {
    throw new Error("Token span exceeds content bounds");
  }
  const fingerprint = await computeFingerprint(tokenization.tokens, tokenOffset, tokenLength, config2.fingerprint_algo);
  return {
    structure_path: structurePath,
    token_offset: tokenOffset,
    token_length: tokenLength,
    fingerprint,
    tokenization_version: config2.version,
    fingerprint_algo: config2.fingerprint_algo
  };
}
async function resolveAnchor(anchor, content, config2 = TOKENIZATION_CONFIG_V1) {
  try {
    const normalizedText = normalizeText(content, config2.normalization.preserve_code_content);
    const tokenization = tokenizeText(normalizedText, config2);
    if (anchor.token_offset + anchor.token_length > tokenization.tokens.length) {
      return {
        anchor,
        resolved: false,
        error: "Token span exceeds current content bounds"
      };
    }
    const currentFingerprint = await computeFingerprint(tokenization.tokens, anchor.token_offset, anchor.token_length, anchor.fingerprint_algo);
    if (currentFingerprint === anchor.fingerprint) {
      return {
        anchor,
        resolved: true
      };
    }
    const searchRadius = Math.min(10, tokenization.tokens.length - anchor.token_length);
    for (let delta2 = 1;delta2 <= searchRadius; delta2++) {
      for (const offset of [
        anchor.token_offset - delta2,
        anchor.token_offset + delta2
      ]) {
        if (offset >= 0 && offset + anchor.token_length <= tokenization.tokens.length) {
          const nearbyFingerprint = await computeFingerprint(tokenization.tokens, offset, anchor.token_length, anchor.fingerprint_algo);
          if (nearbyFingerprint === anchor.fingerprint) {
            return {
              anchor,
              resolved: true,
              nearest_offset: offset
            };
          }
        }
      }
    }
    return {
      anchor,
      resolved: false,
      nearest_offset: anchor.token_offset,
      error: "Fingerprint mismatch - content has changed"
    };
  } catch (error2) {
    return {
      anchor,
      resolved: false,
      error: error2 instanceof Error ? error2.message : "Unknown resolution error"
    };
  }
}
async function detectAnchorDrift(originalAnchor, currentContent, config2 = TOKENIZATION_CONFIG_V1) {
  const resolution = await resolveAnchor(originalAnchor, currentContent, config2);
  if (resolution.resolved && !resolution.nearest_offset) {
    return {
      original_anchor: originalAnchor,
      content_changed: false,
      structure_changed: false,
      fingerprint_mismatch: false
    };
  }
  const currentStructurePath = extractStructurePath(currentContent);
  const structureChanged = currentStructurePath !== originalAnchor.structure_path;
  let suggestedReanchor;
  if (resolution.nearest_offset !== undefined) {
    try {
      suggestedReanchor = await createAnchor(currentContent, currentStructurePath, resolution.nearest_offset, originalAnchor.token_length, config2);
    } catch {
    }
  }
  return {
    original_anchor: originalAnchor,
    content_changed: true,
    structure_changed: structureChanged,
    fingerprint_mismatch: !resolution.resolved,
    suggested_reanchor: suggestedReanchor
  };
}
async function extractAnchorContent(anchor, content, config2 = TOKENIZATION_CONFIG_V1) {
  const resolution = await resolveAnchor(anchor, content, config2);
  if (!resolution.resolved) {
    return null;
  }
  const normalizedText = normalizeText(content, config2.normalization.preserve_code_content);
  const tokenization = tokenizeText(normalizedText, config2);
  const effectiveOffset = resolution.nearest_offset ?? anchor.token_offset;
  const tokens = tokenization.tokens.slice(effectiveOffset, effectiveOffset + anchor.token_length);
  return tokens.join(" ");
}

// src/policy/publication.ts
var PublicationErrorType = exports_Schema2.Literal("title_missing", "title_too_short", "title_too_long", "no_collections", "too_many_collections", "collection_not_found", "too_many_tags", "tag_too_short", "tag_too_long", "tag_invalid_characters", "content_too_long", "metadata_invalid");
var PublicationValidationError = exports_Schema2.Struct({
  type: PublicationErrorType,
  field: exports_Schema2.String,
  message: exports_Schema2.String,
  value: exports_Schema2.optional(exports_Schema2.Unknown)
});
var PublicationValidationResult = exports_Schema2.Struct({
  valid: exports_Schema2.Boolean,
  errors: exports_Schema2.Array(PublicationValidationError)
});
var PublicationValidationRequest = exports_Schema2.Struct({
  title: exports_Schema2.String,
  content_md: exports_Schema2.String,
  metadata: exports_Schema2.Struct({
    tags: exports_Schema2.optional(exports_Schema2.Array(exports_Schema2.String))
  }),
  target_collections: exports_Schema2.Array(exports_Schema2.String)
});

// src/domain/validation.ts
function analyzeContent(content) {
  const words = content.trim().split(/\s+/).filter((word) => word.length > 0);
  const wordCount = words.length;
  const characterCount = content.length;
  const estimatedReadingTimeMinutes = Math.ceil(wordCount / 200);
  const hasCodeBlocks = /```/.test(content) || /`[^`\n]+`/.test(content);
  const hasImages = /!\[.*?\]\(.*?\)/.test(content);
  const hasLinks = /\[.*?\]\(.*?\)/.test(content);
  const headingMatches = content.match(/^#{1,6}\s+.+$/gm) || [];
  const headingCount = headingMatches.length;
  const maxHeadingLevel = headingMatches.reduce((max7, heading) => {
    const level = heading.match(/^#{1,6}/)?.[0].length || 0;
    return Math.max(max7, level);
  }, 0);
  return {
    wordCount,
    characterCount,
    estimatedReadingTimeMinutes,
    hasCodeBlocks,
    hasImages,
    hasLinks,
    headingCount,
    maxHeadingLevel
  };
}

// src/pipelines/chunking/passage.ts
function validateChunkingConfig(config2) {
  const errors2 = [];
  if (config2.maxTokensPerPassage < 10) {
    errors2.push("maxTokensPerPassage must be at least 10");
  }
  if (config2.maxTokensPerPassage > 1000) {
    errors2.push("maxTokensPerPassage cannot exceed 1000");
  }
  if (config2.overlapTokens >= config2.maxTokensPerPassage) {
    errors2.push("overlapTokens must be less than maxTokensPerPassage");
  }
  if (config2.overlapTokens < 0) {
    errors2.push("overlapTokens cannot be negative");
  }
  if (config2.maxNoteTokens < config2.maxTokensPerPassage) {
    errors2.push("maxNoteTokens must be at least maxTokensPerPassage");
  }
  if (config2.minPassageTokens < 1) {
    errors2.push("minPassageTokens must be at least 1");
  }
  if (config2.minPassageTokens >= config2.maxTokensPerPassage) {
    errors2.push("minPassageTokens must be less than maxTokensPerPassage");
  }
  return errors2;
}
function extractStructureBoundaries(content, tokenOffsets) {
  const boundaries = [];
  const lines = content.split("\n");
  let charOffset = 0;
  const headingStack = [];
  for (const line of lines) {
    const trimmed2 = line.trim();
    const match25 = trimmed2.match(/^(#{1,6})\s+(.+)$/);
    if (match25) {
      const level = match25[1].length;
      const heading = match25[2].trim();
      headingStack.splice(level - 1);
      headingStack[level - 1] = heading.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "-").substring(0, 50);
      const closestTokenIndex = tokenOffsets.findIndex((offset) => offset >= charOffset);
      if (closestTokenIndex !== -1) {
        boundaries.push({
          tokenOffset: closestTokenIndex,
          structurePath: "/" + headingStack.filter(Boolean).join("/"),
          headingText: heading,
          charOffset
        });
      }
    }
    charOffset += line.length + 1;
  }
  return boundaries;
}
function generateSnippet(tokens, startToken, endToken, maxLength2 = 200) {
  const content = tokens.slice(startToken, endToken).join(" ");
  if (content.length <= maxLength2) {
    return content;
  }
  const truncated = content.substring(0, maxLength2);
  const lastSpace = truncated.lastIndexOf(" ");
  return lastSpace > maxLength2 * 0.8 ? truncated.substring(0, lastSpace) + "\u2026" : truncated + "\u2026";
}
function calculateCharacterRange(tokenOffsets, normalizedText, startToken, endToken) {
  const charOffset = tokenOffsets[startToken] || 0;
  let charEnd;
  if (endToken < tokenOffsets.length) {
    charEnd = tokenOffsets[endToken];
  } else {
    charEnd = normalizedText.length;
  }
  return {
    charOffset,
    charLength: charEnd - charOffset
  };
}
function chunkContent(versionId, content, config2 = DEFAULT_CHUNKING_CONFIG2, tokenizationConfig = TOKENIZATION_CONFIG_V1) {
  return exports_Effect.try({
    try: () => {
      const configErrors = validateChunkingConfig(config2);
      if (configErrors.length > 0) {
        throw {
          _tag: "InvalidChunkingConfig",
          errors: configErrors
        };
      }
      const normalizedContent = normalizeText(content, true);
      const tokenization = tokenizeText(normalizedContent, tokenizationConfig);
      if (tokenization.tokens.length > config2.maxNoteTokens) {
        throw {
          _tag: "ContentTooLarge",
          tokenCount: tokenization.tokens.length,
          maxTokens: config2.maxNoteTokens
        };
      }
      const structureBoundaries = config2.preserveStructureBoundaries ? extractStructureBoundaries(normalizedContent, tokenization.tokenOffsets) : [];
      const chunks2 = [];
      const stride = config2.maxTokensPerPassage - config2.overlapTokens;
      let currentStructurePath = "/";
      for (let startToken = 0;startToken < tokenization.tokens.length; startToken += stride) {
        const endToken = Math.min(startToken + config2.maxTokensPerPassage, tokenization.tokens.length);
        if (endToken - startToken < config2.minPassageTokens && endToken < tokenization.tokens.length) {
          continue;
        }
        if (config2.preserveStructureBoundaries) {
          const relevantBoundary = structureBoundaries.filter((b) => b.tokenOffset <= startToken).pop();
          if (relevantBoundary) {
            currentStructurePath = relevantBoundary.structurePath;
          }
        }
        const { charOffset, charLength } = calculateCharacterRange(tokenization.tokenOffsets, normalizedContent, startToken, endToken);
        const chunkContent2 = tokenization.tokens.slice(startToken, endToken).join(" ");
        const snippet = generateSnippet(tokenization.tokens, startToken, endToken);
        chunks2.push({
          passage_id: `pas_${ulid()}`,
          version_id: versionId,
          structure_path: currentStructurePath,
          token_offset: startToken,
          token_length: endToken - startToken,
          content: chunkContent2,
          snippet,
          char_offset: charOffset,
          char_length: charLength
        });
      }
      return chunks2;
    },
    catch: (error2) => {
      if (typeof error2 === "object" && error2 !== null && "_tag" in error2) {
        return error2;
      }
      return {
        _tag: "TokenizationFailed",
        reason: error2 instanceof Error ? error2.message : "Unknown tokenization error"
      };
    }
  });
}
var DEFAULT_CHUNKING_CONFIG2 = {
  maxTokensPerPassage: 180,
  overlapTokens: 90,
  maxNoteTokens: 20000,
  preserveStructureBoundaries: true,
  minPassageTokens: 10
};

// src/adapters/parsing/markdown.adapter.ts
function createMarkdownParsingAdapter() {
  return new MarkdownParsingAdapter;
}
var parsingError = (error2) => exports_Effect.fail(error2);

class MarkdownParsingAdapter {
  normalizeContent = (content, preserveCodeContent = true) => exports_Effect.try({
    try: () => normalizeText(content, preserveCodeContent),
    catch: (error2) => ({
      _tag: "TokenizationFailed",
      reason: error2 instanceof Error ? error2.message : "Normalization failed"
    })
  });
  tokenizeContent = (content, config2) => exports_Effect.try({
    try: () => {
      const normalized = normalizeText(content, true);
      return tokenizeText(normalized, config2);
    },
    catch: (error2) => ({
      _tag: "TokenizationFailed",
      reason: error2 instanceof Error ? error2.message : "Tokenization failed"
    })
  });
  extractMarkdownStructure = (content) => exports_Effect.try({
    try: () => {
      const lines = content.split("\n");
      const headings = [];
      const codeBlocks = [];
      const links = [];
      const images = [];
      let charOffset = 0;
      let inCodeBlock = false;
      let codeBlockStart = 0;
      let codeBlockLanguage;
      for (const line of lines) {
        const trimmed2 = line.trim();
        if (trimmed2.startsWith("```")) {
          if (!inCodeBlock) {
            inCodeBlock = true;
            codeBlockStart = charOffset;
            codeBlockLanguage = trimmed2.substring(3) || undefined;
          } else {
            inCodeBlock = false;
            codeBlocks.push({
              language: codeBlockLanguage,
              char_start: codeBlockStart,
              char_end: charOffset + line.length
            });
          }
        }
        if (!inCodeBlock) {
          const headingMatch = trimmed2.match(/^(#{1,6})\s+(.+)$/);
          if (headingMatch) {
            const level = headingMatch[1].length;
            const text = headingMatch[2].trim();
            const normalized_id = text.toLowerCase().replace(/[^a-z0-9\s]/g, "").replace(/\s+/g, "-").substring(0, 50);
            headings.push({
              level,
              text,
              normalized_id,
              char_offset: charOffset
            });
          }
          const linkMatches = line.matchAll(/(!?)\[([^\]]*)\]\(([^)]+)\)/g);
          for (const match25 of linkMatches) {
            const isImage = match25[1] === "!";
            const text = match25[2];
            const url2 = match25[3];
            const linkOffset = charOffset + match25.index;
            if (isImage) {
              images.push({
                alt_text: text,
                url: url2,
                char_offset: linkOffset
              });
            } else {
              links.push({
                text,
                url: url2,
                char_offset: linkOffset
              });
            }
          }
        }
        charOffset += line.length + 1;
      }
      return {
        headings,
        code_blocks: codeBlocks,
        links,
        images
      };
    },
    catch: (error2) => ({
      _tag: "StructureExtractionFailed",
      content: content.substring(0, 100) + "..."
    })
  });
  extractStructurePath = (content, targetCharOffset) => exports_Effect.try({
    try: () => extractStructurePath(content),
    catch: (error2) => ({
      _tag: "StructureExtractionFailed",
      content: content.substring(0, 100) + "..."
    })
  });
  chunkContent = (content, config2 = DEFAULT_CHUNKING_CONFIG) => exports_Effect.gen(this, function* () {
    const versionId = `ver_${Date.now()}`;
    const chunks2 = yield* chunkContent(versionId, content, config2);
    return chunks2.map((chunk4) => ({
      structure_path: chunk4.structure_path,
      content: chunk4.content,
      token_span: {
        offset: chunk4.token_offset,
        length: chunk4.token_length
      },
      snippet: chunk4.snippet,
      char_offset: chunk4.char_offset,
      char_length: chunk4.char_length
    }));
  }).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "InvalidMarkdown",
    content: content.substring(0, 100) + "..."
  })));
  validateChunkingConfig = (config2) => exports_Effect.sync(() => {
    const errors2 = [];
    if (config2.max_tokens_per_chunk < 10) {
      errors2.push("max_tokens_per_chunk must be at least 10");
    }
    if (config2.overlap_tokens >= config2.max_tokens_per_chunk) {
      errors2.push("overlap_tokens must be less than max_tokens_per_chunk");
    }
    return {
      valid: errors2.length === 0,
      errors: errors2
    };
  });
  createAnchor = (content, structure_path, token_offset, token_length, config2) => exports_Effect.promise(() => createAnchor(content, structure_path, token_offset, token_length, config2)).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "AnchorResolutionFailed",
    anchor: {
      structure_path,
      token_offset,
      token_length
    },
    reason: error2 instanceof Error ? error2.message : "Anchor creation failed"
  })));
  resolveAnchor = (anchor, content, config2) => exports_Effect.promise(() => resolveAnchor(anchor, content, config2)).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "AnchorResolutionFailed",
    anchor,
    reason: error2 instanceof Error ? error2.message : "Anchor resolution failed"
  })));
  detectAnchorDrift = (originalAnchor, currentContent, config2) => exports_Effect.promise(() => detectAnchorDrift(originalAnchor, currentContent, config2)).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "AnchorResolutionFailed",
    anchor: originalAnchor,
    reason: error2 instanceof Error ? error2.message : "Drift detection failed"
  })));
  extractAnchorContent = (anchor, content, config2) => exports_Effect.promise(() => extractAnchorContent(anchor, content, config2)).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "AnchorResolutionFailed",
    anchor,
    reason: error2 instanceof Error ? error2.message : "Content extraction failed"
  })));
  analyzeContent = (content) => exports_Effect.try({
    try: () => {
      const analysis = analyzeContent(content);
      return {
        word_count: analysis.wordCount,
        character_count: analysis.characterCount,
        estimated_reading_time_minutes: analysis.estimatedReadingTimeMinutes,
        features: {
          has_code_blocks: analysis.hasCodeBlocks,
          has_images: analysis.hasImages,
          has_links: analysis.hasLinks,
          heading_count: analysis.headingCount,
          max_heading_level: analysis.maxHeadingLevel
        }
      };
    },
    catch: (error2) => ({
      _tag: "InvalidMarkdown",
      content: content.substring(0, 100) + "..."
    })
  });
  validateMarkdown = (content) => exports_Effect.sync(() => {
    const errors2 = [];
    const codeBlockMatches = content.match(/```/g);
    if (codeBlockMatches && codeBlockMatches.length % 2 !== 0) {
      errors2.push("Unclosed code block detected");
    }
    const malformedLinks = content.match(/\[[^\]]*\]\([^)]*$/gm);
    if (malformedLinks) {
      errors2.push("Malformed links detected");
    }
    return {
      valid: errors2.length === 0,
      errors: errors2
    };
  });
  renderToHtml = (content, highlightRanges) => exports_Effect.sync(() => {
    return content.replace(/^# (.+)$/gm, "<h1>$1</h1>").replace(/^## (.+)$/gm, "<h2>$1</h2>").replace(/^### (.+)$/gm, "<h3>$1</h3>").replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>").replace(/\*(.+?)\*/g, "<em>$1</em>").replace(/`(.+?)`/g, "<code>$1</code>").replace(/\n\n/g, "</p><p>").replace(/^/, "<p>").replace(/$/, "</p>");
  });
  renderToPlainText = (content) => exports_Effect.sync(() => {
    return content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*(.+?)\*\*/g, "$1").replace(/\*(.+?)\*/g, "$1").replace(/`(.+?)`/g, "$1").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "$1").trim();
  });
  computeContentHash = (content) => exports_Effect.promise(async () => {
    const encoder3 = new TextEncoder;
    const data = encoder3.encode(content);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  }).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "TokenizationFailed",
    reason: error2 instanceof Error ? error2.message : "Hash computation failed"
  })));
  computeAnchorFingerprint = (tokens, offset, length4, algorithm = "sha256") => exports_Effect.promise(() => computeFingerprint(tokens, offset, length4, algorithm)).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "TokenizationFailed",
    reason: error2 instanceof Error ? error2.message : "Fingerprint computation failed"
  })));
  batchChunkVersions = (versions, config2 = DEFAULT_CHUNKING_CONFIG) => exports_Effect.all(versions.map(({ version_id, content }) => chunkContent(version_id, content, config2).pipe(exports_Effect.map((chunks2) => chunks2.map((chunk4) => ({ ...chunk4, version_id }))))), { concurrency: "unbounded" }).pipe(exports_Effect.map((chunkArrays) => chunkArrays.flat()), exports_Effect.catchAll((error2) => parsingError({
    _tag: "InvalidMarkdown",
    content: "Multiple versions"
  })));
  batchResolveAnchors = (anchorsWithContent, config2) => exports_Effect.all(anchorsWithContent.map(({ anchor, content }) => exports_Effect.promise(() => resolveAnchor(anchor, content, config2))), { concurrency: "unbounded" }).pipe(exports_Effect.catchAll((error2) => parsingError({
    _tag: "AnchorResolutionFailed",
    anchor: anchorsWithContent[0]?.anchor || {},
    reason: error2 instanceof Error ? error2.message : "Batch anchor resolution failed"
  })));
}

// src/adapters/observability/local.adapter.ts
function createLocalObservabilityAdapter() {
  return new LocalObservabilityAdapter;
}

class LocalObservabilityAdapter {
  storage;
  activeTimers;
  constructor() {
    this.storage = exports_Ref.unsafeMake({
      counters: new Map,
      gauges: new Map,
      timers: new Map,
      events: [],
      health: new Map
    });
    this.activeTimers = new Map;
  }
  recordCounter = (name, value6, tags2) => exports_Ref.update(this.storage, (storage) => {
    const key = this.createMetricKey(name, tags2);
    const currentValue = storage.counters.get(key) || 0;
    const updatedCounters = new Map(storage.counters);
    updatedCounters.set(key, currentValue + value6);
    return {
      ...storage,
      counters: updatedCounters
    };
  });
  recordGauge = (name, value6, tags2) => exports_Ref.update(this.storage, (storage) => {
    const key = this.createMetricKey(name, tags2);
    const updatedGauges = new Map(storage.gauges);
    updatedGauges.set(key, value6);
    return {
      ...storage,
      gauges: updatedGauges
    };
  });
  recordTimer = (name, durationMs, tags2) => exports_Ref.update(this.storage, (storage) => {
    const key = this.createMetricKey(name, tags2);
    const currentValues = storage.timers.get(key) || [];
    const updatedTimers = new Map(storage.timers);
    updatedTimers.set(key, [...currentValues, durationMs]);
    return {
      ...storage,
      timers: updatedTimers
    };
  });
  startTimer = (name, tags2) => exports_Effect.sync(() => {
    const timerId = `${name}_${Date.now()}_${Math.random()}`;
    const timer2 = {
      name,
      started_at: new Date,
      tags: tags2
    };
    this.activeTimers.set(timerId, timer2);
    return () => exports_Effect.gen(this, function* () {
      const activeTimer = this.activeTimers.get(timerId);
      if (!activeTimer) {
        yield* exports_Effect.fail({
          _tag: "MetricRecordingFailed",
          metric: name,
          reason: "Timer not found"
        });
      }
      const completedAt = new Date;
      const durationMs = completedAt.getTime() - activeTimer.started_at.getTime();
      yield* this.recordTimer(name, durationMs, tags2);
      this.activeTimers.delete(timerId);
      return {
        duration_ms: durationMs,
        started_at: activeTimer.started_at,
        completed_at: completedAt
      };
    });
  });
  recordSearchLatency = (durationMs, queryId, resultCount) => exports_Effect.gen(this, function* () {
    yield* this.recordTimer(METRIC_NAMES.SEARCH_LATENCY, durationMs, {
      query_id: queryId,
      result_count: String(resultCount)
    });
    yield* this.recordEvent({
      event_type: EVENT_TYPES.QUERY_SUBMITTED,
      timestamp: new Date,
      metadata: {
        query_id: queryId,
        latency_ms: durationMs,
        result_count: resultCount
      }
    });
  });
  recordVisibilityLatency = (durationMs, versionId, operation) => exports_Effect.gen(this, function* () {
    yield* this.recordTimer(METRIC_NAMES.VISIBILITY_LATENCY, durationMs, {
      version_id: versionId,
      operation
    });
    yield* this.recordEvent({
      event_type: EVENT_TYPES.VERSION_PUBLISHED,
      timestamp: new Date,
      metadata: {
        version_id: versionId,
        operation,
        latency_ms: durationMs
      }
    });
  });
  recordReadingLatency = (durationMs, versionId, anchorResolved) => this.recordTimer(METRIC_NAMES.READING_LATENCY, durationMs, {
    version_id: versionId,
    anchor_resolved: String(anchorResolved)
  });
  getSloMeasurements = () => exports_Ref.get(this.storage).pipe(exports_Effect.map((storage) => {
    const measurements = [];
    const searchLatencies = storage.timers.get(METRIC_NAMES.SEARCH_LATENCY) || [];
    if (searchLatencies.length > 0) {
      const sorted = [...searchLatencies].sort((a, b) => a - b);
      const p50Index = Math.floor(sorted.length * 0.5);
      const p95Index = Math.floor(sorted.length * 0.95);
      const p99Index = Math.floor(sorted.length * 0.99);
      measurements.push({
        metric_name: METRIC_NAMES.SEARCH_LATENCY,
        target_ms: 200,
        current_p50_ms: sorted[p50Index] || 0,
        current_p95_ms: sorted[p95Index] || 0,
        current_p99_ms: sorted[p99Index] || 0,
        breach_count_24h: sorted.filter((latency) => latency > 500).length
      });
    }
    const visibilityLatencies = storage.timers.get(METRIC_NAMES.VISIBILITY_LATENCY) || [];
    if (visibilityLatencies.length > 0) {
      const sorted = [...visibilityLatencies].sort((a, b) => a - b);
      const p50Index = Math.floor(sorted.length * 0.5);
      const p95Index = Math.floor(sorted.length * 0.95);
      const p99Index = Math.floor(sorted.length * 0.99);
      measurements.push({
        metric_name: METRIC_NAMES.VISIBILITY_LATENCY,
        target_ms: 5000,
        current_p50_ms: sorted[p50Index] || 0,
        current_p95_ms: sorted[p95Index] || 0,
        current_p99_ms: sorted[p99Index] || 0,
        breach_count_24h: sorted.filter((latency) => latency > 1e4).length
      });
    }
    return measurements;
  }));
  isSloBreached = (metricName) => exports_Effect.gen(this, function* () {
    const measurements = yield* this.getSloMeasurements();
    const metric = measurements.find((m) => m.metric_name === metricName);
    if (!metric) {
      return false;
    }
    if (metricName === METRIC_NAMES.SEARCH_LATENCY) {
      return metric.current_p95_ms > 500;
    }
    if (metricName === METRIC_NAMES.VISIBILITY_LATENCY) {
      return metric.current_p95_ms > 1e4;
    }
    return false;
  });
  recordQueryEvent = (queryId, scopeCollectionCount, hasFilters) => this.recordEvent({
    event_type: EVENT_TYPES.QUERY_SUBMITTED,
    timestamp: new Date,
    metadata: {
      query_id: queryId,
      scope_collection_count: scopeCollectionCount,
      has_filters: hasFilters
    }
  });
  recordAnswerEvent = (answerId, citationCount, compositionTimeMs, coverageRatio) => this.recordEvent({
    event_type: EVENT_TYPES.ANSWER_COMPOSED,
    timestamp: new Date,
    metadata: {
      answer_id: answerId,
      citation_count: citationCount,
      composition_time_ms: compositionTimeMs,
      coverage_ratio: coverageRatio
    }
  });
  recordNoAnswerEvent = (queryId, reason, candidateCount) => this.recordEvent({
    event_type: EVENT_TYPES.NO_ANSWER_RETURNED,
    timestamp: new Date,
    metadata: {
      query_id: queryId,
      reason,
      candidate_count: candidateCount
    }
  });
  recordCitationInteraction = (citationId, action, sessionId) => this.recordEvent({
    event_type: EVENT_TYPES.CITATION_OPENED,
    timestamp: new Date,
    session_id: sessionId,
    metadata: {
      citation_id: citationId,
      action
    }
  });
  recordHealthStatus = (component, status3) => exports_Ref.update(this.storage, (storage) => {
    const updatedHealth = new Map(storage.health);
    updatedHealth.set(component, status3);
    return {
      ...storage,
      health: updatedHealth
    };
  });
  getSystemHealth = () => exports_Ref.get(this.storage).pipe(exports_Effect.map((storage) => {
    const components = Array.from(storage.health.values());
    const criticalIssues = [];
    let healthyCount = 0;
    let degradedCount = 0;
    let unhealthyCount = 0;
    for (const component of components) {
      switch (component.status) {
        case "healthy":
          healthyCount++;
          break;
        case "degraded":
          degradedCount++;
          break;
        case "unhealthy":
          unhealthyCount++;
          criticalIssues.push(`${component.component}: ${component.details || "Unhealthy"}`);
          break;
      }
    }
    let overallStatus;
    if (unhealthyCount > 0) {
      overallStatus = "unhealthy";
    } else if (degradedCount > 0) {
      overallStatus = "degraded";
    } else {
      overallStatus = "healthy";
    }
    return {
      overall_status: overallStatus,
      components,
      critical_issues: criticalIssues
    };
  }));
  performHealthCheck = (component) => exports_Effect.sync(() => {
    const startTime = Date.now();
    const status3 = {
      component,
      status: "healthy",
      last_check: new Date,
      response_time_ms: Date.now() - startTime
    };
    return status3;
  });
  getMetrics = (metricNames, startTime, endTime) => exports_Ref.get(this.storage).pipe(exports_Effect.map((storage) => {
    const metrics = [];
    for (const name of metricNames) {
      for (const [key, value6] of storage.counters) {
        if (key.startsWith(name)) {
          metrics.push({
            name: key,
            type: "counter",
            value: value6,
            timestamp: new Date
          });
        }
      }
      for (const [key, value6] of storage.gauges) {
        if (key.startsWith(name)) {
          metrics.push({
            name: key,
            type: "gauge",
            value: value6,
            timestamp: new Date
          });
        }
      }
      for (const [key, values7] of storage.timers) {
        if (key.startsWith(name) && values7.length > 0) {
          const avg = values7.reduce((sum3, v2) => sum3 + v2, 0) / values7.length;
          metrics.push({
            name: key,
            type: "timer",
            value: avg,
            timestamp: new Date
          });
        }
      }
    }
    return metrics;
  }));
  getTelemetryEvents = (eventTypes, startTime, endTime, limit) => exports_Ref.get(this.storage).pipe(exports_Effect.map((storage) => {
    const filteredEvents = storage.events.filter((event) => eventTypes.includes(event.event_type) && event.timestamp >= startTime && event.timestamp <= endTime).slice(0, limit || 1000);
    return filteredEvents;
  }));
  exportTelemetryData = (startTime, endTime, includeTraces = false) => exports_Effect.gen(this, function* () {
    const allMetricNames = Object.values(METRIC_NAMES);
    const allEventTypes = Object.values(EVENT_TYPES);
    const metrics = yield* this.getMetrics(allMetricNames, startTime, endTime);
    const events = yield* this.getTelemetryEvents(allEventTypes, startTime, endTime);
    const anonymizedEvents = events.map((event) => ({
      ...event,
      session_id: event.session_id ? "session_*" : undefined,
      metadata: {
        ...event.metadata,
        query_id: event.metadata.query_id ? "query_*" : event.metadata.query_id,
        version_id: event.metadata.version_id ? "version_*" : event.metadata.version_id
      }
    }));
    return {
      metrics,
      events: anonymizedEvents,
      anonymization_applied: true
    };
  });
  purgeTelemetryData = (olderThan) => exports_Ref.update(this.storage, (storage) => {
    const filteredEvents = storage.events.filter((event) => event.timestamp >= olderThan);
    const deletedCount = storage.events.length - filteredEvents.length;
    return {
      ...storage,
      events: filteredEvents
    };
  }).pipe(exports_Effect.as({ deleted_count: 0 }));
  getTelemetryRetentionStatus = () => exports_Ref.get(this.storage).pipe(exports_Effect.map((storage) => {
    const now2 = new Date;
    const oldestEvent = storage.events.length > 0 ? storage.events.reduce((oldest, event) => event.timestamp < oldest ? event.timestamp : oldest, now2) : now2;
    return {
      metrics_retention_days: 30,
      events_retention_days: 30,
      traces_retention_days: 7,
      oldest_metric: oldestEvent,
      oldest_event: oldestEvent,
      total_storage_mb: 0.1
    };
  }));
  subscribeToMetrics = (metricNames, callback) => exports_Effect.sync(() => {
    return () => {
    };
  });
  subscribeToSloBreaches = (callback) => exports_Effect.sync(() => {
    return () => {
    };
  });
  createMetricKey(name, tags2) {
    if (!tags2 || Object.keys(tags2).length === 0) {
      return name;
    }
    const tagString = Object.entries(tags2).sort(([a], [b]) => a.localeCompare(b)).map(([key, value6]) => `${key}=${value6}`).join(",");
    return `${name}{${tagString}}`;
  }
  recordEvent = (event) => exports_Ref.update(this.storage, (storage) => ({
    ...storage,
    events: [...storage.events, event]
  }));
}

// src/runtime/layers.ts
function getAppConfigFromEnv() {
  return {
    database: {
      use_postgres: process.env.USE_POSTGRES !== "false",
      auto_migrate: process.env.AUTO_MIGRATE !== "false"
    },
    observability: {
      enabled: process.env.OBSERVABILITY_ENABLED !== "false",
      retention_days: Number.parseInt(process.env.TELEMETRY_RETENTION_DAYS || "30", 10)
    },
    development: {
      hot_reload: true,
      debug_logging: process.env.DEBUG_LOGGING === "true"
    }
  };
}
var DatabaseLayer = exports_Layer.effect(exports_Context.GenericTag("DatabasePool"), exports_Effect.gen(function* () {
  const config2 = getDatabaseConfigFromEnv();
  const pool = createDatabasePool(config2);
  yield* pool.testConnection().pipe(exports_Effect.catchAll(() => exports_Effect.logWarning("Database connection failed - using memory storage as fallback")));
  return pool;
}));
var StorageLayer = exports_Layer.effect(exports_Context.GenericTag("StoragePort"), exports_Effect.gen(function* () {
  const config2 = getAppConfigFromEnv();
  if (config2.database.use_postgres) {
    try {
      const db = yield* exports_Context.get(exports_Context.GenericTag("DatabasePool"));
      if (config2.database.auto_migrate) {
        const migrationManager = createMigrationManager(db);
        const result = yield* migrationManager.runMigrations();
        if (result.applied.length > 0) {
          yield* exports_Effect.log(`Applied ${result.applied.length} database migrations`);
        }
      }
      yield* exports_Effect.log("Using PostgreSQL storage adapter");
      return createPostgresStorageAdapter(db);
    } catch (error2) {
      yield* exports_Effect.logWarning(`PostgreSQL setup failed: ${error2}, falling back to memory storage`);
      return createMemoryStorageAdapter();
    }
  } else {
    yield* exports_Effect.log("Using memory storage adapter");
    return createMemoryStorageAdapter();
  }
})).pipe(exports_Layer.provide(DatabaseLayer));
var IndexingLayer = exports_Layer.effect(exports_Context.GenericTag("IndexingPort"), exports_Effect.gen(function* () {
  yield* exports_Effect.log("Using Orama search adapter");
  return createOramaSearchAdapter();
}));
var ParsingLayer = exports_Layer.effect(exports_Context.GenericTag("ParsingPort"), exports_Effect.gen(function* () {
  yield* exports_Effect.log("Using Markdown parsing adapter");
  return createMarkdownParsingAdapter();
}));
var ObservabilityLayer = exports_Layer.effect(exports_Context.GenericTag("ObservabilityPort"), exports_Effect.gen(function* () {
  const config2 = getAppConfigFromEnv();
  if (config2.observability.enabled) {
    yield* exports_Effect.log("Using local observability adapter");
    return createLocalObservabilityAdapter();
  } else {
    yield* exports_Effect.log("Observability disabled");
    return createLocalObservabilityAdapter();
  }
}));
var AppDependenciesLayer = exports_Layer.effect(exports_Context.GenericTag("ApiAdapterDependencies"), exports_Effect.gen(function* () {
  const storage = yield* exports_Context.get(exports_Context.GenericTag("StoragePort"));
  const indexing = yield* exports_Context.get(exports_Context.GenericTag("IndexingPort"));
  const parsing = yield* exports_Context.get(exports_Context.GenericTag("ParsingPort"));
  const observability = yield* exports_Context.get(exports_Context.GenericTag("ObservabilityPort"));
  return {
    storage,
    indexing,
    parsing,
    observability
  };
})).pipe(exports_Layer.provide(StorageLayer), exports_Layer.provide(IndexingLayer), exports_Layer.provide(ParsingLayer), exports_Layer.provide(ObservabilityLayer));
var MainLayer = exports_Layer.mergeAll(DatabaseLayer, StorageLayer, IndexingLayer, ParsingLayer, ObservabilityLayer, AppDependenciesLayer);
var initializeApp = () => exports_Effect.gen(function* () {
  yield* exports_Effect.log("Initializing knowledge repository application...");
  const deps = yield* exports_Context.get(exports_Context.GenericTag("ApiAdapterDependencies"));
  yield* deps.storage.initializeWorkspace().pipe(exports_Effect.catchAll((error2) => exports_Effect.logWarning(`Workspace initialization failed: ${JSON.stringify(error2)}`)));
  yield* deps.observability.recordCounter("system.startup_total", 1);
  yield* deps.observability.recordHealthStatus("application", {
    component: "application",
    status: "healthy",
    last_check: new Date
  });
  yield* exports_Effect.log("Application initialized successfully");
  return deps;
}).pipe(exports_Effect.provide(MainLayer));
var shutdownApp = (deps) => exports_Effect.gen(function* () {
  yield* exports_Effect.log("Shutting down application...");
  yield* deps.observability.recordCounter("system.shutdown_total", 1).pipe(exports_Effect.catchAll(() => exports_Effect.void));
  yield* deps.storage.performMaintenance().pipe(exports_Effect.catchAll(() => exports_Effect.void));
  yield* exports_Effect.log("Application shutdown complete");
});

// src/runtime/main.ts
var port2 = Number.parseInt(Bun.env.PORT ?? "3001", 10);
var main = exports_Effect.gen(function* () {
  const config2 = getAppConfigFromEnv();
  if (config2.development.debug_logging) {
    console.log("Starting in development mode with debug logging");
  }
  const deps = yield* initializeApp();
  const apiApp = createKnowledgeApiApp(deps);
  yield* exports_Effect.promise(() => new Promise((resolve) => {
    apiApp.listen({ port: port2 }, () => {
      console.log(`\u2705 Knowledge Repository API listening on http://localhost:${port2}`);
      console.log(`\uD83D\uDCCA Health check: http://localhost:${port2}/healthz`);
      console.log(`\uD83D\uDD0D Search endpoint: http://localhost:${port2}/search`);
      resolve();
    });
  }));
  process.on("SIGINT", () => {
    console.log(`
\uD83D\uDED1 Shutting down gracefully...`);
    exports_Effect.runPromise(shutdownApp(deps)).then(() => {
      process.exit(0);
    });
  });
  process.on("SIGTERM", () => {
    console.log(`
\uD83D\uDED1 Received SIGTERM, shutting down...`);
    exports_Effect.runPromise(shutdownApp(deps)).then(() => {
      process.exit(0);
    });
  });
  return deps;
});
if (import.meta.main) {
  exports_Effect.runPromise(main).catch((error2) => {
    console.error("\u274C Application startup failed:", error2);
    process.exit(1);
  });
}
